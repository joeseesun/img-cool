const AbstractNode = {
    isAbstract(value) {
        if (typeof value.start === 'number' && typeof value.end === 'number') {
            return true;
        }
        else {
            return false;
        }
    }
};
var MindLayoutType;
(function (MindLayoutType) {
    MindLayoutType["right"] = "right";
    MindLayoutType["left"] = "left";
    MindLayoutType["standard"] = "standard";
    MindLayoutType["upward"] = "upward";
    MindLayoutType["downward"] = "downward";
    MindLayoutType["rightBottomIndented"] = "right-bottom-indented";
    MindLayoutType["rightTopIndented"] = "right-top-indented";
    MindLayoutType["leftTopIndented"] = "left-top-indented";
    MindLayoutType["leftBottomIndented"] = "left-bottom-indented";
})(MindLayoutType || (MindLayoutType = {}));
var LayoutType;
(function (LayoutType) {
    LayoutType["logic"] = "logic";
    LayoutType["indented"] = "indented";
    LayoutType["fishBone"] = "fish-bone";
})(LayoutType || (LayoutType = {}));

function findLayoutType(node) {
    if (node.origin.layout) {
        return node.origin.layout;
    }
    if (AbstractNode.isAbstract(node.origin)) {
        return getAbstractLayout(findLayoutType(node.parent));
    }
    if (node.parent) {
        return findLayoutType(node.parent);
    }
    return null;
}
const isIndentedLayout = (layout) => {
    return (layout === MindLayoutType.rightBottomIndented ||
        layout === MindLayoutType.rightTopIndented ||
        layout === MindLayoutType.leftBottomIndented ||
        layout === MindLayoutType.leftTopIndented);
};
const isLogicLayout = (layout) => {
    return (layout === MindLayoutType.right ||
        layout === MindLayoutType.left ||
        layout === MindLayoutType.downward ||
        layout === MindLayoutType.upward);
};
const isStandardLayout = (layout) => {
    return layout === MindLayoutType.standard;
};
const isHorizontalLayout = (layout) => {
    return (layout === MindLayoutType.right || layout === MindLayoutType.left || layout === MindLayoutType.standard || isIndentedLayout(layout));
};
const isHorizontalLogicLayout = (layout) => {
    return layout === MindLayoutType.right || layout === MindLayoutType.left || layout === MindLayoutType.standard;
};
const isVerticalLogicLayout = (layout) => {
    return layout === MindLayoutType.upward || layout === MindLayoutType.downward;
};
const isTopLayout = (layout) => {
    return layout === MindLayoutType.leftTopIndented || layout === MindLayoutType.rightTopIndented || layout === MindLayoutType.upward;
};
const isBottomLayout = (layout) => {
    return (layout === MindLayoutType.leftBottomIndented || layout === MindLayoutType.rightBottomIndented || layout === MindLayoutType.downward);
};
const isLeftLayout = (layout) => {
    return layout === MindLayoutType.left || layout === MindLayoutType.leftTopIndented || layout === MindLayoutType.leftBottomIndented;
};
const isRightLayout = (layout) => {
    return layout === MindLayoutType.right || layout === MindLayoutType.rightTopIndented || layout === MindLayoutType.rightBottomIndented;
};
const extractLayoutType = (mindLayoutType) => {
    if (isIndentedLayout(mindLayoutType)) {
        return LayoutType.indented;
    }
    if (isStandardLayout(mindLayoutType)) {
        return LayoutType.logic;
    }
    if (isLogicLayout(mindLayoutType)) {
        return LayoutType.logic;
    }
    return LayoutType.logic;
};
const getAbstractLayout = (parentLayout) => {
    if (isIndentedLayout(parentLayout)) {
        if (isRightLayout(parentLayout)) {
            return MindLayoutType.right;
        }
        else {
            return MindLayoutType.left;
        }
    }
    return parentLayout;
};

/**
 * abstract layout node
 */
class LayoutNode {
    constructor(origin, options, context, parent) {
        this.x = 0;
        this.y = 0;
        this.vGap = 0;
        this.hGap = 0;
        this.width = 0;
        this.height = 0;
        this.depth = 0;
        this.children = [];
        this.left = false;
        this.up = false;
        const hGap = options.getHorizontalGap(origin, parent);
        const vGap = options.getVerticalGap(origin, parent);
        this.origin = origin;
        this.width = options.getWidth(origin);
        this.height = options.getHeight(origin);
        this.x = this.y = 0;
        if (parent) {
            this.parent = parent;
        }
        const layout = findLayoutType(this);
        this.layout = layout && layout !== MindLayoutType.standard ? layout : context.rootLayoutType;
        const verticalConnectingPosition = options.getVerticalConnectingPosition(origin, parent);
        if (verticalConnectingPosition) {
            this.verticalConnectingPosition = verticalConnectingPosition;
        }
        this.addGap(hGap, vGap);
    }
    isRoot() {
        return this.depth === 0;
    }
    addGap(hGap, vGap) {
        const me = this;
        me.hGap += hGap;
        me.vGap += vGap;
        me.width += 2 * hGap;
        me.height += 2 * vGap;
    }
    eachNode(callback) {
        depthFirstRecursion(this, callback);
    }
    getBoundingBox() {
        const bb = {
            left: Number.MAX_VALUE,
            top: Number.MAX_VALUE,
            right: Number.MIN_VALUE,
            bottom: Number.MIN_VALUE,
            width: 0,
            height: 0
        };
        this.eachNode(node => {
            bb.left = Math.min(bb.left, node.x);
            bb.top = Math.min(bb.top, node.y);
            bb.right = Math.max(bb.right, node.x + node.width);
            bb.bottom = Math.max(bb.bottom, node.y + node.height);
        });
        bb.width = bb.right - bb.left;
        bb.height = bb.bottom - bb.top;
        return bb;
    }
    translate(tx = 0, ty = 0) {
        this.eachNode(node => {
            node.x += tx;
            node.y += ty;
        });
    }
    right2left() {
        const me = this;
        const bb = me.getBoundingBox();
        me.eachNode(node => {
            node.x = node.x - (node.x - bb.left) * 2 - node.width;
            node.left = true;
        });
        me.translate(bb.width, 0);
    }
    down2up() {
        const me = this;
        const bb = me.getBoundingBox();
        me.eachNode(node => {
            node.y = node.y - (node.y - bb.top) * 2 - node.height;
            node.up = true;
        });
        me.translate(0, bb.height);
    }
}
function depthFirstRecursion(node, callback) {
    node.children?.forEach(child => {
        depthFirstRecursion(child, callback);
    });
    callback(node);
}
class LayoutBlockNode {
    constructor(left, right, top, bottom, width, height, rootX, rootY, rootWidth, rootHeight) {
        this.left = left;
        this.right = right;
        this.top = top;
        this.bottom = bottom;
        this.width = width;
        this.height = height;
        this.rootX = rootX;
        this.rootY = rootY;
        this.rootWidth = rootWidth;
        this.rootHeight = rootHeight;
    }
}
function toHorizontal(black) {
    return {
        left: black.top,
        right: black.bottom,
        top: black.left,
        bottom: black.right,
        width: black.height,
        height: black.width,
        rootX: black.rootY,
        rootY: black.rootX,
        rootWidth: black.rootHeight,
        rootHeight: black.rootWidth
    };
}
/**
 * Connecting position, affecting horizontal layout
 */
var ConnectingPosition;
(function (ConnectingPosition) {
    ConnectingPosition["middle"] = "middle";
    ConnectingPosition["bottom"] = "bottom";
})(ConnectingPosition || (ConnectingPosition = {}));

/**
 * abstract tree node for tree layout algorithm
 */
class LayoutTreeNode {
    constructor(width, height, y, children, origin) {
        this.width = width;
        this.height = height;
        this.y = y;
        this.children = children;
        this.childrenCount = children.length;
        this.x = 0;
        this.preliminary = 0; // initial horizontal coordinates
        this.modifier = 0;
        this.shift = 0;
        this.change = 0;
        this.tl = null; // Left thread
        this.tr = null; // Right thread
        this.el = null; // extreme left nodes
        this.er = null; // extreme right nodes
        //sum of modifiers at the extreme nodes
        this.msel = 0;
        this.mser = 0;
        this.origin = origin;
    }
}

const getNonAbstractChildren = (parentNode) => {
    if (parentNode.children) {
        return parentNode.children?.filter(child => {
            if (child instanceof LayoutNode) {
                return !AbstractNode.isAbstract(child.origin);
            }
            if (child instanceof LayoutTreeNode) {
                return !AbstractNode.isAbstract(child.origin.origin);
            }
            return !AbstractNode.isAbstract(child);
        });
    }
    else {
        return [];
    }
};
const findAbstractByEndNode = (parentNode, endNode) => {
    const index = parentNode.children.indexOf(endNode);
    return parentNode.children.find(child => {
        if (child instanceof LayoutNode) {
            return AbstractNode.isAbstract(child.origin) && child.origin.end === index;
        }
        if (child instanceof LayoutTreeNode && parentNode instanceof LayoutTreeNode) {
            if (AbstractNode.isAbstract(child.origin.origin)) {
                const { end } = getCorrectStartEnd(child.origin.origin, parentNode.origin);
                return end === index;
            }
            return false;
        }
        return AbstractNode.isAbstract(child) && child.end === index;
    });
};
const findAbstractByStartNode = (parentNode, startNode) => {
    const index = parentNode.children.indexOf(startNode);
    return parentNode.children.find(child => {
        if (child instanceof LayoutNode) {
            return AbstractNode.isAbstract(child.origin) && child.origin.start === index;
        }
        if (child instanceof LayoutTreeNode && parentNode instanceof LayoutTreeNode) {
            if (AbstractNode.isAbstract(child.origin.origin)) {
                const { start } = getCorrectStartEnd(child.origin.origin, parentNode.origin);
                return start === index;
            }
            return false;
        }
        return AbstractNode.isAbstract(child) && child.start === index;
    });
};
/**
 * handle standard layout effect
 * the abstract correct start and end should sub rightNodeCount when it is set on left area
 */
const getCorrectStartEnd = (abstract, parent) => {
    let start = abstract.start;
    let end = abstract.end;
    if (isStandardLayout(parent.layout)) {
        const rightNodeCount = parent.origin.rightNodeCount;
        if (start >= rightNodeCount) {
            end -= rightNodeCount;
            start -= rightNodeCount;
        }
    }
    return { start, end };
};

function moveSubtree(treeNode, i, distance) {
    // Move subtree by changing modifier.
    treeNode.children[i].modifier += distance;
}
function nextLeftContour(treeNode) {
    return treeNode.childrenCount === 0 ? null : treeNode.children[0];
}
function nextRightContour(treeNode) {
    let children = getNonAbstractChildren(treeNode);
    return treeNode.childrenCount === 0 ? null : children[children.length - 1];
}
// separate left siblings
function separate(treeNode, i) {
    if (AbstractNode.isAbstract(treeNode.children[i].origin.origin)) {
        return;
    }
    let leftNode = treeNode.children[i - 1];
    let rightNode = treeNode.children[i];
    let rightContourOfLeftNode = leftNode.modifier + leftNode.preliminary + leftNode.width;
    let leftContourOfRightNode = rightNode.modifier + rightNode.preliminary;
    let sumOfLeftModifier = 0;
    let leftNodeParent = treeNode;
    let rightNodeParent = treeNode;
    while (leftNode || rightNode) {
        if (leftNode) {
            let right = sumOfLeftModifier + leftNode.modifier + leftNode.preliminary + leftNode.width;
            if (right > rightContourOfLeftNode) {
                rightContourOfLeftNode = right;
            }
            rightContourOfLeftNode = compareAbstractRight(leftNodeParent, leftNode, rightContourOfLeftNode, sumOfLeftModifier);
            leftNodeParent = leftNode;
            sumOfLeftModifier = leftNode.modifier + sumOfLeftModifier;
            leftNode = nextRightContour(leftNode);
        }
        if (rightNode) {
            let left = rightNode.modifier + rightNode.preliminary;
            if (left < leftContourOfRightNode) {
                leftContourOfRightNode = left;
            }
            leftContourOfRightNode = compareAbstractLeft(rightNodeParent, rightNode, leftContourOfRightNode);
            rightNodeParent = rightNode;
            rightNode = nextLeftContour(rightNode);
        }
    }
    const distance = rightContourOfLeftNode - leftContourOfRightNode;
    if (distance > 0) {
        moveSubtree(treeNode, i, distance);
    }
}
function positionRootCenter(treeNode) {
    // Position root between children, taking into account their mod.
    const startNode = treeNode.children[0];
    let startX = startNode.preliminary + startNode.modifier;
    const children = getNonAbstractChildren(treeNode);
    const endNode = children[children.length - 1];
    let endX = endNode.modifier + endNode.preliminary + endNode.width;
    /**
     * nested layout: handle black node
     *                ---------
     *              |   parent  |
     *                ---------
     *  -------------
     * |     | ------ |        | ------ |
     * |     | child1 |        | child2 |
     * |     | ------ |        | ------ |
     * |    black     |
     * |              |
     *  -------------
     * The parent is in the center of child 1 and child 2, not black and child2
     */
    if (startNode.origin.blackNode && startNode.origin.blackNode.rootX > startNode.origin.blackNode.left) {
        startX = startX + (startNode.origin.blackNode.rootX - startNode.origin.blackNode.left);
    }
    if (endNode.origin.blackNode && endNode.origin.blackNode.rootX + endNode.origin.blackNode.rootWidth < endNode.origin.blackNode.right) {
        endX = endX - (endNode.origin.blackNode.right - (endNode.origin.blackNode.rootX + endNode.origin.blackNode.rootWidth));
    }
    /**
     * has underline shape: handle connecting position
     */
    if (startNode.origin.verticalConnectingPosition && endNode.origin.verticalConnectingPosition) {
        startX = startX + startNode.width - startNode.origin.vGap;
        endX = endX - endNode.origin.vGap;
    }
    let treeNodeOffset = treeNode.width / 2;
    if (treeNode.origin.verticalConnectingPosition) {
        treeNodeOffset = treeNode.width - treeNode.origin.vGap;
    }
    const preliminary = (startX + endX) / 2 - treeNodeOffset;
    // move sub tree when preliminary to avoid root shifting to left
    if (preliminary > 0) {
        treeNode.preliminary = preliminary;
    }
    else {
        treeNode.children.forEach((c, index) => {
            moveSubtree(treeNode, index, Math.abs(preliminary));
        });
    }
}
// update node's modifier and root node preliminary
function firstWalk(treeNode) {
    if (treeNode.childrenCount === 0) {
        return;
    }
    firstWalk(treeNode.children[0]);
    for (let i = 1; i < treeNode.childrenCount; i++) {
        // Handle abstract effects on layout at the next node next of abstract end node
        const abstract = treeNode.children.find(abstract => {
            let correctEnd = null;
            if (AbstractNode.isAbstract(abstract.origin.origin)) {
                let { end } = getCorrectStartEnd(abstract.origin.origin, treeNode.origin);
                correctEnd = end;
            }
            return correctEnd === i - 1;
        });
        if (abstract) {
            abstractHandle$1(treeNode, abstract, i);
        }
        firstWalk(treeNode.children[i]);
        separate(treeNode, i);
    }
    positionRootCenter(treeNode);
}
function secondWalk(treeNode, sumOfModifier) {
    sumOfModifier += treeNode.modifier;
    // Set absolute (no-relative) horizontal coordinates.
    treeNode.x = treeNode.preliminary + sumOfModifier;
    for (let i = 0; i < treeNode.childrenCount; i++) {
        secondWalk(treeNode.children[i], sumOfModifier);
    }
}
function abstractHandle$1(treeNode, abstract, i) {
    const { start, end } = getCorrectStartEnd(abstract.origin.origin, treeNode.origin);
    const abstractIndex = treeNode.children.indexOf(abstract);
    const startNode = treeNode.children[start];
    let endNode = treeNode.children[end];
    const includeElementStartX = startNode.modifier;
    let includeElementEndX = endNode.modifier + endNode.preliminary + endNode.width;
    let sumOfLeftModifier = endNode.modifier;
    let nodeParent = treeNode;
    // Align the abstract node with the start node of abstract included
    treeNode.children[abstractIndex].modifier = startNode.modifier;
    while (endNode.childrenCount) {
        nodeParent = endNode;
        const nexRightNode = nextRightContour(endNode);
        endNode = nexRightNode ? nexRightNode : endNode;
        let right = sumOfLeftModifier + endNode.modifier + endNode.preliminary + endNode.width;
        includeElementEndX = compareAbstractRight(nodeParent, endNode, includeElementEndX, sumOfLeftModifier);
        sumOfLeftModifier += endNode.modifier;
        if (right > includeElementEndX) {
            includeElementEndX = right;
        }
    }
    const abstractBranchWidth = abstract.origin.blackNode
        ? abstract.origin.blackNode.rootX * 2 + abstract.origin.blackNode.rootWidth
        : abstract.width;
    const abstractIncludeElementWidth = includeElementEndX - includeElementStartX;
    // move abstract of it included node to ensures that the abstract node and its included nodes are aligned based on the horizontal center
    if (abstractIncludeElementWidth > abstractBranchWidth) {
        const distance = (abstractIncludeElementWidth - abstractBranchWidth) / 2;
        // move abstract node and it's children
        moveSubtree(treeNode, abstractIndex, distance);
    }
    else {
        const distance = (abstractBranchWidth - abstractIncludeElementWidth) / 2;
        // move all of abstract included
        for (let i = start; i < end + 1; i++) {
            moveSubtree(treeNode, i, distance);
        }
    }
}
function compareAbstractRight(nodeParent, node, compareTarget, sumOfAbstractModifier) {
    const abstract = findAbstractByEndNode(nodeParent, node);
    if (abstract) {
        return Math.max(abstract.modifier + abstract.width + sumOfAbstractModifier, compareTarget);
    }
    return compareTarget;
}
function compareAbstractLeft(nodeParent, node, compareTarget) {
    const abstract = findAbstractByStartNode(nodeParent, node);
    if (abstract) {
        return Math.min(abstract.modifier + abstract.preliminary, compareTarget);
    }
    return compareTarget;
}
function layout(treeNode) {
    firstWalk(treeNode);
    secondWalk(treeNode, 0);
}

function separateXAxle(node, d = 0) {
    node.x = d;
    node.children.forEach(child => {
        if (AbstractNode.isAbstract(child.origin)) {
            let width = 0;
            for (let i = child.origin.start; i <= child.origin.end; i++) {
                const box = node.children[i].getBoundingBox();
                width = Math.max(box.width, width);
            }
            separateXAxle(child, node.x + node.width / 2 + width);
        }
        else {
            separateXAxle(child, node.x + node.width / 2);
        }
    });
}
function separateYAxle$1(root, options) {
    let previousBottom = root.y + root.height;
    let previousNode = null;
    updateY(root);
    function updateY(node) {
        node.children.forEach((child, index) => {
            const abstract = node.children.find(child => {
                return AbstractNode.isAbstract(child.origin) && child.origin.end === index - 1;
            });
            if (abstract) {
                const attach = previousNode?.origin.isCollapsed ? options.getExtendHeight(child.origin) : 0;
                previousBottom = abstractHandle(node, abstract) + attach;
            }
            if (AbstractNode.isAbstract(child.origin)) {
                return;
            }
            let y = previousBottom + child.vGap;
            if (previousNode && !isHorizontalLogicLayout(previousNode.layout) && previousNode.origin.children.length > 0) {
                if (previousNode.origin.isCollapsed) {
                    y = y + options.getExtendHeight(child.origin);
                }
                else {
                    y = y + options.getIndentedCrossLevelGap();
                }
            }
            child.y = y;
            previousNode = child;
            previousBottom = child.y + child.height;
            updateY(child);
        });
    }
}
function abstractHandle(node, abstract) {
    const abstractNode = abstract.origin;
    const abstractIndex = node.children.indexOf(abstract);
    const startNode = node.children[abstractNode.start];
    const endNode = node.children[abstractNode.end];
    // abstract and start node alignment
    node.children[abstractIndex].y = startNode.y;
    const topContour = startNode.y;
    let bottomContour = endNode.y + endNode.height;
    let bottomContourNode = endNode;
    let bottomContourParenNode = node;
    while (bottomContourNode?.children.length) {
        bottomContourParenNode = bottomContourNode;
        const children = getNonAbstractChildren(bottomContourParenNode);
        bottomContourNode = children[children.length - 1];
        const abstract = findAbstractByEndNode(bottomContourParenNode, bottomContourNode);
        bottomContour = abstract
            ? Math.max(abstract.y + abstract.height, bottomContourNode.y + bottomContourNode.height)
            : bottomContourNode.y + bottomContourNode.height;
    }
    const abstractIncludedHeight = bottomContour - topContour;
    const abstractHeight = abstract.blackNode ? abstract.blackNode.height : abstract.height;
    const abstractBranchHeight = abstract.blackNode ? abstract.blackNode.rootY * 2 + abstract.blackNode.rootHeight : abstract.height;
    if (abstractBranchHeight > abstractIncludedHeight) {
        const distance = (abstractBranchHeight - abstractIncludedHeight) / 2;
        for (let i = abstractNode.start; i <= abstractNode.end; i++) {
            node.children[i].eachNode(child => {
                child.y += distance;
            });
        }
    }
    else {
        const distance = (abstractIncludedHeight - abstractBranchHeight) / 2;
        node.children[abstractIndex].y += distance;
    }
    return Math.max(abstract.y + abstractHeight, startNode.y + abstractIncludedHeight);
}

function setLayoutTreeResult(tree, root, isHorizontal) {
    if (isHorizontal) {
        root.y = tree.x;
    }
    else {
        root.x = tree.x;
    }
    tree.children.forEach((child, i) => {
        setLayoutTreeResult(child, root.children[i], isHorizontal);
    });
}
function separateYAxle(node, isHorizontal, d = 0) {
    if (isHorizontal) {
        if (AbstractNode.isAbstract(node.origin)) {
            const { start, end } = getCorrectStartEnd(node.origin, node.parent);
            for (let i = start; i <= end; i++) {
                const right = node.parent?.children[i].getBoundingBox().right;
                d = Math.max(right, d);
            }
        }
        node.x = d;
        d += node.width;
    }
    else {
        if (AbstractNode.isAbstract(node.origin)) {
            for (let i = node.origin.start; i <= node.origin.end; i++) {
                const bottom = node.parent?.children[i].getBoundingBox().bottom;
                d = Math.max(bottom, d);
            }
        }
        node.y = d;
        d += node.height;
    }
    node.children.forEach(child => {
        separateYAxle(child, isHorizontal, d);
    });
}
const buildLayoutTree = (root, isHorizontal) => {
    const children = [];
    root.children.forEach(child => {
        children.push(buildLayoutTree(child, isHorizontal));
    });
    if (isHorizontal) {
        if (root.blackNode) {
            root.blackNode = toHorizontal(root.blackNode);
        }
        return new LayoutTreeNode(root.height, root.width, root.x, children, root);
    }
    return new LayoutTreeNode(root.width, root.height, root.y, children, root);
};

class BaseLayout {
    constructor() { }
    layout(node, layoutType, options, context, isHorizontal = false, parent) {
        // build layout node
        const isolatedNodes = [];
        const isolatedLayoutRoots = [];
        // 1、build layout node
        const root = this.buildLayoutNode(node, options, context, isolatedNodes, parent);
        // 2、handle sub node layout
        isolatedNodes
            .filter(v => v.origin.children.length > 0)
            .forEach((isolatedNode) => {
            const _mindLayoutType = isolatedNode.layout;
            const toTop = context.toTop || (isHorizontalLayout(context.rootLayoutType) && isTopLayout(_mindLayoutType));
            const toLeft = context.toLeft || (!isHorizontalLayout(context.rootLayoutType) && isLeftLayout(_mindLayoutType));
            const _isHorizontal = isHorizontalLayout(_mindLayoutType);
            const isolatedRoot = this.layout(isolatedNode.origin, extractLayoutType(_mindLayoutType), options, { toTop, toLeft, rootLayoutType: context.rootLayoutType }, _isHorizontal, isolatedNode.parent);
            if (!context.toTop && toTop && layoutType !== LayoutType.indented) {
                isolatedRoot.down2up();
            }
            if (!context.toLeft && toLeft) {
                isolatedRoot.right2left();
            }
            // 3、set sub node as black box
            const boundingBox = isolatedRoot.getBoundingBox();
            isolatedNode.width = boundingBox.width;
            isolatedNode.height = boundingBox.height;
            isolatedNode.blackNode = new LayoutBlockNode(boundingBox.left, boundingBox.right, boundingBox.top, boundingBox.bottom, boundingBox.width, boundingBox.height, isolatedRoot.x, isolatedRoot.y, isolatedRoot.width, isolatedRoot.height);
            isolatedLayoutRoots.push(isolatedRoot);
        });
        // 4、layout handle
        switch (layoutType) {
            case LayoutType.indented:
                separateXAxle(root);
                separateYAxle$1(root, options);
                break;
            case LayoutType.fishBone:
                break;
            case LayoutType.logic:
            default:
                separateYAxle(root, isHorizontal);
                const layoutTree = buildLayoutTree(root, isHorizontal);
                layout(layoutTree);
                setLayoutTreeResult(layoutTree, root, isHorizontal);
                break;
        }
        // 5、apply isolated nodes to root
        const attachedMetaOfIsolatedNodes = []; // store the offset caused by isolated nodes to avoid multiple offset accumulation
        isolatedNodes
            .filter(v => v.origin.children.length > 0)
            .forEach((isolatedNode, index) => {
            if (isolatedNode.parent) {
                const layoutRoot = isolatedLayoutRoots[index];
                layoutRoot.parent = isolatedNode.parent;
                let offsetX, offsetY;
                const parentNodeIsHorizontalLayout = isHorizontalLayout(isolatedNode.parent.layout);
                // the cross direction does not need to be transformed
                if (parentNodeIsHorizontalLayout) {
                    offsetX = layoutRoot.x;
                    offsetY = 0;
                }
                else {
                    offsetX = 0;
                    offsetY = layoutRoot.y;
                }
                layoutRoot.translate(isolatedNode.x - offsetX, isolatedNode.y - offsetY);
                const _index = isolatedNode.parent.children.indexOf(isolatedNode);
                const oldNode = isolatedNode.parent.children[_index];
                isolatedNode.parent.children[_index] = Object.assign(oldNode, layoutRoot);
                const meta = attachedMetaOfIsolatedNodes.find(m => m.parent === isolatedNode.parent && !AbstractNode.isAbstract(isolatedNode.origin));
                if (meta) {
                    if (meta.offsetX < offsetX) {
                        meta.offsetX = offsetX;
                    }
                    if (meta.offsetX < offsetY) {
                        meta.offsetX = offsetY;
                    }
                }
                else if (!AbstractNode.isAbstract(isolatedNode.origin)) {
                    attachedMetaOfIsolatedNodes.push({ parent: isolatedNode.parent, offsetX, offsetY });
                }
            }
        });
        // 6、correct the offset of sibling nodes caused by sub-layout
        attachedMetaOfIsolatedNodes.forEach(meta => {
            meta.parent.children.forEach(child => child.translate(meta.offsetX, meta.offsetY));
        });
        return root;
    }
    buildLayoutNode(origin, options, context, isolatedNodes, parent) {
        const root = new LayoutNode(origin, options, context, parent);
        if (!root.origin.isCollapsed) {
            const nodes = [root];
            let node;
            while ((node = nodes.pop())) {
                if (!node.origin.isCollapsed) {
                    const children = node.origin.children;
                    const length = children ? children.length : 0;
                    node.children = [];
                    if (children && length) {
                        for (let i = 0; i < length; i++) {
                            const child = new LayoutNode(children[i], options, context, node);
                            node.children.push(child);
                            child.depth = node.depth + 1;
                            const isolated = (node.layout !== child.layout &&
                                (extractLayoutType(node.layout) !== extractLayoutType(child.layout) ||
                                    isHorizontalLayout(node.layout) !== isHorizontalLayout(child.layout))) ||
                                AbstractNode.isAbstract(child.origin);
                            if (isolated && !child.origin.isCollapsed) {
                                isolatedNodes.push(child);
                            }
                            else {
                                nodes.push(child);
                            }
                        }
                    }
                }
            }
        }
        return root;
    }
}

class GlobalLayout {
    static layout(root, options, mindLayoutType) {
        const baseLayout = new BaseLayout();
        if (isStandardLayout(mindLayoutType)) {
            const primaryNodeCount = root.children.length;
            const rightBranchNodes = [];
            const leftBranchNodes = [];
            const fakeRootNode = { ...root };
            for (let i = 0; i < primaryNodeCount; i++) {
                const child = root.children[i];
                if (AbstractNode.isAbstract(child) && child.end < root.rightNodeCount) {
                    rightBranchNodes.push(child);
                    continue;
                }
                if (AbstractNode.isAbstract(child) && child.start >= root.rightNodeCount) {
                    leftBranchNodes.push(child);
                    continue;
                }
                if (i < root.rightNodeCount) {
                    rightBranchNodes.push(child);
                }
                else {
                    leftBranchNodes.push(child);
                }
            }
            // right
            fakeRootNode.children = rightBranchNodes;
            const rightRoot = baseLayout.layout(fakeRootNode, LayoutType.logic, options, { toLeft: false, toTop: false, rootLayoutType: mindLayoutType }, true);
            fakeRootNode.children = leftBranchNodes;
            const leftRoot = baseLayout.layout(fakeRootNode, LayoutType.logic, options, { toLeft: true, toTop: false, rootLayoutType: mindLayoutType }, true);
            leftRoot.right2left();
            rightRoot.translate(leftRoot.x - rightRoot.x, leftRoot.y - rightRoot.y);
            const rightAbstractArray = rightRoot.children.filter(child => AbstractNode.isAbstract(child.origin));
            rightRoot.children = rightRoot.children.filter(child => !AbstractNode.isAbstract(child.origin));
            leftRoot.children.forEach(leftPrimaryNode => {
                rightRoot.children.push(leftPrimaryNode);
                leftPrimaryNode.parent = rightRoot;
            });
            rightRoot.children = rightRoot.children.concat(rightAbstractArray);
            rightRoot.x = leftRoot.x;
            rightRoot.origin = root;
            return rightRoot;
        }
        const isIndented = isIndentedLayout(mindLayoutType);
        const layoutType = isIndented ? LayoutType.indented : LayoutType.logic;
        const isHorizontal = isIndented ? true : isHorizontalLayout(mindLayoutType);
        const toTop = isTopLayout(mindLayoutType);
        const toLeft = isLeftLayout(mindLayoutType);
        const resultRoot = baseLayout.layout(root, layoutType, options, { toTop, toLeft, rootLayoutType: mindLayoutType }, isHorizontal);
        if (toTop) {
            resultRoot.down2up();
        }
        if (toLeft) {
            resultRoot.right2left();
        }
        return resultRoot;
    }
}

/*
 * Public API Surface of layouts
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AbstractNode, ConnectingPosition, GlobalLayout, LayoutBlockNode, LayoutNode, LayoutType, MindLayoutType, extractLayoutType, findAbstractByEndNode, findAbstractByStartNode, findLayoutType, getAbstractLayout, getCorrectStartEnd, getNonAbstractChildren, isBottomLayout, isHorizontalLayout, isHorizontalLogicLayout, isIndentedLayout, isLeftLayout, isLogicLayout, isRightLayout, isStandardLayout, isTopLayout, isVerticalLogicLayout, toHorizontal };
//# sourceMappingURL=plait-layouts.mjs.map
