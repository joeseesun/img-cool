{"version":3,"file":"plait-layouts.mjs","sources":["../../../packages/layouts/src/interfaces/mind.ts","../../../packages/layouts/src/utils/layout.ts","../../../packages/layouts/src/interfaces/layout-node.ts","../../../packages/layouts/src/interfaces/layout-tree-node.ts","../../../packages/layouts/src/utils/abstract.ts","../../../packages/layouts/src/algorithms/non-overlapping-tree-layout.ts","../../../packages/layouts/src/layouts/indent.ts","../../../packages/layouts/src/layouts/logic.ts","../../../packages/layouts/src/layouts/base-layout.ts","../../../packages/layouts/src/layouts/global-layout.ts","../../../packages/layouts/src/public-api.ts","../../../packages/layouts/src/plait-layouts.ts"],"sourcesContent":["import { LayoutNode, ConnectingPosition } from './layout-node';\n\nexport interface LayoutOptions {\n    getHeight: (node: OriginNode) => number;\n    getWidth: (node: OriginNode) => number;\n    getHorizontalGap: (node: OriginNode, parent?: LayoutNode) => number;\n    getVerticalGap: (node: OriginNode, parent?: LayoutNode) => number;\n    getVerticalConnectingPosition: (node: OriginNode, parent?: LayoutNode) => ConnectingPosition;\n    getExtendWidth?: (node: OriginNode) => number;\n    getExtendHeight: (node: OriginNode) => number;\n    getIndentedCrossLevelGap: () => number;\n}\n\nexport interface LayoutContext {\n    toLeft: boolean;\n    toTop: boolean;\n    rootLayoutType: MindLayoutType;\n}\n\nexport interface OriginNode {\n    children: OriginNode[];\n    isCollapsed?: boolean;\n    layout?: string;\n    rightNodeCount: number;\n}\n\nexport interface AbstractNode extends OriginNode {\n    start: number;\n    end: number;\n}\n\nexport const AbstractNode = {\n    isAbstract(value: any): value is AbstractNode {\n        if (typeof value.start === 'number' && typeof value.end === 'number') {\n            return true;\n        } else {\n            return false;\n        }\n    }\n};\n\nexport enum MindLayoutType {\n    'right' = 'right',\n    'left' = 'left',\n    'standard' = 'standard',\n    'upward' = 'upward',\n    'downward' = 'downward',\n    'rightBottomIndented' = 'right-bottom-indented',\n    'rightTopIndented' = 'right-top-indented',\n    'leftTopIndented' = 'left-top-indented',\n    'leftBottomIndented' = 'left-bottom-indented'\n}\n\nexport enum LayoutType {\n    'logic' = 'logic',\n    'indented' = 'indented',\n    'fishBone' = 'fish-bone'\n}\n","import { LayoutNode } from '../interfaces/layout-node';\nimport { AbstractNode, LayoutType, MindLayoutType } from '../interfaces/mind';\n\nexport function findLayoutType(node: LayoutNode): MindLayoutType | null {\n    if (node.origin.layout) {\n        return node.origin.layout as MindLayoutType;\n    }\n\n    if (AbstractNode.isAbstract(node.origin)) {\n        return getAbstractLayout(findLayoutType(node.parent!)!);\n    }\n\n    if (node.parent) {\n        return findLayoutType(node.parent);\n    }\n\n    return null;\n}\n\nexport const isIndentedLayout = (layout: MindLayoutType) => {\n    return (\n        layout === MindLayoutType.rightBottomIndented ||\n        layout === MindLayoutType.rightTopIndented ||\n        layout === MindLayoutType.leftBottomIndented ||\n        layout === MindLayoutType.leftTopIndented\n    );\n};\n\nexport const isLogicLayout = (layout: MindLayoutType) => {\n    return (\n        layout === MindLayoutType.right ||\n        layout === MindLayoutType.left ||\n        layout === MindLayoutType.downward ||\n        layout === MindLayoutType.upward\n    );\n};\n\nexport const isStandardLayout = (layout: MindLayoutType) => {\n    return layout === MindLayoutType.standard;\n};\n\nexport const isHorizontalLayout = (layout: MindLayoutType) => {\n    return (\n        layout === MindLayoutType.right || layout === MindLayoutType.left || layout === MindLayoutType.standard || isIndentedLayout(layout)\n    );\n};\n\nexport const isHorizontalLogicLayout = (layout: MindLayoutType) => {\n    return layout === MindLayoutType.right || layout === MindLayoutType.left || layout === MindLayoutType.standard;\n};\n\nexport const isVerticalLogicLayout = (layout: MindLayoutType) => {\n    return layout === MindLayoutType.upward || layout === MindLayoutType.downward;\n};\n\nexport const isTopLayout = (layout: MindLayoutType) => {\n    return layout === MindLayoutType.leftTopIndented || layout === MindLayoutType.rightTopIndented || layout === MindLayoutType.upward;\n};\n\nexport const isBottomLayout = (layout: MindLayoutType) => {\n    return (\n        layout === MindLayoutType.leftBottomIndented || layout === MindLayoutType.rightBottomIndented || layout === MindLayoutType.downward\n    );\n};\n\nexport const isLeftLayout = (layout: MindLayoutType) => {\n    return layout === MindLayoutType.left || layout === MindLayoutType.leftTopIndented || layout === MindLayoutType.leftBottomIndented;\n};\n\nexport const isRightLayout = (layout: MindLayoutType) => {\n    return layout === MindLayoutType.right || layout === MindLayoutType.rightTopIndented || layout === MindLayoutType.rightBottomIndented;\n};\n\nexport const extractLayoutType = (mindLayoutType: MindLayoutType): LayoutType => {\n    if (isIndentedLayout(mindLayoutType)) {\n        return LayoutType.indented;\n    }\n    if (isStandardLayout(mindLayoutType)) {\n        return LayoutType.logic;\n    }\n    if (isLogicLayout(mindLayoutType)) {\n        return LayoutType.logic;\n    }\n    return LayoutType.logic;\n};\n\nexport const getAbstractLayout = (parentLayout: MindLayoutType) => {\n    if (isIndentedLayout(parentLayout)) {\n        if (isRightLayout(parentLayout)) {\n            return MindLayoutType.right;\n        } else {\n            return MindLayoutType.left;\n        }\n    }\n    return parentLayout;\n};\n","import { LayoutContext, LayoutOptions, MindLayoutType, OriginNode } from './mind';\nimport { findLayoutType } from '../utils/layout';\n\n/**\n * abstract layout node\n */\nexport class LayoutNode {\n    x = 0;\n    y = 0;\n    vGap = 0;\n    hGap = 0;\n    origin: OriginNode;\n    blackNode?: LayoutBlockNode;\n    width = 0;\n    height = 0;\n    depth = 0;\n    children: LayoutNode[] = [];\n    parent?: LayoutNode;\n    left = false;\n    up = false;\n    layout: MindLayoutType;\n    verticalConnectingPosition?: ConnectingPosition;\n\n    constructor(origin: OriginNode, options: LayoutOptions, context: LayoutContext, parent?: LayoutNode) {\n        const hGap = options.getHorizontalGap(origin, parent);\n        const vGap = options.getVerticalGap(origin, parent);\n        this.origin = origin;\n        this.width = options.getWidth(origin);\n        this.height = options.getHeight(origin);\n        this.x = this.y = 0;\n        if (parent) {\n            this.parent = parent;\n        }\n        const layout = findLayoutType(this);\n        this.layout = layout && layout !== MindLayoutType.standard ? layout : context.rootLayoutType;\n\n        const verticalConnectingPosition = options.getVerticalConnectingPosition(origin, parent);\n        if (verticalConnectingPosition) {\n            this.verticalConnectingPosition = verticalConnectingPosition;\n        }\n        this.addGap(hGap, vGap);\n    }\n\n    isRoot() {\n        return this.depth === 0;\n    }\n\n    addGap(hGap: number, vGap: number) {\n        const me = this;\n        me.hGap += hGap;\n        me.vGap += vGap;\n        me.width += 2 * hGap;\n        me.height += 2 * vGap;\n    }\n\n    eachNode(callback: (node: LayoutNode) => void) {\n        depthFirstRecursion(this, callback);\n    }\n\n    getBoundingBox(): BoundingBox {\n        const bb: BoundingBox = {\n            left: Number.MAX_VALUE,\n            top: Number.MAX_VALUE,\n            right: Number.MIN_VALUE,\n            bottom: Number.MIN_VALUE,\n            width: 0,\n            height: 0\n        };\n        this.eachNode(node => {\n            bb.left = Math.min(bb.left, node.x);\n            bb.top = Math.min(bb.top, node.y);\n            bb.right = Math.max(bb.right, node.x + node.width);\n            bb.bottom = Math.max(bb.bottom, node.y + node.height);\n        });\n        bb.width = bb.right - bb.left;\n        bb.height = bb.bottom - bb.top;\n        return bb;\n    }\n\n    translate(tx = 0, ty = 0) {\n        this.eachNode(node => {\n            node.x += tx;\n            node.y += ty;\n        });\n    }\n\n    right2left() {\n        const me = this;\n        const bb = me.getBoundingBox();\n        me.eachNode(node => {\n            node.x = node.x - (node.x - bb.left) * 2 - node.width;\n            node.left = true;\n        });\n        me.translate(bb.width, 0);\n    }\n\n    down2up() {\n        const me = this;\n        const bb = me.getBoundingBox();\n        me.eachNode(node => {\n            node.y = node.y - (node.y - bb.top) * 2 - node.height;\n            node.up = true;\n        });\n        me.translate(0, bb.height);\n    }\n}\n\nfunction depthFirstRecursion(node: LayoutNode, callback: (node: LayoutNode) => void) {\n    node.children?.forEach(child => {\n        depthFirstRecursion(child, callback);\n    });\n    callback(node);\n}\n\nexport interface BoundingBox {\n    left: number;\n    top: number;\n    right: number;\n    bottom: number;\n    width: number;\n    height: number;\n}\n\nexport class LayoutBlockNode {\n    left: number;\n    right: number;\n    top: number;\n    bottom: number;\n    width: number;\n    height: number;\n    rootX: number;\n    rootY: number;\n    rootWidth: number;\n    rootHeight: number;\n\n    constructor(\n        left: number,\n        right: number,\n        top: number,\n        bottom: number,\n        width: number,\n        height: number,\n        rootX: number,\n        rootY: number,\n        rootWidth: number,\n        rootHeight: number\n    ) {\n        this.left = left;\n        this.right = right;\n        this.top = top;\n        this.bottom = bottom;\n        this.width = width;\n        this.height = height;\n        this.rootX = rootX;\n        this.rootY = rootY;\n        this.rootWidth = rootWidth;\n        this.rootHeight = rootHeight;\n    }\n}\n\nexport function toHorizontal(black: LayoutBlockNode): LayoutBlockNode {\n    return {\n        left: black.top,\n        right: black.bottom,\n        top: black.left,\n        bottom: black.right,\n        width: black.height,\n        height: black.width,\n        rootX: black.rootY,\n        rootY: black.rootX,\n        rootWidth: black.rootHeight,\n        rootHeight: black.rootWidth\n    };\n}\n\n/**\n * Connecting position, affecting horizontal layout\n */\nexport enum ConnectingPosition {\n    middle = 'middle',\n    bottom = 'bottom'\n}\n","import { LayoutNode } from './layout-node';\n\n/**\n * abstract tree node for tree layout algorithm\n */\nexport class LayoutTreeNode {\n    width: number;\n    height: number;\n    y: number;\n    children: LayoutTreeNode[];\n    childrenCount: number;\n    x: number;\n    preliminary: number;\n    modifier: number; // Describes how much the entire subtree should be moved horizontally\n    shift: number;\n    change: number;\n    tl: any;\n    tr: any;\n    el: LayoutTreeNode | null;\n    er: LayoutTreeNode | null;\n    msel: number;\n    mser: number;\n    origin: LayoutNode;\n\n    constructor(width: number, height: number, y: number, children: LayoutTreeNode[], origin: LayoutNode) {\n        this.width = width;\n        this.height = height;\n        this.y = y;\n        this.children = children;\n        this.childrenCount = children.length;\n\n        this.x = 0;\n        this.preliminary = 0; // initial horizontal coordinates\n        this.modifier = 0;\n        this.shift = 0;\n        this.change = 0;\n        this.tl = null; // Left thread\n        this.tr = null; // Right thread\n        this.el = null; // extreme left nodes\n        this.er = null; // extreme right nodes\n        //sum of modifiers at the extreme nodes\n        this.msel = 0;\n        this.mser = 0;\n        this.origin = origin;\n    }\n}\n","import { LayoutNode } from '../interfaces/layout-node';\nimport { LayoutTreeNode } from '../interfaces/layout-tree-node';\nimport { AbstractNode } from '../interfaces/mind';\nimport { isStandardLayout } from './layout';\n\nexport const getNonAbstractChildren = <T extends { children?: T[] } = LayoutNode | LayoutTreeNode>(parentNode: T) => {\n    if (parentNode.children) {\n        return parentNode.children?.filter(child => {\n            if (child instanceof LayoutNode) {\n                return !AbstractNode.isAbstract(child.origin);\n            }\n            if (child instanceof LayoutTreeNode) {\n                return !AbstractNode.isAbstract(child.origin.origin);\n            }\n            return !AbstractNode.isAbstract(child);\n        });\n    } else {\n        return [];\n    }\n};\n\nexport const findAbstractByEndNode = <T extends { children: T[] } = LayoutNode | LayoutTreeNode>(parentNode: T, endNode: T) => {\n    const index = parentNode.children.indexOf(endNode);\n    return parentNode.children.find(child => {\n        if (child instanceof LayoutNode) {\n            return AbstractNode.isAbstract(child.origin) && child.origin.end === index;\n        }\n        if (child instanceof LayoutTreeNode && parentNode instanceof LayoutTreeNode) {\n            if (AbstractNode.isAbstract(child.origin.origin)) {\n                const { end } = getCorrectStartEnd(child.origin.origin, parentNode.origin);\n                return end === index;\n            }\n            return false;\n        }\n        return AbstractNode.isAbstract(child) && child.end === index;\n    });\n};\n\nexport const findAbstractByStartNode = <T extends { children: T[] } = LayoutNode | LayoutTreeNode>(parentNode: T, startNode: T) => {\n    const index = parentNode.children.indexOf(startNode);\n    return parentNode.children.find(child => {\n        if (child instanceof LayoutNode) {\n            return AbstractNode.isAbstract(child.origin) && child.origin.start === index;\n        }\n        if (child instanceof LayoutTreeNode && parentNode instanceof LayoutTreeNode) {\n            if (AbstractNode.isAbstract(child.origin.origin)) {\n                const { start } = getCorrectStartEnd(child.origin.origin, parentNode.origin);\n                return start === index;\n            }\n            return false;\n        }\n        return AbstractNode.isAbstract(child) && child.start === index;\n    });\n};\n\n/**\n * handle standard layout effect\n * the abstract correct start and end should sub rightNodeCount when it is set on left area\n */\nexport const getCorrectStartEnd = (abstract: AbstractNode, parent: LayoutNode) => {\n    let start = abstract.start;\n    let end = abstract.end;\n    if (isStandardLayout(parent.layout)) {\n        const rightNodeCount = parent.origin.rightNodeCount;\n        if (start >= rightNodeCount) {\n            end -= rightNodeCount;\n            start -= rightNodeCount;\n        }\n    }\n    return { start, end };\n};\n","import { LayoutTreeNode } from '../interfaces/layout-tree-node';\nimport { findAbstractByEndNode, findAbstractByStartNode, getNonAbstractChildren, getCorrectStartEnd } from '../utils/abstract';\nimport { AbstractNode } from '../interfaces/mind';\n\nfunction moveSubtree(treeNode: LayoutTreeNode, i: number, distance: number) {\n    // Move subtree by changing modifier.\n    treeNode.children[i].modifier += distance;\n}\n\nfunction nextLeftContour(treeNode: LayoutTreeNode) {\n    return treeNode.childrenCount === 0 ? null : treeNode.children[0];\n}\n\nfunction nextRightContour(treeNode: LayoutTreeNode) {\n    let children = getNonAbstractChildren(treeNode);\n    return treeNode.childrenCount === 0 ? null : children[children.length - 1];\n}\n\n// separate left siblings\nfunction separate(treeNode: LayoutTreeNode, i: number) {\n    if (AbstractNode.isAbstract(treeNode.children[i].origin.origin)) {\n        return;\n    }\n\n    let leftNode: LayoutTreeNode | null = treeNode.children[i - 1];\n    let rightNode: LayoutTreeNode | null = treeNode.children[i];\n\n    let rightContourOfLeftNode = leftNode.modifier + leftNode.preliminary + leftNode.width;\n    let leftContourOfRightNode = rightNode.modifier + rightNode.preliminary;\n    let sumOfLeftModifier = 0;\n\n    let leftNodeParent = treeNode;\n    let rightNodeParent = treeNode;\n\n    while (leftNode || rightNode) {\n        if (leftNode) {\n            let right = sumOfLeftModifier + leftNode.modifier + leftNode.preliminary + leftNode.width;\n\n            if (right > rightContourOfLeftNode) {\n                rightContourOfLeftNode = right;\n            }\n            rightContourOfLeftNode = compareAbstractRight(leftNodeParent, leftNode, rightContourOfLeftNode, sumOfLeftModifier);\n\n            leftNodeParent = leftNode;\n            sumOfLeftModifier = leftNode.modifier + sumOfLeftModifier;\n            leftNode = nextRightContour(leftNode);\n        }\n\n        if (rightNode) {\n            let left = rightNode.modifier + rightNode.preliminary;\n            if (left < leftContourOfRightNode) {\n                leftContourOfRightNode = left;\n            }\n\n            leftContourOfRightNode = compareAbstractLeft(rightNodeParent, rightNode, leftContourOfRightNode);\n\n            rightNodeParent = rightNode;\n            rightNode = nextLeftContour(rightNode);\n        }\n    }\n\n    const distance = rightContourOfLeftNode - leftContourOfRightNode;\n    if (distance > 0) {\n        moveSubtree(treeNode, i, distance);\n    }\n}\n\nfunction positionRootCenter(treeNode: LayoutTreeNode) {\n    // Position root between children, taking into account their mod.\n    const startNode = treeNode.children[0];\n    let startX = startNode.preliminary + startNode.modifier;\n    const children = getNonAbstractChildren(treeNode);\n    const endNode = children[children.length - 1];\n    let endX = endNode.modifier + endNode.preliminary + endNode.width;\n\n    /**\n     * nested layout: handle black node\n     *                ---------\n     *              |   parent  |\n     *                ---------\n     *  -------------\n     * |     | ------ |        | ------ |\n     * |     | child1 |        | child2 |\n     * |     | ------ |        | ------ |\n     * |    black     |\n     * |              |\n     *  -------------\n     * The parent is in the center of child 1 and child 2, not black and child2\n     */\n    if (startNode.origin.blackNode && startNode.origin.blackNode.rootX > startNode.origin.blackNode.left) {\n        startX = startX + (startNode.origin.blackNode.rootX - startNode.origin.blackNode.left);\n    }\n    if (endNode.origin.blackNode && endNode.origin.blackNode.rootX + endNode.origin.blackNode.rootWidth < endNode.origin.blackNode.right) {\n        endX = endX - (endNode.origin.blackNode.right - (endNode.origin.blackNode.rootX + endNode.origin.blackNode.rootWidth));\n    }\n\n    /**\n     * has underline shape: handle connecting position\n     */\n    if (startNode.origin.verticalConnectingPosition && endNode.origin.verticalConnectingPosition) {\n        startX = startX + startNode.width - startNode.origin.vGap;\n        endX = endX - endNode.origin.vGap;\n    }\n    let treeNodeOffset = treeNode.width / 2;\n    if (treeNode.origin.verticalConnectingPosition) {\n        treeNodeOffset = treeNode.width - treeNode.origin.vGap;\n    }\n\n    const preliminary = (startX + endX) / 2 - treeNodeOffset;\n    // move sub tree when preliminary to avoid root shifting to left\n    if (preliminary > 0) {\n        treeNode.preliminary = preliminary;\n    } else {\n        treeNode.children.forEach((c, index) => {\n            moveSubtree(treeNode, index, Math.abs(preliminary));\n        });\n    }\n}\n\n// update node's modifier and root node preliminary\nfunction firstWalk(treeNode: LayoutTreeNode) {\n    if (treeNode.childrenCount === 0) {\n        return;\n    }\n    firstWalk(treeNode.children[0]);\n    for (let i = 1; i < treeNode.childrenCount; i++) {\n        // Handle abstract effects on layout at the next node next of abstract end node\n        const abstract = treeNode.children.find(abstract => {\n            let correctEnd = null;\n            if (AbstractNode.isAbstract(abstract.origin.origin)) {\n                let { end } = getCorrectStartEnd(abstract.origin.origin, treeNode.origin);\n                correctEnd = end;\n            }\n            return correctEnd === i - 1;\n        });\n\n        if (abstract) {\n            abstractHandle(treeNode, abstract, i);\n        }\n\n        firstWalk(treeNode.children[i]);\n        separate(treeNode, i);\n    }\n    positionRootCenter(treeNode);\n}\n\nfunction secondWalk(treeNode: LayoutTreeNode, sumOfModifier: number) {\n    sumOfModifier += treeNode.modifier;\n    // Set absolute (no-relative) horizontal coordinates.\n    treeNode.x = treeNode.preliminary + sumOfModifier;\n    for (let i = 0; i < treeNode.childrenCount; i++) {\n        secondWalk(treeNode.children[i], sumOfModifier);\n    }\n}\n\nfunction abstractHandle(treeNode: LayoutTreeNode, abstract: LayoutTreeNode, i: number) {\n    const { start, end } = getCorrectStartEnd(abstract.origin.origin as AbstractNode, treeNode.origin);\n\n    const abstractIndex = treeNode.children.indexOf(abstract);\n    const startNode = treeNode.children[start];\n\n    let endNode = treeNode.children[end];\n\n    const includeElementStartX = startNode.modifier;\n    let includeElementEndX = endNode.modifier + endNode.preliminary + endNode.width;\n\n    let sumOfLeftModifier = endNode.modifier;\n    let nodeParent = treeNode;\n\n    // Align the abstract node with the start node of abstract included\n    treeNode.children[abstractIndex].modifier = startNode.modifier;\n\n    while (endNode.childrenCount) {\n        nodeParent = endNode;\n        const nexRightNode = nextRightContour(endNode);\n        endNode = nexRightNode ? nexRightNode : endNode;\n        let right = sumOfLeftModifier + endNode.modifier + endNode.preliminary + endNode.width;\n\n        includeElementEndX = compareAbstractRight(nodeParent, endNode, includeElementEndX, sumOfLeftModifier);\n        sumOfLeftModifier += endNode.modifier;\n\n        if (right > includeElementEndX) {\n            includeElementEndX = right;\n        }\n    }\n\n    const abstractBranchWidth = abstract.origin.blackNode\n        ? abstract.origin.blackNode.rootX * 2 + abstract.origin.blackNode.rootWidth\n        : abstract.width;\n    const abstractIncludeElementWidth = includeElementEndX - includeElementStartX;\n\n    // move abstract of it included node to ensures that the abstract node and its included nodes are aligned based on the horizontal center\n    if (abstractIncludeElementWidth > abstractBranchWidth) {\n        const distance = (abstractIncludeElementWidth - abstractBranchWidth) / 2;\n        // move abstract node and it's children\n        moveSubtree(treeNode, abstractIndex, distance);\n    } else {\n        const distance = (abstractBranchWidth - abstractIncludeElementWidth) / 2;\n        // move all of abstract included\n        for (let i = start; i < end + 1; i++) {\n            moveSubtree(treeNode, i, distance);\n        }\n    }\n}\n\nfunction compareAbstractRight(nodeParent: LayoutTreeNode, node: LayoutTreeNode, compareTarget: number, sumOfAbstractModifier: number) {\n    const abstract = findAbstractByEndNode(nodeParent, node);\n    if (abstract) {\n        return Math.max(abstract.modifier + abstract.width + sumOfAbstractModifier, compareTarget);\n    }\n    return compareTarget;\n}\n\nfunction compareAbstractLeft(nodeParent: LayoutTreeNode, node: LayoutTreeNode, compareTarget: number) {\n    const abstract = findAbstractByStartNode(nodeParent, node);\n\n    if (abstract) {\n        return Math.min(abstract.modifier + abstract.preliminary, compareTarget);\n    }\n    return compareTarget;\n}\n\nfunction layout(treeNode: LayoutTreeNode) {\n    firstWalk(treeNode);\n    secondWalk(treeNode, 0);\n}\n\nexport { layout };\n","import { LayoutNode } from '../interfaces/layout-node';\nimport { AbstractNode, LayoutOptions } from '../interfaces/mind';\nimport { findAbstractByEndNode, getNonAbstractChildren } from '../utils/abstract';\nimport { isHorizontalLogicLayout } from '../utils/layout';\n\nexport function separateXAxle(node: LayoutNode, d = 0) {\n    node.x = d;\n    node.children.forEach(child => {\n        if (AbstractNode.isAbstract(child.origin)) {\n            let width = 0;\n            for (let i = child.origin.start!; i <= child.origin.end!; i++) {\n                const box = node.children[i].getBoundingBox();\n                width = Math.max(box.width, width);\n            }\n            separateXAxle(child, node.x + node.width / 2 + width);\n        } else {\n            separateXAxle(child, node.x + node.width / 2);\n        }\n    });\n}\n\nexport function separateYAxle(root: LayoutNode, options: LayoutOptions) {\n    let previousBottom = root.y + root.height;\n    let previousNode: null | LayoutNode = null;\n    updateY(root);\n    function updateY(node: LayoutNode) {\n        node.children.forEach((child, index) => {\n            const abstract = node.children.find(child => {\n                return AbstractNode.isAbstract(child.origin) && child.origin.end === index - 1;\n            });\n            if (abstract) {\n                const attach = previousNode?.origin.isCollapsed ? options.getExtendHeight(child.origin) : 0;\n                previousBottom = abstractHandle(node, abstract) + attach;\n            }\n\n            if (AbstractNode.isAbstract(child.origin)) {\n                return;\n            }\n\n            let y = previousBottom + child.vGap;\n            if (previousNode && !isHorizontalLogicLayout(previousNode.layout) && previousNode.origin.children.length > 0) {\n                if (previousNode.origin.isCollapsed) {\n                    y = y + options.getExtendHeight(child.origin);\n                } else {\n                    y = y + options.getIndentedCrossLevelGap();\n                }\n            }\n            child.y = y;\n            previousNode = child;\n            previousBottom = child.y + child.height;\n            updateY(child);\n        });\n    }\n}\n\nfunction abstractHandle(node: LayoutNode, abstract: LayoutNode) {\n    const abstractNode = abstract.origin as AbstractNode;\n    const abstractIndex = node.children.indexOf(abstract);\n    const startNode = node.children[abstractNode.start];\n    const endNode = node.children[abstractNode.end];\n\n    // abstract and start node alignment\n    node.children[abstractIndex].y = startNode.y;\n\n    const topContour = startNode.y;\n    let bottomContour = endNode.y + endNode.height;\n\n    let bottomContourNode: LayoutNode | null = endNode;\n    let bottomContourParenNode = node;\n\n    while (bottomContourNode?.children.length) {\n        bottomContourParenNode = bottomContourNode;\n        const children = getNonAbstractChildren(bottomContourParenNode);\n        bottomContourNode = children[children.length - 1];\n\n        const abstract = findAbstractByEndNode(bottomContourParenNode, bottomContourNode);\n        bottomContour = abstract\n            ? Math.max(abstract.y + abstract.height, bottomContourNode.y + bottomContourNode.height)\n            : bottomContourNode.y + bottomContourNode.height;\n    }\n\n    const abstractIncludedHeight = bottomContour - topContour;\n    const abstractHeight = abstract.blackNode ? abstract.blackNode.height : abstract.height;\n    const abstractBranchHeight = abstract.blackNode ? abstract.blackNode.rootY * 2 + abstract.blackNode.rootHeight : abstract.height;\n    if (abstractBranchHeight > abstractIncludedHeight) {\n        const distance = (abstractBranchHeight - abstractIncludedHeight) / 2;\n        for (let i = abstractNode.start; i <= abstractNode.end; i++) {\n            node.children[i].eachNode(child => {\n                child.y += distance;\n            });\n        }\n    } else {\n        const distance = (abstractIncludedHeight - abstractBranchHeight) / 2;\n        node.children[abstractIndex].y += distance;\n    }\n    return Math.max(abstract.y + abstractHeight, startNode.y + abstractIncludedHeight);\n}\n","import { LayoutNode, toHorizontal } from '../interfaces/layout-node';\nimport { LayoutTreeNode } from '../interfaces/layout-tree-node';\nimport { AbstractNode } from '../interfaces/mind';\nimport { getCorrectStartEnd } from '../utils/abstract';\n\nexport function setLayoutTreeResult(tree: LayoutTreeNode, root: LayoutNode, isHorizontal: Boolean) {\n    if (isHorizontal) {\n        root.y = tree.x;\n    } else {\n        root.x = tree.x;\n    }\n    tree.children.forEach((child, i) => {\n        setLayoutTreeResult(child, root.children[i], isHorizontal);\n    });\n}\n\nexport function separateYAxle(node: LayoutNode, isHorizontal: boolean, d = 0) {\n    if (isHorizontal) {\n        if (AbstractNode.isAbstract(node.origin)) {\n            const { start, end } = getCorrectStartEnd(node.origin, node.parent!);\n\n            for (let i = start!; i <= end!; i++) {\n                const right = node.parent?.children[i].getBoundingBox().right;\n                d = Math.max(right!, d);\n            }\n        }\n        node.x = d;\n\n        d += node.width;\n    } else {\n        if (AbstractNode.isAbstract(node.origin)) {\n            for (let i = node.origin.start!; i <= node.origin.end!; i++) {\n                const bottom = node.parent?.children[i].getBoundingBox().bottom;\n                d = Math.max(bottom!, d);\n            }\n        }\n        node.y = d;\n        d += node.height;\n    }\n    node.children.forEach(child => {\n        separateYAxle(child, isHorizontal, d);\n    });\n}\n\nexport const buildLayoutTree = (root: LayoutNode, isHorizontal: boolean) => {\n    const children: LayoutTreeNode[] = [];\n    root.children.forEach(child => {\n        children.push(buildLayoutTree(child, isHorizontal));\n    });\n    if (isHorizontal) {\n        if (root.blackNode) {\n            root.blackNode = toHorizontal(root.blackNode);\n        }\n        return new LayoutTreeNode(root.height, root.width, root.x, children, root);\n    }\n    return new LayoutTreeNode(root.width, root.height, root.y, children, root);\n};\n","import { layout } from '../algorithms/non-overlapping-tree-layout';\nimport { LayoutBlockNode, LayoutNode } from '../interfaces/layout-node';\nimport { AbstractNode, LayoutContext, LayoutOptions, LayoutType, MindLayoutType, OriginNode } from '../interfaces/mind';\nimport { extractLayoutType, isHorizontalLayout, isLeftLayout, isTopLayout } from '../utils/layout';\nimport * as indent from './indent';\nimport * as logic from './logic';\n\nexport class BaseLayout {\n    constructor() {}\n\n    layout(\n        node: OriginNode,\n        layoutType: string,\n        options: LayoutOptions,\n        context: LayoutContext,\n        isHorizontal = false,\n        parent?: LayoutNode\n    ) {\n        // build layout node\n        const isolatedNodes: LayoutNode[] = [];\n        const isolatedLayoutRoots: LayoutNode[] = [];\n\n        // 1、build layout node\n        const root = this.buildLayoutNode(node, options, context, isolatedNodes, parent);\n\n        // 2、handle sub node layout\n        isolatedNodes\n            .filter(v => v.origin.children.length > 0)\n            .forEach((isolatedNode: LayoutNode) => {\n                const _mindLayoutType = isolatedNode.layout as MindLayoutType;\n                const toTop = context.toTop || (isHorizontalLayout(context.rootLayoutType) && isTopLayout(_mindLayoutType));\n                const toLeft = context.toLeft || (!isHorizontalLayout(context.rootLayoutType) && isLeftLayout(_mindLayoutType));\n                const _isHorizontal = isHorizontalLayout(_mindLayoutType);\n                const isolatedRoot = this.layout(\n                    isolatedNode.origin,\n                    extractLayoutType(_mindLayoutType),\n                    options,\n                    { toTop, toLeft, rootLayoutType: context.rootLayoutType },\n                    _isHorizontal,\n                    isolatedNode.parent\n                );\n                if (!context.toTop && toTop && layoutType !== LayoutType.indented) {\n                    isolatedRoot.down2up();\n                }\n                if (!context.toLeft && toLeft) {\n                    isolatedRoot.right2left();\n                }\n                // 3、set sub node as black box\n                const boundingBox = isolatedRoot.getBoundingBox();\n                isolatedNode.width = boundingBox.width;\n                isolatedNode.height = boundingBox.height;\n                isolatedNode.blackNode = new LayoutBlockNode(\n                    boundingBox.left,\n                    boundingBox.right,\n                    boundingBox.top,\n                    boundingBox.bottom,\n                    boundingBox.width,\n                    boundingBox.height,\n                    isolatedRoot.x,\n                    isolatedRoot.y,\n                    isolatedRoot.width,\n                    isolatedRoot.height\n                );\n\n                isolatedLayoutRoots.push(isolatedRoot);\n            });\n\n        // 4、layout handle\n        switch (layoutType) {\n            case LayoutType.indented:\n                indent.separateXAxle(root);\n                indent.separateYAxle(root, options);\n                break;\n            case LayoutType.fishBone:\n                break;\n            case LayoutType.logic:\n            default:\n                logic.separateYAxle(root, isHorizontal);\n                const layoutTree = logic.buildLayoutTree(root, isHorizontal);\n                layout(layoutTree);\n                logic.setLayoutTreeResult(layoutTree, root, isHorizontal);\n                break;\n        }\n\n        // 5、apply isolated nodes to root\n        const attachedMetaOfIsolatedNodes: { parent: LayoutNode; offsetX: number; offsetY: number }[] = []; // store the offset caused by isolated nodes to avoid multiple offset accumulation\n        isolatedNodes\n            .filter(v => v.origin.children.length > 0)\n            .forEach((isolatedNode: LayoutNode, index) => {\n                if (isolatedNode.parent) {\n                    const layoutRoot = isolatedLayoutRoots[index];\n                    layoutRoot.parent = isolatedNode.parent;\n                    let offsetX, offsetY;\n                    const parentNodeIsHorizontalLayout = isHorizontalLayout(isolatedNode.parent.layout);\n                    // the cross direction does not need to be transformed\n                    if (parentNodeIsHorizontalLayout) {\n                        offsetX = layoutRoot.x;\n                        offsetY = 0;\n                    } else {\n                        offsetX = 0;\n                        offsetY = layoutRoot.y;\n                    }\n                    layoutRoot.translate(isolatedNode.x - offsetX, isolatedNode.y - offsetY);\n                    const _index = isolatedNode.parent.children.indexOf(isolatedNode);\n                    const oldNode = isolatedNode.parent.children[_index];\n                    isolatedNode.parent.children[_index] = Object.assign(oldNode, layoutRoot);\n                    const meta = attachedMetaOfIsolatedNodes.find(\n                        m => m.parent === isolatedNode.parent && !AbstractNode.isAbstract(isolatedNode.origin)\n                    );\n                    if (meta) {\n                        if (meta.offsetX < offsetX) {\n                            meta.offsetX = offsetX;\n                        }\n                        if (meta.offsetX < offsetY) {\n                            meta.offsetX = offsetY;\n                        }\n                    } else if (!AbstractNode.isAbstract(isolatedNode.origin)) {\n                        attachedMetaOfIsolatedNodes.push({ parent: isolatedNode.parent, offsetX, offsetY });\n                    }\n                }\n            });\n        // 6、correct the offset of sibling nodes caused by sub-layout\n        attachedMetaOfIsolatedNodes.forEach(meta => {\n            meta.parent.children.forEach(child => child.translate(meta.offsetX, meta.offsetY));\n        });\n\n        return root;\n    }\n\n    private buildLayoutNode(\n        origin: OriginNode,\n        options: LayoutOptions,\n        context: LayoutContext,\n        isolatedNodes: LayoutNode[],\n        parent?: LayoutNode\n    ) {\n        const root = new LayoutNode(origin, options, context, parent);\n        if (!root.origin.isCollapsed) {\n            const nodes: LayoutNode[] = [root];\n            let node: LayoutNode | undefined;\n            while ((node = nodes.pop())) {\n                if (!node.origin.isCollapsed) {\n                    const children = node.origin.children;\n                    const length = children ? children.length : 0;\n                    node.children = [];\n                    if (children && length) {\n                        for (let i = 0; i < length; i++) {\n                            const child = new LayoutNode(children[i], options, context, node);\n                            node.children.push(child);\n                            child.depth = node.depth + 1;\n                            const isolated =\n                                (node.layout !== child.layout &&\n                                    (extractLayoutType(node.layout) !== extractLayoutType(child.layout) ||\n                                        isHorizontalLayout(node.layout) !== isHorizontalLayout(child.layout))) ||\n                                AbstractNode.isAbstract(child.origin);\n                            if (isolated && !child.origin.isCollapsed) {\n                                isolatedNodes.push(child);\n                            } else {\n                                nodes.push(child);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return root;\n    }\n}\n","import { AbstractNode, LayoutOptions, LayoutType, MindLayoutType, OriginNode } from '../interfaces/mind';\nimport { isHorizontalLayout, isIndentedLayout, isLeftLayout, isStandardLayout, isTopLayout } from '../utils/layout';\nimport { BaseLayout } from './base-layout';\n\nexport class GlobalLayout {\n    static layout(root: OriginNode, options: LayoutOptions, mindLayoutType: MindLayoutType) {\n        const baseLayout = new BaseLayout();\n\n        if (isStandardLayout(mindLayoutType)) {\n            const primaryNodeCount = root.children.length;\n            const rightBranchNodes = [];\n            const leftBranchNodes = [];\n            const fakeRootNode = { ...root };\n            for (let i = 0; i < primaryNodeCount; i++) {\n                const child = root.children[i];\n\n                if (AbstractNode.isAbstract(child) && child.end < root.rightNodeCount) {\n                    rightBranchNodes.push(child);\n                    continue;\n                }\n                if (AbstractNode.isAbstract(child) && child.start >= root.rightNodeCount) {\n                    leftBranchNodes.push(child);\n                    continue;\n                }\n\n                if (i < root.rightNodeCount) {\n                    rightBranchNodes.push(child);\n                } else {\n                    leftBranchNodes.push(child);\n                }\n            }\n            // right\n            fakeRootNode.children = rightBranchNodes;\n            const rightRoot = baseLayout.layout(\n                fakeRootNode,\n                LayoutType.logic,\n                options,\n                { toLeft: false, toTop: false, rootLayoutType: mindLayoutType },\n                true\n            );\n            fakeRootNode.children = leftBranchNodes;\n            const leftRoot = baseLayout.layout(\n                fakeRootNode,\n                LayoutType.logic,\n                options,\n                { toLeft: true, toTop: false, rootLayoutType: mindLayoutType },\n                true\n            );\n            leftRoot.right2left();\n            rightRoot.translate(leftRoot.x - rightRoot.x, leftRoot.y - rightRoot.y);\n\n            const rightAbstractArray = rightRoot.children.filter(child => AbstractNode.isAbstract(child.origin));\n            rightRoot.children = rightRoot.children.filter(child => !AbstractNode.isAbstract(child.origin));\n\n            leftRoot.children.forEach(leftPrimaryNode => {\n                rightRoot.children.push(leftPrimaryNode);\n                leftPrimaryNode.parent = rightRoot;\n            });\n            rightRoot.children = rightRoot.children.concat(rightAbstractArray);\n\n            rightRoot.x = leftRoot.x;\n            rightRoot.origin = root;\n            return rightRoot;\n        }\n\n        const isIndented = isIndentedLayout(mindLayoutType);\n        const layoutType = isIndented ? LayoutType.indented : LayoutType.logic;\n        const isHorizontal = isIndented ? true : isHorizontalLayout(mindLayoutType);\n        const toTop = isTopLayout(mindLayoutType);\n        const toLeft = isLeftLayout(mindLayoutType);\n        const resultRoot = baseLayout.layout(root, layoutType, options, { toTop, toLeft, rootLayoutType: mindLayoutType }, isHorizontal);\n        if (toTop) {\n            resultRoot.down2up();\n        }\n        if (toLeft) {\n            resultRoot.right2left();\n        }\n        return resultRoot;\n    }\n}\n","/*\n * Public API Surface of layouts\n */\n\nexport * from './layouts/global-layout';\nexport * from './utils/layout';\nexport * from './utils/abstract';\nexport * from './interfaces/layout-node';\nexport * from './interfaces/mind';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":["abstractHandle","separateYAxle","indent.separateXAxle","indent.separateYAxle","logic.separateYAxle","logic.buildLayoutTree","logic.setLayoutTreeResult"],"mappings":"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"}