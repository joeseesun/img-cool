import { PlaitBoard, PlaitOperation } from '../interfaces';
/**
 * Check whether to merge an operation into the previous operation.
 */
export declare const shouldMerge: (op: PlaitOperation, prev: PlaitOperation | undefined) => boolean;
/**
 * Check whether an operation needs to be saved to the history.
 */
export declare const shouldSave: (op: PlaitOperation, prev: PlaitOperation | undefined) => boolean;
/**
 * Check whether an operation should clear the redos stack.
 */
export declare const shouldClear: (op: PlaitOperation) => boolean;
export declare const PlaitHistoryBoard: {
    /**
     * Get the saving flag's current value.
     */
    isSaving(board: PlaitBoard): boolean | undefined;
    /**
     * Get the merge flag's current value.
     */
    isMerging(board: PlaitBoard): boolean | undefined;
    /**
     * Get the splitting once flag's current value.
     */
    isSplittingOnce(board: PlaitBoard): boolean | undefined;
    setSplittingOnce(board: PlaitBoard, value: boolean | undefined): void;
    /**
     * Apply a series of changes inside a synchronous `fn`, These operations will
     * be merged into the previous history.
     */
    withMerging(board: PlaitBoard, fn: () => void): void;
    /**
     * Apply a series of changes inside a synchronous `fn`, ensuring that the first
     * operation starts a new batch in the history. Subsequent operations will be
     * merged as usual.
     */
    withNewBatch(board: PlaitBoard, fn: () => void): void;
    /**
     * Apply a series of changes inside a synchronous `fn`, without merging any of
     * the new operations into previous save point in the history.
     */
    withoutMerging(board: PlaitBoard, fn: () => void): void;
    /**
     * Apply a series of changes inside a synchronous `fn`, without saving any of
     * their operations into the history.
     */
    withoutSaving(board: PlaitBoard, fn: () => void): void;
};
