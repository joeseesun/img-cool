import { Point, SVGArcCommand } from '../interfaces';
import { RectangleClient } from '../interfaces/rectangle-client';
export declare function distanceBetweenPointAndSegment(x: number, y: number, x1: number, y1: number, x2: number, y2: number): number;
export declare function getNearestPointBetweenPointAndSegment(point: Point, linePoints: [Point, Point]): Point;
export declare function distanceBetweenPointAndSegments(point: Point, points: Point[]): number;
export declare function getNearestPointBetweenPointAndSegments(point: Point, points: Point[], isClose?: Boolean): Point;
export declare function getNearestPointBetweenPointAndDiscreteSegments(point: Point, segments: [Point, Point][]): Point;
export declare function getNearestPointBetweenPointAndEllipse(point: Point, center: Point, rx: number, ry: number): Point;
export declare function rotate(x1: number, y1: number, x2: number, y2: number, angle: number): number[];
export declare function distanceBetweenPointAndPoint(x1: number, y1: number, x2: number, y2: number): number;
export declare function distanceBetweenPointAndRectangle(x: number, y: number, rect: RectangleClient): number;
export declare const isLineHitLine: (a: Point, b: Point, c: Point, d: Point) => boolean;
export declare const isLineHitRectangle: (points: Point[], rectangle: RectangleClient) => boolean;
export declare const isLineHitRectangleEdge: (points: Point[], rectangle: RectangleClient, isClose?: boolean) => boolean;
export declare const isSingleLineHitRectangleEdge: (p1: Point, p2: Point, rectangle: RectangleClient) => boolean;
export declare const isPointInPolygon: (point: Point, points: Point[]) => boolean;
export declare const isPointInEllipse: (point: Point, center: Point, rx: number, ry: number, angle?: number) => boolean;
export declare const isPointInRoundRectangle: (point: Point, rectangle: RectangleClient, radius: number, angle?: number) => boolean;
export declare const catmullRomFitting: (points: Point[]) => Point[];
/**
 * the result of slope is based on Cartesian coordinate system
 * x, y are based on the position in the Cartesian coordinate system
 */
export declare function getEllipseTangentSlope(x: number, y: number, a: number, b: number): number;
/**
 * x, y are based on the position in the Cartesian coordinate system
 */
export declare function getVectorFromPointAndSlope(x: number, y: number, slope: number): Point;
/**
 * The DOM likes values to be fixed to 3 decimal places
 */
export declare function toDomPrecision(v: number): number;
export declare function toFixed(v: number): number;
export declare function ceilToDecimal(value: number, decimalPlaces: number): number;
/**
 * Whether two numbers numbers a and b are approximately equal.
 *
 * @param a - The first point.
 * @param b - The second point.
 * @public
 */
export declare function approximately(a: number, b: number, precision?: number): boolean;
export declare function getCrossingPointsBetweenEllipseAndSegment(startPoint: Point, endPoint: Point, cx: number, cy: number, rx: number, ry: number, segment_only?: boolean): number[][];
/**
 * Get a point between two points.
 * @param x0 The x-axis coordinate of the first point.
 * @param y0 The y-axis coordinate of the first point.
 * @param x1 The x-axis coordinate of the second point.
 * @param y1 The y-axis coordinate of the second point.
 * @param d Normalized
 */
export declare function getPointBetween(x0: number, y0: number, x1: number, y1: number, d?: number): number[];
/**
 * 获取点到半椭圆弧段的最近点
 * @param point 目标点
 * @param startPoint 弧段起点
 * @param arcCommand SVG 弧形命令参数
 */
/**
 * 计算椭圆弧的中心点和实际半径
 */
export declare function getEllipseArcCenter(startPoint: Point, arcCommand: SVGArcCommand): {
    center: Point;
    rx: number;
    ry: number;
};
export declare function getNearestPointBetweenPointAndArc(point: Point, startPoint: Point, arcCommand: SVGArcCommand): Point;
