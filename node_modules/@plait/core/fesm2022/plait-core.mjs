import { createDraft, finishDraft, isDraft } from 'immer';
import { isKeyHotkey, isHotkey } from 'is-hotkey';
import { Subject } from 'rxjs';

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const MAC_ENTER = 3;
const BACKSPACE = 8;
const TAB = 9;
const NUM_CENTER = 12;
const ENTER = 13;
const SHIFT = 16;
const CONTROL = 17;
const ALT = 18;
const PAUSE = 19;
const CAPS_LOCK = 20;
const ESCAPE = 27;
const SPACE = 32;
const PAGE_UP = 33;
const PAGE_DOWN = 34;
const END = 35;
const HOME = 36;
const LEFT_ARROW = 37;
const UP_ARROW = 38;
const RIGHT_ARROW = 39;
const DOWN_ARROW = 40;
const PLUS_SIGN = 43;
const PRINT_SCREEN = 44;
const INSERT = 45;
const DELETE = 46;
const ZERO = 48;
const ONE = 49;
const TWO = 50;
const THREE = 51;
const FOUR = 52;
const FIVE = 53;
const SIX = 54;
const SEVEN = 55;
const EIGHT = 56;
const NINE = 57;
const FF_SEMICOLON = 59; // Firefox (Gecko) fires this for semicolon instead of 186
const FF_EQUALS = 61; // Firefox (Gecko) fires this for equals instead of 187
const QUESTION_MARK = 63;
const AT_SIGN = 64;
const A = 65;
const B = 66;
const C = 67;
const D = 68;
const E = 69;
const F = 70;
const G = 71;
const H = 72;
const I = 73;
const J = 74;
const K = 75;
const L = 76;
const M = 77;
const N = 78;
const O = 79;
const P = 80;
const Q = 81;
const R = 82;
const S = 83;
const T = 84;
const U = 85;
const V = 86;
const W = 87;
const X = 88;
const Y = 89;
const Z = 90;
const META = 91; // WIN_KEY_LEFT
const MAC_WK_CMD_LEFT = 91;
const MAC_WK_CMD_RIGHT = 93;
const CONTEXT_MENU = 93;
const NUMPAD_ZERO = 96;
const NUMPAD_ONE = 97;
const NUMPAD_TWO = 98;
const NUMPAD_THREE = 99;
const NUMPAD_FOUR = 100;
const NUMPAD_FIVE = 101;
const NUMPAD_SIX = 102;
const NUMPAD_SEVEN = 103;
const NUMPAD_EIGHT = 104;
const NUMPAD_NINE = 105;
const NUMPAD_MULTIPLY = 106;
const NUMPAD_PLUS = 107;
const NUMPAD_MINUS = 109;
const NUMPAD_PERIOD = 110;
const NUMPAD_DIVIDE = 111;
const F1 = 112;
const F2 = 113;
const F3 = 114;
const F4 = 115;
const F5 = 116;
const F6 = 117;
const F7 = 118;
const F8 = 119;
const F9 = 120;
const F10 = 121;
const F11 = 122;
const F12 = 123;
const NUM_LOCK = 144;
const SCROLL_LOCK = 145;
const FIRST_MEDIA = 166;
const FF_MINUS = 173;
const MUTE = 173; // Firefox (Gecko) fires 181 for MUTE
const VOLUME_DOWN = 174; // Firefox (Gecko) fires 182 for VOLUME_DOWN
const VOLUME_UP = 175; // Firefox (Gecko) fires 183 for VOLUME_UP
const FF_MUTE = 181;
const FF_VOLUME_DOWN = 182;
const LAST_MEDIA = 183;
const FF_VOLUME_UP = 183;
const SEMICOLON = 186; // Firefox (Gecko) fires 59 for SEMICOLON
const EQUALS = 187; // Firefox (Gecko) fires 61 for EQUALS
const COMMA = 188;
const DASH = 189; // Firefox (Gecko) fires 173 for DASH/MINUS
const PERIOD = 190;
const SLASH = 191;
const APOSTROPHE = 192;
const TILDE = 192;
const OPEN_SQUARE_BRACKET = 219;
const BACKSLASH = 220;
const CLOSE_SQUARE_BRACKET = 221;
const SINGLE_QUOTE = 222;
const MAC_META = 224;

var ResizeCursorClass;
(function (ResizeCursorClass) {
    ResizeCursorClass["ew"] = "ew-resize";
    ResizeCursorClass["ns"] = "ns-resize";
    ResizeCursorClass["nesw"] = "nesw-resize";
    ResizeCursorClass["nwse"] = "nwse-resize";
})(ResizeCursorClass || (ResizeCursorClass = {}));
var CursorClass;
(function (CursorClass) {
    CursorClass["crosshair"] = "crosshair";
})(CursorClass || (CursorClass = {}));
const RESIZE_CURSORS = [ResizeCursorClass.ns, ResizeCursorClass.nesw, ResizeCursorClass.ew, ResizeCursorClass.nwse];

const ATTACHED_ELEMENT_CLASS_NAME = 'plait-board-attached';
const ACTIVE_STROKE_WIDTH = 1;
const SNAPPING_STROKE_WIDTH = 2;
const SELECTION_RECTANGLE_CLASS_NAME = 'selection-rectangle';
const SELECTION_RECTANGLE_BOUNDING_CLASS_NAME = 'selection-rectangle-bounding';

const ZOOM_STEP = 0.1;
const MIN_ZOOM = 0.1;
const MAX_ZOOM = 4;

const HOST_CLASS_NAME = 'plait-board-container';
const ACTIVE_MOVING_CLASS_NAME = 'active-with-moving';
const ROTATE_HANDLE_CLASS_NAME = 'rotate-handle';
const RESIZE_HANDLE_CLASS_NAME = 'resize-handle';
const SCROLL_BAR_WIDTH = 20;
const MAX_RADIUS = 16;
const POINTER_BUTTON = {
    MAIN: 0,
    WHEEL: 1,
    SECONDARY: 2,
    TOUCH: -1
};
const PRESS_AND_MOVE_BUFFER = 3;
const DRAG_SELECTION_PRESS_AND_MOVE_BUFFER = 10;
const HIT_DISTANCE_BUFFER = 5;

function hasBeforeContextChange(value) {
    if (value.beforeContextChange) {
        return true;
    }
    return false;
}
function hasOnContextChanged(value) {
    if (value.onContextChanged) {
        return true;
    }
    return false;
}

// record richtext type status
const IS_BOARD_CACHE = new WeakMap();
const FLUSHING = new WeakMap();
const NODE_TO_INDEX = new WeakMap();
const NODE_TO_PARENT = new WeakMap();
const KEY_TO_ELEMENT_MAP = new WeakMap();
const NODE_TO_G = new WeakMap();
const NODE_TO_CONTAINER_G = new WeakMap();
const IS_TEXT_EDITABLE = new WeakMap();
const BOARD_TO_ON_CHANGE = new WeakMap();
const BOARD_TO_AFTER_CHANGE = new WeakMap();
const BOARD_TO_ROUGH_SVG = new WeakMap();
const BOARD_TO_HOST = new WeakMap();
const BOARD_TO_CONTEXT = new WeakMap();
const IS_BOARD_ALIVE = new WeakMap();
const BOARD_TO_ELEMENT_HOST = new WeakMap();
const BOARD_TO_SELECTED_ELEMENT = new WeakMap();
const BOARD_TO_MOVING_POINT_IN_BOARD = new WeakMap();
const BOARD_TO_MOVING_POINT = new WeakMap();
const BOARD_TO_VIEWPORT_ORIGINATION = new WeakMap();
const BOARD_TO_IS_SELECTION_MOVING = new WeakMap();
// save no standard selected elements
const BOARD_TO_TEMPORARY_ELEMENTS = new WeakMap();
const BOARD_TO_MOVING_ELEMENT = new WeakMap();
const PATH_REFS = new WeakMap();
const ELEMENT_TO_REF = new WeakMap();

function isNullOrUndefined(value) {
    return value === null || value === undefined;
}
/**
 * get {x,y} point
 * @param point
 * @returns point
 */
function normalizePoint(point) {
    return Array.isArray(point)
        ? {
            x: point[0],
            y: point[1]
        }
        : point;
}
const rgbaToHEX = (rgb, opacity) => {
    return rgb + Math.floor(opacity * 255).toString(16);
};
function isContextmenu(event) {
    return event.button === 2;
}
function uniqueById(elements) {
    const uniqueMap = new Map();
    elements.forEach(item => {
        if (!uniqueMap.has(item.id)) {
            uniqueMap.set(item.id, item);
        }
    });
    return Array.from(uniqueMap.values());
}
const findLastIndex = (array, cb, fromIndex = array.length - 1) => {
    if (fromIndex < 0) {
        fromIndex = array.length + fromIndex;
    }
    fromIndex = Math.min(array.length - 1, Math.max(fromIndex, 0));
    let index = fromIndex + 1;
    while (--index > -1) {
        if (cb(array[index], index, array)) {
            return index;
        }
    }
    return -1;
};
const findIndex = (array, cb, fromIndex = 0) => {
    // fromIndex = 2
    if (fromIndex < 0) {
        fromIndex = array.length + fromIndex;
    }
    fromIndex = Math.min(array.length, Math.max(fromIndex, 0));
    let index = fromIndex - 1;
    while (++index < array.length) {
        if (cb(array[index], index, array)) {
            return index;
        }
    }
    return -1;
};
const isIndicesContinuous = (indexes) => {
    indexes.sort((a, b) => a - b);
    for (let i = 1; i < indexes.length; i++) {
        if (indexes[i] !== indexes[i - 1] + 1) {
            return false;
        }
    }
    return true;
};

const Viewport = {
    isViewport: (value) => {
        return !isNullOrUndefined(value.zoom) && !isNullOrUndefined(value.viewBackgroundColor);
    }
};

const Path = {
    /**
     * Get a list of ancestor paths for a given path.
     *
     * The paths are sorted from shallowest to deepest ancestor. However, if the
     * `reverse: true` option is passed, they are reversed.
     */
    ancestors(path, options = {}) {
        const { reverse = false } = options;
        let paths = Path.levels(path, options);
        if (reverse) {
            paths = paths.slice(1);
        }
        else {
            paths = paths.slice(0, -1);
        }
        return paths;
    },
    /**
     * Get a list of paths at every level down to a path. Note: this is the same
     * as `Path.ancestors`, but including the path itself.
     *
     * The paths are sorted from shallowest to deepest. However, if the `reverse:
     * true` option is passed, they are reversed.
     */
    levels(path, options = {}) {
        const { reverse = false } = options;
        const list = [];
        for (let i = 0; i <= path.length; i++) {
            list.push(path.slice(0, i));
        }
        if (reverse) {
            list.reverse();
        }
        return list;
    },
    parent(path) {
        if (path.length === 0) {
            throw new Error(`Cannot get the parent path of the root path [${path}].`);
        }
        return path.slice(0, -1);
    },
    next(path) {
        if (path.length === 0) {
            throw new Error(`Cannot get the next path of a root path [${path}], because it has no next index.`);
        }
        const last = path[path.length - 1];
        return path.slice(0, -1).concat(last + 1);
    },
    hasPrevious(path) {
        return path[path.length - 1] > 0;
    },
    previous(path) {
        if (path.length === 0) {
            throw new Error(`Cannot get the previous path of a root path [${path}], because it has no previous index.`);
        }
        const last = path[path.length - 1];
        if (last <= 0) {
            throw new Error(`Cannot get the previous path of a first child path [${path}] because it would result in a negative index.`);
        }
        return path.slice(0, -1).concat(last - 1);
    },
    /**
     * Check if a path is an ancestor of another.
     */
    isAncestor(path, another) {
        return path.length < another.length && Path.compare(path, another) === 0;
    },
    /**
     * Compare a path to another, returning an integer indicating whether the path
     * was before, at, or after the other.
     *
     * Note: Two paths of unequal length can still receive a `0` result if one is
     * directly above or below the other. If you want exact matching, use
     * [[Path.equals]] instead.
     */
    compare(path, another) {
        const min = Math.min(path.length, another.length);
        for (let i = 0; i < min; i++) {
            if (path[i] < another[i])
                return -1;
            if (path[i] > another[i])
                return 1;
        }
        return 0;
    },
    /**
     * Check if a path is exactly equal to another.
     */
    equals(path, another) {
        return path.length === another.length && path.every((n, i) => n === another[i]);
    },
    /**
     * Check if a path ends before one of the indexes in another.
     */
    endsBefore(path, another) {
        const i = path.length - 1;
        const as = path.slice(0, i);
        const bs = another.slice(0, i);
        const av = path[i];
        const bv = another[i];
        return Path.equals(as, bs) && av < bv;
    },
    /**
     * Check if a path is a sibling of another.
     */
    isSibling(path, another) {
        if (path.length !== another.length) {
            return false;
        }
        const as = path.slice(0, -1);
        const bs = another.slice(0, -1);
        const al = path[path.length - 1];
        const bl = another[another.length - 1];
        return al !== bl && Path.equals(as, bs);
    },
    transform(path, operation) {
        if (!path)
            return null;
        // PERF: use destructing instead of immer
        const p = [...path];
        // PERF: Exit early if the operation is guaranteed not to have an effect.
        if (path.length === 0) {
            return p;
        }
        switch (operation.type) {
            case 'insert_node': {
                const { path: op } = operation;
                if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {
                    p[op.length - 1] += 1;
                }
                break;
            }
            case 'remove_node': {
                const { path: op } = operation;
                if (Path.equals(op, p) || Path.isAncestor(op, p)) {
                    return null;
                }
                else if (Path.endsBefore(op, p)) {
                    p[op.length - 1] -= 1;
                }
                break;
            }
            case 'move_node': {
                const { path: op, newPath: onp } = operation;
                // If the old and new path are the same, it's a no-op.
                if (Path.equals(op, onp)) {
                    return p;
                }
                if (Path.isAncestor(op, p) || Path.equals(op, p)) {
                    const copy = onp.slice();
                    if (Path.endsBefore(op, onp) && op.length < onp.length) {
                        copy[op.length - 1] -= 1;
                    }
                    return copy.concat(p.slice(op.length));
                }
                else if (Path.isSibling(op, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {
                    if (Path.endsBefore(op, p)) {
                        p[op.length - 1] -= 1;
                    }
                    else {
                        p[op.length - 1] += 1;
                    }
                }
                else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {
                    if (Path.endsBefore(op, p)) {
                        p[op.length - 1] -= 1;
                    }
                    p[onp.length - 1] += 1;
                }
                else if (Path.endsBefore(op, p)) {
                    if (Path.equals(onp, p)) {
                        p[onp.length - 1] += 1;
                    }
                    p[op.length - 1] -= 1;
                }
                break;
            }
        }
        return p;
    }
};

const PlaitNode = {
    parent: (board, path) => {
        const parentPath = Path.parent(path);
        const p = PlaitNode.get(board, parentPath);
        return p;
    },
    /**
     * Return a generator of all the ancestor nodes above a specific path.
     *
     * By default the order is top-down, from highest to lowest ancestor in
     * the tree, but you can pass the `reverse: true` option to go bottom-up.
     */
    *parents(root, path, options = {}) {
        for (const p of Path.ancestors(path, options)) {
            const n = PlaitNode.get(root, p);
            yield n;
        }
    },
    get(root, path) {
        let node = root;
        for (let i = 0; i < path.length; i++) {
            const p = path[i];
            if (!node || !node.children || !node.children[p]) {
                throw new Error(`Cannot find a descendant at path [${path}]`);
            }
            node = node.children[p];
        }
        return node;
    },
    last(board, path) {
        let n = PlaitNode.get(board, path);
        while (n && n.children && n.children.length > 0) {
            const i = n.children.length - 1;
            n = n.children[i];
        }
        return n;
    },
    first(board, path) {
        const p = path.slice();
        let n = PlaitNode.get(board, p);
        if (!n.children || !board.isExpanded(n)) {
            return n;
        }
        while (n && n.children && n.children.length > 0 && board.isExpanded(n)) {
            if (n.children.length === 0) {
                break;
            }
            else {
                n = n.children[0];
                p.push(0);
            }
        }
        return n;
    }
};

const applyToDraft = (board, selection, viewport, theme, op) => {
    switch (op.type) {
        case 'insert_node': {
            const { path, node } = op;
            const parent = PlaitNode.parent(board, path);
            const index = path[path.length - 1];
            if (!parent.children || index > parent.children.length) {
                throw new Error(`Cannot apply an "insert_node" operation at path [${path}] because the destination is past the end of the node.`);
            }
            parent.children.splice(index, 0, node);
            break;
        }
        case 'remove_node': {
            const { path } = op;
            const parent = PlaitNode.parent(board, path);
            const index = path[path.length - 1];
            if (!parent.children || index > parent.children.length) {
                throw new Error(`Cannot apply an "insert_node" operation at path [${path}] because the destination is past the end of the node.`);
            }
            parent.children.splice(index, 1);
            break;
        }
        case 'move_node': {
            const { path, newPath } = op;
            if (Path.isAncestor(path, newPath)) {
                throw new Error(`Cannot move a path [${path}] to new path [${newPath}] because the destination is inside itself.`);
            }
            const node = PlaitNode.get(board, path);
            const parent = PlaitNode.parent(board, path);
            const index = path[path.length - 1];
            // This is tricky, but since the `path` and `newPath` both refer to
            // the same snapshot in time, there's a mismatch. After either
            // removing the original position, the second step's path can be out
            // of date. So instead of using the `op.newPath` directly, we
            // transform `op.path` to ascertain what the `newPath` would be after
            // the operation was applied.
            parent.children?.splice(index, 1);
            const truePath = Path.transform(path, op);
            const newParent = PlaitNode.get(board, Path.parent(truePath));
            const newIndex = truePath[truePath.length - 1];
            newParent.children?.splice(newIndex, 0, node);
            break;
        }
        case 'set_node': {
            const { path, properties, newProperties } = op;
            if (path.length === 0) {
                throw new Error(`Cannot set properties on the root node!`);
            }
            const node = PlaitNode.get(board, path);
            for (const key in newProperties) {
                const value = newProperties[key];
                if (value == null) {
                    delete node[key];
                }
                else {
                    node[key] = value;
                }
            }
            // properties that were previously defined, but are now missing, must be deleted
            for (const key in properties) {
                if (!newProperties.hasOwnProperty(key)) {
                    delete node[key];
                }
            }
            break;
        }
        case 'set_viewport': {
            const { newProperties } = op;
            if (newProperties == null) {
                viewport = newProperties;
            }
            else {
                if (viewport == null) {
                    if (!Viewport.isViewport(newProperties)) {
                        throw new Error(`Cannot apply an incomplete "set_viewport" operation properties ${JSON.stringify(newProperties)} when there is no current viewport.`);
                    }
                    viewport = { ...newProperties };
                }
                for (const key in newProperties) {
                    const value = newProperties[key];
                    if (value == null) {
                        delete viewport[key];
                    }
                    else {
                        viewport[key] = value;
                    }
                }
            }
            break;
        }
        case 'set_selection': {
            const { newProperties } = op;
            if (newProperties == null) {
                selection = newProperties;
            }
            else {
                if (selection === null) {
                    selection = op.newProperties;
                }
                else {
                    selection = newProperties;
                }
            }
            break;
        }
        case 'set_theme': {
            const { newProperties } = op;
            theme = newProperties;
            break;
        }
    }
    return { selection, viewport, theme };
};
const GeneralTransforms = {
    /**
     * Transform the board by an operation.
     */
    transform(board, op) {
        board.children = createDraft(board.children);
        let viewport = board.viewport && createDraft(board.viewport);
        let selection = board.selection && createDraft(board.selection);
        let theme = board.theme && createDraft(board.theme);
        try {
            const state = applyToDraft(board, selection, viewport, theme, op);
            viewport = state.viewport;
            selection = state.selection;
            theme = state.theme;
        }
        finally {
            board.children = finishDraft(board.children);
            if (selection) {
                board.selection = isDraft(selection) ? finishDraft(selection) : selection;
            }
            else {
                board.selection = null;
            }
            board.viewport = isDraft(viewport) ? finishDraft(viewport) : viewport;
            board.theme = isDraft(theme) ? finishDraft(theme) : theme;
        }
    }
};

const RectangleClient = {
    isHit: (origin, target) => {
        return RectangleClient.isHitX(origin, target) && RectangleClient.isHitY(origin, target);
    },
    isHitX: (origin, target) => {
        const minX = origin.x < target.x ? origin.x : target.x;
        const maxX = origin.x + origin.width > target.x + target.width ? origin.x + origin.width : target.x + target.width;
        // float calculate error( eg: 1.4210854715202004e-14 > 0)
        if (Math.floor(maxX - minX - origin.width - target.width) <= 0) {
            return true;
        }
        else {
            return false;
        }
    },
    isHitY: (origin, target) => {
        const minY = origin.y < target.y ? origin.y : target.y;
        const maxY = origin.y + origin.height > target.y + target.height ? origin.y + origin.height : target.y + target.height;
        // float calculate error( eg: 1.4210854715202004e-14 > 0)
        if (Math.floor(maxY - minY - origin.height - target.height) <= 0) {
            return true;
        }
        else {
            return false;
        }
    },
    getPoints(rectangle) {
        return [
            [rectangle.x, rectangle.y],
            [rectangle.x + rectangle.width, rectangle.y + rectangle.height]
        ];
    },
    getRectangleByCenterPoint(point, width, height) {
        return RectangleClient.getRectangleByPoint([point[0] - width / 2, point[1] - height / 2], width, height);
    },
    getRectangleByPoint(point, width, height) {
        return {
            x: point[0],
            y: point[1],
            width,
            height
        };
    },
    getRectangleByPoints(points) {
        if (isPointArray(points)) {
            points = [points];
        }
        let xMin = Infinity;
        let yMin = Infinity;
        let xMax = -Infinity;
        let yMax = -Infinity;
        for (const point of points) {
            const xArray = point.map(ele => ele[0]);
            const yArray = point.map(ele => ele[1]);
            xMin = Math.min(xMin, ...xArray);
            yMin = Math.min(yMin, ...yArray);
            xMax = Math.max(xMax, ...xArray);
            yMin = Math.min(yMin, ...yArray);
            yMax = Math.max(yMax, ...yArray);
        }
        const rect = { x: xMin, y: yMin, width: xMax - xMin, height: yMax - yMin };
        return rect;
    },
    getCornerPointsByPoints(points) {
        const xArray = points.map(ele => ele[0]);
        const yArray = points.map(ele => ele[1]);
        const xMin = Math.min(...xArray);
        const xMax = Math.max(...xArray);
        const yMin = Math.min(...yArray);
        const yMax = Math.max(...yArray);
        return [
            [xMin, yMin],
            [xMax, yMin],
            [xMax, yMax],
            [xMin, yMax]
        ];
    },
    getOutlineRectangle: (rectangle, offset) => {
        return {
            x: rectangle.x + offset,
            y: rectangle.y + offset,
            width: rectangle.width - offset * 2,
            height: rectangle.height - offset * 2
        };
    },
    inflate: (rectangle, delta) => {
        const half = delta / 2;
        return {
            x: rectangle.x - half,
            y: rectangle.y - half,
            width: rectangle.width + half * 2,
            height: rectangle.height + half * 2
        };
    },
    isEqual: (rectangle, otherRectangle) => {
        return (rectangle.x === otherRectangle.x &&
            rectangle.y === otherRectangle.y &&
            rectangle.width === otherRectangle.width &&
            rectangle.height === otherRectangle.height);
    },
    getCornerPoints: (rectangle) => {
        return [
            [rectangle.x, rectangle.y],
            [rectangle.x + rectangle.width, rectangle.y],
            [rectangle.x + rectangle.width, rectangle.y + rectangle.height],
            [rectangle.x, rectangle.y + rectangle.height]
        ];
    },
    getCenterPoint: (rectangle) => {
        return [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height / 2];
    },
    getCenterPointByPoints: (points) => {
        return RectangleClient.getCenterPoint(RectangleClient.getRectangleByPoints(points));
    },
    getEdgeCenterPoints: (rectangle) => {
        return [
            [rectangle.x + rectangle.width / 2, rectangle.y],
            [rectangle.x + rectangle.width, rectangle.y + rectangle.height / 2],
            [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height],
            [rectangle.x, rectangle.y + rectangle.height / 2]
        ];
    },
    getConnectionPoint: (rectangle, point) => {
        return [rectangle.x + rectangle.width * point[0], rectangle.y + rectangle.height * point[1]];
    },
    expand(rectangle, left, top = left, right = left, bottom = top) {
        return {
            x: rectangle.x - left,
            y: rectangle.y - top,
            width: rectangle.width + left + right,
            height: rectangle.height + top + bottom
        };
    },
    getGapCenter(rectangle1, rectangle2, isHorizontal) {
        const axis = isHorizontal ? 'x' : 'y';
        const side = isHorizontal ? 'width' : 'height';
        const align = [rectangle1[axis], rectangle1[axis] + rectangle1[side], rectangle2[axis], rectangle2[axis] + rectangle2[side]];
        const sortArr = align.sort((a, b) => a - b);
        return (sortArr[1] + sortArr[2]) / 2;
    },
    isPointInRectangle(rectangle, point) {
        const x = point[0], y = point[1];
        return x > rectangle.x && x < rectangle.x + rectangle.width && y > rectangle.y && y < rectangle.y + rectangle.height;
    },
    getBoundingRectangle(rectangles) {
        if (rectangles.length === 0) {
            throw new Error('rectangles can not be empty array');
        }
        let minX = Number.MAX_VALUE;
        let minY = Number.MAX_VALUE;
        let maxX = Number.NEGATIVE_INFINITY;
        let maxY = Number.NEGATIVE_INFINITY;
        rectangles.forEach(rect => {
            minX = Math.min(minX, rect.x);
            minY = Math.min(minY, rect.y);
            maxX = Math.max(maxX, rect.x + rect.width);
            maxY = Math.max(maxY, rect.y + rect.height);
        });
        return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
        };
    }
};
function isPointArray(data) {
    return (Array.isArray(data) &&
        data.every(item => Array.isArray(item) && item.length === 2 && typeof item[0] === 'number' && typeof item[1] === 'number'));
}

// https://stackoverflow.com/a/6853926/232122
function distanceBetweenPointAndSegment(x, y, x1, y1, x2, y2) {
    const A = x - x1;
    const B = y - y1;
    const C = x2 - x1;
    const D = y2 - y1;
    const dot = A * C + B * D;
    const lenSquare = C * C + D * D;
    let param = -1;
    if (lenSquare !== 0) {
        // in case of 0 length line
        param = dot / lenSquare;
    }
    let xx, yy;
    if (param < 0) {
        xx = x1;
        yy = y1;
    }
    else if (param > 1) {
        xx = x2;
        yy = y2;
    }
    else {
        xx = x1 + param * C;
        yy = y1 + param * D;
    }
    const dx = x - xx;
    const dy = y - yy;
    return Math.hypot(dx, dy);
}
function getNearestPointBetweenPointAndSegment(point, linePoints) {
    const x = point[0], y = point[1], x1 = linePoints[0][0], y1 = linePoints[0][1], x2 = linePoints[1][0], y2 = linePoints[1][1];
    const A = x - x1;
    const B = y - y1;
    const C = x2 - x1;
    const D = y2 - y1;
    const dot = A * C + B * D;
    const lenSquare = C * C + D * D;
    let param = -1;
    if (lenSquare !== 0) {
        // in case of 0 length line
        param = dot / lenSquare;
    }
    let xx, yy;
    if (param < 0) {
        xx = x1;
        yy = y1;
    }
    else if (param > 1) {
        xx = x2;
        yy = y2;
    }
    else {
        xx = x1 + param * C;
        yy = y1 + param * D;
    }
    return [xx, yy];
}
function distanceBetweenPointAndSegments(point, points) {
    const len = points.length;
    let distance = Infinity;
    if (points.length === 1) {
        return distanceBetweenPointAndPoint(...points[0], ...point);
    }
    for (let i = 0; i < len - 1; i++) {
        const p = points[i];
        const p2 = points[i + 1];
        const currentDistance = distanceBetweenPointAndSegment(point[0], point[1], p[0], p[1], p2[0], p2[1]);
        if (currentDistance < distance) {
            distance = currentDistance;
        }
    }
    return distance;
}
function getNearestPointBetweenPointAndSegments(point, points, isClose = true) {
    const len = points.length;
    let distance = Infinity;
    let result = point;
    for (let i = 0; i < len; i++) {
        const p = points[i];
        if (i === len - 1 && !isClose)
            continue;
        const p2 = i === len - 1 ? points[0] : points[i + 1];
        const currentDistance = distanceBetweenPointAndSegment(point[0], point[1], p[0], p[1], p2[0], p2[1]);
        if (currentDistance < distance) {
            distance = currentDistance;
            result = getNearestPointBetweenPointAndSegment(point, [p, p2]);
        }
    }
    return result;
}
function getNearestPointBetweenPointAndDiscreteSegments(point, segments) {
    let minDistance = Infinity;
    let nearestPoint = point;
    for (const segment of segments) {
        const currentNearestPoint = getNearestPointBetweenPointAndSegment(point, segment);
        const currentDistance = distanceBetweenPointAndPoint(point[0], point[1], currentNearestPoint[0], currentNearestPoint[1]);
        if (currentDistance < minDistance) {
            minDistance = currentDistance;
            nearestPoint = currentNearestPoint;
        }
    }
    return nearestPoint;
}
function getNearestPointBetweenPointAndEllipse(point, center, rx, ry) {
    const rectangleClient = {
        x: center[0] - rx,
        y: center[1] - ry,
        height: ry * 2,
        width: rx * 2
    };
    // https://stackoverflow.com/a/46007540/232122
    const px = Math.abs(point[0] - rectangleClient.x - rectangleClient.width / 2);
    const py = Math.abs(point[1] - rectangleClient.y - rectangleClient.height / 2);
    let tx = 0.707;
    let ty = 0.707;
    const a = Math.abs(rectangleClient.width) / 2;
    const b = Math.abs(rectangleClient.height) / 2;
    [0, 1, 2, 3].forEach((x) => {
        const xx = a * tx;
        const yy = b * ty;
        const ex = ((a * a - b * b) * tx ** 3) / a;
        const ey = ((b * b - a * a) * ty ** 3) / b;
        const rx = xx - ex;
        const ry = yy - ey;
        const qx = px - ex;
        const qy = py - ey;
        const r = Math.hypot(ry, rx);
        const q = Math.hypot(qy, qx);
        tx = Math.min(1, Math.max(0, ((qx * r) / q + ex) / a));
        ty = Math.min(1, Math.max(0, ((qy * r) / q + ey) / b));
        const t = Math.hypot(ty, tx);
        tx /= t;
        ty /= t;
    });
    const signX = point[0] > center[0] ? 1 : -1;
    const signY = point[1] > center[1] ? 1 : -1;
    return [center[0] + a * tx * signX, center[1] + b * ty * signY];
}
function rotate(x1, y1, x2, y2, angle) {
    // ùëé‚Ä≤ùë•=(ùëéùë•‚àíùëêùë•)cosùúÉ‚àí(ùëéùë¶‚àíùëêùë¶)sinùúÉ+ùëêùë•
    // ùëé‚Ä≤ùë¶=(ùëéùë•‚àíùëêùë•)sinùúÉ+(ùëéùë¶‚àíùëêùë¶)cosùúÉ+ùëêùë¶.
    // https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line
    return [(x1 - x2) * Math.cos(angle) - (y1 - y2) * Math.sin(angle) + x2, (x1 - x2) * Math.sin(angle) + (y1 - y2) * Math.cos(angle) + y2];
}
function distanceBetweenPointAndPoint(x1, y1, x2, y2) {
    const dx = x1 - x2;
    const dy = y1 - y2;
    return Math.hypot(dx, dy);
}
// https://stackoverflow.com/questions/5254838/calculating-distance-between-a-point-and-a-rectangular-box-nearest-point
function distanceBetweenPointAndRectangle(x, y, rect) {
    var dx = Math.max(rect.x - x, 0, x - (rect.x + rect.width));
    var dy = Math.max(rect.y - y, 0, y - (rect.y + rect.height));
    return Math.sqrt(dx * dx + dy * dy);
}
const isLineHitLine = (a, b, c, d) => {
    if (Point.isEquals(a, b) && Point.isEquals(c, d) && !Point.isEquals(a, c)) {
        return false;
    }
    const crossProduct = (v1, v2) => v1[0] * v2[1] - v1[1] * v2[0];
    const ab = [b[0] - a[0], b[1] - a[1]];
    const ac = [c[0] - a[0], c[1] - a[1]];
    const ad = [d[0] - a[0], d[1] - a[1]];
    const ca = [a[0] - c[0], a[1] - c[1]];
    const cb = [b[0] - c[0], b[1] - c[1]];
    const cd = [d[0] - c[0], d[1] - c[1]];
    return crossProduct(ab, ac) * crossProduct(ab, ad) <= 0 && crossProduct(cd, ca) * crossProduct(cd, cb) <= 0;
};
const isLineHitRectangle = (points, rectangle) => {
    if (points.length === 1) {
        return RectangleClient.isPointInRectangle(rectangle, points[0]);
    }
    const rectanglePoints = RectangleClient.getCornerPoints(rectangle);
    const len = points.length;
    for (let i = 0; i < len; i++) {
        const p1 = points[i];
        const p2 = points[(i + 1) % len];
        if (i === len - 1 && Point.isEquals(p1, p2))
            continue;
        const isHit = isSingleLineHitRectangleEdge(p1, p2, rectangle);
        if (isHit || isPointInPolygon(p1, rectanglePoints) || isPointInPolygon(p2, rectanglePoints)) {
            return true;
        }
    }
    return false;
};
const isLineHitRectangleEdge = (points, rectangle, isClose = true) => {
    const len = points.length;
    for (let i = 0; i < len; i++) {
        if (i === len - 1 && !isClose)
            continue;
        const p1 = points[i];
        const p2 = points[(i + 1) % len];
        const isHit = isSingleLineHitRectangleEdge(p1, p2, rectangle);
        if (isHit) {
            return true;
        }
    }
    return false;
};
const isSingleLineHitRectangleEdge = (p1, p2, rectangle) => {
    const rectanglePoints = RectangleClient.getCornerPoints(rectangle);
    return (isLineHitLine(p1, p2, rectanglePoints[0], rectanglePoints[1]) ||
        isLineHitLine(p1, p2, rectanglePoints[1], rectanglePoints[2]) ||
        isLineHitLine(p1, p2, rectanglePoints[2], rectanglePoints[3]) ||
        isLineHitLine(p1, p2, rectanglePoints[3], rectanglePoints[0]));
};
//https://stackoverflow.com/questions/22521982/check-if-point-is-inside-a-polygon
const isPointInPolygon = (point, points) => {
    // ray-casting algorithm based on
    // https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html
    const x = point[0], y = point[1];
    let inside = false;
    for (var i = 0, j = points.length - 1; i < points.length; j = i++) {
        let xi = points[i][0], yi = points[i][1];
        let xj = points[j][0], yj = points[j][1];
        let intersect = yi > y != yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;
        if (intersect)
            inside = !inside;
    }
    return inside;
};
const isPointInEllipse = (point, center, rx, ry, angle = 0) => {
    const cosAngle = Math.cos(angle);
    const sinAngle = Math.sin(angle);
    const x1 = (point[0] - center[0]) * cosAngle + (point[1] - center[1]) * sinAngle;
    const y1 = (point[1] - center[1]) * cosAngle - (point[0] - center[0]) * sinAngle;
    return (x1 * x1) / (rx * rx) + (y1 * y1) / (ry * ry) <= 1;
};
const isPointInRoundRectangle = (point, rectangle, radius, angle = 0) => {
    const { x: rectX, y: rectY, width, height } = rectangle;
    const isInRectangle = point[0] >= rectX && point[0] <= rectX + width && point[1] >= rectY && point[1] <= rectY + height;
    const handleLeftTop = point[0] >= rectX &&
        point[0] <= rectX + radius &&
        point[1] >= rectY &&
        point[1] <= rectY + radius &&
        Math.hypot(point[0] - (rectX + radius), point[1] - (rectY + radius)) > radius;
    const handleLeftBottom = point[0] >= rectX &&
        point[0] <= rectX + radius &&
        point[1] >= rectY + height &&
        point[1] <= rectY + height - radius &&
        Math.hypot(point[0] - (rectX + radius), point[1] - (rectY + height - radius)) > radius;
    const handleRightTop = point[0] >= rectX + width - radius &&
        point[0] <= rectX + width &&
        point[1] >= rectY &&
        point[1] <= rectY + radius &&
        Math.hypot(point[0] - (rectX + width - radius), point[1] - (rectY + radius)) > radius;
    const handleRightBottom = point[0] >= rectX + width - radius &&
        point[0] <= rectX + width &&
        point[1] >= rectY + height - radius &&
        point[1] <= rectY + height &&
        Math.hypot(point[0] - (rectX + width - radius), point[1] - (rectY + height - radius)) > radius;
    const isInCorner = handleLeftTop || handleLeftBottom || handleRightTop || handleRightBottom;
    return isInRectangle && !isInCorner;
};
// https://gist.github.com/nicholaswmin/c2661eb11cad5671d816
const catmullRomFitting = function (points) {
    const alpha = 0.5;
    let p0, p1, p2, p3, bp1, bp2, d1, d2, d3, A, B, N, M;
    var d3powA, d2powA, d3pow2A, d2pow2A, d1pow2A, d1powA;
    const result = [];
    result.push([Math.round(points[0][0]), Math.round(points[0][1])]);
    var length = points.length;
    for (var i = 0; i < length - 1; i++) {
        p0 = i == 0 ? points[0] : points[i - 1];
        p1 = points[i];
        p2 = points[i + 1];
        p3 = i + 2 < length ? points[i + 2] : p2;
        d1 = Math.sqrt(Math.pow(p0[0] - p1[0], 2) + Math.pow(p0[1] - p1[1], 2));
        d2 = Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));
        d3 = Math.sqrt(Math.pow(p2[0] - p3[0], 2) + Math.pow(p2[1] - p3[1], 2));
        // Catmull-Rom to Cubic Bezier conversion matrix
        // A = 2d1^2a + 3d1^a * d2^a + d3^2a
        // B = 2d3^2a + 3d3^a * d2^a + d2^2a
        // [   0             1            0          0          ]
        // [   -d2^2a /N     A/N          d1^2a /N   0          ]
        // [   0             d3^2a /M     B/M        -d2^2a /M  ]
        // [   0             0            1          0          ]
        d3powA = Math.pow(d3, alpha);
        d3pow2A = Math.pow(d3, 2 * alpha);
        d2powA = Math.pow(d2, alpha);
        d2pow2A = Math.pow(d2, 2 * alpha);
        d1powA = Math.pow(d1, alpha);
        d1pow2A = Math.pow(d1, 2 * alpha);
        A = 2 * d1pow2A + 3 * d1powA * d2powA + d2pow2A;
        B = 2 * d3pow2A + 3 * d3powA * d2powA + d2pow2A;
        N = 3 * d1powA * (d1powA + d2powA);
        if (N > 0) {
            N = 1 / N;
        }
        M = 3 * d3powA * (d3powA + d2powA);
        if (M > 0) {
            M = 1 / M;
        }
        bp1 = [(-d2pow2A * p0[0] + A * p1[0] + d1pow2A * p2[0]) * N, (-d2pow2A * p0[1] + A * p1[1] + d1pow2A * p2[1]) * N];
        bp2 = [(d3pow2A * p1[0] + B * p2[0] - d2pow2A * p3[0]) * M, (d3pow2A * p1[1] + B * p2[1] - d2pow2A * p3[1]) * M];
        if (bp1[0] == 0 && bp1[1] == 0) {
            bp1 = p1;
        }
        if (bp2[0] == 0 && bp2[1] == 0) {
            bp2 = p2;
        }
        result.push(bp1, bp2, p2);
    }
    return result;
};
/**
 * the result of slope is based on Cartesian coordinate system
 * x, y are based on the position in the Cartesian coordinate system
 */
function getEllipseTangentSlope(x, y, a, b) {
    if (Math.abs(y) === 0) {
        return x > 0 ? -Infinity : Infinity;
    }
    const k = (-b * b * x) / (a * a * y);
    return k;
}
/**
 * x, y are based on the position in the Cartesian coordinate system
 */
function getVectorFromPointAndSlope(x, y, slope) {
    if (slope === Infinity) {
        return [0, -1];
    }
    else if (slope === -Infinity) {
        return [0, 1];
    }
    let vector = [1, -slope];
    if (y < 0) {
        vector = [-vector[0], -vector[1]];
    }
    return vector;
}
/**
 * The DOM likes values to be fixed to 3 decimal places
 */
function toDomPrecision(v) {
    return +v.toFixed(4);
}
function toFixed(v) {
    return +v.toFixed(2);
}
function ceilToDecimal(value, decimalPlaces) {
    const factor = Math.pow(10, decimalPlaces);
    return Math.ceil(value * factor) / factor;
}
/**
 * Whether two numbers numbers a and b are approximately equal.
 *
 * @param a - The first point.
 * @param b - The second point.
 * @public
 */
function approximately(a, b, precision = 0.000001) {
    return Math.abs(a - b) <= precision;
}
// https://medium.com/@steveruiz/find-the-points-where-a-line-segment-intercepts-an-angled-ellipse-in-javascript-typescript-e451524beece
function getCrossingPointsBetweenEllipseAndSegment(startPoint, endPoint, cx, cy, rx, ry, segment_only = true) {
    // If the ellipse or line segment are empty, return no tValues.
    if (rx === 0 || ry === 0 || (startPoint[0] === endPoint[0] && startPoint[1] === endPoint[1])) {
        return [];
    }
    rx = rx < 0 ? rx : -rx;
    ry = ry < 0 ? ry : -ry;
    startPoint[0] -= cx;
    startPoint[1] -= cy;
    endPoint[0] -= cx;
    endPoint[1] -= cy;
    // Calculate the quadratic parameters.
    var A = ((endPoint[0] - startPoint[0]) * (endPoint[0] - startPoint[0])) / rx / rx +
        ((endPoint[1] - startPoint[1]) * (endPoint[1] - startPoint[1])) / ry / ry;
    var B = (2 * startPoint[0] * (endPoint[0] - startPoint[0])) / rx / rx + (2 * startPoint[1] * (endPoint[1] - startPoint[1])) / ry / ry;
    var C = (startPoint[0] * startPoint[0]) / rx / rx + (startPoint[1] * startPoint[1]) / ry / ry - 1;
    // Make a list of t values (normalized points on the line where intersections occur).
    var tValues = [];
    // Calculate the discriminant.
    var discriminant = B * B - 4 * A * C;
    if (discriminant === 0) {
        // One real solution.
        tValues.push(-B / 2 / A);
    }
    else if (discriminant > 0) {
        // Two real solutions.
        tValues.push((-B + Math.sqrt(discriminant)) / 2 / A);
        tValues.push((-B - Math.sqrt(discriminant)) / 2 / A);
    }
    return (tValues
        // Filter to only points that are on the segment.
        .filter((t) => !segment_only || (t >= 0 && t <= 1))
        // Solve for points.
        .map((t) => [startPoint[0] + (endPoint[0] - startPoint[0]) * t + cx, startPoint[1] + (endPoint[1] - startPoint[1]) * t + cy]));
}
/**
 * Get a point between two points.
 * @param x0 The x-axis coordinate of the first point.
 * @param y0 The y-axis coordinate of the first point.
 * @param x1 The x-axis coordinate of the second point.
 * @param y1 The y-axis coordinate of the second point.
 * @param d Normalized
 */
function getPointBetween(x0, y0, x1, y1, d = 0.5) {
    return [x0 + (x1 - x0) * d, y0 + (y1 - y0) * d];
}
/**
 * Ëé∑ÂèñÁÇπÂà∞ÂçäÊ§≠ÂúÜÂºßÊÆµÁöÑÊúÄËøëÁÇπ
 * @param point ÁõÆÊ†áÁÇπ
 * @param startPoint ÂºßÊÆµËµ∑ÁÇπ
 * @param arcCommand SVG ÂºßÂΩ¢ÂëΩ‰ª§ÂèÇÊï∞
 */
/**
 * ËÆ°ÁÆóÊ§≠ÂúÜÂºßÁöÑ‰∏≠ÂøÉÁÇπÂíåÂÆûÈôÖÂçäÂæÑ
 */
function getEllipseArcCenter(startPoint, arcCommand) {
    // 1. Â∞ÜÂùêÊ†áËΩ¨Êç¢Âà∞Ê†áÂáÜ‰ΩçÁΩÆ
    const dx = (arcCommand.endX - startPoint[0]) / 2;
    const dy = (arcCommand.endY - startPoint[1]) / 2;
    const cosAngle = Math.cos(arcCommand.xAxisRotation);
    const sinAngle = Math.sin(arcCommand.xAxisRotation);
    // ÊóãËΩ¨Âà∞Ê§≠ÂúÜÂùêÊ†áÁ≥ª
    const x1 = cosAngle * dx + sinAngle * dy;
    const y1 = -sinAngle * dx + cosAngle * dy;
    // 2. ËÆ°ÁÆó‰∏≠ÂøÉÁÇπ
    const rx = Math.abs(arcCommand.rx);
    const ry = Math.abs(arcCommand.ry);
    // Á°Æ‰øùÂçäÂæÑË∂≥Â§üÂ§ß
    const lambda = (x1 * x1) / (rx * rx) + (y1 * y1) / (ry * ry);
    const factor = lambda > 1 ? Math.sqrt(lambda) : 1;
    const adjustedRx = rx * factor;
    const adjustedRy = ry * factor;
    // ËÆ°ÁÆó‰∏≠ÂøÉÁÇπÂùêÊ†á
    const sign = arcCommand.largeArcFlag === arcCommand.sweepFlag ? -1 : 1;
    const sq = (adjustedRx * adjustedRx * adjustedRy * adjustedRy - adjustedRx * adjustedRx * y1 * y1 - adjustedRy * adjustedRy * x1 * x1) /
        (adjustedRx * adjustedRx * y1 * y1 + adjustedRy * adjustedRy * x1 * x1);
    const coef = sign * Math.sqrt(Math.max(0, sq));
    const centerX = coef * ((adjustedRx * y1) / adjustedRy);
    const centerY = coef * (-(adjustedRy * x1) / adjustedRx);
    // 3. ËΩ¨Êç¢ÂõûÂéüÂßãÂùêÊ†áÁ≥ª
    const cx = cosAngle * centerX - sinAngle * centerY + (startPoint[0] + arcCommand.endX) / 2;
    const cy = sinAngle * centerX + cosAngle * centerY + (startPoint[1] + arcCommand.endY) / 2;
    return {
        center: [cx, cy],
        rx: adjustedRx,
        ry: adjustedRy
    };
}
function getNearestPointBetweenPointAndArc(point, startPoint, arcCommand) {
    const { center, rx, ry } = getEllipseArcCenter(startPoint, arcCommand);
    // Ëé∑ÂèñÊ§≠ÂúÜ‰∏äÁöÑÊúÄËøëÁÇπ
    const nearestPoint = getNearestPointBetweenPointAndEllipse(point, center, rx, ry);
    // Âà§Êñ≠ÊúÄËøëÁÇπÊòØÂê¶Âú®ÂºßÊÆµ‰∏ä
    const startAngle = Math.atan2(startPoint[1] - center[1], startPoint[0] - center[0]);
    const endAngle = Math.atan2(arcCommand.endY - center[1], arcCommand.endX - center[0]);
    const pointAngle = Math.atan2(nearestPoint[1] - center[1], nearestPoint[0] - center[0]);
    // Ê£ÄÊü•ÁÇπÊòØÂê¶Âú®ÂºßÊÆµËåÉÂõ¥ÂÜÖ
    const isInArc = isAngleBetween(pointAngle, startAngle, endAngle, arcCommand.sweepFlag === 1);
    if (isInArc) {
        return nearestPoint;
    }
    // Â¶ÇÊûú‰∏çÂú®ÂºßÊÆµ‰∏äÔºåËøîÂõûÊúÄËøëÁöÑÁ´ØÁÇπ
    const distanceToStart = distanceBetweenPointAndPoint(point[0], point[1], startPoint[0], startPoint[1]);
    const distanceToEnd = distanceBetweenPointAndPoint(point[0], point[1], arcCommand.endX, arcCommand.endY);
    return distanceToStart < distanceToEnd ? startPoint : [arcCommand.endX, arcCommand.endY];
}
function isAngleBetween(angle, start, end, clockwise) {
    // Ê†áÂáÜÂåñËßíÂ∫¶Âà∞ [0, 2œÄ]
    const normalize = (a) => ((a % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
    const a = normalize(angle);
    const s = normalize(start);
    const e = normalize(end);
    if (clockwise) {
        return s <= e ? a >= s && a <= e : a >= s || a <= e;
    }
    else {
        return s >= e ? a <= s && a >= e : a <= s || a >= e;
    }
}

function isInPlaitBoard(board, x, y) {
    const plaitBoardElement = PlaitBoard.getBoardContainer(board);
    const plaitBoardRect = plaitBoardElement.getBoundingClientRect();
    const distances = distanceBetweenPointAndRectangle(x, y, plaitBoardRect);
    return distances === 0;
}
function getRealScrollBarWidth(board) {
    const { hideScrollbar } = board.options;
    let scrollBarWidth = 0;
    if (!hideScrollbar) {
        const viewportContainer = PlaitBoard.getViewportContainer(board);
        scrollBarWidth = viewportContainer.offsetWidth - viewportContainer.clientWidth;
    }
    return scrollBarWidth;
}

const NS = 'http://www.w3.org/2000/svg';
function createG() {
    const newG = document.createElementNS(NS, 'g');
    return newG;
}
function createPath() {
    const newG = document.createElementNS(NS, 'path');
    return newG;
}
function createRect(rectangle, options) {
    const rect = document.createElementNS(NS, 'rect');
    rect.setAttribute('x', `${rectangle.x}`);
    rect.setAttribute('y', `${rectangle.y}`);
    rect.setAttribute('width', `${rectangle.width}`);
    rect.setAttribute('height', `${rectangle.height}`);
    for (let key in options) {
        const optionKey = key;
        rect.setAttribute(key, `${options[optionKey]}`);
    }
    return rect;
}
const setStrokeLinecap = (g, value) => {
    g.setAttribute('stroke-linecap', value);
};
const setPathStrokeLinecap = (g, value) => {
    g.querySelectorAll('path').forEach(path => {
        path.setAttribute('stroke-linecap', value);
    });
};
function createMask() {
    return document.createElementNS(NS, 'mask');
}
function createSVG() {
    const svg = document.createElementNS(NS, 'svg');
    return svg;
}
function createText(x, y, fill, textContent) {
    var text = document.createElementNS(NS, 'text');
    text.setAttribute('x', `${x}`);
    text.setAttribute('y', `${y}`);
    text.setAttribute('fill', fill);
    text.textContent = textContent;
    return text;
}
/**
 * Check if a DOM node is an element node.
 */
const isDOMElement = (value) => {
    return isDOMNode(value) && value.nodeType === 1;
};
/**
 * Check if a value is a DOM node.
 */
const isDOMNode = (value) => {
    return value instanceof window.Node;
};
const hasInputOrTextareaTarget = (target) => {
    if (isDOMElement(target)) {
        if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {
            return true;
        }
    }
    return false;
};
const isSecondaryPointer = (event) => {
    return event.button === POINTER_BUTTON.SECONDARY;
};
const isMainPointer = (event) => {
    return event.button === POINTER_BUTTON.MAIN;
};
const isWheelPointer = (event) => {
    return event.button === POINTER_BUTTON.WHEEL;
};

function createForeignObject(x, y, width, height) {
    var newForeignObject = document.createElementNS(NS, 'foreignObject');
    newForeignObject.setAttribute('x', `${x}`);
    newForeignObject.setAttribute('y', `${y}`);
    newForeignObject.setAttribute('width', `${ceilToDecimal(width, 0)}`);
    newForeignObject.setAttribute('height', `${height}`);
    return newForeignObject;
}
function updateForeignObject(target, width, height, x, y) {
    const foreignObject = target instanceof SVGForeignObjectElement ? target : target.querySelector('foreignObject');
    if (foreignObject) {
        foreignObject.setAttribute('width', `${ceilToDecimal(width, 0)}`);
        foreignObject.setAttribute('height', `${height}`);
        foreignObject.setAttribute('x', `${x}`);
        foreignObject.setAttribute('y', `${y}`);
    }
}
function updateForeignObjectWidth(target, width) {
    const foreignObject = target instanceof SVGForeignObjectElement ? target : target.querySelector('foreignObject');
    if (foreignObject) {
        foreignObject.setAttribute('width', `${ceilToDecimal(width, 0)}`);
    }
}

const IS_MAC = typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);

const IS_IOS = typeof navigator !== 'undefined' &&
    typeof window !== 'undefined' &&
    /iPad|iPhone|iPod/.test(navigator.userAgent) &&
    !window.MSStream;
const IS_APPLE = typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent);
const IS_FIREFOX = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
const IS_SAFARI = typeof navigator !== 'undefined' && /Version\/[\d\.]+.*Safari/.test(navigator.userAgent);
// "modern" Edge was released at 79.x
const IS_EDGE_LEGACY = typeof navigator !== 'undefined' && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])/i.test(navigator.userAgent);
const IS_CHROME = typeof navigator !== 'undefined' && /Chrome/i.test(navigator.userAgent);
// Native beforeInput events don't work well with react on Chrome 75 and older, Chrome 76+ can use beforeInput
const IS_CHROME_LEGACY = typeof navigator !== 'undefined' && /Chrome?\/(?:[0-7][0-5]|[0-6][0-9])/i.test(navigator.userAgent);
const IS_WINDOWS = typeof navigator !== 'undefined' && /Windows/.test(navigator.userAgent);

// Credits to slate - https://github.com/ianstormtaylor/slate
/**
 * Check whether to merge an operation into the previous operation.
 */
const shouldMerge = (op, prev) => {
    if (op.type === 'set_viewport' && op.type === prev?.type) {
        return true;
    }
    return false;
};
/**
 * Check whether an operation needs to be saved to the history.
 */
const shouldSave = (op, prev) => {
    if (op.type === 'set_selection' || op.type === 'set_viewport') {
        return false;
    }
    return true;
};
/**
 * Check whether an operation should clear the redos stack.
 */
const shouldClear = (op) => {
    if (op.type === 'set_selection') {
        return false;
    }
    return true;
};
const PlaitHistoryBoard = {
    /**
     * Get the saving flag's current value.
     */
    isSaving(board) {
        return SAVING.get(board);
    },
    /**
     * Get the merge flag's current value.
     */
    isMerging(board) {
        return MERGING.get(board);
    },
    /**
     * Get the splitting once flag's current value.
     */
    isSplittingOnce(board) {
        return SPLITTING_ONCE.get(board);
    },
    setSplittingOnce(board, value) {
        SPLITTING_ONCE.set(board, value);
    },
    /**
     * Apply a series of changes inside a synchronous `fn`, These operations will
     * be merged into the previous history.
     */
    withMerging(board, fn) {
        const prev = PlaitHistoryBoard.isMerging(board);
        MERGING.set(board, true);
        fn();
        MERGING.set(board, prev);
    },
    /**
     * Apply a series of changes inside a synchronous `fn`, ensuring that the first
     * operation starts a new batch in the history. Subsequent operations will be
     * merged as usual.
     */
    withNewBatch(board, fn) {
        const prev = PlaitHistoryBoard.isMerging(board);
        MERGING.set(board, true);
        SPLITTING_ONCE.set(board, true);
        fn();
        MERGING.set(board, prev);
        SPLITTING_ONCE.delete(board);
    },
    /**
     * Apply a series of changes inside a synchronous `fn`, without merging any of
     * the new operations into previous save point in the history.
     */
    withoutMerging(board, fn) {
        const prev = PlaitHistoryBoard.isMerging(board);
        MERGING.set(board, false);
        fn();
        MERGING.set(board, prev);
    },
    /**
     * Apply a series of changes inside a synchronous `fn`, without saving any of
     * their operations into the history.
     */
    withoutSaving(board, fn) {
        const prev = PlaitHistoryBoard.isSaving(board);
        SAVING.set(board, false);
        fn();
        SAVING.set(board, prev);
    }
};

/**
 * Hotkey mappings for each platform.
 */
const HOTKEYS = {
    bold: 'mod+b',
    compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],
    arrow: ['down', 'left', 'right', 'up'],
    extendArrow: ['shift+down', 'shift+left', 'shift+right', 'shift+up'],
    moveBackward: 'left',
    moveForward: 'right',
    moveUp: 'up',
    moveDown: 'down',
    moveWordBackward: 'ctrl+left',
    moveWordForward: 'ctrl+right',
    deleteBackward: 'shift?+backspace',
    deleteForward: 'shift?+delete',
    extendBackward: 'shift+left',
    extendForward: 'shift+right',
    extendUp: 'shift+up',
    extendDown: 'shift+down',
    italic: 'mod+i',
    splitBlock: 'shift?+enter',
    undo: 'mod+z',
    shift: 'shift'
};
const APPLE_HOTKEYS = {
    moveLineBackward: 'opt+up',
    moveLineForward: 'opt+down',
    moveWordBackward: 'opt+left',
    moveWordForward: 'opt+right',
    deleteBackward: ['ctrl+backspace', 'ctrl+h'],
    deleteForward: ['ctrl+delete', 'ctrl+d'],
    deleteLineBackward: 'cmd+shift?+backspace',
    deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],
    deleteWordBackward: 'opt+shift?+backspace',
    deleteWordForward: 'opt+shift?+delete',
    extendLineBackward: 'opt+shift+up',
    extendLineForward: 'opt+shift+down',
    redo: 'cmd+shift+z',
    transposeCharacter: 'ctrl+t'
};
const WINDOWS_HOTKEYS = {
    deleteWordBackward: 'ctrl+shift?+backspace',
    deleteWordForward: 'ctrl+shift?+delete',
    redo: ['ctrl+y', 'ctrl+shift+z']
};
/**
 * Create a platform-aware hotkey checker.
 */
const create = (key) => {
    const generic = HOTKEYS[key];
    const apple = APPLE_HOTKEYS[key];
    const windows = WINDOWS_HOTKEYS[key];
    const isGeneric = generic && isKeyHotkey(generic);
    const isApple = apple && isKeyHotkey(apple);
    const isWindows = windows && isKeyHotkey(windows);
    return (event) => {
        if (isGeneric && isGeneric(event)) {
            return true;
        }
        if (IS_APPLE && isApple && isApple(event)) {
            return true;
        }
        if (!IS_APPLE && isWindows && isWindows(event)) {
            return true;
        }
        return false;
    };
};
/**
 * Hotkeys.
 */
const hotkeys = {
    isBold: create('bold'),
    isCompose: create('compose'),
    isArrow: create('arrow'),
    isMoveBackward: create('moveBackward'),
    isMoveForward: create('moveForward'),
    isMoveUp: create('moveUp'),
    isMoveDown: create('moveDown'),
    isDeleteBackward: create('deleteBackward'),
    isDeleteForward: create('deleteForward'),
    isDeleteLineBackward: create('deleteLineBackward'),
    isDeleteLineForward: create('deleteLineForward'),
    isDeleteWordBackward: create('deleteWordBackward'),
    isDeleteWordForward: create('deleteWordForward'),
    isExtendBackward: create('extendBackward'),
    isExtendForward: create('extendForward'),
    isExtendUp: create('extendUp'),
    isExtendDown: create('extendDown'),
    isExtendArrow: create('extendArrow'),
    isExtendLineBackward: create('extendLineBackward'),
    isExtendLineForward: create('extendLineForward'),
    isItalic: create('italic'),
    isMoveLineBackward: create('moveLineBackward'),
    isMoveLineForward: create('moveLineForward'),
    isMoveWordBackward: create('moveWordBackward'),
    isMoveWordForward: create('moveWordForward'),
    isRedo: create('redo'),
    isSplitBlock: create('splitBlock'),
    isTransposeCharacter: create('transposeCharacter'),
    isUndo: create('undo'),
    isShift: create('shift')
};

function idCreator(length = 5) {
    // remove numeral
    const $chars = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz'; /**** Easily confusing characters are removed by default oOLl,9gq,Vv,Uu,I1****/
    const maxPosition = $chars.length;
    let key = '';
    for (let i = 0; i < length; i++) {
        key += $chars.charAt(Math.floor(Math.random() * maxPosition));
    }
    return key;
}

function depthFirstRecursion(node, callback, recursion, isReverse) {
    if (node.children && (!recursion || recursion(node))) {
        let children = [...node.children];
        children = isReverse ? children.reverse() : children;
        children.forEach(child => {
            depthFirstRecursion(child, callback, recursion);
        });
    }
    callback(node);
}
const getIsRecursionFunc = (board) => {
    return (element) => {
        if (PlaitBoard.isBoard(element) || board.isRecursion(element)) {
            return true;
        }
        else {
            return false;
        }
    };
};

const SELECTION_BORDER_COLOR = '#6698FF';
const SELECTION_FILL_COLOR = '#6698FF25'; // opacity 0.25
const Selection = {
    isCollapsed(selection) {
        if (selection.anchor[0] == selection.focus[0] && selection.anchor[1] === selection.focus[1]) {
            return true;
        }
        else {
            return false;
        }
    }
};

const PlaitElement = {
    isRootElement(value) {
        const parent = NODE_TO_PARENT.get(value);
        if (parent && PlaitBoard.isBoard(parent)) {
            return true;
        }
        else {
            return false;
        }
    },
    getElementRef(value) {
        return ELEMENT_TO_REF.get(value);
    },
    getElementG(value) {
        const g = NODE_TO_G.get(value);
        if (!g) {
            throw new Error(`can not resolve element g: ${JSON.stringify(value)}`);
        }
        return g;
    },
    hasMounted(element) {
        const containerG = PlaitElement.getContainerG(element, { suppressThrow: true });
        if (containerG) {
            return true;
        }
        else {
            return false;
        }
    },
    getContainerG(value, options) {
        const containerG = NODE_TO_CONTAINER_G.get(value) || null;
        if (!containerG) {
            if (options.suppressThrow) {
                return null;
            }
            throw new Error('can not resolve container g');
        }
        return containerG;
    }
};

const sortElements = (board, elements, ascendingOrder = true) => {
    return [...elements].sort((a, b) => {
        const pathA = PlaitBoard.findPath(board, a);
        const pathB = PlaitBoard.findPath(board, b);
        return ascendingOrder ? pathA[0] - pathB[0] : pathB[0] - pathA[0];
    });
};

const TEMPORARY_G = new Map();
const getTemporaryGArray = (debugKey) => {
    return TEMPORARY_G.get(debugKey) || [];
};
const setTemporaryGArray = (debugKey, gArray) => {
    TEMPORARY_G.set(debugKey, gArray);
};
class DebugGenerator {
    constructor(debugKey) {
        this.debugKey = debugKey;
    }
    isDebug() {
        return isDebug(this.debugKey);
    }
    clear() {
        if (!this.isDebug()) {
            return;
        }
        const gArray = getTemporaryGArray(this.debugKey);
        setTemporaryGArray(this.debugKey, []);
        gArray.forEach((g) => g.remove());
    }
    drawPolygon(board, points, options) {
        if (!isDebug(this.debugKey)) {
            return;
        }
        const polygonG = PlaitBoard.getRoughSVG(board).polygon(points, options || { stroke: 'red' });
        polygonG.classList.add(this.debugKey);
        PlaitBoard.getElementTopHost(board).append(polygonG);
        const gArray = getTemporaryGArray(this.debugKey);
        gArray.push(polygonG);
        setTemporaryGArray(this.debugKey, gArray);
        return polygonG;
    }
    drawLine(board, points, options) {
        if (!isDebug(this.debugKey)) {
            return;
        }
        const lineG = PlaitBoard.getRoughSVG(board).linearPath(points, options || { stroke: 'red' });
        lineG.classList.add(this.debugKey);
        PlaitBoard.getElementTopHost(board).append(lineG);
        const gArray = getTemporaryGArray(this.debugKey);
        gArray.push(lineG);
        setTemporaryGArray(this.debugKey, gArray);
        return lineG;
    }
    drawRectangle(board, data, options) {
        if (!isDebug(this.debugKey)) {
            return;
        }
        let rectangle;
        if (data instanceof Array) {
            rectangle = RectangleClient.getRectangleByPoints(data);
        }
        else {
            rectangle = data;
        }
        const rectangleG = PlaitBoard.getRoughSVG(board).rectangle(rectangle.x, rectangle.y, rectangle.width, rectangle.height, options || { stroke: 'red' });
        rectangleG.classList.add(this.debugKey);
        PlaitBoard.getElementTopHost(board).append(rectangleG);
        const gArray = getTemporaryGArray(this.debugKey);
        gArray.push(rectangleG);
        setTemporaryGArray(this.debugKey, gArray);
        return rectangleG;
    }
    drawCircles(board, points, diameter = 0, isCumulativeDiameter = false, options) {
        if (!isDebug(this.debugKey)) {
            return;
        }
        const result = [];
        points.forEach((p, i) => {
            const circle = PlaitBoard.getRoughSVG(board).circle(p[0], p[1], isCumulativeDiameter ? diameter * (i + 1) : diameter, Object.assign({}, { stroke: 'red', fill: 'red', fillStyle: 'solid' }, options || {}));
            circle.classList.add(this.debugKey);
            PlaitBoard.getElementTopHost(board).append(circle);
            const gArray = getTemporaryGArray(this.debugKey);
            gArray.push(circle);
            result.push(circle);
            setTemporaryGArray(this.debugKey, gArray);
        });
        return result;
    }
}
const createDebugGenerator = (debugKey) => {
    return new DebugGenerator(debugKey);
};
const isDebug = (key) => {
    const defaultKey = 'debug:plait';
    return localStorage.getItem(key || defaultKey) === 'true';
};

var PlaitPluginKey;
(function (PlaitPluginKey) {
    PlaitPluginKey["withSelection"] = "withSelection";
    PlaitPluginKey["withHand"] = "withHand";
})(PlaitPluginKey || (PlaitPluginKey = {}));

const getHitElementsBySelection = (board, selection, match = () => true) => {
    const newSelection = selection || board.selection;
    const rectangleHitElements = [];
    if (!newSelection) {
        return [];
    }
    const isCollapsed = Selection.isCollapsed(newSelection);
    if (isCollapsed) {
        const hitElements = getHitElementsByPoint(board, newSelection.anchor, match);
        if (hitElements?.length) {
            return hitElements;
        }
        else {
            return [];
        }
    }
    depthFirstRecursion(board, (node) => {
        if (!PlaitBoard.isBoard(node) && match(node)) {
            let isRectangleHit = false;
            try {
                isRectangleHit = board.isRectangleHit(node, newSelection);
            }
            catch (error) {
                if (isDebug()) {
                    console.error('isRectangleHit', error, 'node', node);
                }
            }
            if (isRectangleHit) {
                rectangleHitElements.push(node);
            }
        }
    }, getIsRecursionFunc(board), true);
    return rectangleHitElements;
};
const getHitElementsByPoint = (board, point, match = () => true, isStrict = true) => {
    let hitElements = [];
    depthFirstRecursion(board, (node) => {
        if (PlaitBoard.isBoard(node) || !match(node) || !PlaitElement.hasMounted(node)) {
            return;
        }
        let isHit = false;
        try {
            isHit = board.isHit(node, point, isStrict);
        }
        catch (error) {
            if (isDebug()) {
                console.error('isHit', error, 'node', node);
            }
        }
        if (isHit) {
            hitElements.push(node);
            return;
        }
    }, getIsRecursionFunc(board), true);
    return hitElements;
};
const getHitElementByPoint = (board, point, match = () => true, isStrict = true) => {
    const pointHitElements = getHitElementsByPoint(board, point, match, isStrict);
    const hitElement = board.getOneHitElement(pointHitElements);
    return hitElement;
};
const getHitSelectedElements = (board, point) => {
    const selectedElements = getSelectedElements(board);
    const targetRectangle = selectedElements.length > 0 && getRectangleByElements(board, selectedElements, false);
    const isInTargetRectangle = targetRectangle && RectangleClient.isPointInRectangle(targetRectangle, point);
    if (isInTargetRectangle) {
        return selectedElements;
    }
    else {
        return [];
    }
};
const cacheSelectedElements = (board, selectedElements) => {
    const sortedElements = sortElements(board, selectedElements);
    BOARD_TO_SELECTED_ELEMENT.set(board, sortedElements);
};
const getSelectedElements = (board) => {
    return BOARD_TO_SELECTED_ELEMENT.get(board) || [];
};
const addSelectedElement = (board, element) => {
    let elements = [];
    if (Array.isArray(element)) {
        elements.push(...element);
    }
    else {
        elements.push(element);
    }
    const selectedElements = getSelectedElements(board);
    cacheSelectedElements(board, [...selectedElements, ...elements]);
};
const removeSelectedElement = (board, element, isRemoveChildren = false) => {
    const selectedElements = getSelectedElements(board);
    if (selectedElements.includes(element)) {
        const targetElements = [];
        if (board.isRecursion(element) && isRemoveChildren) {
            depthFirstRecursion(element, (node) => {
                targetElements.push(node);
            }, (node) => board.isRecursion(node));
        }
        else {
            targetElements.push(element);
        }
        const newSelectedElements = selectedElements.filter((value) => !targetElements.includes(value));
        cacheSelectedElements(board, newSelectedElements);
    }
};
const replaceSelectedElement = (board, element, newElement) => {
    const selectedElements = getSelectedElements(board);
    selectedElements.splice(selectedElements.indexOf(element), 1, newElement);
};
const clearSelectedElement = (board) => {
    cacheSelectedElements(board, []);
};
const isSelectedElement = (board, element) => {
    const selectedElements = getSelectedElements(board);
    return !!selectedElements.find((value) => value === element);
};
const temporaryDisableSelection = (board) => {
    const currentOptions = board.getPluginOptions(PlaitPluginKey.withSelection);
    board.setPluginOptions(PlaitPluginKey.withSelection, {
        isDisabledSelection: true
    });
    setTimeout(() => {
        board.setPluginOptions(PlaitPluginKey.withSelection, { ...currentOptions });
    }, 0);
};
const isHitSelectedRectangle = (board, point) => {
    const hitSelectedElements = getHitSelectedElements(board, point);
    return hitSelectedElements.length > 0;
};
const isHitElement = (board, point) => {
    const hitElement = getHitElementByPoint(board, point);
    return !!hitElement || isHitSelectedRectangle(board, point);
};

/**
 * drawRoundRectangle
 */
function drawRoundRectangle(rs, x1, y1, x2, y2, options, outline = false, borderRadius) {
    const width = Math.abs(x1 - x2);
    const height = Math.abs(y1 - y2);
    let radius = borderRadius || 0;
    if (radius === 0) {
        const defaultRadius = Math.min(width, height) / 8;
        let radius = defaultRadius;
        if (defaultRadius > MAX_RADIUS) {
            radius = outline ? MAX_RADIUS + 2 : MAX_RADIUS;
        }
    }
    const point1 = [x1 + radius, y1];
    const point2 = [x2 - radius, y1];
    const point3 = [x2, y1 + radius];
    const point4 = [x2, y2 - radius];
    const point5 = [x2 - radius, y2];
    const point6 = [x1 + radius, y2];
    const point7 = [x1, y2 - radius];
    const point8 = [x1, y1 + radius];
    const rectangleG = rs.path(`M${point2[0]} ${point2[1]} A ${radius} ${radius}, 0, 0, 1, ${point3[0]} ${point3[1]} L ${point4[0]} ${point4[1]} A ${radius} ${radius}, 0, 0, 1, ${point5[0]} ${point5[1]} L ${point6[0]} ${point6[1]} A ${radius} ${radius}, 0, 0, 1, ${point7[0]} ${point7[1]} L ${point8[0]} ${point8[1]} A ${radius} ${radius}, 0, 0, 1, ${point1[0]} ${point1[1]} Z`, options);
    setStrokeLinecap(rectangleG, 'round');
    return rectangleG;
}
const drawRectangle = (board, rectangle, options) => {
    const roughSVG = PlaitBoard.getRoughSVG(board);
    const rectangleG = roughSVG.rectangle(rectangle.x, rectangle.y, rectangle.width, rectangle.height, options);
    setStrokeLinecap(rectangleG, 'round');
    return rectangleG;
};

function arrowPoints(start, end, degree = 40) {
    const width = Math.abs(start[0] - end[0]);
    const height = Math.abs(start[1] - end[1]);
    let hypotenuse = Math.hypot(width, height); // ÊñúËæπ
    const realRotateLine = hypotenuse / 2;
    const rotateWidth = (realRotateLine / hypotenuse) * width;
    const rotateHeight = (realRotateLine / hypotenuse) * height;
    const rotatePoint = [
        end[0] > start[0] ? end[0] - rotateWidth : end[0] + rotateWidth,
        end[1] > start[1] ? end[1] - rotateHeight : end[1] + rotateHeight
    ];
    const pointRight = rotate(rotatePoint[0], rotatePoint[1], end[0], end[1], (degree * Math.PI) / 180);
    const pointLeft = rotate(rotatePoint[0], rotatePoint[1], end[0], end[1], (-degree * Math.PI) / 180);
    return { pointLeft, pointRight };
}
function drawArrow(rs, start, end, options, maxHypotenuseLength = 10, degree = 40) {
    const { pointLeft, pointRight } = arrowPoints(start, end, degree);
    const arrowLineLeft = rs.linearPath([pointLeft, end], options);
    const arrowLineRight = rs.linearPath([pointRight, end], options);
    return [arrowLineLeft, arrowLineRight];
}

function drawCircle(roughSVG, point, diameter, options) {
    return roughSVG.circle(point[0], point[1], diameter, options);
}

function drawLine(rs, start, end, options) {
    return rs.linearPath([start, end], options);
}
function drawLinearPath(points, options, closePath) {
    const g = createG();
    const path = createPath();
    let polylinePath = '';
    points.forEach((point, index) => {
        if (index === 0) {
            polylinePath += `M ${point[0]} ${point[1]} `;
        }
        else {
            polylinePath += `L ${point[0]} ${point[1]} `;
        }
    });
    if (closePath) {
        polylinePath += 'Z';
    }
    path.setAttribute('d', polylinePath);
    path.setAttribute('stroke', `${options?.stroke}`);
    path.setAttribute('stroke-width', `${options?.strokeWidth}`);
    path.setAttribute('fill', `${options?.fill || 'none'}`);
    options?.strokeLineDash && path.setAttribute('stroke-dasharray', `${options.strokeLineDash}`);
    g.appendChild(path);
    return g;
}
function drawBezierPath(points, options) {
    const g = createG();
    const path = createPath();
    let polylinePath = '';
    for (let i = 0; i < points.length - 3; i += 3) {
        if (i === 0) {
            polylinePath += `M ${points[0][0]} ${points[0][1]} `;
        }
        else {
            polylinePath += `C ${points[i + 1][0]} ${points[i + 1][1]}, ${points[i + 2][0]} ${points[i + 2][1]}, ${points[i + 3][0]} ${points[i + 3][1]}`;
        }
    }
    path.setAttribute('d', polylinePath);
    path.setAttribute('stroke', `${options?.stroke}`);
    path.setAttribute('stroke-width', `${options?.strokeWidth}`);
    path.setAttribute('fill', `none`);
    g.appendChild(path);
    return g;
}

function setViewport(board, viewport) {
    const operation = { type: 'set_viewport', properties: board.viewport, newProperties: viewport };
    board.apply(operation);
}
const ViewportTransforms$1 = {
    setViewport
};

function setTheme(board, themeColorMode) {
    const operation = { type: 'set_theme', properties: board.theme, newProperties: themeColorMode };
    board.apply(operation);
}
const ViewportTransforms = {
    setTheme
};

function updateViewport(board, origination, zoom) {
    zoom = zoom ?? board.viewport.zoom;
    setViewport(board, {
        ...board.viewport,
        zoom,
        origination
    });
    clearViewportOrigination(board);
}
function updateZoom(board, newZoom, center) {
    newZoom = clampZoomLevel(newZoom);
    const nativeElement = PlaitBoard.getBoardContainer(board);
    const nativeElementRect = nativeElement.getBoundingClientRect();
    const boardContainerRect = PlaitBoard.getBoardContainer(board).getBoundingClientRect();
    let focusPoint = [boardContainerRect.width / 2, boardContainerRect.height / 2];
    if (center && distanceBetweenPointAndRectangle(center[0], center[1], nativeElementRect) === 0) {
        focusPoint = [center[0] - nativeElementRect.x, center[1] - nativeElementRect.y];
    }
    const zoom = board.viewport.zoom;
    const origination = getViewportOrigination(board);
    const centerX = origination[0] + focusPoint[0] / zoom;
    const centerY = origination[1] + focusPoint[1] / zoom;
    const newOrigination = [centerX - focusPoint[0] / newZoom, centerY - focusPoint[1] / newZoom];
    updateViewport(board, newOrigination, newZoom);
}
function fitViewport(board) {
    let scrollBarWidth = getRealScrollBarWidth(board);
    const boardContainerRect = PlaitBoard.getBoardContainer(board).getBoundingClientRect();
    const elementHostBox = getRectangleByElements(board, board.children, true);
    const zoom = board.viewport.zoom;
    const autoFitPadding = 16;
    const viewportWidth = boardContainerRect.width - 2 * autoFitPadding;
    const viewportHeight = boardContainerRect.height - 2 * autoFitPadding;
    let newZoom = zoom;
    if (viewportWidth < elementHostBox.width || viewportHeight < elementHostBox.height) {
        newZoom = Math.min(viewportWidth / elementHostBox.width, viewportHeight / elementHostBox.height);
    }
    else {
        newZoom = 1;
    }
    const centerPoint = getViewBoxCenterPoint(board);
    const newOrigination = [
        centerPoint[0] - boardContainerRect.width / 2 / newZoom + scrollBarWidth / 2 / zoom,
        centerPoint[1] - boardContainerRect.height / 2 / newZoom + scrollBarWidth / 2 / zoom
    ];
    updateViewport(board, newOrigination, newZoom);
}
function fitViewportWidth(board, options) {
    let scrollBarWidth = getRealScrollBarWidth(board);
    const boardContainer = PlaitBoard.getBoardContainer(board);
    const boardContainerRectangle = boardContainer.getBoundingClientRect();
    let finalWidth = 0;
    if (options.maxWidth) {
        finalWidth = options.maxWidth;
    }
    else {
        finalWidth = boardContainerRectangle.width;
    }
    const elementHostBox = getRectangleByElements(board, board.children, true);
    const contentWidth = finalWidth - 2 * options.autoFitPadding;
    let newZoom = 0;
    if (contentWidth < elementHostBox.width) {
        newZoom = Math.min(contentWidth / elementHostBox.width);
    }
    else {
        newZoom = 1;
    }
    let finalHeight = elementHostBox.height * newZoom + 2 * options.autoFitPadding;
    if (finalHeight > options.limitHeight) {
        const containerEl = boardContainer.closest(`.${options.containerClass}`);
        containerEl.style.height = `${finalHeight}px`;
        initializeViewportContainer(board);
    }
    else {
        finalHeight = options.limitHeight;
    }
    const centerX = elementHostBox.x + elementHostBox.width / 2;
    const centerY = elementHostBox.y + elementHostBox.height / 2;
    const newOrigination = [
        centerX - finalWidth / 2 / newZoom + scrollBarWidth / 2 / newZoom,
        centerY - finalHeight / 2 / newZoom + scrollBarWidth / 2 / newZoom
    ];
    updateViewport(board, newOrigination, newZoom);
}
/**
 * apply theme to every element (remove element custom properties)
 * invoke applyThemeColor
 */
function updateThemeColor(board, mode) {
    mode = mode ?? board.theme.themeColorMode;
    setTheme(board, { themeColorMode: mode });
    depthFirstRecursion(board, element => {
        board.applyTheme(element);
    });
}
const updatePointerType = (board, pointer) => {
    if (board.pointer === pointer)
        return;
    board.pointer = pointer;
};
function moveToCenter(board, centerPoint) {
    const plaitElement = getSelectedElements(board)?.[0];
    if (plaitElement) {
        const boardContainerRect = PlaitBoard.getBoardContainer(board).getBoundingClientRect();
        const scrollBarWidth = getRealScrollBarWidth(board);
        const oldCenterPoint = getViewBoxCenterPoint(board);
        const left = centerPoint[0] - oldCenterPoint[0];
        const top = centerPoint[1] - oldCenterPoint[1];
        const zoom = board.viewport.zoom;
        const origination = [
            left - boardContainerRect.width / 2 / zoom + scrollBarWidth / 2 / zoom,
            top - boardContainerRect.height / 2 / zoom + scrollBarWidth / 2 / zoom
        ];
        setViewport(board, {
            ...board.viewport,
            origination
        });
        clearViewportOrigination(board);
    }
}
const BoardTransforms = {
    updatePointerType,
    updateViewport,
    fitViewport,
    updateZoom,
    updateThemeColor,
    fitViewportWidth,
    moveToCenter
};

const getViewBox = (board) => {
    return PlaitBoard.getHost(board).viewBox.baseVal;
};
/**
 * Get the screen point starting from the upper left corner of the svg element (based on the svg screen coordinate system)
 * reference: https://github.com/worktile/plait/blob/develop/packages/core/src/utils/to-point.md
 */
function toHostPoint(board, x, y) {
    const host = PlaitBoard.getHost(board);
    const rect = host.getBoundingClientRect();
    return [x - rect.x, y - rect.y];
}
function toActiveRectangleFromViewBoxRectangle(board, rectangle) {
    const leftTop = [rectangle.x, rectangle.y];
    const rightBottom = [rectangle.x + rectangle.width, rectangle.y + rectangle.height];
    const leftTopOfActive = toActivePointFromViewBoxPoint(board, leftTop);
    const rightBottomOfActive = toActivePointFromViewBoxPoint(board, rightBottom);
    return RectangleClient.getRectangleByPoints([leftTopOfActive, rightBottomOfActive]);
}
function toActivePointFromViewBoxPoint(board, point) {
    const screenPoint = toScreenPointFromHostPoint(board, toHostPointFromViewBoxPoint(board, point));
    return toActivePoint(board, screenPoint[0], screenPoint[1]);
}
/**
 * Get the screen point starting from the upper left corner of the svg element (based on the svg screen coordinate system)
 */
function toActivePoint(board, x, y) {
    const boardContainer = PlaitBoard.getBoardContainer(board);
    const rect = boardContainer.getBoundingClientRect();
    return [x - rect.x, y - rect.y];
}
function toScreenPointFromActivePoint(board, activePoint) {
    const boardContainer = PlaitBoard.getBoardContainer(board);
    const rect = boardContainer.getBoundingClientRect();
    return [rect.x + activePoint[0], rect.y + activePoint[1]];
}
/**
 * Get the point in the coordinate system of the svg viewBox
 * reference: https://github.com/worktile/plait/blob/develop/packages/core/src/utils/to-point.md
 */
function toViewBoxPoint(board, hostPoint) {
    const viewBox = getViewBox(board);
    const { zoom } = board.viewport;
    const x = hostPoint[0] / zoom + viewBox.x;
    const y = hostPoint[1] / zoom + viewBox.y;
    const newPoint = [x, y];
    return newPoint;
}
function toViewBoxPoints(board, hostPoints) {
    const newPoints = hostPoints.map((point) => {
        return toViewBoxPoint(board, point);
    });
    return newPoints;
}
/**
 * `toHostPoint` reverse processing
 * Get the screen point starting from the upper left corner of the browser window or the viewport (based on the screen coordinate system)
 */
function toScreenPointFromHostPoint(board, hostPoint) {
    const host = PlaitBoard.getHost(board);
    const rect = host.getBoundingClientRect();
    return [hostPoint[0] + rect.x, hostPoint[1] + rect.y];
}
/**
 * `toViewBoxPoint` reverse processing
 */
function toHostPointFromViewBoxPoint(board, viewBoxPoint) {
    const { zoom } = board.viewport;
    const viewBox = getViewBox(board);
    const x = (viewBoxPoint[0] - viewBox.x) * zoom;
    const y = (viewBoxPoint[1] - viewBox.y) * zoom;
    return [x, y];
}

const VIEWPORT_PADDING_RATIO = 0.75;
const IS_FROM_SCROLLING = new WeakMap();
const IS_FROM_VIEWPORT_CHANGE = new WeakMap();
function getViewportContainerRect(board) {
    const { hideScrollbar } = board.options;
    const scrollBarWidth = hideScrollbar ? SCROLL_BAR_WIDTH : 0;
    const viewportRect = PlaitBoard.getBoardContainer(board).getBoundingClientRect();
    return {
        width: viewportRect.width + scrollBarWidth,
        height: viewportRect.height + scrollBarWidth
    };
}
function getElementHostBBox(board, zoom) {
    const childrenRect = getRectangleByElements(board, board.children, true);
    let left;
    let right;
    let top;
    let bottom;
    left = childrenRect.x;
    right = childrenRect.x + childrenRect.width;
    top = childrenRect.y;
    bottom = childrenRect.y + childrenRect.height;
    return {
        left,
        right,
        top,
        bottom
    };
}
/**
 * Normalize the scaling ratio, or return the corrected scaling ratio if the limit is exceeded
 */
function clampZoomLevel(zoom, minZoom = MIN_ZOOM, maxZoom = MAX_ZOOM) {
    return zoom < minZoom ? minZoom : zoom > maxZoom ? maxZoom : zoom;
}
/**
 * Prepares element bounding box with minimum size constraints
 */
function prepareElementBBox(board, zoom) {
    const boardContainerRectangle = PlaitBoard.getBoardContainer(board).getBoundingClientRect();
    const elementHostBBox = getElementHostBBox(board, zoom);
    const containerWidth = boardContainerRectangle.width;
    const containerHeight = boardContainerRectangle.height;
    // Calculate bounding box dimensions
    let width = elementHostBBox.right - elementHostBBox.left;
    let height = elementHostBBox.bottom - elementHostBBox.top;
    // If elementHostBBox dimensions are smaller than container dimensions,
    // use half of container dimensions as minimum size
    const minWidth = containerWidth / 2;
    const minHeight = containerHeight / 2;
    if (width < minWidth / zoom) {
        // Center the content horizontally if applying minimum width
        const center = elementHostBBox.left + width / 2;
        elementHostBBox.left = center - minWidth / 2 / zoom;
        elementHostBBox.right = center + minWidth / 2 / zoom;
        width = minWidth / zoom;
    }
    if (height < minHeight / zoom) {
        // Center the content vertically if applying minimum height
        const center = elementHostBBox.top + height / 2;
        elementHostBBox.top = center - minHeight / 2 / zoom;
        elementHostBBox.bottom = center + minHeight / 2 / zoom;
        height = minHeight / zoom;
    }
    return {
        elementHostBBox,
        containerWidth,
        containerHeight,
        width,
        height
    };
}
/**
 * Calculates viewBox based on element bounding box with padding
 */
function calculateViewBox(elementHostBBox, containerWidth, containerHeight, width, height, zoom, paddingRatio = VIEWPORT_PADDING_RATIO) {
    const horizontalPaddingInViewBox = (containerWidth * paddingRatio) / zoom;
    const verticalPaddingInViewBox = (containerHeight * paddingRatio) / zoom;
    return [
        elementHostBBox.left - horizontalPaddingInViewBox,
        elementHostBBox.top - verticalPaddingInViewBox,
        width + horizontalPaddingInViewBox * 2,
        height + verticalPaddingInViewBox * 2
    ];
}
function calcNewViewBox(board, zoom) {
    const { elementHostBBox, containerWidth, containerHeight, width, height } = prepareElementBBox(board, zoom);
    return calculateViewBox(elementHostBBox, containerWidth, containerHeight, width, height, zoom);
}
function getViewBoxCenterPoint(board) {
    const childrenRectangle = getRectangleByElements(board, board.children, true);
    return [childrenRectangle.x + childrenRectangle.width / 2, childrenRectangle.y + childrenRectangle.height / 2];
}
function setSVGViewBox(board, viewBox) {
    const zoom = board.viewport.zoom;
    const hostElement = PlaitBoard.getHost(board);
    hostElement.style.display = 'block';
    hostElement.style.width = `${viewBox[2] * zoom}px`;
    hostElement.style.height = `${viewBox[3] * zoom}px`;
    if (viewBox && viewBox[2] > 0 && viewBox[3] > 0) {
        hostElement.setAttribute('viewBox', viewBox.join(' '));
    }
}
function updateViewportOffset(board) {
    const origination = getViewportOrigination(board);
    if (!origination) {
        return;
    }
    const [scrollLeft, scrollTop] = toHostPointFromViewBoxPoint(board, origination);
    updateViewportContainerScroll(board, scrollLeft, scrollTop);
}
function updateViewportContainerScroll(board, left, top, isFromViewportChange = true) {
    const viewportContainer = PlaitBoard.getViewportContainer(board);
    const previousScrollLeft = viewportContainer.scrollLeft;
    const previousScrollTop = viewportContainer.scrollTop;
    // scrollTop assign 11.8 will get 11.5 in chrome
    // scrollTop assign 11.8 will get 11 in firefox, safari
    // scrollTop assign 11.4 will get 11 in chrome, firefox, safari
    // use approximately method to determine the new value is valid updating to avoid debouncing
    if (!approximately(viewportContainer.scrollLeft, left, 1) || !approximately(viewportContainer.scrollTop, top, 1)) {
        viewportContainer.scrollLeft = left;
        viewportContainer.scrollTop = top;
        const offsetWidth = viewportContainer.offsetWidth;
        const offsetHeight = viewportContainer.offsetHeight;
        if (previousScrollLeft === viewportContainer.scrollLeft && previousScrollTop === viewportContainer.scrollTop) {
            // The scroll event cannot be triggered, so the origination is modified directly based on the scroll distance.
            updateViewportByScrolling(board, previousScrollLeft, previousScrollTop);
        }
        else {
            const isValidLeftOrTop = left > 0 &&
                top > 0 &&
                left < viewportContainer.scrollWidth - offsetWidth &&
                top < viewportContainer.scrollHeight - offsetHeight;
            if (isFromViewportChange && isValidLeftOrTop) {
                setIsFromViewportChange(board, true);
            }
        }
    }
}
function updateViewportByScrolling(board, scrollLeft, scrollTop) {
    const origination = toViewBoxPoint(board, [scrollLeft, scrollTop]);
    if (Point.isEquals(origination, getViewportOrigination(board))) {
        return;
    }
    BoardTransforms.updateViewport(board, origination);
    setIsFromScrolling(board, true);
}
function initializeViewportContainer(board) {
    const { width, height } = getViewportContainerRect(board);
    const viewportContainer = PlaitBoard.getViewportContainer(board);
    viewportContainer.style.width = `${width}px`;
    viewportContainer.style.height = `${height}px`;
}
function initializeViewBox(board) {
    const zoom = board.viewport.zoom;
    const viewBox = calcNewViewBox(board, zoom);
    setSVGViewBox(board, viewBox);
}
function updateViewBox(board) {
    const zoom = board.viewport.zoom;
    const { elementHostBBox, containerWidth, containerHeight, width, height } = prepareElementBBox(board, zoom);
    // Use 0.5 ratio to check if contents are within current viewBox
    const checkViewBox = calculateViewBox(elementHostBBox, containerWidth, containerHeight, width, height, zoom, 0.5 // Use smaller padding ratio for checking
    );
    // Get current viewBox
    const currentViewBox = getViewBox(board);
    // Only update if new viewBox is NOT contained within current viewBox
    if (checkViewBox[0] < currentViewBox.x ||
        checkViewBox[1] < currentViewBox.y ||
        checkViewBox[0] + checkViewBox[2] > currentViewBox.x + currentViewBox.width ||
        checkViewBox[1] + checkViewBox[3] > currentViewBox.y + currentViewBox.height) {
        // Update with larger padding ratio
        const newViewBox = calculateViewBox(elementHostBBox, containerWidth, containerHeight, width, height, zoom, VIEWPORT_PADDING_RATIO);
        setSVGViewBox(board, newViewBox);
    }
}
function initializeViewportOffset(board) {
    if (!board.viewport?.origination) {
        const zoom = board.viewport.zoom;
        const viewportContainerRect = PlaitBoard.getBoardContainer(board).getBoundingClientRect();
        const viewBox = calcNewViewBox(board, zoom);
        const centerX = viewBox[0] + viewBox[2] / 2;
        const centerY = viewBox[1] + viewBox[3] / 2;
        const origination = [centerX - viewportContainerRect.width / 2 / zoom, centerY - viewportContainerRect.height / 2 / zoom];
        updateViewportOrigination(board, origination);
        updateViewportOffset(board);
        return;
    }
    updateViewportOffset(board);
}
const updateViewportOrigination = (board, origination) => {
    BOARD_TO_VIEWPORT_ORIGINATION.set(board, origination);
};
const clearViewportOrigination = (board) => {
    BOARD_TO_VIEWPORT_ORIGINATION.delete(board);
};
const getViewportOrigination = (board) => {
    const origination = BOARD_TO_VIEWPORT_ORIGINATION.get(board);
    if (origination) {
        return origination;
    }
    else {
        return board.viewport.origination;
    }
};
const isFromScrolling = (board) => {
    return !!IS_FROM_SCROLLING.get(board);
};
const setIsFromScrolling = (board, state) => {
    IS_FROM_SCROLLING.set(board, state);
};
const isFromViewportChange = (board) => {
    return !!IS_FROM_VIEWPORT_CHANGE.get(board);
};
const setIsFromViewportChange = (board, state) => {
    IS_FROM_VIEWPORT_CHANGE.set(board, state);
};
function scrollToRectangle(board, client) { }

function insertNode(board, node, path) {
    const operation = { type: 'insert_node', node, path };
    board.apply(operation);
}
function setNode(board, props, path) {
    const properties = {};
    const newProperties = {};
    const node = PlaitNode.get(board, path);
    for (const k in props) {
        if (node[k] !== props[k]) {
            if (node.hasOwnProperty(k)) {
                properties[k] = node[k];
            }
            if (props[k] != null)
                newProperties[k] = props[k];
        }
    }
    const operation = { type: 'set_node', properties, newProperties, path };
    board.apply(operation);
}
function removeNode(board, path) {
    const node = PlaitNode.get(board, path);
    const operation = { type: 'remove_node', path, node };
    board.apply(operation);
}
function moveNode(board, path, newPath) {
    const operation = { type: 'move_node', path, newPath };
    board.apply(operation);
}
const NodeTransforms = {
    insertNode,
    setNode,
    removeNode,
    moveNode
};

const BOARD_TO_RAF = new WeakMap();
const getTimerId = (board, key) => {
    const state = getRAFState(board);
    return state[key] || null;
};
const getRAFState = (board) => {
    return BOARD_TO_RAF.get(board) || {};
};
const throttleRAF = (board, key, fn) => {
    const scheduleFunc = () => {
        let timerId = requestAnimationFrame(() => {
            const value = BOARD_TO_RAF.get(board) || {};
            value[key] = null;
            BOARD_TO_RAF.set(board, value);
            PlaitBoard.isAlive(board) && fn();
        });
        const state = getRAFState(board);
        state[key] = timerId;
        BOARD_TO_RAF.set(board, state);
    };
    let timerId = getTimerId(board, key);
    if (timerId !== null) {
        cancelAnimationFrame(timerId);
    }
    scheduleFunc();
};
const debounce = (func, wait, options) => {
    let timeoutId = null;
    return (args) => {
        if (timeoutId !== null) {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => {
                func(args);
                timeoutId = null;
            }, wait);
        }
        else {
            if (options?.leading) {
                func(args);
            }
            timeoutId = setTimeout(() => {
                timeoutId = null;
                if (!options?.leading) {
                    func(args);
                }
            }, wait);
        }
    };
};
const getElementsIndices = (board, elements) => {
    sortElements(board, elements);
    return elements
        .map(item => {
        return board.children.map(item => item.id).indexOf(item.id);
    })
        .filter(item => item >= 0);
};
const getHighestIndexOfElement = (board, elements) => {
    const indices = getElementsIndices(board, elements);
    return indices[indices.length - 1];
};
const moveElementsToNewPath = (board, moveOptions) => {
    moveOptions
        .map(item => {
        const path = PlaitBoard.findPath(board, item.element);
        const ref = board.pathRef(path);
        return () => {
            ref.current && NodeTransforms.moveNode(board, ref.current, item.newPath);
            ref.unref();
        };
    })
        .forEach(action => {
        action();
    });
};

const IS_DRAGGING = new WeakMap();
const isDragging = (board) => {
    return !!IS_DRAGGING.get(board);
};
const setDragging = (board, state) => {
    IS_DRAGGING.set(board, state);
};

const getMovingElements = (board) => {
    return BOARD_TO_MOVING_ELEMENT.get(board) || [];
};
const isMovingElements = (board) => {
    return (BOARD_TO_MOVING_ELEMENT.get(board) || []).length > 0;
};
const removeMovingElements = (board) => {
    BOARD_TO_MOVING_ELEMENT.delete(board);
    setDragging(board, false);
};
const cacheMovingElements = (board, elements) => {
    BOARD_TO_MOVING_ELEMENT.set(board, elements);
    setDragging(board, true);
};

const FOREIGN_OBJECT_EXPRESSION = `foreignObject[class^='foreign-object']`;
/**
 * Is element node
 * @param node
 * @returns
 */
function isElementNode(node) {
    return node.nodeType === Node.ELEMENT_NODE;
}
/**
 * load image resources
 * @param url image url
 * @returns image element
 */
function loadImage(src) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'Anonymous';
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error('Failed to load image'));
        img.src = src;
    });
}
/**
 * create and return canvas and context
 * @param width canvas width
 * @param height canvas height
 * @param fillStyle fill style
 * @returns canvas and context
 */
function createCanvas(width, height, fillStyle = 'transparent') {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = width;
    canvas.height = height;
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    ctx.strokeStyle = '#ffffff';
    ctx.fillStyle = fillStyle;
    ctx.fillRect(0, 0, width, height);
    return {
        canvas,
        ctx
    };
}
/**
 * convert image to base64
 * @param url image url
 * @returns image base64
 */
async function convertImageToBase64(url) {
    const response = await fetch(url);
    const blob = await response.blob();
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    });
}
/**
 * clone node style
 * @param nativeNode source node
 * @param clonedNode clone node
 */
function cloneCSSStyle(nativeNode, clonedNode) {
    const targetStyle = clonedNode?.style;
    if (!targetStyle) {
        return;
    }
    const sourceStyle = window.getComputedStyle(nativeNode);
    if (sourceStyle.cssText) {
        targetStyle.cssText = sourceStyle.cssText;
        targetStyle.transformOrigin = sourceStyle.transformOrigin;
    }
    else {
        Array.from(sourceStyle).forEach(name => {
            let value = sourceStyle.getPropertyValue(name);
            targetStyle.setProperty(name, value, sourceStyle.getPropertyPriority(name));
        });
    }
}
/**
 * batch clone target styles
 * @param sourceNode
 * @param cloneNode
 * @param inlineStyleClassNames
 */
function batchCloneCSSStyle(sourceNode, cloneNode, inlineStyleClassNames) {
    if (inlineStyleClassNames) {
        const classNames = inlineStyleClassNames + `, ${FOREIGN_OBJECT_EXPRESSION}`;
        const sourceNodes = Array.from(sourceNode.querySelectorAll(classNames));
        const cloneNodes = Array.from(cloneNode.querySelectorAll(classNames));
        sourceNodes.forEach((node, index) => {
            const childElements = Array.from(node.querySelectorAll('*')).filter(isElementNode);
            const cloneChildElements = Array.from(cloneNodes[index].querySelectorAll('*')).filter(isElementNode);
            sourceNodes.push(...childElements);
            cloneNodes.push(...cloneChildElements);
        });
        // processing styles
        sourceNodes.map((node, index) => {
            cloneCSSStyle(node, cloneNodes[index]);
        });
    }
}
/**
 * convert images in target nodes in batches
 * @param sourceNode
 * @param cloneNode
 */
async function batchConvertImage(sourceNode, cloneNode) {
    const sourceImageNodes = Array.from(sourceNode.querySelectorAll(`${FOREIGN_OBJECT_EXPRESSION}`));
    const cloneImageNodes = Array.from(cloneNode.querySelectorAll(`${FOREIGN_OBJECT_EXPRESSION}`));
    await Promise.all(sourceImageNodes.map((_, index) => {
        return new Promise(resolve => {
            const cloneImageNode = cloneImageNodes[index];
            // processing image
            const image = cloneImageNode.querySelector('img');
            const url = image?.getAttribute('src');
            if (!url) {
                return resolve(true);
            }
            convertImageToBase64(url).then(base64Image => {
                image?.setAttribute('src', base64Image);
                resolve(true);
            });
        });
    }));
}
/**
 * clone svg element
 * @param board board
 * @param options parameter configuration
 * @returns clone svg element
 */
async function cloneSvg(board, elements, rectangle, options) {
    const { width, height, x, y } = rectangle;
    const { padding = 4, inlineStyleClassNames } = options;
    const sourceSvg = PlaitBoard.getHost(board);
    const selectedGElements = elements.map(value => PlaitElement.getElementG(value));
    const cloneSvgElement = sourceSvg.cloneNode();
    const newHostElement = PlaitBoard.getElementHost(board).cloneNode();
    cloneSvgElement.style.width = `${width}px`;
    cloneSvgElement.style.height = `${height}px`;
    cloneSvgElement.style.backgroundColor = '';
    cloneSvgElement.setAttribute('width', `${width}`);
    cloneSvgElement.setAttribute('height', `${height}`);
    cloneSvgElement.setAttribute('viewBox', [x - padding, y - padding, width + 2 * padding, height + 2 * padding].join(','));
    const promiseArray = new Array(selectedGElements.length);
    await Promise.all(selectedGElements.map(async (child, i) => {
        const cloneChild = child.cloneNode(true);
        batchCloneCSSStyle(child, cloneChild, inlineStyleClassNames);
        await batchConvertImage(child, cloneChild);
        promiseArray[i] = cloneChild;
    }));
    newHostElement.append(...promiseArray);
    cloneSvgElement.appendChild(newHostElement);
    return cloneSvgElement;
}
/**
 * current board transfer pictures
 * @param board board
 * @param options parameter configuration
 * @returns images in the specified format base64
 */
async function toImage(board, options) {
    if (!board) {
        return undefined;
    }
    const elements = options.elements || findElements(board, { match: () => true, recursion: () => true, isReverse: false });
    const targetRectangle = getRectangleByElements(board, elements, false);
    const { ratio = 2, fillStyle = 'transparent' } = options;
    const { width, height } = targetRectangle;
    const ratioWidth = width * ratio;
    const ratioHeight = height * ratio;
    const cloneSvgElement = await cloneSvg(board, elements, targetRectangle, options);
    const { canvas, ctx } = createCanvas(ratioWidth, ratioHeight, fillStyle);
    const svgStr = new XMLSerializer().serializeToString(cloneSvgElement);
    const imgSrc = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svgStr)}`;
    try {
        const img = await loadImage(imgSrc);
        ctx.drawImage(img, 0, 0, ratioWidth, ratioHeight);
        return canvas.toDataURL('image/png');
    }
    catch (error) {
        console.error('Error converting SVG to image:', error);
        return undefined;
    }
}
/**
 * download the file with the specified name
 * @param url download url
 * @param name file name
 */
function downloadImage(url, name) {
    const a = document.createElement('a');
    a.href = url;
    a.download = name;
    a.click();
    a.remove();
}

var WritableClipboardType;
(function (WritableClipboardType) {
    WritableClipboardType["medias"] = "medias";
    WritableClipboardType["elements"] = "elements";
})(WritableClipboardType || (WritableClipboardType = {}));
var WritableClipboardOperationType;
(function (WritableClipboardOperationType) {
    WritableClipboardOperationType["copy"] = "copy";
    WritableClipboardOperationType["cut"] = "cut";
    WritableClipboardOperationType["duplicate"] = "duplicate";
    WritableClipboardOperationType["paste"] = "paste";
})(WritableClipboardOperationType || (WritableClipboardOperationType = {}));

const buildPlaitHtml = (type, data) => {
    const stringifiedClipboard = replaceAngleBrackets(JSON.stringify({
        type,
        data
    }));
    return `<plait>${stringifiedClipboard}</plait>`;
};
const getClipboardFromHtml = (html) => {
    let plaitString = html?.match(/<plait[^>]*>(.*)<\/plait>/)?.[1];
    if (plaitString) {
        plaitString = reverseReplaceAngleBrackets(plaitString);
        try {
            const plaitJson = JSON.parse(plaitString);
            if (plaitJson) {
                if (plaitJson.type === WritableClipboardType.elements) {
                    return {
                        elements: plaitJson.data
                    };
                }
                else if (plaitJson.type === WritableClipboardType.medias) {
                    return {
                        medias: plaitJson.data
                    };
                }
            }
        }
        catch (error) {
            console.error(error);
            return null;
        }
    }
    return null;
};
const stripHtml = (html) => {
    // See <https://github.com/developit/preact-markup/blob/4788b8d61b4e24f83688710746ee36e7464f7bbc/src/parse-markup.js#L60-L69>
    const doc = document.implementation.createHTMLDocument('');
    doc.documentElement.innerHTML = html.trim();
    return doc.body.textContent || doc.body.innerText || '';
};
const getProbablySupportsClipboardWrite = () => {
    return 'clipboard' in navigator && 'write' in navigator.clipboard;
};
const getProbablySupportsClipboardWriteText = () => {
    return 'clipboard' in navigator && 'writeText' in navigator.clipboard;
};
const getProbablySupportsClipboardRead = () => {
    return 'clipboard' in navigator && 'read' in navigator.clipboard;
};
const createClipboardContext = (type, elements, text) => {
    return {
        type,
        elements,
        text
    };
};
const addClipboardContext = (clipboardContext, addition) => {
    const { type, elements, text } = clipboardContext;
    if (type === addition.type) {
        return {
            type,
            elements: elements.concat(addition.elements),
            text: text + ' ' + addition.text
        };
    }
    return clipboardContext;
};
const addOrCreateClipboardContext = (clipboardContext, addition) => {
    if (!clipboardContext) {
        return addition;
    }
    else {
        return addClipboardContext(clipboardContext, addition);
    }
};
const replaceAngleBrackets = (str) => {
    return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');
};
const reverseReplaceAngleBrackets = (str) => {
    return str.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
};

const setDataTransferClipboard = (dataTransfer, type, data) => {
    dataTransfer?.setData(`text/html`, buildPlaitHtml(type, data));
};
const setDataTransferClipboardText = (data, text) => {
    data?.setData(`text/plain`, text);
};
const getDataTransferClipboard = (data) => {
    const html = data?.getData(`text/html`);
    if (html) {
        const htmlClipboardData = getClipboardFromHtml(html);
        if (htmlClipboardData) {
            return htmlClipboardData;
        }
    }
    return {};
};
const getDataTransferClipboardText = (data) => {
    if (!data) {
        return {};
    }
    const text = data?.getData(`text/plain`);
    if (text) {
        const htmlClipboardData = getClipboardFromHtml(text);
        if (htmlClipboardData) {
            return htmlClipboardData;
        }
    }
    return {
        text
    };
};

const setNavigatorClipboard = async (type, data, text = '') => {
    let textClipboard = text;
    if (getProbablySupportsClipboardWrite()) {
        await navigator.clipboard.write([
            new ClipboardItem({
                'text/html': new Blob([buildPlaitHtml(type, data)], {
                    type: 'text/html'
                }),
                'text/plain': new Blob([textClipboard ?? JSON.stringify(data)], { type: 'text/plain' })
            })
        ]);
    }
};
const getNavigatorClipboard = async () => {
    if (!getProbablySupportsClipboardRead()) {
        return {};
    }
    const clipboardItems = await navigator.clipboard.read();
    let clipboardData = {};
    if (Array.isArray(clipboardItems) && clipboardItems[0] instanceof ClipboardItem) {
        for (const item of clipboardItems) {
            if (isFile(item)) {
                const clipboardFiles = item.types.filter(type => type.match(/^image\//));
                const fileBlobs = await Promise.all(clipboardFiles.map(type => item.getType(type)));
                const urls = fileBlobs.filter(Boolean).map(blob => URL.createObjectURL(blob));
                const files = await Promise.all(urls.map(async (url) => {
                    const blob = await (await fetch(url)).blob();
                    return new File([blob], 'plait-file', { type: blob.type });
                }));
                return {
                    files
                };
            }
            if (item.types.includes('text/html')) {
                const htmlContent = await blobAsString(await item.getType('text/html'));
                const htmlClipboardData = getClipboardFromHtml(htmlContent);
                if (htmlClipboardData) {
                    return htmlClipboardData;
                }
                if (htmlContent && htmlContent.trim()) {
                    clipboardData = { text: stripHtml(htmlContent) };
                }
            }
            if (item.types.includes('text/plain')) {
                const textContent = await blobAsString(await item.getType('text/plain'));
                clipboardData = {
                    text: stripHtml(textContent)
                };
            }
        }
    }
    return clipboardData;
};
const isFile = (item) => {
    return item.types.find(i => i.match(/^image\//));
};
const blobAsString = (blob) => {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.addEventListener('loadend', () => {
            const text = reader.result;
            resolve(text);
        });
        reader.addEventListener('error', () => {
            reject(reader.error);
        });
        reader.readAsText(blob);
    });
};

const getClipboardData = async (dataTransfer) => {
    let clipboardData = {};
    if (dataTransfer) {
        if (dataTransfer.files.length) {
            return { files: Array.from(dataTransfer.files) };
        }
        clipboardData = getDataTransferClipboard(dataTransfer);
        if (Object.keys(clipboardData).length === 0) {
            clipboardData = getDataTransferClipboardText(dataTransfer);
        }
        return clipboardData;
    }
    if (getProbablySupportsClipboardRead()) {
        return await getNavigatorClipboard();
    }
    return clipboardData;
};
const setClipboardData = async (dataTransfer, clipboardContext) => {
    if (!clipboardContext) {
        return;
    }
    const { type, elements, text } = clipboardContext;
    if (getProbablySupportsClipboardWrite()) {
        return await setNavigatorClipboard(type, elements, text);
    }
    if (dataTransfer) {
        setDataTransferClipboard(dataTransfer, type, elements);
        setDataTransferClipboardText(dataTransfer, text);
        return;
    }
    // Compatible with situations where navigator.clipboard.write is not supported and dataTransfer is empty
    // Such as contextmenu copy in Firefox.
    if (getProbablySupportsClipboardWriteText()) {
        return await navigator.clipboard.writeText(buildPlaitHtml(type, elements));
    }
};

function isSelectionMoving(board) {
    return !!BOARD_TO_IS_SELECTION_MOVING.get(board);
}
function setSelectionMoving(board) {
    PlaitBoard.getBoardContainer(board).classList.add('selection-moving');
    BOARD_TO_IS_SELECTION_MOVING.set(board, true);
    setDragging(board, true);
}
function clearSelectionMoving(board) {
    PlaitBoard.getBoardContainer(board).classList.remove('selection-moving');
    BOARD_TO_IS_SELECTION_MOVING.delete(board);
    setDragging(board, false);
}
function isHandleSelection(board) {
    const options = getSelectionOptions(board);
    return board.pointer !== PlaitPointerType.hand && !options.isDisabledSelection && !PlaitBoard.isReadonly(board);
}
function hasSetSelectionOperation(board) {
    return !!board.operations.find((op) => PlaitOperation.isSetSelectionOperation(op));
}
function getTemporaryElements(board) {
    const ref = BOARD_TO_TEMPORARY_ELEMENTS.get(board);
    if (ref) {
        return ref.elements;
    }
    else {
        return undefined;
    }
}
function getTemporaryRef(board) {
    return BOARD_TO_TEMPORARY_ELEMENTS.get(board);
}
function deleteTemporaryElements(board) {
    BOARD_TO_TEMPORARY_ELEMENTS.delete(board);
}
function drawSelectionRectangleG(board) {
    const elements = getSelectedElements(board);
    const rectangle = getRectangleByElements(board, elements, false);
    const activeRectangle = toActiveRectangleFromViewBoxRectangle(board, rectangle);
    if (activeRectangle.width > 0 && activeRectangle.height > 0 && elements.length > 1) {
        const selectionRectangleG = drawRectangle(board, RectangleClient.inflate(activeRectangle, ACTIVE_STROKE_WIDTH), {
            stroke: SELECTION_BORDER_COLOR,
            strokeWidth: ACTIVE_STROKE_WIDTH,
            fillStyle: 'solid'
        });
        selectionRectangleG.classList.add(SELECTION_RECTANGLE_CLASS_NAME, SELECTION_RECTANGLE_BOUNDING_CLASS_NAME);
        const angle = getSelectionAngle(elements);
        if (angle) {
            setAngleForG(selectionRectangleG, RectangleClient.getCenterPoint(activeRectangle), angle);
        }
        return selectionRectangleG;
    }
    return null;
}
function setSelectedElementsWithGroup(board, elements, isShift) {
    if (!board.selection) {
        return;
    }
    const selectedElements = getSelectedElements(board);
    if (!Selection.isCollapsed(board.selection)) {
        let newElements = [...selectedElements];
        elements.forEach((item) => {
            if (!item.groupId) {
                newElements.push(item);
            }
            else {
                newElements.push(...getElementsInGroupByElement(board, item));
            }
        });
        cacheSelectedElements(board, uniqueById(newElements));
        return;
    }
    if (Selection.isCollapsed(board.selection)) {
        const hitElement = elements[0];
        const hitElementGroups = getGroupByElement(board, hitElement, true);
        if (hitElementGroups.length > 0) {
            const elementsInHighestGroup = getElementsInGroup(board, hitElementGroups[hitElementGroups.length - 1], true) || [];
            const isSelectGroupElement = selectedElements.some((element) => elementsInHighestGroup.map((item) => item.id).includes(element.id));
            if (isShift) {
                cacheSelectedElementsWithGroupOnShift(board, elements, isSelectGroupElement, elementsInHighestGroup);
            }
            else {
                cacheSelectedElementsWithGroup(board, elements, isSelectGroupElement, hitElementGroups);
            }
        }
    }
}
function cacheSelectedElementsWithGroupOnShift(board, elements, isSelectGroupElement, elementsInHighestGroup) {
    const selectedElements = getSelectedElements(board);
    let newElements = [...selectedElements];
    const hitElement = elements[0];
    let pendingElements = [];
    if (!isSelectGroupElement) {
        pendingElements = elementsInHighestGroup;
    }
    else {
        const isHitSelectedElement = selectedElements.some((item) => item.id === hitElement.id);
        const selectedElementsInGroup = elementsInHighestGroup.filter((item) => selectedElements.includes(item));
        if (isHitSelectedElement) {
            pendingElements = selectedElementsInGroup.filter((item) => item.id !== hitElement.id);
        }
        else {
            pendingElements.push(...selectedElementsInGroup, ...elements);
        }
    }
    elementsInHighestGroup.forEach((element) => {
        if (newElements.includes(element)) {
            newElements.splice(newElements.indexOf(element), 1);
        }
    });
    if (pendingElements.length) {
        newElements.push(...pendingElements);
    }
    cacheSelectedElements(board, uniqueById(newElements));
}
function cacheSelectedElementsWithGroup(board, elements, isSelectGroupElement, hitElementGroups) {
    let newElements = [...elements];
    const selectedGroups = filterSelectedGroups(board, hitElementGroups);
    if (selectedGroups.length > 0) {
        if (selectedGroups.length > 1) {
            newElements = getAllElementsInGroup(board, selectedGroups[selectedGroups.length - 2], true);
        }
        else {
            const element = board.getOneHitElement(elements);
            if (element) {
                newElements = [element];
            }
        }
    }
    else {
        const elementsInGroup = getAllElementsInGroup(board, hitElementGroups[hitElementGroups.length - 1], true);
        if (!isSelectGroupElement) {
            newElements = elementsInGroup;
        }
        else {
            const element = board.getOneHitElement(elements);
            if (element) {
                newElements = [element];
            }
        }
    }
    cacheSelectedElements(board, uniqueById(newElements));
}
const getSelectionOptions = (board) => {
    const options = board.getPluginOptions(PlaitPluginKey.withSelection);
    return options;
};
const setSelectionOptions = (board, options) => {
    board.setPluginOptions(PlaitPluginKey.withSelection, options);
};

const getElementsInGroup = (board, group, recursion, includeGroup) => {
    let result = [];
    const elements = board.children.filter(value => value.groupId === group.id);
    if (recursion) {
        elements.forEach(item => {
            if (PlaitGroupElement.isGroup(item)) {
                if (includeGroup) {
                    result.push(item);
                }
                result.push(...getElementsInGroup(board, item, recursion, includeGroup));
            }
            else {
                result.push(item);
            }
        });
    }
    else {
        result = includeGroup ? elements : elements.filter(item => !PlaitGroupElement.isGroup(item));
    }
    return result;
};
const getAllElementsInGroup = (board, group, recursion, includeGroup) => {
    const elementsInGroup = getElementsInGroup(board, group, recursion, includeGroup);
    const result = [];
    elementsInGroup.forEach(element => {
        depthFirstRecursion(element, node => {
            result.push(node);
        }, () => true);
    });
    return result;
};
const getRectangleByGroup = (board, group, recursion) => {
    const elementsInGroup = getAllElementsInGroup(board, group, recursion);
    return getRectangleByElements(board, elementsInGroup, false);
};
const getGroupByElement = (board, element, recursion, originElements) => {
    const group = (originElements || board.children).find(item => item.id === element?.groupId);
    if (!group) {
        return recursion ? [] : null;
    }
    if (recursion) {
        const groups = [group];
        const grandGroups = getGroupByElement(board, group, recursion, originElements);
        if (grandGroups.length) {
            groups.push(...grandGroups);
        }
        return groups;
    }
    else {
        return group;
    }
};
const getHighestGroup = (board, element) => {
    const hitElementGroups = getGroupByElement(board, element, true);
    if (hitElementGroups.length) {
        return hitElementGroups[hitElementGroups.length - 1];
    }
    return null;
};
const getElementsInGroupByElement = (board, element) => {
    const highestGroup = getHighestGroup(board, element);
    if (highestGroup) {
        return getAllElementsInGroup(board, highestGroup, true);
    }
    else {
        return [element];
    }
};
const isSelectedElementOrGroup = (board, element, elements) => {
    const selectedElements = elements?.length ? elements : getSelectedElements(board);
    if (PlaitGroupElement.isGroup(element)) {
        return isSelectedAllElementsInGroup(board, element, elements);
    }
    return selectedElements.map(item => item.id).includes(element.id);
};
const isSelectedAllElementsInGroup = (board, group, elements) => {
    const selectedElements = elements?.length ? elements : getSelectedElements(board);
    const elementsInGroup = getElementsInGroup(board, group, true);
    return elementsInGroup.every(item => selectedElements.map(element => element.id).includes(item.id));
};
const filterSelectedGroups = (board, groups, elements) => {
    const selectedGroups = [];
    groups.forEach(item => {
        if (isSelectedElementOrGroup(board, item, elements)) {
            selectedGroups.push(item);
        }
    });
    return selectedGroups;
};
const getSelectedGroups = (board, elements, originElements) => {
    const highestSelectedGroups = getHighestSelectedGroups(board, elements, originElements);
    const groups = [];
    highestSelectedGroups.forEach(item => {
        groups.push(item);
        const elementsInGroup = getElementsInGroup(board, item, true, true);
        groups.push(...elementsInGroup.filter(item => PlaitGroupElement.isGroup(item)));
    });
    return groups;
};
const getHighestSelectedGroup = (board, element, elements, originElements) => {
    const hitElementGroups = getGroupByElement(board, element, true, originElements);
    const selectedGroups = filterSelectedGroups(board, hitElementGroups, elements);
    if (selectedGroups.length) {
        return selectedGroups[selectedGroups.length - 1];
    }
    return null;
};
const getHighestSelectedGroups = (board, elements, originElements) => {
    let result = [];
    const selectedElements = elements?.length ? elements : getSelectedElements(board);
    selectedElements.forEach(item => {
        if (item.groupId) {
            const group = getHighestSelectedGroup(board, item, elements, originElements);
            if (group && !result.includes(group)) {
                result.push(group);
            }
        }
    });
    return result;
};
const getSelectedIsolatedElements = (board, elements) => {
    let result = [];
    const selectedElements = elements?.length ? elements : getSelectedElements(board);
    selectedElements
        .filter(item => !PlaitGroupElement.isGroup(item))
        .forEach(item => {
        if (!item.groupId) {
            result.push(item);
        }
        else {
            const group = getHighestSelectedGroup(board, item, elements);
            if (!group) {
                result.push(item);
            }
        }
    });
    return result;
};
const getSelectedIsolatedElementsCanAddToGroup = (board, elements) => {
    const selectedIsolatedElements = getSelectedIsolatedElements(board, elements);
    return selectedIsolatedElements.filter(item => board.canAddToGroup(item));
};
const getHighestSelectedElements = (board, elements) => {
    return [...getHighestSelectedGroups(board, elements), ...getSelectedIsolatedElements(board, elements)];
};
const createGroupRectangleG = (board, elements) => {
    const selectedElementIds = getSelectedElements(board).map(item => item.id);
    let groupRectangleG = null;
    const isMoving = isSelectionMoving(board);
    elements.forEach(item => {
        const isRender = (!selectedElementIds.includes(item.id) && !isMoving) || isMoving;
        if (item.groupId && isRender) {
            if (!groupRectangleG) {
                groupRectangleG = createG();
            }
            const elements = getElementsInGroupByElement(board, item);
            const rectangle = getRectangleByElements(board, elements, false);
            const rectangleG = drawRectangle(board, rectangle, {
                stroke: SELECTION_BORDER_COLOR,
                strokeWidth: ACTIVE_STROKE_WIDTH,
                strokeLineDash: [5]
            });
            const angle = getSelectionAngle(elements);
            if (angle) {
                setAngleForG(rectangleG, RectangleClient.getCenterPoint(rectangle), angle);
            }
            groupRectangleG.append(rectangleG);
        }
    });
    return groupRectangleG;
};
const createGroup = (groupId) => {
    return groupId
        ? {
            id: idCreator(),
            type: 'group',
            groupId
        }
        : {
            id: idCreator(),
            type: 'group'
        };
};
const nonGroupInHighestSelectedElements = (elements) => {
    return elements.every(item => !item.groupId);
};
const hasSelectedElementsInSameGroup = (elements) => {
    return elements.every(item => item.groupId && item.groupId === elements[0].groupId);
};
const canAddGroup = (board, elements) => {
    const highestSelectedElements = getHighestSelectedElements(board, elements);
    const rootElements = highestSelectedElements.filter(item => board.canAddToGroup(item));
    if (rootElements.length > 1) {
        return nonGroupInHighestSelectedElements(rootElements) || hasSelectedElementsInSameGroup(rootElements);
    }
    return false;
};
const canRemoveGroup = (board, elements, originElements) => {
    const selectedGroups = getHighestSelectedGroups(board, elements, originElements);
    const selectedElements = elements?.length ? elements : getSelectedElements(board);
    return selectedElements.length > 0 && selectedGroups.length > 0;
};
const getEditingGroup = (board, element) => {
    const groups = getGroupByElement(board, element, true);
    let editingGroup = null;
    if (groups?.length) {
        for (let i = 0; i < groups?.length; i++) {
            if (!isSelectedAllElementsInGroup(board, groups[i])) {
                editingGroup = groups[i];
                break;
            }
        }
    }
    return editingGroup;
};
const moveElementsToNewPathAfterAddGroup = (board, selectedElements, newPath) => {
    const moveElements = [...selectedElements];
    sortElements(board, moveElements);
    moveElements.pop();
    moveElementsToNewPath(board, moveElements.map(element => {
        return {
            element,
            newPath
        };
    }));
};

const deleteFragment = (board) => {
    const elements = board.getDeletedFragment([]);
    board.deleteFragment(elements);
};
const setFragment = (board, operationType, clipboardData) => {
    const selectedElements = getSelectedElements(board);
    const rectangle = getRectangleByElements(board, selectedElements, false);
    const clipboardContext = board.buildFragment(null, rectangle, operationType);
    clipboardContext && setClipboardData(clipboardData, clipboardContext);
};
const duplicateElements = (board, elements, point) => {
    const targetElements = elements?.length ? elements : getSelectedElements(board);
    const targetRectangle = getRectangleByElements(board, targetElements, false);
    const clipboardContext = board.buildFragment(null, targetRectangle, WritableClipboardOperationType.duplicate, targetElements);
    const stringifiedContext = clipboardContext && JSON.stringify(clipboardContext);
    const clonedContext = stringifiedContext && JSON.parse(stringifiedContext);
    clonedContext &&
        board.insertFragment({
            ...clonedContext,
            text: undefined
        }, point || [targetRectangle.x + targetRectangle.width / 2, targetRectangle.y + targetRectangle.height / 2], WritableClipboardOperationType.duplicate);
};

const SNAP_TOLERANCE = 2;
const SNAP_SPACING = 24;
function getSnapRectangles(board, activeElements) {
    const elements = findElements(board, {
        match: element => board.isAlign(element) && !activeElements.some(item => item.id === element.id),
        recursion: () => true,
        isReverse: false
    });
    return elements.map(item => {
        const rectangle = board.getRectangle(item);
        return getRectangleByAngle(rectangle, item.angle || 0);
    });
}
function getBarPoint(point, isHorizontal) {
    return isHorizontal
        ? [
            [point[0], point[1] - 4],
            [point[0], point[1] + 4]
        ]
        : [
            [point[0] - 4, point[1]],
            [point[0] + 4, point[1]]
        ];
}
function getMinPointDelta(pointRectangles, axis, isHorizontal) {
    let delta = SNAP_TOLERANCE;
    pointRectangles.forEach(item => {
        const distance = getNearestDelta(axis, item, isHorizontal);
        if (Math.abs(distance) < Math.abs(delta)) {
            delta = distance;
        }
    });
    return delta;
}
const getNearestDelta = (axis, rectangle, isHorizontal) => {
    const pointAxis = getTripleAxis(rectangle, isHorizontal);
    const deltas = pointAxis.map(item => item - axis);
    const absDeltas = deltas.map(item => Math.abs(item));
    const index = absDeltas.indexOf(Math.min(...absDeltas));
    return deltas[index];
};
const getTripleAxis = (rectangle, isHorizontal) => {
    const axis = isHorizontal ? 'x' : 'y';
    const side = isHorizontal ? 'width' : 'height';
    return [rectangle[axis], rectangle[axis] + rectangle[side] / 2, rectangle[axis] + rectangle[side]];
};
function getNearestPointRectangle(snapRectangles, activeRectangle) {
    let minDistance = Infinity;
    let nearestRectangle = snapRectangles[0];
    snapRectangles.forEach(item => {
        const distance = Math.sqrt(Math.pow(activeRectangle.x - item.x, 2) + Math.pow(activeRectangle.y - item.y, 2));
        if (distance < minDistance) {
            minDistance = distance;
            nearestRectangle = item;
        }
    });
    return nearestRectangle;
}
const isSnapPoint = (axis, rectangle, isHorizontal) => {
    const pointAxis = getTripleAxis(rectangle, isHorizontal);
    return pointAxis.includes(axis);
};
function drawPointSnapLines(board, activeRectangle, snapRectangles, drawHorizontal = true, drawVertical = true, snapMiddle = false) {
    let pointLinePoints = [];
    const pointAxisX = getTripleAxis(activeRectangle, true);
    const pointAxisY = getTripleAxis(activeRectangle, false);
    const pointLineRefs = [
        {
            axis: pointAxisX[0],
            isHorizontal: true,
            pointRectangles: []
        },
        {
            axis: pointAxisX[1],
            isHorizontal: true,
            pointRectangles: []
        },
        {
            axis: pointAxisX[2],
            isHorizontal: true,
            pointRectangles: []
        },
        {
            axis: pointAxisY[0],
            isHorizontal: false,
            pointRectangles: []
        },
        {
            axis: pointAxisY[1],
            isHorizontal: false,
            pointRectangles: []
        },
        {
            axis: pointAxisY[2],
            isHorizontal: false,
            pointRectangles: []
        }
    ];
    for (let index = 0; index < snapRectangles.length; index++) {
        const element = snapRectangles[index];
        if (isSnapPoint(pointLineRefs[0].axis, element, pointLineRefs[0].isHorizontal)) {
            pointLineRefs[0].pointRectangles.push(element);
        }
        if (isSnapPoint(pointLineRefs[1].axis, element, pointLineRefs[1].isHorizontal)) {
            pointLineRefs[1].pointRectangles.push(element);
        }
        if (isSnapPoint(pointLineRefs[2].axis, element, pointLineRefs[2].isHorizontal)) {
            pointLineRefs[2].pointRectangles.push(element);
        }
        if (isSnapPoint(pointLineRefs[3].axis, element, pointLineRefs[3].isHorizontal)) {
            pointLineRefs[3].pointRectangles.push(element);
        }
        if (isSnapPoint(pointLineRefs[4].axis, element, pointLineRefs[4].isHorizontal)) {
            pointLineRefs[4].pointRectangles.push(element);
        }
        if (isSnapPoint(pointLineRefs[5].axis, element, pointLineRefs[5].isHorizontal)) {
            pointLineRefs[5].pointRectangles.push(element);
        }
    }
    const setResizePointSnapLine = (axis, pointRectangle, isHorizontal) => {
        const boundingRectangle = RectangleClient.inflate(RectangleClient.getBoundingRectangle([activeRectangle, pointRectangle]), SNAP_SPACING);
        if (isHorizontal) {
            const pointStart = [axis, boundingRectangle.y];
            const pointEnd = [axis, boundingRectangle.y + boundingRectangle.height];
            pointLinePoints.push([pointStart, pointEnd]);
        }
        else {
            const pointStart = [boundingRectangle.x, axis];
            const pointEnd = [boundingRectangle.x + boundingRectangle.width, axis];
            pointLinePoints.push([pointStart, pointEnd]);
        }
    };
    if (drawHorizontal && pointLineRefs[0].pointRectangles.length) {
        const leftRectangle = pointLineRefs[0].pointRectangles.length === 1
            ? pointLineRefs[0].pointRectangles[0]
            : getNearestPointRectangle(pointLineRefs[0].pointRectangles, activeRectangle);
        setResizePointSnapLine(pointLineRefs[0].axis, leftRectangle, pointLineRefs[0].isHorizontal);
    }
    if (drawHorizontal && snapMiddle && pointLineRefs[1].pointRectangles.length) {
        const middleRectangle = pointLineRefs[1].pointRectangles.length === 1
            ? pointLineRefs[1].pointRectangles[0]
            : getNearestPointRectangle(pointLineRefs[1].pointRectangles, activeRectangle);
        setResizePointSnapLine(pointLineRefs[1].axis, middleRectangle, pointLineRefs[1].isHorizontal);
    }
    if (drawHorizontal && pointLineRefs[2].pointRectangles.length) {
        const rightRectangle = pointLineRefs[2].pointRectangles.length === 1
            ? pointLineRefs[2].pointRectangles[0]
            : getNearestPointRectangle(pointLineRefs[2].pointRectangles, activeRectangle);
        setResizePointSnapLine(pointLineRefs[2].axis, rightRectangle, pointLineRefs[2].isHorizontal);
    }
    if (drawVertical && pointLineRefs[3].pointRectangles.length) {
        const topRectangle = pointLineRefs[3].pointRectangles.length === 1
            ? pointLineRefs[3].pointRectangles[0]
            : getNearestPointRectangle(pointLineRefs[3].pointRectangles, activeRectangle);
        setResizePointSnapLine(pointLineRefs[3].axis, topRectangle, pointLineRefs[3].isHorizontal);
    }
    if (drawVertical && snapMiddle && pointLineRefs[4].pointRectangles.length) {
        const middleRectangle = pointLineRefs[4].pointRectangles.length === 1
            ? pointLineRefs[4].pointRectangles[0]
            : getNearestPointRectangle(pointLineRefs[4].pointRectangles, activeRectangle);
        setResizePointSnapLine(pointLineRefs[4].axis, middleRectangle, pointLineRefs[4].isHorizontal);
    }
    if (drawVertical && pointLineRefs[5].pointRectangles.length) {
        const rightRectangle = pointLineRefs[5].pointRectangles.length === 1
            ? pointLineRefs[5].pointRectangles[0]
            : getNearestPointRectangle(pointLineRefs[5].pointRectangles, activeRectangle);
        setResizePointSnapLine(pointLineRefs[5].axis, rightRectangle, pointLineRefs[5].isHorizontal);
    }
    return drawDashedLines(board, pointLinePoints);
}
function drawDashedLines(board, lines) {
    const g = createG();
    lines.forEach(points => {
        if (!points.length)
            return;
        const line = PlaitBoard.getRoughSVG(board).line(points[0][0], points[0][1], points[1][0], points[1][1], {
            stroke: SELECTION_BORDER_COLOR,
            strokeWidth: 1,
            strokeLineDash: [4, 4]
        });
        g.appendChild(line);
    });
    return g;
}
function drawSolidLines(board, lines) {
    const g = createG();
    lines.forEach(points => {
        if (!points.length)
            return;
        let isHorizontal = points[0][1] === points[1][1];
        const line = PlaitBoard.getRoughSVG(board).line(points[0][0], points[0][1], points[1][0], points[1][1], {
            stroke: SELECTION_BORDER_COLOR,
            strokeWidth: 1
        });
        g.appendChild(line);
        points.forEach(point => {
            const barPoint = getBarPoint(point, isHorizontal);
            const bar = PlaitBoard.getRoughSVG(board).line(barPoint[0][0], barPoint[0][1], barPoint[1][0], barPoint[1][1], {
                stroke: SELECTION_BORDER_COLOR,
                strokeWidth: 1
            });
            g.appendChild(bar);
        });
    });
    return g;
}

const getOneMoveOptions = (board, direction) => {
    const indicesToMove = getElementsIndices(board, getSelectedElements(board));
    let groupedIndices = toContiguousGroups(board, indicesToMove);
    if (direction === 'up') {
        groupedIndices = groupedIndices.reverse();
    }
    let moveContents = [];
    groupedIndices.forEach((indices, i) => {
        const leadingIndex = indices[0];
        const trailingIndex = indices[indices.length - 1];
        const boundaryIndex = direction === 'down' ? leadingIndex : trailingIndex;
        const targetIndex = getTargetIndex(board, boundaryIndex, direction);
        if (targetIndex === -1 || boundaryIndex === targetIndex) {
            return;
        }
        if (direction === 'down') {
            indices = indices.reverse();
        }
        moveContents.push(...indices.map(path => {
            return {
                element: board.children[path],
                newPath: [targetIndex]
            };
        }));
    });
    return moveContents;
};
const getAllMoveOptions = (board, direction) => {
    const indicesToMove = getElementsIndices(board, getSelectedElements(board));
    let groupedIndices = toContiguousGroups(board, indicesToMove);
    let moveContents = [];
    if (direction === 'down') {
        groupedIndices = groupedIndices.reverse();
    }
    groupedIndices.forEach(indices => {
        const leadingIndex = indices[0];
        const trailingIndex = indices[indices.length - 1];
        const boundaryIndex = direction === 'down' ? leadingIndex : trailingIndex;
        const sourceElement = board.children[boundaryIndex];
        const editingGroup = getEditingGroup(board, sourceElement);
        let targetIndex = direction === 'down' ? 0 : board.children.length - 1;
        if (editingGroup) {
            const elementsInGroup = sortElements(board, getElementsInGroup(board, editingGroup, true, true));
            targetIndex =
                direction === 'down'
                    ? board.children.indexOf(elementsInGroup[0])
                    : board.children.indexOf(elementsInGroup[elementsInGroup.length - 1]);
        }
        if (direction === 'down') {
            indices = indices.reverse();
        }
        moveContents.push(...indices.map(path => {
            return {
                element: board.children[path],
                newPath: [targetIndex]
            };
        }));
    });
    return moveContents;
};
const canSetZIndex = (board) => {
    const selectedElements = getSelectedElements(board).filter(item => board.canSetZIndex(item));
    return selectedElements.length > 0;
};
const toContiguousGroups = (board, array) => {
    let cursor = 0;
    return array.reduce((acc, value, index) => {
        if (index > 0) {
            const currentElement = board.children[value];
            const previousElement = board.children[array[index - 1]];
            const isContiguous = value - 1 === array[index - 1]
                ? true
                : board.children.every((item, childIndex) => {
                    if (childIndex > array[index - 1] && childIndex <= value - 1) {
                        return PlaitGroupElement.isGroup(item);
                    }
                    return true;
                });
            let isPartialSelectGroupElement = false;
            if (previousElement?.groupId || (currentElement?.groupId && previousElement?.groupId !== currentElement?.groupId)) {
                let isPartialSelectPreviousGroup = false;
                let isPartialSelectCurrentElement = false;
                if (previousElement.groupId) {
                    const highestGroup = getHighestGroup(board, previousElement);
                    isPartialSelectPreviousGroup = !isSelectedAllElementsInGroup(board, highestGroup);
                }
                if (currentElement.groupId) {
                    const highestGroup = getHighestGroup(board, currentElement);
                    isPartialSelectCurrentElement = !isSelectedAllElementsInGroup(board, highestGroup);
                }
                isPartialSelectGroupElement = isPartialSelectPreviousGroup || isPartialSelectCurrentElement;
            }
            if (!isContiguous || isPartialSelectGroupElement) {
                cursor = ++cursor;
            }
        }
        (acc[cursor] || (acc[cursor] = [])).push(value);
        return acc;
    }, []);
};
/**
 * Returns next candidate index that's available to be moved to. Currently that
 *  is a non-deleted element, and not inside a group (unless we're editing it).
 */
const getTargetIndex = (board, boundaryIndex, direction) => {
    if ((boundaryIndex === 0 && direction === 'down') || (boundaryIndex === board.children.length - 1 && direction === 'up')) {
        return -1;
    }
    const indexFilter = (element) => {
        if (element.isDeleted || PlaitGroupElement.isGroup(element)) {
            return false;
        }
        return true;
    };
    const candidateIndex = direction === 'down'
        ? findLastIndex(board.children, el => indexFilter(el), Math.max(0, boundaryIndex - 1))
        : findIndex(board.children, el => indexFilter(el), boundaryIndex + 1);
    const nextElement = board.children[candidateIndex];
    if (!nextElement) {
        return -1;
    }
    const elements = [...board.children];
    const sourceElement = elements[boundaryIndex];
    const editingGroup = getEditingGroup(board, sourceElement);
    const nextElementGroups = (getGroupByElement(board, nextElement, true) || []);
    // candidate element is a sibling in current editing group ‚Üí return
    if (editingGroup && sourceElement?.groupId !== nextElement?.groupId) {
        // candidate element is outside current editing group ‚Üí prevent
        if (!nextElementGroups.find(item => item.id === editingGroup.id)) {
            return -1;
        }
    }
    if (!nextElement.groupId) {
        return candidateIndex;
    }
    let siblingGroup;
    if (editingGroup) {
        siblingGroup = nextElementGroups[nextElementGroups.indexOf(editingGroup) - 1];
    }
    else {
        siblingGroup = nextElementGroups[nextElementGroups.length - 1];
    }
    if (siblingGroup) {
        let elementsInSiblingGroup = getElementsInGroup(board, siblingGroup, true, false);
        if (elementsInSiblingGroup.length) {
            elementsInSiblingGroup.sort((a, b) => {
                const indexA = board.children.findIndex(child => child.id === a.id);
                const indexB = board.children.findIndex(child => child.id === b.id);
                return indexA - indexB;
            });
            // assumes getElementsInGroup() returned elements are sorted
            // by zIndex (ascending)
            return direction === 'down'
                ? elements.indexOf(elementsInSiblingGroup[0])
                : elements.indexOf(elementsInSiblingGroup[elementsInSiblingGroup.length - 1]);
        }
    }
    return candidateIndex;
};

const isMobileDeviceEvent = (event) => {
    return isPencilEvent(event) || isTouchEvent(event);
};
const isPencilEvent = (event) => {
    return event.pointerType === 'pen';
};
const isTouchEvent = (event) => {
    return event.pointerType === 'touch';
};
const isMouseEvent = (event) => {
    return event.pointerType === 'mouse';
};

const addGroup = (board, elements) => {
    const selectedGroups = getHighestSelectedGroups(board, elements);
    const selectedIsolatedElements = getSelectedIsolatedElementsCanAddToGroup(board);
    const highestSelectedElements = [...selectedGroups, ...selectedIsolatedElements];
    const group = createGroup();
    if (canAddGroup(board)) {
        highestSelectedElements.forEach(item => {
            const path = PlaitBoard.findPath(board, item);
            NodeTransforms.setNode(board, { groupId: group.id }, path);
        });
        const selectedElements = getSelectedElements(board);
        const highestIndexOfSelectedElement = getHighestIndexOfElement(board, selectedElements);
        const indices = getElementsIndices(board, highestSelectedElements);
        const isContinuous = isIndicesContinuous(indices);
        if (!isContinuous) {
            moveElementsToNewPathAfterAddGroup(board, selectedElements, [highestIndexOfSelectedElement - 1]);
        }
        if (hasSelectedElementsInSameGroup(highestSelectedElements)) {
            const newGroupId = selectedIsolatedElements[0].groupId;
            NodeTransforms.insertNode(board, {
                ...group,
                groupId: newGroupId
            }, [board.children.length]);
        }
        else {
            NodeTransforms.insertNode(board, group, [board.children.length]);
        }
    }
};
const removeGroup = (board, elements) => {
    const selectedGroups = getHighestSelectedGroups(board, elements);
    if (canRemoveGroup(board)) {
        selectedGroups.forEach(group => {
            const elementsInGroup = findElements(board, {
                match: item => item.groupId === group.id,
                recursion: () => false
            });
            elementsInGroup.forEach(element => {
                const path = PlaitBoard.findPath(board, element);
                NodeTransforms.setNode(board, { groupId: group.groupId || undefined }, path);
            });
        });
        selectedGroups
            .map(group => {
            const groupPath = PlaitBoard.findPath(board, group);
            const groupRef = board.pathRef(groupPath);
            return () => {
                groupRef.current && NodeTransforms.removeNode(board, groupRef.current);
                groupRef.unref();
            };
        })
            .forEach(action => {
            action();
        });
    }
};
const GroupTransforms = {
    addGroup,
    removeGroup
};

function setSelection(board, selection) {
    const operation = { type: 'set_selection', properties: board.selection, newProperties: selection };
    board.apply(operation);
}
const SelectionTransforms = {
    setSelection,
    addSelectionWithTemporaryElements
};
function addSelectionWithTemporaryElements(board, elements) {
    const timeoutId = setTimeout(() => {
        setSelection(board, { anchor: [0, 0], focus: [0, 0] });
    }, 0);
    let ref = getTemporaryRef(board);
    if (ref) {
        clearTimeout(ref.timeoutId);
        const currentElements = ref.elements;
        ref.elements.push(...elements.filter(element => !currentElements.includes(element)));
        ref.timeoutId = timeoutId;
    }
    else {
        BOARD_TO_TEMPORARY_ELEMENTS.set(board, { timeoutId, elements });
    }
}

const moveToTop = (board) => {
    const moveOptions = getAllMoveOptions(board, 'up');
    moveElementsToNewPath(board, moveOptions);
};
const moveToBottom = (board) => {
    const moveOptions = getAllMoveOptions(board, 'down');
    moveElementsToNewPath(board, moveOptions);
};
const moveUp = (board) => {
    const moveOptions = getOneMoveOptions(board, 'up');
    moveElementsToNewPath(board, moveOptions);
};
const moveDown = (board) => {
    const moveOptions = getOneMoveOptions(board, 'down');
    moveElementsToNewPath(board, moveOptions);
};
const ZIndexTransforms = { moveUp, moveDown, moveToTop, moveToBottom };

const removeElements = (board, elements) => {
    elements
        .map(element => {
        const path = PlaitBoard.findPath(board, element);
        const ref = board.pathRef(path);
        return () => {
            ref.current && removeNode(board, ref.current);
            ref.unref();
            removeSelectedElement(board, element, true);
        };
    })
        .forEach(action => {
        action();
    });
};
const CoreTransforms = {
    removeElements
};

const Transforms = {
    ...GeneralTransforms,
    ...ViewportTransforms$1,
    ...SelectionTransforms,
    ...NodeTransforms,
    ...GroupTransforms,
    ...ZIndexTransforms
};

const rotatePoints = (points, centerPoint, angle) => {
    if (!angle) {
        angle = 0;
    }
    if (Array.isArray(points) && typeof points[0] === 'number') {
        return rotate(points[0], points[1], centerPoint[0], centerPoint[1], angle);
    }
    else {
        return points.map((point) => {
            return rotate(point[0], point[1], centerPoint[0], centerPoint[1], angle || 0);
        });
    }
};
const getSelectionAngle = (elements) => {
    let angle = elements[0]?.angle || 0;
    elements.forEach((item) => {
        if (item.angle !== angle && !approximately(((item.angle || 0) % (Math.PI / 2)) - (angle % (Math.PI / 2)), 0)) {
            angle = 0;
        }
    });
    return angle;
};
const hasSameAngle = (elements) => {
    if (!elements.length) {
        return false;
    }
    const angle = elements[0].angle;
    if (angle === undefined) {
        return false;
    }
    return !elements.some((item) => item.angle !== angle);
};
const getRotatedBoundingRectangle = (rectanglesCornerPoints, angle) => {
    let rectanglesFromOrigin = [];
    for (let i = 0; i < rectanglesCornerPoints.length; i++) {
        const cornerPoints = rectanglesCornerPoints[i];
        const invertCornerPointsFromOrigin = rotatePoints(cornerPoints, [0, 0], -angle);
        rectanglesFromOrigin.push(RectangleClient.getRectangleByPoints(invertCornerPointsFromOrigin));
    }
    const selectionRectangleFromOrigin = RectangleClient.getBoundingRectangle(rectanglesFromOrigin);
    const selectionCornerPoints = RectangleClient.getCornerPoints(selectionRectangleFromOrigin);
    const cornerPointsFromOrigin = rotatePoints(selectionCornerPoints, [0, 0], angle);
    const centerPoint = RectangleClient.getCenterPoint(RectangleClient.getRectangleByPoints(cornerPointsFromOrigin));
    return RectangleClient.getRectangleByPoints(rotatePoints(cornerPointsFromOrigin, centerPoint, -angle));
};
const getOffsetAfterRotate = (rectangle, rotateCenterPoint, angle) => {
    const targetCenterPoint = RectangleClient.getCenterPoint(rectangle);
    const [rotatedCenterPoint] = rotatePoints([targetCenterPoint], rotateCenterPoint, angle);
    const offsetX = rotatedCenterPoint[0] - targetCenterPoint[0];
    const offsetY = rotatedCenterPoint[1] - targetCenterPoint[1];
    return { offsetX, offsetY };
};
const rotatedDataPoints = (points, rotateCenterPoint, angle) => {
    const { offsetX, offsetY } = getOffsetAfterRotate(RectangleClient.getRectangleByPoints(points), rotateCenterPoint, angle);
    return points.map((p) => [p[0] + offsetX, p[1] + offsetY]);
};
const hasValidAngle = (node) => {
    return isValidAngle(node.angle);
};
const isValidAngle = (angle) => {
    return angle && angle !== 0;
};
const rotatePointsByElement = (points, element) => {
    if (hasValidAngle(element)) {
        let rectangle = RectangleClient.getRectangleByPoints(element.points);
        const centerPoint = RectangleClient.getCenterPoint(rectangle);
        return rotatePoints(points, centerPoint, element.angle);
    }
    else {
        return null;
    }
};
const rotatePointsByAngle = (points, angle) => {
    if (isValidAngle(angle)) {
        let rectangle = RectangleClient.getRectangleByPoints(points);
        const centerPoint = RectangleClient.getCenterPoint(rectangle);
        return rotatePoints(points, centerPoint, angle);
    }
    else {
        return null;
    }
};
const rotateAntiPointsByElement = (board, points, element, isToActive = false) => {
    if (hasValidAngle(element)) {
        let rectangle = RectangleClient.getRectangleByPoints(element.points);
        const activeRectangle = isToActive ? toActiveRectangleFromViewBoxRectangle(board, rectangle) : rectangle;
        const centerPoint = RectangleClient.getCenterPoint(activeRectangle);
        return rotatePoints(points, centerPoint, element.angle ? -element.angle : 0);
    }
    else {
        return null;
    }
};
const getRectangleByAngle = (rectangle, angle) => {
    if (angle) {
        const cornerPoints = RectangleClient.getCornerPoints(rectangle);
        const centerPoint = RectangleClient.getCenterPoint(rectangle);
        return RectangleClient.getRectangleByPoints(rotatePoints(cornerPoints, centerPoint, angle));
    }
    return rectangle;
};
const isAxisChangedByAngle = (angle) => {
    const unitAngle = Math.abs(angle) % Math.PI;
    return unitAngle >= (1 / 4) * Math.PI && unitAngle <= (3 / 4) * Math.PI;
};
function degreesToRadians(d) {
    return (d / 180) * Math.PI;
}
function radiansToDegrees(r) {
    return (r / Math.PI) * 180;
}
function rotateElements(board, elements, angle) {
    const selectionRectangle = getRectangleByElements(board, elements, false);
    const selectionCenterPoint = RectangleClient.getCenterPoint(selectionRectangle);
    elements.forEach((item) => {
        const originAngle = item.angle;
        const points = rotatedDataPoints(item.points, selectionCenterPoint, normalizeAngle(angle));
        const path = PlaitBoard.findPath(board, item);
        Transforms.setNode(board, { points, angle: normalizeAngle((originAngle || 0) + angle) }, path);
    });
}
const normalizeAngle = (angle) => {
    if (angle < 0) {
        return angle + 2 * Math.PI;
    }
    if (angle >= 2 * Math.PI) {
        return angle - 2 * Math.PI;
    }
    return angle;
};
const getAngleBetweenPoints = (startPoint, endPoint, centerPoint) => {
    const startAngle = (5 * Math.PI) / 2 + Math.atan2(startPoint[1] - centerPoint[1], startPoint[0] - centerPoint[0]);
    const endAngle = (5 * Math.PI) / 2 + Math.atan2(endPoint[1] - centerPoint[1], endPoint[0] - centerPoint[0]);
    return normalizeAngle(endAngle - startAngle);
};
const getAngleByElement = (element) => {
    return element?.angle;
};
const setAngleForG = (g, centerPoint, angle) => {
    if (angle === 0) {
        g.removeAttribute('transform');
        return;
    }
    var centerX = centerPoint[0];
    var centerY = centerPoint[1];
    let cosTheta = Math.cos(angle);
    let sinTheta = Math.sin(angle);
    let transformMatrix = [
        cosTheta,
        sinTheta,
        -sinTheta,
        cosTheta,
        centerX * (1 - cosTheta) + centerY * sinTheta,
        centerY * (1 - cosTheta) - centerX * sinTheta
    ];
    let matrix = 'matrix(' + transformMatrix.join(',') + ')';
    g.setAttribute('transform', `${matrix}`);
};

function getRectangleByElements(board, elements, recursion) {
    const rectanglesCornerPoints = [];
    const callback = (node) => {
        const nodeRectangle = board.getRectangle(node);
        if (nodeRectangle) {
            const cornerPoints = RectangleClient.getCornerPoints(nodeRectangle);
            const rotatedCornerPoints = rotatePointsByElement(cornerPoints, node) || cornerPoints;
            rectanglesCornerPoints.push(rotatedCornerPoints);
        }
        else {
            console.error(`can not get rectangle of element:`, node);
        }
    };
    elements.forEach(element => {
        if (recursion) {
            depthFirstRecursion(element, node => callback(node), node => board.isRecursion(node));
        }
        else {
            callback(element);
        }
    });
    if (rectanglesCornerPoints.length > 0) {
        if (hasSameAngle(elements)) {
            const angle = getSelectionAngle(elements);
            return getRotatedBoundingRectangle(rectanglesCornerPoints, angle);
        }
        else {
            const flatCornerPoints = rectanglesCornerPoints.reduce((acc, val) => {
                return acc.concat(val);
            }, []);
            return RectangleClient.getRectangleByPoints(flatCornerPoints);
        }
    }
    else {
        return {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        };
    }
}
function getBoundingRectangleByElements(board, elements, recursion) {
    const rectangle = getRectangleByElements(board, elements, recursion);
    const angle = getSelectionAngle(elements);
    return getRectangleByAngle(rectangle, angle);
}
function getBoardRectangle(board) {
    return getRectangleByElements(board, board.children, true);
}
function getElementById(board, id, dataSource) {
    const cachedElement = !dataSource && getElementMap(board).get(id);
    if (cachedElement) {
        return cachedElement;
    }
    if (!dataSource) {
        dataSource = findElements(board, { match: element => true, recursion: element => true });
    }
    let element = dataSource.find(element => element.id === id);
    return element;
}
function getElementMap(board) {
    const elementMap = KEY_TO_ELEMENT_MAP.get(board);
    if (!elementMap) {
        throw new Error('can not resolve element map');
    }
    return elementMap;
}
function findElements(board, options) {
    let elements = [];
    const isReverse = options.isReverse ?? true;
    depthFirstRecursion(board, node => {
        if (!PlaitBoard.isBoard(node) && options.match(node)) {
            elements.push(node);
        }
    }, (value) => {
        if (PlaitBoard.isBoard(value)) {
            return true;
        }
        else {
            return getIsRecursionFunc(board)(value) && options.recursion(value);
        }
    }, isReverse);
    return elements;
}

var ThemeColorMode;
(function (ThemeColorMode) {
    ThemeColorMode["default"] = "default";
    ThemeColorMode["colorful"] = "colorful";
    ThemeColorMode["soft"] = "soft";
    ThemeColorMode["retro"] = "retro";
    ThemeColorMode["dark"] = "dark";
    ThemeColorMode["starry"] = "starry";
})(ThemeColorMode || (ThemeColorMode = {}));
const DEFAULT_COLOR = '#333333';
const DefaultThemeColor = {
    mode: ThemeColorMode.default,
    boardBackground: '#ffffff',
    textColor: DEFAULT_COLOR
};
const ColorfulThemeColor = {
    mode: ThemeColorMode.colorful,
    boardBackground: '#ffffff',
    textColor: DEFAULT_COLOR
};
const SoftThemeColor = {
    mode: ThemeColorMode.soft,
    boardBackground: '#f5f5f5',
    textColor: DEFAULT_COLOR
};
const RetroThemeColor = {
    mode: ThemeColorMode.retro,
    boardBackground: '#f9f8ed',
    textColor: DEFAULT_COLOR
};
const DarkThemeColor = {
    mode: ThemeColorMode.dark,
    boardBackground: '#141414',
    textColor: '#FFFFFF'
};
const StarryThemeColor = {
    mode: ThemeColorMode.starry,
    boardBackground: '#0d2537',
    textColor: '#FFFFFF'
};
const ThemeColors = [
    DefaultThemeColor,
    ColorfulThemeColor,
    SoftThemeColor,
    RetroThemeColor,
    DarkThemeColor,
    StarryThemeColor
];

const PlaitBoard = {
    isBoard(value) {
        const cachedIsBoard = IS_BOARD_CACHE.get(value);
        if (cachedIsBoard !== undefined) {
            return cachedIsBoard;
        }
        const isBoard = typeof value.onChange === 'function' && typeof value.apply === 'function';
        IS_BOARD_CACHE.set(value, isBoard);
        return isBoard;
    },
    isAlive(board) {
        const isAlive = IS_BOARD_ALIVE.get(board);
        return !!isAlive;
    },
    findPath(board, node) {
        const path = [];
        let child = node;
        while (true) {
            const parent = NODE_TO_PARENT.get(child);
            if (parent == null) {
                if (PlaitBoard.isBoard(child)) {
                    return path;
                }
                else {
                    break;
                }
            }
            const i = NODE_TO_INDEX.get(child);
            if (i == null) {
                break;
            }
            path.unshift(i);
            child = parent;
        }
        throw new Error(`Unable to find the path for Plait node: ${JSON.stringify(node)}`);
    },
    getHost(board) {
        return BOARD_TO_HOST.get(board);
    },
    getElementLowerHost(board) {
        return BOARD_TO_ELEMENT_HOST.get(board)?.lowerHost;
    },
    getElementHost(board) {
        return BOARD_TO_ELEMENT_HOST.get(board)?.host;
    },
    getElementUpperHost(board) {
        return BOARD_TO_ELEMENT_HOST.get(board)?.upperHost;
    },
    getElementTopHost(board) {
        return BOARD_TO_ELEMENT_HOST.get(board)?.topHost;
    },
    getActiveHost(board) {
        return BOARD_TO_ELEMENT_HOST.get(board)?.activeHost;
    },
    getRoughSVG(board) {
        return BOARD_TO_ROUGH_SVG.get(board);
    },
    getBoardContainer(board) {
        return BOARD_TO_ELEMENT_HOST.get(board)?.container;
    },
    getBoardContext(board) {
        return BOARD_TO_CONTEXT.get(board);
    },
    getRectangle(board) {
        return getRectangleByElements(board, board.children, true);
    },
    getViewportContainer(board) {
        return BOARD_TO_ELEMENT_HOST.get(board)?.viewportContainer;
    },
    isFocus(board) {
        return !!board.selection;
    },
    isReadonly(board) {
        return board.options.readonly;
    },
    hasBeenTextEditing(board) {
        return !!IS_TEXT_EDITABLE.get(board);
    },
    getPointer(board) {
        return board.pointer;
    },
    isPointer(board, pointer) {
        return board.pointer === pointer;
    },
    isInPointer(board, pointers) {
        const point = board.pointer;
        return pointers.includes(point);
    },
    getMovingPointInBoard(board) {
        return BOARD_TO_MOVING_POINT_IN_BOARD.get(board);
    },
    isMovingPointInBoard(board) {
        const point = BOARD_TO_MOVING_POINT.get(board);
        const rect = PlaitBoard.getBoardContainer(board).getBoundingClientRect();
        if (point && distanceBetweenPointAndRectangle(point[0], point[1], rect) === 0) {
            return true;
        }
        return false;
    },
    getThemeColors(board) {
        return (board.options.themeColors || ThemeColors);
    }
};

var PlaitPointerType;
(function (PlaitPointerType) {
    PlaitPointerType["hand"] = "hand";
    PlaitPointerType["selection"] = "selection";
})(PlaitPointerType || (PlaitPointerType = {}));

/**
 * Extendable Custom Types Interface
 */

const isSetViewportOperation = (value) => {
    return value.type === 'set_viewport';
};
const isSetSelectionOperation = (value) => {
    return value.type === 'set_selection';
};
const isSetThemeOperation = (value) => {
    return value.type === 'set_theme';
};
const inverse = (op) => {
    switch (op.type) {
        case 'insert_node': {
            return { ...op, type: 'remove_node' };
        }
        case 'remove_node': {
            return { ...op, type: 'insert_node' };
        }
        case 'move_node': {
            const { newPath, path } = op;
            // PERF: in this case the move operation is a no-op anyways.
            if (Path.equals(newPath, path)) {
                return op;
            }
            // when operation path is [0,0] -> [0,2], should exec Path.transform to get [0,1] -> [0,0]
            // shoud not return [0,2] -> [0,0] #WIK-8981
            // if (Path.isSibling(path, newPath)) {
            //     return { ...op, path: newPath, newPath: path };
            // }
            // If the move does not happen within a single parent it is possible
            // for the move to impact the true path to the location where the node
            // was removed from and where it was inserted. We have to adjust for this
            // and find the original path. We can accomplish this (only in non-sibling)
            // moves by looking at the impact of the move operation on the node
            // after the original move path.
            const inversePath = Path.transform(path, op);
            const inverseNewPath = Path.transform(Path.next(path), op);
            return { ...op, path: inversePath, newPath: inverseNewPath };
        }
        case 'set_node': {
            const { properties, newProperties } = op;
            return { ...op, properties: newProperties, newProperties: properties };
        }
        case 'set_selection': {
            const { properties, newProperties } = op;
            if (properties == null) {
                return {
                    ...op,
                    properties: newProperties,
                    newProperties: null
                };
            }
            else if (newProperties == null) {
                return {
                    ...op,
                    properties: null,
                    newProperties: properties
                };
            }
            else {
                return { ...op, properties: newProperties, newProperties: properties };
            }
        }
        case 'set_viewport': {
            const { properties, newProperties } = op;
            if (properties == null) {
                return {
                    ...op,
                    properties: newProperties,
                    newProperties: newProperties
                };
            }
            else if (newProperties == null) {
                return {
                    ...op,
                    properties: properties,
                    newProperties: properties
                };
            }
            else {
                return { ...op, properties: newProperties, newProperties: properties };
            }
        }
        case 'set_theme': {
            const { properties, newProperties } = op;
            return { ...op, properties: newProperties, newProperties: properties };
        }
    }
};
const PlaitOperation = {
    isSetViewportOperation,
    isSetSelectionOperation,
    isSetThemeOperation,
    inverse
};

const Point = {
    isEquals(point, otherPoint) {
        return point && otherPoint && point[0] === otherPoint[0] && point[1] === otherPoint[1];
    },
    isHorizontal(point, otherPoint, tolerance = 0) {
        return point && otherPoint && Point.isOverHorizontal([point, otherPoint], tolerance);
    },
    isOverHorizontal(points, tolerance = 0) {
        return points.every(point => Math.abs(point[1] - points[0][1]) <= tolerance);
    },
    isVertical(point, otherPoint, tolerance = 0) {
        return point && otherPoint && Point.isOverVertical([point, otherPoint], tolerance);
    },
    isOverVertical(points, tolerance = 0) {
        return points.every(point => Math.abs(point[0] - points[0][0]) <= tolerance);
    },
    isAlign(points, tolerance = 0) {
        return Point.isOverHorizontal(points, tolerance) || Point.isOverVertical(points, tolerance);
    },
    getOffsetX(point1, point2) {
        return point2[0] - point1[0];
    },
    getOffsetY(point1, point2) {
        return point2[1] - point1[1];
    }
};

const SAVING = new WeakMap();
const MERGING = new WeakMap();
const HISTORY = new WeakMap();
const SPLITTING_ONCE = new WeakMap();

var Direction;
(function (Direction) {
    Direction["left"] = "left";
    Direction["top"] = "top";
    Direction["right"] = "right";
    Direction["bottom"] = "bottom";
})(Direction || (Direction = {}));
const isHorizontalDirection = (direction) => {
    return direction === Direction.left || direction === Direction.right;
};
const isVerticalDirection = (direction) => {
    return !isHorizontalDirection(direction);
};

const PlaitGroupElement = {
    isGroup: (value) => {
        return value.type === 'group';
    }
};

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function isListLikeIterable(obj) {
    if (!isJsObject(obj))
        return false;
    return (Array.isArray(obj) ||
        (!(obj instanceof Map) && // JS Map are iterables but return entries as [k, v]
            Symbol.iterator in obj)); // JS Iterable have a Symbol.iterator prop
}
function isJsObject(o) {
    return o !== null && (typeof o === 'function' || typeof o === 'object');
}
function iterateListLike(obj, fn) {
    if (Array.isArray(obj)) {
        for (let i = 0; i < obj.length; i++) {
            fn(obj[i]);
        }
    }
    else {
        const iterator = obj[Symbol.iterator]();
        let item;
        while (!(item = iterator.next()).done) {
            fn(item.value);
        }
    }
}

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const trackByIdentity = (index, item) => item;
class DefaultIterableDiffer {
    constructor(trackByFn) {
        this.length = 0;
        // Keeps track of the used records at any point in time (during & across `_check()` calls)
        this._linkedRecords = null;
        // Keeps track of the removed records at any point in time during `_check()` calls.
        this._unlinkedRecords = null;
        this._previousItHead = null;
        this._itHead = null;
        this._itTail = null;
        this._additionsHead = null;
        this._additionsTail = null;
        this._movesHead = null;
        this._movesTail = null;
        this._removalsHead = null;
        this._removalsTail = null;
        // Keeps track of records where custom track by is the same, but item identity has changed
        this._identityChangesHead = null;
        this._identityChangesTail = null;
        this._trackByFn = trackByFn || trackByIdentity;
    }
    forEachItem(fn) {
        let record;
        for (record = this._itHead; record !== null; record = record._next) {
            fn(record);
        }
    }
    forEachOperation(fn) {
        let nextIt = this._itHead;
        let nextRemove = this._removalsHead;
        let addRemoveOffset = 0;
        let moveOffsets = null;
        while (nextIt || nextRemove) {
            // Figure out which is the next record to process
            // Order: remove, add, move
            const record = !nextRemove ||
                nextIt &&
                    nextIt.currentIndex <
                        getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ?
                nextIt :
                nextRemove;
            const adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
            const currentIndex = record.currentIndex;
            // consume the item, and adjust the addRemoveOffset and update moveDistance if necessary
            if (record === nextRemove) {
                addRemoveOffset--;
                nextRemove = nextRemove._nextRemoved;
            }
            else {
                nextIt = nextIt._next;
                if (record.previousIndex == null) {
                    addRemoveOffset++;
                }
                else {
                    // INVARIANT:  currentIndex < previousIndex
                    if (!moveOffsets)
                        moveOffsets = [];
                    const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
                    const localCurrentIndex = currentIndex - addRemoveOffset;
                    if (localMovePreviousIndex != localCurrentIndex) {
                        for (let i = 0; i < localMovePreviousIndex; i++) {
                            const offset = i < moveOffsets.length ? moveOffsets[i] : (moveOffsets[i] = 0);
                            const index = offset + i;
                            if (localCurrentIndex <= index && index < localMovePreviousIndex) {
                                moveOffsets[i] = offset + 1;
                            }
                        }
                        const previousIndex = record.previousIndex;
                        moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
                    }
                }
            }
            if (adjPreviousIndex !== currentIndex) {
                fn(record, adjPreviousIndex, currentIndex);
            }
        }
    }
    forEachPreviousItem(fn) {
        let record;
        for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
            fn(record);
        }
    }
    forEachAddedItem(fn) {
        let record;
        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
            fn(record);
        }
    }
    forEachMovedItem(fn) {
        let record;
        for (record = this._movesHead; record !== null; record = record._nextMoved) {
            fn(record);
        }
    }
    forEachRemovedItem(fn) {
        let record;
        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
            fn(record);
        }
    }
    forEachIdentityChange(fn) {
        let record;
        for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
            fn(record);
        }
    }
    diff(collection) {
        if (collection == null)
            collection = [];
        if (!isListLikeIterable(collection)) {
            throw new Error('Exception: Error trying to diff. Only arrays and iterables are allowed');
        }
        if (this.check(collection)) {
            return this;
        }
        else {
            return null;
        }
    }
    onDestroy() { }
    check(collection) {
        this._reset();
        let record = this._itHead;
        let mayBeDirty = false;
        let index;
        let item;
        let itemTrackBy;
        if (Array.isArray(collection)) {
            this.length = collection.length;
            for (let index = 0; index < this.length; index++) {
                item = collection[index];
                itemTrackBy = this._trackByFn(index, item);
                if (record === null || !Object.is(record.trackById, itemTrackBy)) {
                    record = this._mismatch(record, item, itemTrackBy, index);
                    mayBeDirty = true;
                }
                else {
                    if (mayBeDirty) {
                        record = this._verifyReinsertion(record, item, itemTrackBy, index);
                    }
                    if (!Object.is(record.item, item))
                        this._addIdentityChange(record, item);
                }
                record = record._next;
            }
        }
        else {
            index = 0;
            iterateListLike(collection, (item) => {
                itemTrackBy = this._trackByFn(index, item);
                if (record === null || !Object.is(record.trackById, itemTrackBy)) {
                    record = this._mismatch(record, item, itemTrackBy, index);
                    mayBeDirty = true;
                }
                else {
                    if (mayBeDirty) {
                        record = this._verifyReinsertion(record, item, itemTrackBy, index);
                    }
                    if (!Object.is(record.item, item))
                        this._addIdentityChange(record, item);
                }
                record = record._next;
                index++;
            });
            this.length = index;
        }
        this._truncate(record);
        this.collection = collection;
        return this.isDirty;
    }
    /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity
     * changes.
     */
    get isDirty() {
        return this._additionsHead !== null || this._movesHead !== null ||
            this._removalsHead !== null || this._identityChangesHead !== null;
    }
    /**
     * Reset the state of the change objects to show no changes. This means set previousKey to
     * currentKey, and clear all of the queues (additions, moves, removals).
     * Set the previousIndexes of moved and added items to their currentIndexes
     * Reset the list of additions, moves and removals
     *
     * @internal
     */
    _reset() {
        if (this.isDirty) {
            let record;
            for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
                record._nextPrevious = record._next;
            }
            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                record.previousIndex = record.currentIndex;
            }
            this._additionsHead = this._additionsTail = null;
            for (record = this._movesHead; record !== null; record = record._nextMoved) {
                record.previousIndex = record.currentIndex;
            }
            this._movesHead = this._movesTail = null;
            this._removalsHead = this._removalsTail = null;
            this._identityChangesHead = this._identityChangesTail = null;
        }
    }
    /**
     * This is the core function which handles differences between collections.
     *
     * - `record` is the record which we saw at this position last time. If null then it is a new
     *   item.
     * - `item` is the current item in the collection
     * - `index` is the position of the item in the collection
     *
     * @internal
     */
    _mismatch(record, item, itemTrackBy, index) {
        // The previous record after which we will append the current one.
        let previousRecord;
        if (record === null) {
            previousRecord = this._itTail;
        }
        else {
            previousRecord = record._prev;
            // Remove the record from the collection since we know it does not match the item.
            this._remove(record);
        }
        // See if we have evicted the item, which used to be at some anterior position of _itHead list.
        record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
        if (record !== null) {
            // It is an item which we have evicted earlier: reinsert it back into the list.
            // But first we need to check if identity changed, so we can update in view if necessary.
            if (!Object.is(record.item, item))
                this._addIdentityChange(record, item);
            this._reinsertAfter(record, previousRecord, index);
        }
        else {
            // Attempt to see if the item is at some posterior position of _itHead list.
            record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
            if (record !== null) {
                // We have the item in _itHead at/after `index` position. We need to move it forward in the
                // collection.
                // But first we need to check if identity changed, so we can update in view if necessary.
                if (!Object.is(record.item, item))
                    this._addIdentityChange(record, item);
                this._moveAfter(record, previousRecord, index);
            }
            else {
                // It is a new item: add it.
                record =
                    this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index);
            }
        }
        return record;
    }
    /**
     * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
     *
     * Use case: `[a, a]` => `[b, a, a]`
     *
     * If we did not have this check then the insertion of `b` would:
     *   1) evict first `a`
     *   2) insert `b` at `0` index.
     *   3) leave `a` at index `1` as is. <-- this is wrong!
     *   3) reinsert `a` at index 2. <-- this is wrong!
     *
     * The correct behavior is:
     *   1) evict first `a`
     *   2) insert `b` at `0` index.
     *   3) reinsert `a` at index 1.
     *   3) move `a` at from `1` to `2`.
     *
     *
     * Double check that we have not evicted a duplicate item. We need to check if the item type may
     * have already been removed:
     * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
     * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
     * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
     * at the end.
     *
     * @internal
     */
    _verifyReinsertion(record, item, itemTrackBy, index) {
        let reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
        if (reinsertRecord !== null) {
            record = this._reinsertAfter(reinsertRecord, record._prev, index);
        }
        else if (record.currentIndex != index) {
            record.currentIndex = index;
            this._addToMoves(record, index);
        }
        return record;
    }
    /**
     * Get rid of any excess {@link IterableChangeRecord_}s from the previous collection
     *
     * - `record` The first excess {@link IterableChangeRecord_}.
     *
     * @internal
     */
    _truncate(record) {
        // Anything after that needs to be removed;
        while (record !== null) {
            const nextRecord = record._next;
            this._addToRemovals(this._unlink(record));
            record = nextRecord;
        }
        if (this._unlinkedRecords !== null) {
            this._unlinkedRecords.clear();
        }
        if (this._additionsTail !== null) {
            this._additionsTail._nextAdded = null;
        }
        if (this._movesTail !== null) {
            this._movesTail._nextMoved = null;
        }
        if (this._itTail !== null) {
            this._itTail._next = null;
        }
        if (this._removalsTail !== null) {
            this._removalsTail._nextRemoved = null;
        }
        if (this._identityChangesTail !== null) {
            this._identityChangesTail._nextIdentityChange = null;
        }
    }
    /** @internal */
    _reinsertAfter(record, prevRecord, index) {
        if (this._unlinkedRecords !== null) {
            this._unlinkedRecords.remove(record);
        }
        const prev = record._prevRemoved;
        const next = record._nextRemoved;
        if (prev === null) {
            this._removalsHead = next;
        }
        else {
            prev._nextRemoved = next;
        }
        if (next === null) {
            this._removalsTail = prev;
        }
        else {
            next._prevRemoved = prev;
        }
        this._insertAfter(record, prevRecord, index);
        this._addToMoves(record, index);
        return record;
    }
    /** @internal */
    _moveAfter(record, prevRecord, index) {
        this._unlink(record);
        this._insertAfter(record, prevRecord, index);
        this._addToMoves(record, index);
        return record;
    }
    /** @internal */
    _addAfter(record, prevRecord, index) {
        this._insertAfter(record, prevRecord, index);
        if (this._additionsTail === null) {
            // assert(this._additionsHead === null);
            this._additionsTail = this._additionsHead = record;
        }
        else {
            // assert(_additionsTail._nextAdded === null);
            // assert(record._nextAdded === null);
            this._additionsTail = this._additionsTail._nextAdded = record;
        }
        return record;
    }
    /** @internal */
    _insertAfter(record, prevRecord, index) {
        const next = prevRecord === null ? this._itHead : prevRecord._next;
        record._next = next;
        record._prev = prevRecord;
        if (next === null) {
            this._itTail = record;
        }
        else {
            next._prev = record;
        }
        if (prevRecord === null) {
            this._itHead = record;
        }
        else {
            prevRecord._next = record;
        }
        if (this._linkedRecords === null) {
            this._linkedRecords = new _DuplicateMap();
        }
        this._linkedRecords.put(record);
        record.currentIndex = index;
        return record;
    }
    /** @internal */
    _remove(record) {
        return this._addToRemovals(this._unlink(record));
    }
    /** @internal */
    _unlink(record) {
        if (this._linkedRecords !== null) {
            this._linkedRecords.remove(record);
        }
        const prev = record._prev;
        const next = record._next;
        if (prev === null) {
            this._itHead = next;
        }
        else {
            prev._next = next;
        }
        if (next === null) {
            this._itTail = prev;
        }
        else {
            next._prev = prev;
        }
        return record;
    }
    /** @internal */
    _addToMoves(record, toIndex) {
        if (record.previousIndex === toIndex) {
            return record;
        }
        if (this._movesTail === null) {
            this._movesTail = this._movesHead = record;
        }
        else {
            this._movesTail = this._movesTail._nextMoved = record;
        }
        return record;
    }
    _addToRemovals(record) {
        if (this._unlinkedRecords === null) {
            this._unlinkedRecords = new _DuplicateMap();
        }
        this._unlinkedRecords.put(record);
        record.currentIndex = null;
        record._nextRemoved = null;
        if (this._removalsTail === null) {
            this._removalsTail = this._removalsHead = record;
            record._prevRemoved = null;
        }
        else {
            record._prevRemoved = this._removalsTail;
            this._removalsTail = this._removalsTail._nextRemoved = record;
        }
        return record;
    }
    /** @internal */
    _addIdentityChange(record, item) {
        record.item = item;
        if (this._identityChangesTail === null) {
            this._identityChangesTail = this._identityChangesHead = record;
        }
        else {
            this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
        }
        return record;
    }
}
class IterableChangeRecord_ {
    constructor(item, trackById) {
        this.item = item;
        this.trackById = trackById;
        this.currentIndex = null;
        this.previousIndex = null;
        /** @internal */
        this._nextPrevious = null;
        /** @internal */
        this._prev = null;
        /** @internal */
        this._next = null;
        /** @internal */
        this._prevDup = null;
        /** @internal */
        this._nextDup = null;
        /** @internal */
        this._prevRemoved = null;
        /** @internal */
        this._nextRemoved = null;
        /** @internal */
        this._nextAdded = null;
        /** @internal */
        this._nextMoved = null;
        /** @internal */
        this._nextIdentityChange = null;
    }
}
// A linked list of IterableChangeRecords with the same IterableChangeRecord_.item
class _DuplicateItemRecordList {
    constructor() {
        /** @internal */
        this._head = null;
        /** @internal */
        this._tail = null;
    }
    /**
     * Append the record to the list of duplicates.
     *
     * Note: by design all records in the list of duplicates hold the same value in record.item.
     */
    add(record) {
        if (this._head === null) {
            this._head = this._tail = record;
            record._nextDup = null;
            record._prevDup = null;
        }
        else {
            this._tail._nextDup = record;
            record._prevDup = this._tail;
            record._nextDup = null;
            this._tail = record;
        }
    }
    // Returns a IterableChangeRecord_ having IterableChangeRecord_.trackById == trackById and
    // IterableChangeRecord_.currentIndex >= atOrAfterIndex
    get(trackById, atOrAfterIndex) {
        let record;
        for (record = this._head; record !== null; record = record._nextDup) {
            if ((atOrAfterIndex === null || atOrAfterIndex <= record.currentIndex) &&
                Object.is(record.trackById, trackById)) {
                return record;
            }
        }
        return null;
    }
    /**
     * Remove one {@link IterableChangeRecord_} from the list of duplicates.
     *
     * Returns whether the list of duplicates is empty.
     */
    remove(record) {
        const prev = record._prevDup;
        const next = record._nextDup;
        if (prev === null) {
            this._head = next;
        }
        else {
            prev._nextDup = next;
        }
        if (next === null) {
            this._tail = prev;
        }
        else {
            next._prevDup = prev;
        }
        return this._head === null;
    }
}
class _DuplicateMap {
    constructor() {
        this.map = new Map();
    }
    put(record) {
        const key = record.trackById;
        let duplicates = this.map.get(key);
        if (!duplicates) {
            duplicates = new _DuplicateItemRecordList();
            this.map.set(key, duplicates);
        }
        duplicates.add(record);
    }
    /**
     * Retrieve the `value` using key. Because the IterableChangeRecord_ value may be one which we
     * have already iterated over, we use the `atOrAfterIndex` to pretend it is not there.
     *
     * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
     * have any more `a`s needs to return the second `a`.
     */
    get(trackById, atOrAfterIndex) {
        const key = trackById;
        const recordList = this.map.get(key);
        return recordList ? recordList.get(trackById, atOrAfterIndex) : null;
    }
    /**
     * Removes a {@link IterableChangeRecord_} from the list of duplicates.
     *
     * The list of duplicates also is removed from the map if it gets empty.
     */
    remove(record) {
        const key = record.trackById;
        const recordList = this.map.get(key);
        // Remove the list of duplicates when it gets empty
        if (recordList.remove(record)) {
            this.map.delete(key);
        }
        return record;
    }
    get isEmpty() {
        return this.map.size === 0;
    }
    clear() {
        this.map.clear();
    }
}
function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
    const previousIndex = item.previousIndex;
    if (previousIndex === null)
        return previousIndex;
    let moveOffset = 0;
    if (moveOffsets && previousIndex < moveOffsets.length) {
        moveOffset = moveOffsets[previousIndex];
    }
    return previousIndex + addRemoveOffset + moveOffset;
}

class ListRender {
    constructor(board) {
        this.board = board;
        this.children = [];
        this.instances = [];
        this.contexts = [];
        this.differ = null;
        this.initialized = false;
    }
    initialize(children, childrenContext) {
        this.initialized = true;
        this.children = children;
        children.forEach((descendant, index) => {
            NODE_TO_INDEX.set(descendant, index);
            NODE_TO_PARENT.set(descendant, childrenContext.parent);
            const context = getContext(this.board, descendant, index, childrenContext.parent);
            const componentType = getComponentType(this.board, context);
            const instance = createPluginComponent(this.board, componentType, context, childrenContext);
            this.instances.push(instance);
            this.contexts.push(context);
        });
        this.differ = new DefaultIterableDiffer(trackBy);
        this.differ.diff(children);
    }
    update(children, childrenContext) {
        if (!this.initialized) {
            this.initialize(children, childrenContext);
            return;
        }
        if (!this.differ) {
            throw new Error('Exception: Can not find differ ');
        }
        const { board, parent } = childrenContext;
        const diffResult = this.differ.diff(children);
        if (diffResult) {
            const newContexts = [];
            const newInstances = [];
            // for moving scene: the current index for first element before moving
            let currentIndexForFirstElement = null;
            diffResult.forEachItem((record) => {
                NODE_TO_INDEX.set(record.item, record.currentIndex);
                NODE_TO_PARENT.set(record.item, childrenContext.parent);
                const previousContext = record.previousIndex === null ? undefined : this.contexts[record.previousIndex];
                const context = getContext(board, record.item, record.currentIndex, parent, previousContext);
                if (record.previousIndex === null) {
                    const componentType = getComponentType(board, context);
                    const componentRef = createPluginComponent(board, componentType, context, childrenContext);
                    newContexts.push(context);
                    newInstances.push(componentRef);
                }
                else {
                    const instance = this.instances[record.previousIndex];
                    instance.context = context;
                    newInstances.push(instance);
                    newContexts.push(context);
                }
                // item might has been changed, so need to compare the id
                if (record.item === this.children[0] || record.item.id === this.children[0]?.id) {
                    currentIndexForFirstElement = record.currentIndex;
                }
            });
            diffResult.forEachOperation(record => {
                // removed
                if (record.currentIndex === null) {
                    const componentRef = this.instances[record.previousIndex];
                    componentRef?.destroy();
                }
                // moved
                if (record.previousIndex !== null && record.currentIndex !== null) {
                    mountOnItemMove(record.item, record.currentIndex, childrenContext, currentIndexForFirstElement);
                }
            });
            this.instances = newInstances;
            this.contexts = newContexts;
            this.children = children;
        }
        else {
            const newContexts = [];
            this.children.forEach((element, index) => {
                NODE_TO_INDEX.set(element, index);
                NODE_TO_PARENT.set(element, childrenContext.parent);
                const previousContext = this.contexts[index];
                const previousInstance = this.instances[index];
                const context = getContext(board, element, index, parent, previousContext);
                previousInstance.context = context;
                newContexts.push(context);
            });
            this.contexts = newContexts;
        }
    }
    destroy() {
        this.children.forEach((element, index) => {
            if (this.instances[index]) {
                this.instances[index].destroy();
            }
        });
        this.instances = [];
        this.children = [];
        this.contexts = [];
        this.initialized = false;
        this.differ = null;
    }
}
const trackBy = (index, element) => {
    return element.id;
};
const createPluginComponent = (board, componentType, context, childrenContext) => {
    const instance = new componentType();
    instance.context = context;
    board.normalizeElement(context);
    try {
        instance.initialize();
    }
    catch (error) {
        if (isDebug()) {
            console.error('list-render-initialize', error, 'context', context);
        }
    }
    const g = instance.getContainerG();
    mountElementG(context.index, g, childrenContext);
    instance.initializeListRender();
    return instance;
};
const getComponentType = (board, context) => {
    const result = board.drawElement(context);
    return result;
};
const getContext = (board, element, index, parent, previousContext) => {
    let isSelected = isSelectedElement(board, element);
    const previousElement = previousContext && previousContext.element;
    if (previousElement && previousElement !== element && isSelectedElement(board, previousElement)) {
        isSelected = true;
        replaceSelectedElement(board, previousElement, element);
    }
    const context = {
        element: element,
        parent: parent,
        board: board,
        selected: isSelected,
        index,
        hasThemeChanged: !!board.operations?.find(op => op.type === 'set_theme')
    };
    return context;
};
// the g depth of root elementÔºö[1]-[2]-[3]-[4]
// the g depth of root element and children elementÔºàthe [2] element has childrenÔºâÔºö
// [1]-
// [2]([2-1-1][2-1-2][2-1][2-2][2-3-1][2-3-2][2-3][2])-
// [3]-
// [4]
const mountElementG = (index, g, childrenContext, 
// for moving scene: the current index for first element before moving
currentIndexForFirstElement = null) => {
    const { parent, parentG } = childrenContext;
    if (PlaitBoard.isBoard(parent)) {
        if (index > 0) {
            const previousElement = parent.children[index - 1];
            const previousContainerG = PlaitElement.getContainerG(previousElement, { suppressThrow: false });
            previousContainerG.insertAdjacentElement('afterend', g);
        }
        else {
            if (currentIndexForFirstElement !== null) {
                const firstElement = parent.children[currentIndexForFirstElement];
                const firstContainerG = firstElement && PlaitElement.getContainerG(firstElement, { suppressThrow: true });
                if (firstElement && firstContainerG) {
                    parentG.insertBefore(g, firstContainerG);
                }
                else {
                    throw new Error('fail to mount container on moving');
                }
            }
            else {
                parentG.append(g);
            }
        }
    }
    else {
        if (index > 0) {
            const previousElement = parent.children[index - 1];
            const previousElementG = PlaitElement.getElementG(previousElement);
            previousElementG.insertAdjacentElement('afterend', g);
        }
        else {
            if (currentIndexForFirstElement) {
                const nextElement = parent.children[currentIndexForFirstElement];
                const nextPath = nextElement && PlaitBoard.findPath(childrenContext.board, nextElement);
                const first = nextPath && PlaitNode.first(childrenContext.board, nextPath);
                const firstContainerG = first && PlaitElement.getContainerG(first, { suppressThrow: false });
                if (firstContainerG) {
                    parentG.insertBefore(g, firstContainerG);
                }
                else {
                    throw new Error('fail to mount container on moving');
                }
            }
            else {
                let parentElementG = PlaitElement.getElementG(parent);
                parentG.insertBefore(g, parentElementG);
            }
        }
    }
};
const mountOnItemMove = (element, index, childrenContext, currentIndexForFirstElement) => {
    const containerG = PlaitElement.getContainerG(element, { suppressThrow: false });
    mountElementG(index, containerG, childrenContext, currentIndexForFirstElement);
    if (element.children && !PlaitElement.isRootElement(element) && childrenContext.board.isExpanded(element)) {
        element.children.forEach((child, index) => {
            mountOnItemMove(child, index, { ...childrenContext, parent: element }, null);
        });
    }
};

/**
 * Âü∫‰∫é element-flavour ÂÆûÁé∞ÂÖÉÁ¥†ÁöÑÁªòÂà∂ÔºåÂèñ‰ª£ Angular ÁªÑ‰ª∂
 */
class ElementFlavour {
    get hasChildren() {
        return !!this.element.children;
    }
    set context(value) {
        if (hasBeforeContextChange(this)) {
            this.beforeContextChange(value);
        }
        const previousContext = this._context;
        this._context = value;
        if (this.initialized) {
            const elementG = this.getElementG();
            const containerG = this.getContainerG();
            NODE_TO_G.set(this.element, elementG);
            NODE_TO_CONTAINER_G.set(this.element, containerG);
            getElementMap(this.board).set(this.element.id, this.element);
            ELEMENT_TO_REF.set(this.element, this.ref);
            this.updateListRender();
            if (hasOnContextChanged(this)) {
                this.onContextChanged(value, previousContext);
            }
        }
        else {
            if (PlaitElement.isRootElement(this.element) && this.hasChildren) {
                this._g = createG();
                this._containerG = createG();
                this._containerG.append(this._g);
            }
            else {
                this._g = createG();
                this._containerG = this._g;
            }
            NODE_TO_G.set(this.element, this._g);
            NODE_TO_CONTAINER_G.set(this.element, this._containerG);
            ELEMENT_TO_REF.set(this.element, this.ref);
            getElementMap(this.board).set(this.element.id, this.element);
        }
    }
    get context() {
        return this._context;
    }
    get element() {
        return this.context && this.context.element;
    }
    get board() {
        return this.context && this.context.board;
    }
    get selected() {
        return this.context && this.context.selected;
    }
    getContainerG() {
        return this._containerG;
    }
    getElementG() {
        return this._g;
    }
    constructor(ref) {
        this.ref = ref;
        this.initialized = false;
    }
    initialize() {
        if (this.element.type) {
            this.getContainerG().setAttribute(`plait-${this.element.type}`, 'true');
        }
        if (this.hasChildren) {
            if (PlaitElement.isRootElement(this.element)) {
                this._rootContainerG = this._containerG;
            }
            else {
                const path = PlaitBoard.findPath(this.board, this.element);
                const rootNode = PlaitNode.get(this.board, path.slice(0, 1));
                this._rootContainerG = PlaitElement.getContainerG(rootNode, { suppressThrow: false });
            }
        }
        this.getContainerG().setAttribute('plait-data-id', this.element.id);
        this.initialized = true;
    }
    initializeListRender() {
        if (this.hasChildren) {
            this.listRender = new ListRender(this.board);
            if (this.board.isExpanded(this.element)) {
                this.listRender.initialize(this.element.children, this.initializeChildrenContext());
            }
        }
    }
    getRef() {
        return this.ref;
    }
    updateListRender() {
        if (this.hasChildren) {
            if (!this.listRender) {
                throw new Error('incorrectly initialize list render');
            }
            if (this.board.isExpanded(this.element)) {
                this.listRender.update(this.element.children, this.initializeChildrenContext());
            }
            else {
                if (this.listRender.initialized) {
                    this.listRender.destroy();
                }
            }
        }
    }
    initializeChildrenContext() {
        if (!this._rootContainerG) {
            throw new Error('can not resolve root container g');
        }
        return {
            board: this.board,
            parent: this.element,
            parentG: this._rootContainerG
        };
    }
    destroy() {
        if (NODE_TO_G.get(this.element) === this._g) {
            NODE_TO_G.delete(this.element);
        }
        getElementMap(this.board).delete(this.element.id);
        if (NODE_TO_CONTAINER_G.get(this.element) === this._containerG) {
            NODE_TO_CONTAINER_G.delete(this.element);
        }
        if (ELEMENT_TO_REF.get(this.element) === this.ref) {
            ELEMENT_TO_REF.set(this.element, this.ref);
        }
        removeSelectedElement(this.board, this.element);
        this.getContainerG().remove();
        this.listRender?.destroy();
    }
}

class PlaitBoardContext {
    constructor() {
        this._stable = new Subject();
        this.uploadingFiles = [];
    }
    getUploadingFile(url) {
        return this.uploadingFiles.find(file => file.url === url);
    }
    setUploadingFile(file) {
        return this.uploadingFiles.push(file);
    }
    removeUploadingFile(fileEntry) {
        this.uploadingFiles = this.uploadingFiles.filter(file => file.url !== fileEntry.url);
    }
    onStable() {
        return this._stable.asObservable();
    }
    nextStable() {
        this._stable.next('');
    }
}

const PathRef = {
    transform(ref, op) {
        const { current } = ref;
        if (current == null) {
            return;
        }
        const path = Path.transform(current, op);
        ref.current = path;
        if (path == null) {
            ref.unref();
        }
    }
};

function createBoard(children, options) {
    const board = {
        viewport: {
            zoom: 1
        },
        children,
        theme: { themeColorMode: ThemeColorMode.default },
        operations: [],
        history: {
            redos: [],
            undos: []
        },
        selection: null,
        options: options || {
            readonly: false,
            hideScrollbar: false,
            disabledScrollOnNonFocus: false
        },
        pointer: options?.readonly ? PlaitPointerType.hand : PlaitPointerType.selection,
        undo: () => { },
        redo: () => { },
        apply: (operation) => {
            for (const ref of board.pathRefs()) {
                PathRef.transform(ref, operation);
            }
            board.operations.push(operation);
            Transforms.transform(board, operation);
            if (!FLUSHING.get(board)) {
                FLUSHING.set(board, true);
                Promise.resolve().then(() => {
                    FLUSHING.set(board, false);
                    board.onChange();
                    board.afterChange();
                    board.operations = [];
                });
            }
        },
        pathRef: (path, options) => {
            const affinity = options?.affinity || 'forward';
            const ref = {
                current: path,
                affinity,
                unref() {
                    const { current } = ref;
                    const pathRefs = board.pathRefs();
                    pathRefs.delete(ref);
                    ref.current = null;
                    return current;
                }
            };
            const refs = board.pathRefs();
            refs.add(ref);
            return ref;
        },
        pathRefs: () => {
            let refs = PATH_REFS.get(board);
            if (!refs) {
                refs = new Set();
                PATH_REFS.set(board, refs);
            }
            return refs;
        },
        onChange: () => { },
        afterChange: () => { },
        drawSelectionRectangle: () => {
            return drawSelectionRectangleG(board);
        },
        mousedown: (event) => { },
        mousemove: (event) => { },
        mouseleave: (event) => { },
        globalMousemove: (event) => { },
        mouseup: (event) => { },
        globalMouseup: (event) => { },
        keyDown: (event) => { },
        globalKeyDown: (event) => { },
        keyUp: (event) => { },
        dblClick: (event) => { },
        buildFragment: (clipboardContext, rectangle, operationType, originData) => clipboardContext,
        insertFragment: (clipboardData, targetPoint, operationType) => { },
        deleteFragment: (elements) => {
            CoreTransforms.removeElements(board, elements);
        },
        getDeletedFragment: (data) => data,
        getRelatedFragment: (data, originData) => data,
        normalizeElement: (context) => { },
        drawElement: (context) => {
            throw new Error(`can not resolve plugin element component type: ${context.element.type}`);
        },
        isWithinSelection: (element) => false,
        isRectangleHit: (element) => false,
        isHit: (element) => false,
        isInsidePoint: (element) => false,
        getOneHitElement: (data) => data[0],
        isRecursion: (element) => true,
        isMovable: (element) => false,
        getRectangle: (element) => null,
        applyTheme: (element) => { },
        isAlign: (element) => false,
        pointerDown: (pointer) => { },
        pointerMove: (pointer) => { },
        pointerUp: (pointer) => { },
        pointerCancel: (pointer) => { },
        pointerOut: (pointer) => { },
        pointerLeave: (pointer) => { },
        globalPointerMove: (pointer) => { },
        globalPointerUp: (pointer) => { },
        drop: (event) => {
            return false;
        },
        isImageBindingAllowed: (element) => false,
        canAddToGroup: (element) => true,
        canSetZIndex: (element) => true,
        isExpanded: (element) => true
    };
    return board;
}

function withBoard(board) {
    const { onChange, afterChange } = board;
    board.onChange = () => {
        const onContextChange = BOARD_TO_ON_CHANGE.get(board);
        if (onContextChange) {
            onContextChange();
        }
        onChange();
    };
    board.afterChange = () => {
        const afterContextChange = BOARD_TO_AFTER_CHANGE.get(board);
        if (afterContextChange) {
            afterContextChange();
        }
        afterChange();
    };
    return board;
}

const isSmartHand = (board, event) => {
    return PlaitBoard.isPointer(board, PlaitPointerType.selection) && isMobileDeviceEvent(event);
};

const ShortcutKey = 'Space';
function withHandPointer(board) {
    const { pointerDown, pointerMove, globalPointerUp, keyDown, keyUp, pointerUp } = board;
    let isHandMoving = false;
    let movingPoint = null;
    let pointerDownEvent = null;
    let hasWheelPressed = false;
    let beingPressedShortcutKey = false;
    board.pointerDown = (event) => {
        const options = board.getPluginOptions(PlaitPluginKey.withHand);
        const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
        const isHitTarget = isHitElement(board, point);
        const canEnterHandMode = options?.isHandMode(board, event) ||
            PlaitBoard.isPointer(board, PlaitPointerType.hand) ||
            (isSmartHand(board, event) && !isHitTarget) ||
            beingPressedShortcutKey;
        if (canEnterHandMode && isMainPointer(event)) {
            movingPoint = {
                x: event.x,
                y: event.y
            };
            if (!PlaitBoard.isPointer(board, PlaitPointerType.hand)) {
                PlaitBoard.getBoardContainer(board).classList.add('viewport-moving');
            }
        }
        else if (isWheelPointer(event)) {
            hasWheelPressed = true;
            // Prevent the browser's default behavior of scrolling the page when the mouse wheel is pressed.
            event.preventDefault();
            movingPoint = {
                x: event.x,
                y: event.y
            };
            isHandMoving = true;
            PlaitBoard.getBoardContainer(board).classList.add('viewport-moving');
        }
        pointerDownEvent = event;
        pointerDown(event);
    };
    board.pointerMove = (event) => {
        const options = board.getPluginOptions(PlaitPluginKey.withHand);
        // ÈòàÂÄºÂøÖÈ°ªÂ§ß‰∫é withSelection ‰∏≠ pointerMove ÁöÑ PRESS_AND_MOVE_BUFFERÔºö
        // 1. È¶ñÂÖàÊ£ÄÊµãÊòØÂê¶Êª°Ë∂≥ËøõÂÖ•ÊãñÈÄâÁä∂ÊÄÅÁöÑÊù°‰ª∂
        // 2. ‰ªÖÂΩì‰∏çÊª°Ë∂≥ÊãñÈÄâÊù°‰ª∂Êó∂ÔºåÊâç‰ºöËÄÉËôëËß¶Âèë withHand Ë°å‰∏∫
        // Must exceed the DRAG_SELECTION_PRESS_AND_MOVE_BUFFER threshold defined in withSelection's pointerMove.
        // The system first checks for drag selection state eligibility
        // withHand behavior is only triggered if drag selection state is not initiated.
        const triggerDistance = DRAG_SELECTION_PRESS_AND_MOVE_BUFFER + 4;
        if (movingPoint &&
            !isHandMoving &&
            !isSelectionMoving(board) &&
            pointerDownEvent &&
            distanceBetweenPointAndPoint(pointerDownEvent.x, pointerDownEvent.y, event.x, event.y) > triggerDistance &&
            !isMovingElements(board)) {
            isHandMoving = true;
            PlaitBoard.getBoardContainer(board).classList.add('viewport-moving');
        }
        const canEnterHandMode = options?.isHandMode(board, event) ||
            PlaitBoard.isPointer(board, PlaitPointerType.hand) ||
            isSmartHand(board, event) ||
            hasWheelPressed ||
            beingPressedShortcutKey;
        if (canEnterHandMode && isHandMoving && movingPoint && !isSelectionMoving(board) && !isMovingElements(board)) {
            const viewportContainer = PlaitBoard.getViewportContainer(board);
            const left = viewportContainer.scrollLeft - (event.x - movingPoint.x);
            const top = viewportContainer.scrollTop - (event.y - movingPoint.y);
            updateViewportContainerScroll(board, left, top, false);
            movingPoint.x = event.x;
            movingPoint.y = event.y;
        }
        pointerMove(event);
    };
    board.pointerUp = (event) => {
        if (isHandMoving) {
            return;
        }
        pointerUp(event);
    };
    board.globalPointerUp = (event) => {
        if (movingPoint) {
            movingPoint = null;
        }
        isHandMoving = false;
        PlaitBoard.getBoardContainer(board).classList.remove('viewport-moving');
        hasWheelPressed = false;
        globalPointerUp(event);
    };
    board.keyDown = (event) => {
        if (event.code === ShortcutKey) {
            if (!board.options.readonly && !PlaitBoard.isPointer(board, PlaitPointerType.hand)) {
                beingPressedShortcutKey = true;
                setSelectionOptions(board, { isDisabledSelection: true });
                PlaitBoard.getBoardContainer(board).classList.add('viewport-moving');
            }
            event.preventDefault();
        }
        keyDown(event);
    };
    board.keyUp = (event) => {
        if (!board.options.readonly && event.code === ShortcutKey) {
            beingPressedShortcutKey = false;
            setSelectionOptions(board, { isDisabledSelection: false });
            PlaitBoard.getBoardContainer(board).classList.remove('viewport-moving');
        }
        keyUp(event);
    };
    return board;
}

function withHistory(board) {
    const { apply, keyDown } = board;
    board.history = { undos: [], redos: [] };
    board.redo = () => {
        const { history } = board;
        const { redos } = history;
        if (redos.length > 0) {
            const batch = redos[redos.length - 1];
            PlaitHistoryBoard.withoutSaving(board, () => {
                for (const op of batch) {
                    board.apply(op);
                }
            });
            history.redos.pop();
            history.undos.push(batch);
        }
    };
    board.undo = () => {
        const { history } = board;
        const { undos } = history;
        if (undos.length > 0) {
            const batch = undos[undos.length - 1];
            PlaitHistoryBoard.withoutSaving(board, () => {
                const inverseOps = batch.map(PlaitOperation.inverse).reverse();
                for (const op of inverseOps) {
                    board.apply(op);
                }
            });
            history.redos.push(batch);
            history.undos.pop();
        }
    };
    board.apply = (op) => {
        const { operations, history } = board;
        const { undos } = history;
        const lastBatch = undos[undos.length - 1];
        const lastOp = lastBatch && lastBatch[lastBatch.length - 1];
        let save = PlaitHistoryBoard.isSaving(board);
        let merge = PlaitHistoryBoard.isMerging(board);
        if (save == null) {
            save = shouldSave(op, lastOp);
        }
        if (save) {
            if (!merge) {
                if (lastBatch == null) {
                    merge = false;
                }
                else if (operations.length !== 0) {
                    merge = true;
                }
                else {
                    merge = shouldMerge(op, lastOp);
                }
            }
            if (PlaitHistoryBoard.isSplittingOnce(board)) {
                merge = false;
                PlaitHistoryBoard.setSplittingOnce(board, undefined);
            }
            if (lastBatch && merge) {
                lastBatch.push(op);
            }
            else {
                const batch = [op];
                undos.push(batch);
            }
            while (undos.length > 100) {
                undos.shift();
            }
            if (shouldClear(op)) {
                history.redos = [];
            }
        }
        apply(op);
    };
    board.keyDown = (event) => {
        if (isHotkey('mod+z', event)) {
            board.undo();
            return;
        }
        if (isHotkey('mod+shift+z', event)) {
            board.redo();
            return;
        }
        keyDown(event);
    };
    return board;
}

const withHotkey = (board) => {
    const { keyDown, keyUp, globalKeyDown } = board;
    board.keyDown = (event) => {
        const options = board.getPluginOptions(PlaitPluginKey.withSelection);
        if (!PlaitBoard.isReadonly(board) && options.isMultipleSelection && isHotkey('mod+a', event)) {
            event.preventDefault();
            let elements = [];
            depthFirstRecursion(board, node => {
                if (PlaitBoard.isBoard(node)) {
                    return;
                }
                elements.push(node);
            }, node => {
                if (PlaitBoard.isBoard(node) || board.isRecursion(node)) {
                    return true;
                }
                else {
                    return false;
                }
            }, true);
            Transforms.addSelectionWithTemporaryElements(board, elements);
            return;
        }
        if (!PlaitBoard.isReadonly(board)) {
            if (isKeyHotkey('mod+]', event)) {
                event.preventDefault();
                Transforms.moveUp(board);
                return;
            }
            if (isKeyHotkey('mod+[', event)) {
                event.preventDefault();
                Transforms.moveDown(board);
                return;
            }
            if (isKeyHotkey('mod+option+‚Äò', event)) {
                event.preventDefault();
                Transforms.moveToTop(board);
                return;
            }
            if (isKeyHotkey('mod+option+‚Äú', event)) {
                event.preventDefault();
                Transforms.moveToBottom(board);
                return;
            }
        }
        const selectedElements = getSelectedElements(board);
        if (!PlaitBoard.isReadonly(board) && selectedElements.length > 0) {
            if (isKeyHotkey('mod+d', event)) {
                event.preventDefault();
                duplicateElements(board);
                return;
            }
        }
        if (!PlaitBoard.isReadonly(board) &&
            selectedElements.length > 0 &&
            (hotkeys.isDeleteBackward(event) || hotkeys.isDeleteForward(event))) {
            event.preventDefault();
            deleteFragment(board);
        }
        keyDown(event);
    };
    board.keyUp = (event) => {
        keyUp(event);
    };
    board.globalKeyDown = (event) => {
        if (PlaitBoard.getMovingPointInBoard(board) || PlaitBoard.isMovingPointInBoard(board)) {
            if (isHotkey(['mod+=', 'mod++'], { byKey: true })(event)) {
                event.preventDefault();
                BoardTransforms.updateZoom(board, board.viewport.zoom + 0.1);
                return;
            }
            if (isHotkey(['mod+shift+=', 'mod+shift++'], { byKey: true })(event)) {
                event.preventDefault();
                BoardTransforms.fitViewport(board);
                return;
            }
            if (isHotkey(['mod+-', 'mod+shift+-'])(event)) {
                event.preventDefault();
                BoardTransforms.updateZoom(board, board.viewport.zoom - 0.1);
                return;
            }
            if (isHotkey(['mod+0', 'mod+shift+0'], { byKey: true })(event)) {
                event.preventDefault();
                BoardTransforms.updateZoom(board, 1);
                return;
            }
        }
        globalKeyDown(event);
    };
    return board;
};

function getSnapMovingRef(board, activeRectangle, activeElements) {
    const snapRectangles = getSnapRectangles(board, activeElements);
    const snapG = createG();
    let snapDelta = getPointLineDelta(activeRectangle, snapRectangles);
    const pointLinesG = drawMovingPointSnapLines(board, snapDelta, activeRectangle, snapRectangles);
    snapG.append(pointLinesG);
    const result = getGapSnapLinesAndDelta(board, snapDelta, activeRectangle, snapRectangles);
    snapDelta = result.snapDelta;
    snapG.append(result.snapG);
    return { ...snapDelta, snapG };
}
function getPointLineDeltas(activeRectangle, snapRectangles, isHorizontal) {
    const axis = getTripleAxis(activeRectangle, isHorizontal);
    const deltaStart = getMinPointDelta(snapRectangles, axis[0], isHorizontal);
    const deltaMiddle = getMinPointDelta(snapRectangles, axis[1], isHorizontal);
    const deltaEnd = getMinPointDelta(snapRectangles, axis[2], isHorizontal);
    return [deltaStart, deltaMiddle, deltaEnd];
}
function getPointLineDelta(activeRectangle, snapRectangles) {
    let snapDelta = {
        deltaX: 0,
        deltaY: 0
    };
    function getDelta(isHorizontal) {
        let delta = 0;
        const deltas = getPointLineDeltas(activeRectangle, snapRectangles, isHorizontal);
        for (let i = 0; i < deltas.length; i++) {
            if (Math.abs(deltas[i]) < SNAP_TOLERANCE) {
                delta = deltas[i];
                break;
            }
        }
        return delta;
    }
    snapDelta.deltaX = getDelta(true);
    snapDelta.deltaY = getDelta(false);
    return snapDelta;
}
function updateActiveRectangle(snapDelta, activeRectangle) {
    const { deltaX, deltaY } = snapDelta;
    const { x, y, width, height } = activeRectangle;
    return {
        x: x + deltaX,
        y: y + deltaY,
        width,
        height
    };
}
function drawMovingPointSnapLines(board, snapDelta, activeRectangle, snapRectangles) {
    const newActiveRectangle = updateActiveRectangle(snapDelta, activeRectangle);
    return drawPointSnapLines(board, newActiveRectangle, snapRectangles, true, true, true);
}
function getGapSnapLinesAndDelta(board, snapDelta, activeRectangle, snapRectangles) {
    let deltaX = snapDelta.deltaX;
    let deltaY = snapDelta.deltaY;
    const gapHorizontalResult = getGapLinesAndDelta(activeRectangle, snapRectangles, true);
    const gapVerticalResult = getGapLinesAndDelta(activeRectangle, snapRectangles, false);
    const gapSnapLines = [...gapHorizontalResult.lines, ...gapVerticalResult.lines];
    if (gapHorizontalResult.delta) {
        deltaX = gapHorizontalResult.delta;
    }
    if (gapVerticalResult.delta) {
        deltaY = gapVerticalResult.delta;
    }
    return {
        snapDelta: { deltaX, deltaY },
        snapG: drawSolidLines(board, gapSnapLines)
    };
}
function getGapLinesAndDelta(activeRectangle, snapRectangles, isHorizontal) {
    let lines = [];
    let delta = 0;
    let rectangles = [];
    const axis = isHorizontal ? 'x' : 'y';
    const side = isHorizontal ? 'width' : 'height';
    const activeRectangleCenter = activeRectangle[axis] + activeRectangle[side] / 2;
    snapRectangles.forEach(rec => {
        const isCross = isHorizontal ? isHorizontalCross(rec, activeRectangle) : isVerticalCross(rec, activeRectangle);
        if (isCross && !RectangleClient.isHit(rec, activeRectangle)) {
            rectangles.push(rec);
        }
    });
    rectangles = [...rectangles, activeRectangle].sort((a, b) => a[axis] - b[axis]);
    const refArray = [];
    let gapDistance = 0;
    let beforeIndex = undefined;
    let afterIndex = undefined;
    for (let i = 0; i < rectangles.length; i++) {
        for (let j = i + 1; j < rectangles.length; j++) {
            const before = rectangles[i];
            const after = rectangles[j];
            const distance = after[axis] - (before[axis] + before[side]);
            let dif = Infinity;
            if (refArray[i]?.after) {
                refArray[i].after.push({ distance, index: j });
            }
            else {
                refArray[i] = { ...refArray[i], after: [{ distance, index: j }] };
            }
            if (refArray[j]?.before) {
                refArray[j].before.push({ distance, index: i });
            }
            else {
                refArray[j] = { ...refArray[j], before: [{ distance, index: i }] };
            }
            //middle
            let _center = (before[axis] + before[side] + after[axis]) / 2;
            dif = Math.abs(_center - activeRectangleCenter);
            if (dif < SNAP_TOLERANCE) {
                gapDistance = (after[axis] - (before[axis] + before[side]) - activeRectangle[side]) / 2;
                delta = _center - activeRectangleCenter;
                beforeIndex = i;
                afterIndex = j;
            }
            //after
            const distanceRight = after[axis] - (before[axis] + before[side]);
            _center = after[axis] + after[side] + distanceRight + activeRectangle[side] / 2;
            dif = Math.abs(_center - activeRectangleCenter);
            if ((!gapDistance || gapDistance !== distanceRight) && dif < SNAP_TOLERANCE) {
                gapDistance = distanceRight;
                beforeIndex = j;
                delta = _center - activeRectangleCenter;
            }
            //before
            const distanceBefore = after[axis] - (before[axis] + before[side]);
            _center = before[axis] - distanceBefore - activeRectangle[side] / 2;
            dif = Math.abs(_center - activeRectangleCenter);
            if (!gapDistance && dif < SNAP_TOLERANCE) {
                gapDistance = distanceBefore;
                afterIndex = i;
                delta = _center - activeRectangleCenter;
            }
        }
    }
    const activeIndex = rectangles.indexOf(activeRectangle);
    let beforeIndexes = [];
    let afterIndexes = [];
    if (beforeIndex !== undefined) {
        beforeIndexes.push(beforeIndex);
        findRectangle(gapDistance, refArray[beforeIndex], 'before', beforeIndexes);
    }
    if (afterIndex !== undefined) {
        afterIndexes.push(afterIndex);
        findRectangle(gapDistance, refArray[afterIndex], 'after', afterIndexes);
    }
    if (beforeIndexes.length || afterIndexes.length) {
        const indexArr = [...beforeIndexes.reverse(), activeIndex, ...afterIndexes];
        activeRectangle[axis] += delta;
        for (let i = 1; i < indexArr.length; i++) {
            lines.push(getLinePoints(rectangles[indexArr[i - 1]], rectangles[indexArr[i]]));
        }
    }
    function findRectangle(distance, ref, direction, rectangleIndexes) {
        const arr = ref[direction];
        const index = refArray.indexOf(ref);
        if ((index === 0 && direction === 'before') || (index === refArray.length - 1 && direction === 'after'))
            return;
        for (let i = 0; i < arr.length; i++) {
            if (Math.abs(arr[i].distance - distance) < 0.1) {
                rectangleIndexes.push(arr[i].index);
                findRectangle(distance, refArray[arr[i].index], direction, rectangleIndexes);
                return;
            }
        }
    }
    function getLinePoints(beforeRectangle, afterRectangle) {
        const oppositeAxis = axis === 'x' ? 'y' : 'x';
        const oppositeSide = side === 'width' ? 'height' : 'width';
        const snap = [
            beforeRectangle[oppositeAxis],
            beforeRectangle[oppositeAxis] + beforeRectangle[oppositeSide],
            afterRectangle[oppositeAxis],
            afterRectangle[oppositeAxis] + afterRectangle[oppositeSide]
        ];
        const sortArr = snap.sort((a, b) => a - b);
        const average = (sortArr[1] + sortArr[2]) / 2;
        const offset = 3;
        return isHorizontal
            ? [
                [beforeRectangle.x + beforeRectangle.width + offset, average],
                [afterRectangle.x - offset, average]
            ]
            : [
                [average, beforeRectangle.y + beforeRectangle.height + offset],
                [average, afterRectangle.y - offset]
            ];
    }
    return { delta, lines };
}
function isHorizontalCross(rectangle, other) {
    return !(rectangle.y + rectangle.height < other.y || rectangle.y > other.y + other.height);
}
function isVerticalCross(rectangle, other) {
    return !(rectangle.x + rectangle.width < other.x || rectangle.x > other.x + other.width);
}

function withMoving(board) {
    const { pointerDown, pointerMove, globalPointerUp, globalPointerMove, globalKeyDown, keyUp } = board;
    let offsetX = 0;
    let offsetY = 0;
    let isPreventDefault = false;
    let startPoint;
    let activeElements = [];
    let snapG = null;
    let activeElementsRectangle = null;
    let selectedTargetElements = null;
    let hitTargetElement = undefined;
    let isHitSelectedTarget = undefined;
    let pendingNodesG = null;
    board.globalKeyDown = (event) => {
        if (!PlaitBoard.isReadonly(board)) {
            if (isKeyHotkey('option', event)) {
                event.preventDefault();
                if (startPoint && activeElements.length && !PlaitBoard.hasBeenTextEditing(board)) {
                    pendingNodesG = drawPendingNodesG(board, activeElements, offsetX, offsetY);
                    pendingNodesG && PlaitBoard.getElementTopHost(board).append(pendingNodesG);
                }
            }
        }
        globalKeyDown(event);
    };
    board.keyUp = (event) => {
        if (!PlaitBoard.isReadonly(board)) {
            if (pendingNodesG && startPoint && activeElements.length && !PlaitBoard.hasBeenTextEditing(board)) {
                event.preventDefault();
                const currentElements = updatePoints(board, activeElements, offsetX, offsetY);
                PlaitBoard.getBoardContainer(board).classList.add('element-moving');
                cacheMovingElements(board, currentElements);
            }
        }
        pendingNodesG?.remove();
        keyUp(event);
    };
    board.pointerDown = (event) => {
        if (PlaitBoard.isReadonly(board) || !PlaitBoard.isPointer(board, PlaitPointerType.selection) || !isMainPointer(event)) {
            pointerDown(event);
            return;
        }
        const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
        hitTargetElement = getHitElementByPoint(board, point, el => board.isMovable(el));
        selectedTargetElements = getSelectedTargetElements(board);
        isHitSelectedTarget = hitTargetElement && selectedTargetElements.includes(hitTargetElement);
        if (hitTargetElement && isHitSelectedTarget) {
            startPoint = point;
            activeElements = selectedTargetElements;
            activeElementsRectangle = getRectangleByElements(board, activeElements, true);
        }
        else if (hitTargetElement) {
            startPoint = point;
            const relatedElements = board.getRelatedFragment([], [hitTargetElement]);
            activeElements = [...getElementsInGroupByElement(board, hitTargetElement), ...relatedElements];
            activeElementsRectangle = getRectangleByElements(board, activeElements, true);
        }
        else {
            // Âè™ÊúâÂà§ÂÆöÁî®Êà∑Êú™Âáª‰∏≠ÂÖÉÁ¥†‰πãÂêéÊâçÂèØ‰ª•È™åËØÅÁî®Êà∑ÊòØÂê¶Âáª‰∏≠‰∫ÜÂ∑≤ÈÄâÂÖÉÁ¥†ÊâÄÂú®ÁöÑÁ©∫ÁôΩÂå∫Âüü
            // Only after it is determined that the user has not hit the element can it be verified whether the user hit the blank area where the selected element is located.
            const targetRectangle = selectedTargetElements.length > 0 && getRectangleByElements(board, selectedTargetElements, false);
            const isHitInTargetRectangle = targetRectangle && RectangleClient.isPointInRectangle(targetRectangle, point);
            if (isHitInTargetRectangle) {
                startPoint = point;
                activeElements = selectedTargetElements;
                activeElementsRectangle = targetRectangle;
            }
        }
        pointerDown(event);
    };
    board.pointerMove = (event) => {
        if (startPoint && activeElements.length && !PlaitBoard.hasBeenTextEditing(board)) {
            if (!isPreventDefault) {
                isPreventDefault = true;
            }
            snapG?.remove();
            pendingNodesG?.remove();
            const endPoint = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
            offsetX = endPoint[0] - startPoint[0];
            offsetY = endPoint[1] - startPoint[1];
            const distance = distanceBetweenPointAndPoint(...endPoint, ...startPoint);
            if (distance > PRESS_AND_MOVE_BUFFER || getMovingElements(board).length > 0) {
                if (hitTargetElement && !isHitSelectedTarget && selectedTargetElements && selectedTargetElements.length > 0) {
                    addSelectionWithTemporaryElements(board, []);
                    hitTargetElement = undefined;
                    selectedTargetElements = null;
                    isHitSelectedTarget = undefined;
                }
                throttleRAF(board, 'with-moving', () => {
                    if (!activeElementsRectangle) {
                        return;
                    }
                    const newRectangle = {
                        ...activeElementsRectangle,
                        x: activeElementsRectangle.x + offsetX,
                        y: activeElementsRectangle.y + offsetY
                    };
                    const activeRectangle = getRectangleByAngle(newRectangle, getSelectionAngle(activeElements));
                    const ref = getSnapMovingRef(board, activeRectangle, activeElements);
                    offsetX += ref.deltaX;
                    offsetY += ref.deltaY;
                    snapG = ref.snapG;
                    snapG.classList.add(ACTIVE_MOVING_CLASS_NAME);
                    PlaitBoard.getElementTopHost(board).append(snapG);
                    if (event.altKey) {
                        pendingNodesG = drawPendingNodesG(board, activeElements, offsetX, offsetY);
                        pendingNodesG && PlaitBoard.getElementTopHost(board).append(pendingNodesG);
                    }
                    else {
                        const currentElements = updatePoints(board, activeElements, offsetX, offsetY);
                        PlaitBoard.getBoardContainer(board).classList.add('element-moving');
                        cacheMovingElements(board, currentElements);
                    }
                });
            }
        }
        if (isPreventDefault) {
            // Prevent canvas scrolling behavior from being triggered during move
            event.preventDefault();
        }
        pointerMove(event);
    };
    board.globalPointerMove = (event) => {
        if (startPoint) {
            const inPlaitBoardElement = isInPlaitBoard(board, event.x, event.y);
            if (!inPlaitBoardElement) {
                cancelMove(board);
            }
        }
        globalPointerMove(event);
    };
    board.globalPointerUp = event => {
        if (event.altKey && activeElements.length) {
            const validElements = getValidElements(board, activeElements);
            const rectangle = getRectangleByElements(board, validElements, false);
            duplicateElements(board, validElements, [rectangle.x + offsetX, rectangle.y + offsetY]);
        }
        isPreventDefault = false;
        hitTargetElement = undefined;
        selectedTargetElements = null;
        isHitSelectedTarget = undefined;
        if (startPoint) {
            cancelMove(board);
        }
        globalPointerUp(event);
    };
    function cancelMove(board) {
        snapG?.remove();
        pendingNodesG?.remove();
        startPoint = null;
        activeElementsRectangle = null;
        offsetX = 0;
        offsetY = 0;
        activeElements = [];
        if (isMovingElements(board)) {
            removeMovingElements(board);
        }
        MERGING.set(board, false);
        PlaitBoard.getBoardContainer(board).classList.remove('element-moving');
    }
    return withArrowMoving(board);
}
function withArrowMoving(board) {
    const { keyDown, keyUp } = board;
    board.keyDown = (event) => {
        const selectedElements = getSelectedElements(board);
        if (!PlaitBoard.isReadonly(board) && selectedElements.length > 0 && (hotkeys.isArrow(event) || hotkeys.isExtendArrow(event))) {
            event.preventDefault();
            const isShift = event.shiftKey ? true : false;
            const offset = [0, 0];
            const buffer = isShift ? 10 : 1;
            switch (true) {
                case hotkeys.isMoveUp(event) || hotkeys.isExtendUp(event): {
                    offset[1] = -buffer;
                    break;
                }
                case hotkeys.isMoveDown(event) || hotkeys.isExtendDown(event): {
                    offset[1] = buffer;
                    break;
                }
                case hotkeys.isMoveBackward(event) || hotkeys.isExtendBackward(event): {
                    offset[0] = -buffer;
                    break;
                }
                case hotkeys.isMoveForward(event) || hotkeys.isExtendForward(event): {
                    offset[0] = buffer;
                    break;
                }
            }
            const targetElements = getSelectedTargetElements(board);
            throttleRAF(board, 'with-arrow-moving', () => {
                updatePoints(board, targetElements, offset[0], offset[1]);
            });
        }
        keyDown(event);
    };
    board.keyUp = (event) => {
        MERGING.set(board, false);
        keyUp(event);
    };
    return board;
}
function getSelectedTargetElements(board) {
    const selectedElements = getSelectedElements(board);
    const movableElements = board.children.filter(item => board.isMovable(item));
    const targetElements = selectedElements.filter(element => {
        return movableElements.includes(element);
    });
    const relatedElements = board.getRelatedFragment([]);
    targetElements.push(...relatedElements);
    return targetElements;
}
function getValidElements(board, activeElements) {
    const validElements = [...activeElements].filter(element => !PlaitGroupElement.isGroup(element) && PlaitElement.isRootElement(element));
    return validElements;
}
function updatePoints(board, activeElements, offsetX, offsetY) {
    const validElements = getValidElements(board, activeElements);
    const currentElements = validElements.map(element => {
        const points = element.points || [];
        const newPoints = points.map(p => [p[0] + offsetX, p[1] + offsetY]);
        const index = NODE_TO_INDEX.get(element);
        Transforms.setNode(board, {
            points: newPoints
        }, [index]);
        MERGING.set(board, true);
        return PlaitNode.get(board, [index]);
    });
    return currentElements;
}
function drawPendingNodesG(board, activeElements, offsetX, offsetY) {
    let pendingNodesG = null;
    const elements = [];
    const validElements = getValidElements(board, activeElements);
    validElements.forEach(element => {
        depthFirstRecursion(element, node => {
            elements.push(node);
        }, () => true);
    });
    elements.forEach(item => {
        let rectangle = board.getRectangle(item);
        if (rectangle) {
            rectangle = {
                x: rectangle.x + offsetX,
                y: rectangle.y + offsetY,
                width: rectangle.width,
                height: rectangle.height
            };
            const movingG = drawRectangle(board, rectangle, {
                stroke: SELECTION_BORDER_COLOR,
                strokeWidth: 1,
                fill: SELECTION_FILL_COLOR,
                fillStyle: 'solid'
            });
            if (!pendingNodesG) {
                pendingNodesG = createG();
                pendingNodesG.classList.add(ACTIVE_MOVING_CLASS_NAME);
            }
            const angle = getAngleByElement(item);
            angle && setAngleForG(movingG, RectangleClient.getCenterPoint(rectangle), angle);
            pendingNodesG.append(movingG);
        }
    });
    return pendingNodesG;
}

const withOptions = (board) => {
    const pluginOptions = new Map();
    const newBoard = board;
    newBoard.getPluginOptions = key => {
        return pluginOptions.get(key);
    };
    newBoard.setPluginOptions = (key, options) => {
        const oldOptions = newBoard.getPluginOptions(key) || {};
        pluginOptions.set(key, { ...oldOptions, ...options });
    };
    return newBoard;
};

function withRelatedFragment(board) {
    const { buildFragment } = board;
    board.buildFragment = (clipboardContext, rectangle, operationType, originData) => {
        let relatedFragment = board.getRelatedFragment(originData || []);
        if (relatedFragment) {
            if (originData?.length) {
                relatedFragment = relatedFragment.filter(item => !originData.map(element => element.id).includes(item.id));
            }
            if (relatedFragment.length) {
                const addition = {
                    text: '',
                    type: WritableClipboardType.elements,
                    elements: relatedFragment
                };
                clipboardContext = addOrCreateClipboardContext(clipboardContext, addition);
            }
        }
        return buildFragment(clipboardContext, rectangle, operationType, originData);
    };
    return board;
}

function withSelection(board) {
    const { pointerDown, pointerUp, pointerMove, globalPointerUp, onChange, afterChange, drawSelectionRectangle } = board;
    let screenStart = null;
    let screenEnd = null;
    let selectionMovingG;
    let selectionRectangleG;
    let isShift = false;
    let timerId = null;
    let pointerDownEvent = null;
    board.pointerDown = (event) => {
        if (!isShift && event.shiftKey) {
            isShift = true;
        }
        if (isShift && !event.shiftKey) {
            isShift = false;
        }
        const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
        const isHitTarget = isHitElement(board, point);
        const options = getSelectionOptions(board);
        if (PlaitBoard.isPointer(board, PlaitPointerType.selection) &&
            isMainPointer(event) &&
            !isHitTarget &&
            options.isMultipleSelection &&
            !options.isDisabledSelection) {
            if (isMobileDeviceEvent(event)) {
                timerId = setTimeout(() => {
                    screenStart = [event.x, event.y];
                    timerId = null;
                }, 120);
            }
            else {
                screenStart = [event.x, event.y];
            }
        }
        pointerDownEvent = event;
        pointerDown(event);
    };
    board.pointerMove = (event) => {
        if (timerId &&
            pointerDownEvent &&
            distanceBetweenPointAndPoint(pointerDownEvent.x, pointerDownEvent.y, event.x, event.y) > DRAG_SELECTION_PRESS_AND_MOVE_BUFFER) {
            clearTimeout(timerId);
            timerId = null;
        }
        if (PlaitBoard.isPointer(board, PlaitPointerType.selection) && screenStart) {
            event.preventDefault();
            screenEnd = [event.x, event.y];
            const rectangle = RectangleClient.getRectangleByPoints([
                toActivePoint(board, ...screenStart),
                toActivePoint(board, ...screenEnd)
            ]);
            selectionMovingG?.remove();
            throttleRAF(board, 'with-selection', () => {
                if (screenStart && screenEnd) {
                    Transforms.setSelection(board, {
                        anchor: toViewBoxPoint(board, toHostPoint(board, screenStart[0], screenStart[1])),
                        focus: toViewBoxPoint(board, toHostPoint(board, screenEnd[0], screenEnd[1]))
                    });
                }
            });
            setSelectionMoving(board);
            selectionMovingG = drawRectangle(board, rectangle, {
                stroke: SELECTION_BORDER_COLOR,
                strokeWidth: 1,
                fill: SELECTION_FILL_COLOR,
                fillStyle: 'solid'
            });
            PlaitBoard.getActiveHost(board).append(selectionMovingG);
        }
        pointerMove(event);
    };
    // handle the end of click select
    board.pointerUp = (event) => {
        const isSetSelectionPointer = PlaitBoard.isPointer(board, PlaitPointerType.selection) || PlaitBoard.isPointer(board, PlaitPointerType.hand);
        const isSkip = !isMainPointer(event) || isDragging(board) || !isSetSelectionPointer;
        if (isSkip) {
            pointerUp(event);
            return;
        }
        const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
        const selection = { anchor: point, focus: point };
        Transforms.setSelection(board, selection);
        pointerUp(event);
    };
    board.globalPointerUp = (event) => {
        if (screenStart && screenEnd) {
            selectionMovingG?.remove();
            clearSelectionMoving(board);
            Transforms.setSelection(board, {
                anchor: toViewBoxPoint(board, toHostPoint(board, screenStart[0], screenStart[1])),
                focus: toViewBoxPoint(board, toHostPoint(board, screenEnd[0], screenEnd[1]))
            });
        }
        const options = getSelectionOptions(board);
        if (PlaitBoard.isFocus(board) && !options.isPreventClearSelection) {
            const isInBoard = event.target instanceof Node && PlaitBoard.getBoardContainer(board).contains(event.target);
            const isInDocument = event.target instanceof Node && document.contains(event.target);
            const isAttachedElement = event.target instanceof Element && event.target.closest(`.${ATTACHED_ELEMENT_CLASS_NAME}`);
            // Clear selection when mouse board outside area
            // The framework needs to determine whether the board is focused through selection
            if (!isInBoard && !screenStart && !isAttachedElement && isInDocument) {
                Transforms.setSelection(board, null);
            }
        }
        screenStart = null;
        screenEnd = null;
        if (timerId) {
            clearTimeout(timerId);
            timerId = null;
        }
        pointerDownEvent = null;
        globalPointerUp(event);
    };
    board.onChange = () => {
        const options = getSelectionOptions(board);
        if (options.isDisabledSelection) {
            clearSelectedElement(board);
        }
        // remove selected element if include
        board.operations.forEach((op) => {
            if (op.type === 'remove_node') {
                removeSelectedElement(board, op.node, true);
            }
        });
        if (isHandleSelection(board) && hasSetSelectionOperation(board)) {
            try {
                if (!isShift) {
                    selectionRectangleG?.remove();
                }
                const temporaryElements = getTemporaryElements(board);
                if (temporaryElements) {
                    cacheSelectedElements(board, [...temporaryElements]);
                }
                else {
                    let elements = getHitElementsBySelection(board);
                    if (!options.isMultipleSelection && elements.length > 1) {
                        elements = [elements[0]];
                    }
                    const isHitElementWithGroup = elements.some((item) => item.groupId);
                    const selectedElements = getSelectedElements(board);
                    if (isHitElementWithGroup) {
                        setSelectedElementsWithGroup(board, elements, isShift);
                    }
                    else {
                        if (board.selection && Selection.isCollapsed(board.selection)) {
                            const element = board.getOneHitElement(elements);
                            if (element) {
                                elements = [element];
                            }
                        }
                        if (isShift) {
                            const newElements = [...selectedElements];
                            if (board.selection && Selection.isCollapsed(board.selection)) {
                                elements.forEach((element) => {
                                    if (newElements.includes(element)) {
                                        newElements.splice(newElements.indexOf(element), 1);
                                    }
                                    else {
                                        newElements.push(element);
                                    }
                                });
                                cacheSelectedElements(board, newElements);
                            }
                            else {
                                elements.forEach((element) => {
                                    if (!newElements.includes(element)) {
                                        newElements.push(element);
                                    }
                                });
                                cacheSelectedElements(board, [...newElements]);
                            }
                        }
                        else {
                            cacheSelectedElements(board, [...elements]);
                        }
                    }
                }
                const newElements = getSelectedElements(board);
                deleteTemporaryElements(board);
                if (!isSelectionMoving(board)) {
                    selectionRectangleG?.remove();
                    if (newElements.length > 1) {
                        selectionRectangleG = board.drawSelectionRectangle();
                        PlaitBoard.getActiveHost(board).append(selectionRectangleG);
                    }
                }
            }
            catch (error) {
                console.error(error);
            }
        }
        onChange();
    };
    board.afterChange = () => {
        if (isHandleSelection(board) && !hasSetSelectionOperation(board)) {
            try {
                const currentSelectedElements = getSelectedElements(board);
                if (currentSelectedElements.length && currentSelectedElements.length > 1) {
                    selectionRectangleG?.remove();
                    selectionRectangleG = board.drawSelectionRectangle();
                    PlaitBoard.getActiveHost(board).append(selectionRectangleG);
                }
                else {
                    selectionRectangleG?.remove();
                }
            }
            catch (error) {
                console.error(error);
            }
        }
        afterChange();
    };
    setSelectionOptions(board, {
        isMultipleSelection: true,
        isDisabledSelection: false,
        isPreventClearSelection: false
    });
    return board;
}

const withI18n = (board) => {
    const newBoard = board;
    newBoard.getI18nValue = (key) => {
        console.warn(`I18n key "${key}" is not found.`);
        return null;
    };
    return newBoard;
};
const getI18nValue = (board, key, defaultValue = '') => {
    const i18nBoard = board;
    return i18nBoard.getI18nValue(key) || defaultValue;
};

/**
 * 1.create board instance
 * 2.build fake node weak map
 */
const createTestingBoard = (plugins, children, options = { readonly: false, hideScrollbar: true, disabledScrollOnNonFocus: false }) => {
    let board = createBoard(children, options);
    plugins.forEach(plugin => {
        board = plugin(board);
    });
    KEY_TO_ELEMENT_MAP.set(board, new Map());
    return board;
};

const fakeNodeWeakMap = (object) => {
    const children = object.children || [];
    children.forEach((value, index) => {
        NODE_TO_PARENT.set(value, object);
        NODE_TO_INDEX.set(value, index);
        fakeNodeWeakMap(value);
    });
};
const clearNodeWeakMap = (object) => {
    const children = object.children || [];
    children.forEach(value => {
        NODE_TO_PARENT.delete(value);
        NODE_TO_INDEX.delete(value);
        clearNodeWeakMap(value);
    });
};

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/** Used to generate unique IDs for events. */
let uniqueIds = 0;
/**
 * Creates a browser MouseEvent with the specified options.
 * @docs-private
 */
function createMouseEvent(type, clientX = 0, clientY = 0, offsetX = 1, offsetY = 1, button = 0, modifiers = {}) {
    // Note: We cannot determine the position of the mouse event based on the screen
    // because the dimensions and position of the browser window are not available
    // To provide reasonable `screenX` and `screenY` coordinates, we simply use the
    // client coordinates as if the browser is opened in fullscreen.
    const screenX = clientX;
    const screenY = clientY;
    const event = new MouseEvent(type, {
        bubbles: true,
        cancelable: true,
        composed: true, // Required for shadow DOM events.
        view: window,
        detail: 0,
        relatedTarget: null,
        screenX,
        screenY,
        clientX,
        clientY,
        ctrlKey: modifiers.control,
        altKey: modifiers.alt,
        shiftKey: modifiers.shift,
        metaKey: modifiers.meta,
        button: button,
        buttons: 1
    });
    // The `MouseEvent` constructor doesn't allow us to pass these properties into the constructor.
    // Override them to `1`, because they're used for fake screen reader event detection.
    if (offsetX != null) {
        defineReadonlyEventProperty(event, 'offsetX', offsetX);
    }
    if (offsetY != null) {
        defineReadonlyEventProperty(event, 'offsetY', offsetY);
    }
    return event;
}
/**
 * Creates a browser `PointerEvent` with the specified options. Pointer events
 * by default will appear as if they are the primary pointer of their type.
 * https://www.w3.org/TR/pointerevents2/#dom-pointerevent-isprimary.
 *
 * For example, if pointer events for a multi-touch interaction are created, the non-primary
 * pointer touches would need to be represented by non-primary pointer events.
 *
 * @docs-private
 */
function createPointerEvent(type, clientX = 0, clientY = 0, offsetX, offsetY, options = { isPrimary: true }) {
    const event = new PointerEvent(type, {
        bubbles: true,
        cancelable: true,
        composed: true, // Required for shadow DOM events.
        view: window,
        clientX,
        clientY,
        ...options
    });
    if (offsetX != null) {
        defineReadonlyEventProperty(event, 'offsetX', offsetX);
    }
    if (offsetY != null) {
        defineReadonlyEventProperty(event, 'offsetY', offsetY);
    }
    return event;
}
/**
 * Creates a browser TouchEvent with the specified pointer coordinates.
 * @docs-private
 */
function createTouchEvent(type, pageX = 0, pageY = 0, clientX = 0, clientY = 0) {
    // We cannot use the `TouchEvent` or `Touch` because Firefox and Safari lack support.
    const event = document.createEvent('UIEvent');
    const touchDetails = { pageX, pageY, clientX, clientY, identifier: uniqueIds++ };
    // TS3.6 removes the initUIEvent method and suggests porting to "new UIEvent()".
    event.initUIEvent(type, true, true, window, 0);
    // Most of the browsers don't have a "initTouchEvent" method that can be used to define
    // the touch details.
    defineReadonlyEventProperty(event, 'touches', [touchDetails]);
    defineReadonlyEventProperty(event, 'targetTouches', [touchDetails]);
    defineReadonlyEventProperty(event, 'changedTouches', [touchDetails]);
    return event;
}
/**
 * Creates a keyboard event with the specified key and modifiers.
 * @docs-private
 */
function createKeyboardEvent(type, keyCode = 0, key = '', modifiers = {}) {
    return new KeyboardEvent(type, {
        bubbles: true,
        cancelable: true,
        composed: true, // Required for shadow DOM events.
        view: window,
        keyCode: keyCode,
        key: key,
        shiftKey: modifiers.shift,
        metaKey: modifiers.meta,
        altKey: modifiers.alt,
        ctrlKey: modifiers.control
    });
}
/**
 * Creates a fake event object with any desired event type.
 * @docs-private
 */
function createFakeEvent(type, bubbles = false, cancelable = true, composed = true) {
    return new Event(type, { bubbles, cancelable, composed });
}
/**
 * Defines a readonly property on the given event object. Readonly properties on an event object
 * are always set as configurable as that matches default readonly properties for DOM event objects.
 */
function defineReadonlyEventProperty(event, propertyName, value) {
    Object.defineProperty(event, propertyName, { get: () => value, configurable: true });
}
function createModModifierKeys() {
    const modifiers = IS_MAC ? { meta: true } : { control: true };
    return modifiers;
}

/*
 * Public API Surface of plait
 */

/**
 * Generated bundle index. Do not edit.
 */

export { A, ACTIVE_MOVING_CLASS_NAME, ACTIVE_STROKE_WIDTH, ALT, APOSTROPHE, ATTACHED_ELEMENT_CLASS_NAME, AT_SIGN, B, BACKSLASH, BACKSPACE, BOARD_TO_AFTER_CHANGE, BOARD_TO_CONTEXT, BOARD_TO_ELEMENT_HOST, BOARD_TO_HOST, BOARD_TO_IS_SELECTION_MOVING, BOARD_TO_MOVING_ELEMENT, BOARD_TO_MOVING_POINT, BOARD_TO_MOVING_POINT_IN_BOARD, BOARD_TO_ON_CHANGE, BOARD_TO_ROUGH_SVG, BOARD_TO_SELECTED_ELEMENT, BOARD_TO_TEMPORARY_ELEMENTS, BOARD_TO_VIEWPORT_ORIGINATION, BoardTransforms, C, CAPS_LOCK, CLOSE_SQUARE_BRACKET, COMMA, CONTEXT_MENU, CONTROL, ColorfulThemeColor, CoreTransforms, CursorClass, D, DASH, DEFAULT_COLOR, DELETE, DOWN_ARROW, DRAG_SELECTION_PRESS_AND_MOVE_BUFFER, DarkThemeColor, DebugGenerator, DefaultThemeColor, Direction, E, EIGHT, ELEMENT_TO_REF, END, ENTER, EQUALS, ESCAPE, ElementFlavour, F, F1, F10, F11, F12, F2, F3, F4, F5, F6, F7, F8, F9, FF_EQUALS, FF_MINUS, FF_MUTE, FF_SEMICOLON, FF_VOLUME_DOWN, FF_VOLUME_UP, FIRST_MEDIA, FIVE, FLUSHING, FOUR, G, H, HISTORY, HIT_DISTANCE_BUFFER, HOME, HOST_CLASS_NAME, I, INSERT, IS_APPLE, IS_BOARD_ALIVE, IS_BOARD_CACHE, IS_CHROME, IS_CHROME_LEGACY, IS_DRAGGING, IS_EDGE_LEGACY, IS_FIREFOX, IS_IOS, IS_MAC, IS_SAFARI, IS_TEXT_EDITABLE, IS_WINDOWS, J, K, KEY_TO_ELEMENT_MAP, L, LAST_MEDIA, LEFT_ARROW, ListRender, M, MAC_ENTER, MAC_META, MAC_WK_CMD_LEFT, MAC_WK_CMD_RIGHT, MAX_RADIUS, MAX_ZOOM, MERGING, META, MIN_ZOOM, MUTE, N, NINE, NODE_TO_CONTAINER_G, NODE_TO_G, NODE_TO_INDEX, NODE_TO_PARENT, NS, NUMPAD_DIVIDE, NUMPAD_EIGHT, NUMPAD_FIVE, NUMPAD_FOUR, NUMPAD_MINUS, NUMPAD_MULTIPLY, NUMPAD_NINE, NUMPAD_ONE, NUMPAD_PERIOD, NUMPAD_PLUS, NUMPAD_SEVEN, NUMPAD_SIX, NUMPAD_THREE, NUMPAD_TWO, NUMPAD_ZERO, NUM_CENTER, NUM_LOCK, O, ONE, OPEN_SQUARE_BRACKET, P, PAGE_DOWN, PAGE_UP, PATH_REFS, PAUSE, PERIOD, PLUS_SIGN, POINTER_BUTTON, PRESS_AND_MOVE_BUFFER, PRINT_SCREEN, Path, PlaitBoard, PlaitBoardContext, PlaitElement, PlaitGroupElement, PlaitHistoryBoard, PlaitNode, PlaitOperation, PlaitPluginKey, PlaitPointerType, Point, Q, QUESTION_MARK, R, RESIZE_CURSORS, RESIZE_HANDLE_CLASS_NAME, RIGHT_ARROW, ROTATE_HANDLE_CLASS_NAME, RectangleClient, ResizeCursorClass, RetroThemeColor, S, SAVING, SCROLL_BAR_WIDTH, SCROLL_LOCK, SELECTION_BORDER_COLOR, SELECTION_FILL_COLOR, SELECTION_RECTANGLE_BOUNDING_CLASS_NAME, SELECTION_RECTANGLE_CLASS_NAME, SEMICOLON, SEVEN, SHIFT, SINGLE_QUOTE, SIX, SLASH, SNAPPING_STROKE_WIDTH, SNAP_TOLERANCE, SPACE, SPLITTING_ONCE, Selection, SoftThemeColor, StarryThemeColor, T, TAB, THREE, TILDE, TWO, ThemeColorMode, ThemeColors, Transforms, U, UP_ARROW, V, VIEWPORT_PADDING_RATIO, VOLUME_DOWN, VOLUME_UP, Viewport, W, WritableClipboardOperationType, WritableClipboardType, X, Y, Z, ZERO, ZOOM_STEP, addClipboardContext, addOrCreateClipboardContext, addSelectedElement, approximately, arrowPoints, buildPlaitHtml, cacheMovingElements, cacheSelectedElements, cacheSelectedElementsWithGroup, cacheSelectedElementsWithGroupOnShift, calcNewViewBox, calculateViewBox, canAddGroup, canRemoveGroup, canSetZIndex, catmullRomFitting, ceilToDecimal, clampZoomLevel, clearNodeWeakMap, clearSelectedElement, clearSelectionMoving, clearViewportOrigination, createBoard, createClipboardContext, createDebugGenerator, createFakeEvent, createForeignObject, createG, createGroup, createGroupRectangleG, createKeyboardEvent, createMask, createModModifierKeys, createMouseEvent, createPath, createPointerEvent, createRect, createSVG, createTestingBoard, createText, createTouchEvent, debounce, degreesToRadians, deleteFragment, deleteTemporaryElements, depthFirstRecursion, distanceBetweenPointAndPoint, distanceBetweenPointAndRectangle, distanceBetweenPointAndSegment, distanceBetweenPointAndSegments, downloadImage, drawArrow, drawBezierPath, drawCircle, drawDashedLines, drawLine, drawLinearPath, drawPendingNodesG, drawPointSnapLines, drawRectangle, drawRoundRectangle, drawSelectionRectangleG, drawSolidLines, duplicateElements, fakeNodeWeakMap, filterSelectedGroups, findElements, findIndex, findLastIndex, getAllElementsInGroup, getAllMoveOptions, getAngleBetweenPoints, getAngleByElement, getBarPoint, getBoardRectangle, getBoundingRectangleByElements, getClipboardData, getClipboardFromHtml, getCrossingPointsBetweenEllipseAndSegment, getDataTransferClipboard, getDataTransferClipboardText, getEditingGroup, getElementById, getElementHostBBox, getElementMap, getElementsInGroup, getElementsInGroupByElement, getElementsIndices, getEllipseArcCenter, getEllipseTangentSlope, getGroupByElement, getHighestGroup, getHighestIndexOfElement, getHighestSelectedElements, getHighestSelectedGroup, getHighestSelectedGroups, getHitElementByPoint, getHitElementsByPoint, getHitElementsBySelection, getHitSelectedElements, getI18nValue, getIsRecursionFunc, getMinPointDelta, getMovingElements, getNearestDelta, getNearestPointBetweenPointAndArc, getNearestPointBetweenPointAndDiscreteSegments, getNearestPointBetweenPointAndEllipse, getNearestPointBetweenPointAndSegment, getNearestPointBetweenPointAndSegments, getNearestPointRectangle, getOffsetAfterRotate, getOneMoveOptions, getPointBetween, getProbablySupportsClipboardRead, getProbablySupportsClipboardWrite, getProbablySupportsClipboardWriteText, getRealScrollBarWidth, getRectangleByAngle, getRectangleByElements, getRectangleByGroup, getRotatedBoundingRectangle, getSelectedElements, getSelectedGroups, getSelectedIsolatedElements, getSelectedIsolatedElementsCanAddToGroup, getSelectedTargetElements, getSelectionAngle, getSelectionOptions, getSnapRectangles, getTemporaryElements, getTemporaryRef, getTripleAxis, getValidElements, getVectorFromPointAndSlope, getViewBox, getViewBoxCenterPoint, getViewportContainerRect, getViewportOrigination, hasBeforeContextChange, hasInputOrTextareaTarget, hasOnContextChanged, hasSameAngle, hasSelectedElementsInSameGroup, hasSetSelectionOperation, hasValidAngle, hotkeys, idCreator, initializeViewBox, initializeViewportContainer, initializeViewportOffset, inverse, isAxisChangedByAngle, isContextmenu, isDOMElement, isDOMNode, isDebug, isDragging, isFromScrolling, isFromViewportChange, isHandleSelection, isHitElement, isHitSelectedRectangle, isHorizontalDirection, isInPlaitBoard, isIndicesContinuous, isLineHitLine, isLineHitRectangle, isLineHitRectangleEdge, isMainPointer, isMobileDeviceEvent, isMouseEvent, isMovingElements, isNullOrUndefined, isPencilEvent, isPointInEllipse, isPointInPolygon, isPointInRoundRectangle, isSecondaryPointer, isSelectedAllElementsInGroup, isSelectedElement, isSelectedElementOrGroup, isSelectionMoving, isSetSelectionOperation, isSetThemeOperation, isSetViewportOperation, isSingleLineHitRectangleEdge, isSnapPoint, isTouchEvent, isValidAngle, isVerticalDirection, isWheelPointer, mountElementG, moveElementsToNewPath, moveElementsToNewPathAfterAddGroup, nonGroupInHighestSelectedElements, normalizeAngle, normalizePoint, prepareElementBBox, radiansToDegrees, removeMovingElements, removeSelectedElement, replaceAngleBrackets, replaceSelectedElement, reverseReplaceAngleBrackets, rgbaToHEX, rotate, rotateAntiPointsByElement, rotateElements, rotatePoints, rotatePointsByAngle, rotatePointsByElement, rotatedDataPoints, scrollToRectangle, setAngleForG, setClipboardData, setDataTransferClipboard, setDataTransferClipboardText, setDragging, setFragment, setIsFromScrolling, setIsFromViewportChange, setPathStrokeLinecap, setSVGViewBox, setSelectedElementsWithGroup, setSelectionMoving, setSelectionOptions, setStrokeLinecap, shouldClear, shouldMerge, shouldSave, sortElements, stripHtml, temporaryDisableSelection, throttleRAF, toActivePoint, toActivePointFromViewBoxPoint, toActiveRectangleFromViewBoxRectangle, toDomPrecision, toFixed, toHostPoint, toHostPointFromViewBoxPoint, toImage, toScreenPointFromActivePoint, toScreenPointFromHostPoint, toViewBoxPoint, toViewBoxPoints, uniqueById, updateForeignObject, updateForeignObjectWidth, updatePoints, updateViewBox, updateViewportByScrolling, updateViewportContainerScroll, updateViewportOffset, updateViewportOrigination, withArrowMoving, withBoard, withHandPointer, withHistory, withHotkey, withI18n, withMoving, withOptions, withRelatedFragment, withSelection };
//# sourceMappingURL=plait-core.mjs.map
