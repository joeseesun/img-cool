import { PlaitOperation } from './operation';
export interface PathLevelsOptions {
    reverse?: boolean;
}
export type Path = number[];
export declare const Path: {
    /**
     * Get a list of ancestor paths for a given path.
     *
     * The paths are sorted from shallowest to deepest ancestor. However, if the
     * `reverse: true` option is passed, they are reversed.
     */
    ancestors(path: Path, options?: PathLevelsOptions): Path[];
    /**
     * Get a list of paths at every level down to a path. Note: this is the same
     * as `Path.ancestors`, but including the path itself.
     *
     * The paths are sorted from shallowest to deepest. However, if the `reverse:
     * true` option is passed, they are reversed.
     */
    levels(path: Path, options?: PathLevelsOptions): Path[];
    parent(path: Path): Path;
    next(path: Path): Path;
    hasPrevious(path: Path): boolean;
    previous(path: Path): Path;
    /**
     * Check if a path is an ancestor of another.
     */
    isAncestor(path: Path, another: Path): boolean;
    /**
     * Compare a path to another, returning an integer indicating whether the path
     * was before, at, or after the other.
     *
     * Note: Two paths of unequal length can still receive a `0` result if one is
     * directly above or below the other. If you want exact matching, use
     * [[Path.equals]] instead.
     */
    compare(path: Path, another: Path): -1 | 0 | 1;
    /**
     * Check if a path is exactly equal to another.
     */
    equals(path: Path, another: Path): boolean;
    /**
     * Check if a path ends before one of the indexes in another.
     */
    endsBefore(path: Path, another: Path): boolean;
    /**
     * Check if a path is a sibling of another.
     */
    isSibling(path: Path, another: Path): boolean;
    transform(path: Path | null, operation: PlaitOperation): Path | null;
};
