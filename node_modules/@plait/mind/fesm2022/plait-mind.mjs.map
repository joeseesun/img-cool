{"version":3,"file":"plait-mind.mjs","sources":["../../../packages/mind/src/utils/weak-maps.ts","../../../packages/mind/src/interfaces/node.ts","../../../packages/mind/src/interfaces/layout.ts","../../../packages/mind/src/interfaces/pointer.ts","../../../packages/mind/src/constants/theme.ts","../../../packages/mind/src/interfaces/theme-color.ts","../../../packages/mind/src/constants/default.ts","../../../packages/mind/src/utils/space/emoji.ts","../../../packages/mind/src/utils/node-style/common.ts","../../../packages/mind/src/constants/node-style.ts","../../../packages/mind/src/utils/abstract/common.ts","../../../packages/mind/src/utils/node-style/branch.ts","../../../packages/mind/src/utils/node-style/shape.ts","../../../packages/mind/src/utils/node/common.ts","../../../packages/mind/src/utils/layout.ts","../../../packages/mind/src/utils/space/layout-options.ts","../../../packages/mind/src/constants/node-topic-style.ts","../../../packages/mind/src/constants/abstract-node.ts","../../../packages/mind/src/utils/common.ts","../../../packages/mind/src/utils/node/create-node.ts","../../../packages/mind/src/utils/mind.ts","../../../packages/mind/src/utils/space/node-space.ts","../../../packages/mind/src/utils/position/node.ts","../../../packages/mind/src/utils/position/emoji.ts","../../../packages/mind/src/utils/position/topic.ts","../../../packages/mind/src/utils/position/image.ts","../../../packages/mind/src/utils/node/adjust-node.ts","../../../packages/mind/src/utils/node/image.ts","../../../packages/mind/src/utils/node/dynamic-width.ts","../../../packages/mind/src/utils/dnd/common.ts","../../../packages/mind/src/utils/dnd/detector.ts","../../../packages/mind/src/utils/draw/node-shape.ts","../../../packages/mind/src/interfaces/types.ts","../../../packages/mind/src/utils/point-placement.ts","../../../packages/mind/src/utils/draw/node-link/indented-link.ts","../../../packages/mind/src/utils/draw/node-link/logic-link.ts","../../../packages/mind/src/utils/draw/node-link/draw-link.ts","../../../packages/mind/src/generators/node-emojis.generator.ts","../../../packages/mind/src/utils/draw/node-dnd.ts","../../../packages/mind/src/plugins/with-abstract-resize.board.ts","../../../packages/mind/src/utils/draw/abstract-outline.ts","../../../packages/mind/src/generators/node-active.generator.ts","../../../packages/mind/src/utils/abstract/resize.ts","../../../packages/mind/src/utils/node/right-node-count.ts","../../../packages/mind/src/utils/path.ts","../../../packages/mind/src/queries/get-correct-layout-by-element.ts","../../../packages/mind/src/queries/get-branch-layouts.ts","../../../packages/mind/src/queries/get-available-sublayouts-by-element.ts","../../../packages/mind/src/queries/get-layout-by-element.ts","../../../packages/mind/src/queries/index.ts","../../../packages/mind/src/interfaces/element.ts","../../../packages/mind/src/utils/draw/node-link/abstract-link.ts","../../../packages/mind/src/transforms/abstract-node.ts","../../../packages/mind/src/transforms/node.ts","../../../packages/mind/src/transforms/emoji.ts","../../../packages/mind/src/transforms/image.ts","../../../packages/mind/src/transforms/layout.ts","../../../packages/mind/src/transforms/property.ts","../../../packages/mind/src/transforms/index.ts","../../../packages/mind/src/generators/node-shape.generator.ts","../../../packages/mind/src/generators/node-more.generator.ts","../../../packages/mind/src/mind-node.component.ts","../../../packages/mind/src/mind.component.ts","../../../packages/mind/src/plugins/with-node-dnd.ts","../../../packages/mind/src/plugins/with-abstract-resize.ts","../../../packages/mind/src/plugins/with-mind-extend.ts","../../../packages/mind/src/plugins/with-mind-create.ts","../../../packages/mind/src/plugins/with-mind-hotkey.ts","../../../packages/mind/src/plugins/with-node-more.ts","../../../packages/mind/src/plugins/with-node-image.ts","../../../packages/mind/src/plugins/with-node-resize.ts","../../../packages/mind/src/plugins/with-node-image-resize.ts","../../../packages/mind/src/utils/clipboard.ts","../../../packages/mind/src/plugins/with-mind-fragment.ts","../../../packages/mind/src/emoji/with-emoji.ts","../../../packages/mind/src/utils/normalize.ts","../../../packages/mind/src/plugins/with-mind.ts","../../../packages/mind/src/emoji/emoji-base.component.ts","../../../packages/mind/src/public-api.ts","../../../packages/mind/src/plait-mind.ts"],"sourcesContent":["import { MindElement } from '../interfaces/element';\nimport { MindNode } from '../interfaces/node';\n\nexport const ELEMENT_TO_NODE = new WeakMap<MindElement, MindNode>();\n","import { MindLayoutType } from '@plait/layouts';\nimport { Path } from '@plait/core';\nimport { MindElement } from './element';\n\nexport interface MindNode {\n    depth: number;\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    hGap: number;\n    vGap: number;\n    children: MindNode[];\n    origin: MindElement;\n    parent: MindNode;\n    left: boolean;\n    up: boolean;\n}\n\nexport const MindNode = {\n    get(root: MindNode, path: Path) {\n        let node = root;\n        for (let i = 0; i < path.length; i++) {\n            const p = path[i];\n            if (!node || !node.children || !node.children[p]) {\n                throw new Error(`Cannot find a descendant at path [${path}]`);\n            }\n            node = node.children[p];\n        }\n        return node;\n    }\n};\n\nexport type ExtendLayoutType = Exclude<MindLayoutType, MindLayoutType.standard>;\n\nexport type CoordinateType = {\n    startX: number;\n    startY: number;\n    endX: number;\n    endY: number;\n};\n\nexport type ExtendUnderlineCoordinateType = {\n    [key in ExtendLayoutType]: CoordinateType;\n};\n\nexport type DetectResult = 'top' | 'bottom' | 'right' | 'left' | null;\n\nexport type RootBaseDirection = 'right' | 'left' | null;\n","import { MindLayoutType } from '@plait/layouts';\n\nexport enum LayoutDirection {\n    'top' = 'top',\n    'right' = 'right',\n    'bottom' = 'bottom',\n    'left' = 'left'\n}\n\nexport const LayoutDirectionsMap: LayoutDirectionMapType = {\n    [MindLayoutType.right]: [LayoutDirection.right],\n    [MindLayoutType.left]: [LayoutDirection.left],\n    [MindLayoutType.upward]: [LayoutDirection.top],\n    [MindLayoutType.downward]: [LayoutDirection.bottom],\n    [MindLayoutType.rightBottomIndented]: [LayoutDirection.right, LayoutDirection.bottom],\n    [MindLayoutType.rightTopIndented]: [LayoutDirection.right, LayoutDirection.top],\n    [MindLayoutType.leftBottomIndented]: [LayoutDirection.left, LayoutDirection.bottom],\n    [MindLayoutType.leftTopIndented]: [LayoutDirection.left, LayoutDirection.top]\n};\n\nexport type LayoutDirectionMapType = { [key: string]: LayoutDirection[] };\n","export enum MindPointerType {\n    'mind' = 'mind'\n}\n","export const DEFAULT_BRANCH_COLORS = [\n    '#A287E0',\n    '#6E80DB',\n    '#6DC4C4',\n    '#E0B75E',\n    '#B1C675',\n    '#77C386',\n    '#C18976',\n    '#E48484',\n    '#E582D4',\n    '#6AB1E4'\n];\n\nexport const COLORFUL_BRANCH_COLORS = [\n    '#F94239',\n    '#FF8612',\n    '#F3D222',\n    '#B3D431',\n    '#00BC7B',\n    '#06ADBF',\n    '#476BFF',\n    '#4E49BE',\n    '#8957E5',\n    '#FE5DA1'\n];\n\nexport const SOFT_BRANCH_COLORS = [\n    '#6D89C1',\n    '#F2BDC7',\n    '#B796D9',\n    '#5BA683',\n    '#B3D431 ',\n    '#F2DC6C',\n    '#F7C98D',\n    '#60B4D1',\n    '#838F9E',\n    '#C1A381'\n];\n\nexport const RETRO_BRANCH_COLORS = [\n    '#459476',\n    '#9A894F',\n    '#D48444',\n    '#E9C358 ',\n    '#4B9D9D',\n    '#C14C41',\n    '#827086 ',\n    '#60718D',\n    '#D38183',\n    '#9DC19D'\n];\n\nexport const DARK_BRANCH_COLORS = [\n    '#3DD1AE',\n    '#F6C659',\n    '#A9E072',\n    '#FF877B ',\n    '#F693E7',\n    '#5DCFFF',\n    '#868AF6',\n    '#4C6DC7',\n    '#D97C26',\n    '#268FAC'\n];\n\nexport const STARRY_BRANCH_COLORS = [\n    '#E46C57',\n    '#579360',\n    '#B98339',\n    '#3A62D1 ',\n    '#B883B7',\n    '#42ABE5',\n    '#2B9D8F',\n    '#A4705E',\n    '#265833',\n    '#787865'\n];\n","import {\n    DefaultThemeColor,\n    StarryThemeColor,\n    ThemeColor,\n    ThemeColorMode,\n    DarkThemeColor,\n    ColorfulThemeColor,\n    SoftThemeColor,\n    RetroThemeColor,\n    DEFAULT_COLOR\n} from '@plait/core';\nimport {\n    COLORFUL_BRANCH_COLORS,\n    DARK_BRANCH_COLORS,\n    DEFAULT_BRANCH_COLORS,\n    RETRO_BRANCH_COLORS,\n    SOFT_BRANCH_COLORS,\n    STARRY_BRANCH_COLORS\n} from '../constants/theme';\n\nexport interface MindThemeColor extends ThemeColor {\n    mode: ThemeColorMode | string;\n    branchColors: string[];\n    rootFill: string;\n    rootTextColor: string;\n}\n\nexport const MindDefaultThemeColor: MindThemeColor = {\n    ...DefaultThemeColor,\n    branchColors: DEFAULT_BRANCH_COLORS,\n    rootFill: '#f5f5f5',\n    rootTextColor: DEFAULT_COLOR\n};\n\nexport const MindColorfulThemeColor: MindThemeColor = {\n    ...ColorfulThemeColor,\n    branchColors: COLORFUL_BRANCH_COLORS,\n    rootFill: DEFAULT_COLOR,\n    rootTextColor: '#FFFFFF'\n};\n\nexport const MindSoftThemeColor: MindThemeColor = {\n    ...SoftThemeColor,\n    branchColors: SOFT_BRANCH_COLORS,\n    rootFill: '#FFFFFF',\n    rootTextColor: DEFAULT_COLOR\n};\n\nexport const MindRetroThemeColor: MindThemeColor = {\n    ...RetroThemeColor,\n    branchColors: RETRO_BRANCH_COLORS,\n    rootFill: '#153D5D',\n    rootTextColor: '#FFFFFF'\n};\n\nexport const MindDarkThemeColor: MindThemeColor = {\n    ...DarkThemeColor,\n    branchColors: DARK_BRANCH_COLORS,\n    rootFill: '#FFFFFF',\n    rootTextColor: DEFAULT_COLOR\n};\n\nexport const MindStarryThemeColor: MindThemeColor = {\n    ...StarryThemeColor,\n    branchColors: STARRY_BRANCH_COLORS,\n    rootFill: '#FFFFFF',\n    rootTextColor: DEFAULT_COLOR\n};\n\nexport const MindThemeColors: MindThemeColor[] = [\n    MindDefaultThemeColor,\n    MindColorfulThemeColor,\n    MindSoftThemeColor,\n    MindRetroThemeColor,\n    MindDarkThemeColor,\n    MindStarryThemeColor\n];\n\nexport const MindThemeColor = {\n    isMindThemeColor(value: any): value is MindThemeColor {\n        if (value.branchColors && value.rootFill && value.rootTextColor) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n};\n","import { rgbaToHEX } from \"@plait/core\";\n\nexport const WithMindPluginKey = 'plait-mind-plugin-key';\n\nexport const BASE = 4;\nexport const PRIMARY_COLOR = '#6698FF';\nexport const GRAY_COLOR = '#AAAAAA';\nexport const STROKE_WIDTH = 2;\n\nexport const RESIZE_HANDLE_BUFFER_DISTANCE = 8;\n\nexport const NODE_MORE_LINE_DISTANCE = 10;\n\nexport const NODE_MORE_STROKE_WIDTH = 2;\n\nexport const NODE_MORE_ICON_DIAMETER = 20;\n\nexport const NODE_MORE_BRIDGE_DISTANCE = 10;\n\nexport const NODE_ADD_CIRCLE_COLOR = rgbaToHEX('#000000', 0.2);\n\nexport const NODE_ADD_HOVER_COLOR = '#6698FF';\n\nexport const NODE_ADD_INNER_CROSS_COLOR = 'white';\n\nexport const DEFAULT_MIND_IMAGE_WIDTH = 240;\n\nexport enum MindI18nKey {\n    mindCentralText = 'mind-center-text',\n    abstractNodeText = 'abstract-node-text'\n}","import { WithMindPluginKey } from '../../constants/default';\nimport { EmojiData, MindElement, PlaitMind } from '../../interfaces';\nimport { WithMindOptions } from '../../interfaces/options';\nimport { PlaitMindBoard } from '../../plugins/with-mind.board';\n\nexport function getEmojisWidthHeight(board: PlaitMindBoard, element: MindElement<EmojiData>) {\n    const options = board.getPluginOptions<WithMindOptions>(WithMindPluginKey);\n    const count = element.data.emojis.length;\n    const fontSize = getEmojiFontSize(element);\n    return {\n        width: fontSize * count + count * 2 * options.emojiPadding + (count - 1) * options.spaceBetweenEmojis,\n        height: element.height\n    };\n}\n\nexport function getEmojiFontSize(element: MindElement<EmojiData>) {\n    if (PlaitMind.isMind(element)) {\n        return 18 + 2;\n    } else {\n        return 14 + 2;\n    }\n}\n","import { PlaitBoard } from '@plait/core';\nimport { MindElement } from '../../interfaces/element';\n\nexport const getAvailableProperty = (board: PlaitBoard, element: MindElement, propertyKey: keyof MindElement) => {\n    return element[propertyKey];\n};\n","import { GRAY_COLOR } from './default';\n\nexport const DefaultAbstractNodeStyle = {\n    branch: { color: GRAY_COLOR, width: 2 },\n    shape: {\n        strokeColor: GRAY_COLOR,\n        strokeWidth: 2\n    }\n};\n\nexport const DefaultNodeStyle = {\n    branch: {\n        width: 2\n    },\n    shape: {\n        rectangleRadius: 4,\n        strokeWidth: 2,\n        fill: 'none'\n    }\n};\n","import { AbstractNode } from '@plait/layouts';\nimport { MindElement, PlaitMind } from '../../interfaces/element';\nimport { Path, PlaitBoard, PlaitElement, PlaitNode } from '@plait/core';\n\nexport const separateChildren = (parentElement: MindElement) => {\n    const rightNodeCount = parentElement.rightNodeCount!;\n    const children = parentElement.children;\n    let rightChildren = [],\n        leftChildren = [];\n\n    for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        if (AbstractNode.isAbstract(child) && child.end < rightNodeCount) {\n            rightChildren.push(child);\n            continue;\n        }\n        if (AbstractNode.isAbstract(child) && child.start >= rightNodeCount) {\n            leftChildren.push(child);\n            continue;\n        }\n\n        if (i < rightNodeCount) {\n            rightChildren.push(child);\n        } else {\n            leftChildren.push(child);\n        }\n    }\n\n    return { leftChildren, rightChildren };\n};\n\nexport const isSetAbstract = (element: PlaitElement) => {\n    return !!getCorrespondingAbstract(element as MindElement);\n};\n\nexport const canSetAbstract = (element: PlaitElement) => {\n    return !PlaitElement.isRootElement(element) && !AbstractNode.isAbstract(element) && !isSetAbstract(element);\n};\n\nexport const getCorrespondingAbstract = (element: MindElement) => {\n    const parent = MindElement.findParent(element as MindElement);\n    if (!parent) return undefined;\n\n    const elementIndex = parent.children.indexOf(element);\n    return parent.children.find(child => {\n        return AbstractNode.isAbstract(child) && elementIndex >= child.start! && elementIndex <= child.end!;\n    });\n};\n\nexport const getBehindAbstracts = (element: MindElement) => {\n    const parent = MindElement.findParent(element as MindElement);\n    if (!parent) return [];\n    const index = parent.children.indexOf(element);\n    return parent.children.filter(child => AbstractNode.isAbstract(child) && child.start! > index);\n};\n\n/**\n * return corresponding abstract that is not child of elements\n */\nexport const getOverallAbstracts = (board: PlaitBoard, elements: MindElement[]) => {\n    const overallAbstracts: MindElement[] = [];\n    elements\n        .filter(value => !AbstractNode.isAbstract(value) && !PlaitMind.isMind(value))\n        .forEach(value => {\n            const abstract = getCorrespondingAbstract(value);\n            if (abstract && elements.indexOf(abstract) === -1 && overallAbstracts.indexOf(abstract) === -1) {\n                const { start, end } = abstract;\n                const parent = MindElement.getParent(value);\n                const isOverall = parent.children.slice(start!, end! + 1).every(includedElement => elements.indexOf(includedElement) > -1);\n                if (isOverall) {\n                    overallAbstracts.push(abstract);\n                }\n            }\n        });\n    return overallAbstracts as (MindElement & AbstractNode)[];\n};\n\nexport interface AbstractRef {\n    abstract: MindElement & AbstractNode;\n    references: MindElement[];\n}\n\n/**\n * abstract node is valid when elements contains at least one element it is referenced with\n */\nexport const getValidAbstractRefs = (board: PlaitBoard, elements: MindElement[]) => {\n    const validAbstractRefs: AbstractRef[] = [];\n    elements\n        .filter(value => !AbstractNode.isAbstract(value) && !PlaitMind.isMind(value))\n        .forEach(value => {\n            const abstract = getCorrespondingAbstract(value);\n            if (abstract && elements.indexOf(abstract) > 0) {\n                const index = validAbstractRefs.findIndex(value => value.abstract === abstract);\n                if (index === -1) {\n                    validAbstractRefs.push({\n                        abstract: abstract as MindElement & AbstractNode,\n                        references: [value]\n                    });\n                } else {\n                    validAbstractRefs[index].references.push(value);\n                }\n            }\n        });\n    return validAbstractRefs;\n};\n\nexport function getRelativeStartEndByAbstractRef(abstractRef: AbstractRef, elements: MindElement[]) {\n    const start = elements.indexOf(abstractRef.references[0]);\n    const end = elements.indexOf(abstractRef.references[abstractRef.references.length - 1]);\n    return { start, end };\n}\n\nexport const insertElementHandleAbstract = (\n    board: PlaitBoard,\n    path: Path,\n    step = 1,\n    // This distinguishes between dragging and adding to the last node summarized in the abstract node\n    isExtendPreviousNode: boolean = true,\n    effectedAbstracts = new Map<MindElement, Pick<AbstractNode, 'start' | 'end'>>()\n) => {\n    const parent = PlaitNode.parent(board, path) as MindElement;\n    const hasPreviousNode = path[path.length - 1] !== 0;\n    let behindAbstracts: MindElement[];\n\n    if (!hasPreviousNode) {\n        behindAbstracts = parent.children.filter(child => AbstractNode.isAbstract(child));\n    } else {\n        const selectedElement = PlaitNode.get(board, Path.previous(path)) as MindElement;\n        behindAbstracts = getBehindAbstracts(selectedElement);\n    }\n\n    if (behindAbstracts.length) {\n        behindAbstracts.forEach(abstract => {\n            let newProperties = effectedAbstracts.get(abstract);\n            if (!newProperties) {\n                newProperties = { start: 0, end: 0 };\n                effectedAbstracts.set(abstract, newProperties);\n            }\n            newProperties.start = newProperties.start + step;\n            newProperties.end = newProperties.end + step;\n        });\n    }\n\n    if (!hasPreviousNode) {\n        return effectedAbstracts;\n    }\n\n    const selectedElement = PlaitNode.get(board, Path.previous(path)) as MindElement;\n    const correspondingAbstract = getCorrespondingAbstract(selectedElement);\n    const isDragToLast = !isExtendPreviousNode && correspondingAbstract && correspondingAbstract.end === path[path.length - 1] - 1;\n\n    if (correspondingAbstract && !isDragToLast) {\n        let newProperties = effectedAbstracts.get(correspondingAbstract);\n        if (!newProperties) {\n            newProperties = { start: 0, end: 0 };\n            effectedAbstracts.set(correspondingAbstract, newProperties);\n        }\n        newProperties.end = newProperties.end + step;\n    }\n\n    return effectedAbstracts;\n};\n\nexport const deleteElementHandleAbstract = (\n    board: PlaitBoard,\n    deletableElements: MindElement[],\n    effectedAbstracts = new Map<MindElement, Pick<AbstractNode, 'start' | 'end'>>()\n) => {\n    deletableElements.forEach(node => {\n        if (!PlaitMind.isMind(node)) {\n            const behindAbstracts = getBehindAbstracts(node).filter(abstract => !deletableElements.includes(abstract));\n            if (behindAbstracts.length) {\n                behindAbstracts.forEach(abstract => {\n                    let newProperties = effectedAbstracts.get(abstract);\n                    if (!newProperties) {\n                        newProperties = { start: 0, end: 0 };\n                        effectedAbstracts.set(abstract, newProperties);\n                    }\n                    newProperties.start = newProperties.start - 1;\n                    newProperties.end = newProperties.end - 1;\n                });\n            }\n\n            const correspondingAbstract = getCorrespondingAbstract(node);\n            if (correspondingAbstract && !deletableElements.includes(correspondingAbstract)) {\n                let newProperties = effectedAbstracts.get(correspondingAbstract);\n                if (!newProperties) {\n                    newProperties = { start: 0, end: 0 };\n\n                    effectedAbstracts.set(correspondingAbstract, newProperties);\n                }\n                newProperties.end = newProperties.end - 1;\n            }\n        }\n    });\n    return effectedAbstracts;\n};\n\nexport const isChildOfAbstract = (board: PlaitBoard, element: MindElement) => {\n    const ancestors = MindElement.getAncestors(board, element) as MindElement[];\n    return !!ancestors.find(value => AbstractNode.isAbstract(value));\n};\n","/**\n * Processing of branch color, width, style, etc. of the mind node\n */\nimport { PlaitBoard, isNullOrUndefined } from '@plait/core';\nimport { BranchShape, MindElement } from '../../interfaces/element';\nimport { STROKE_WIDTH } from '../../constants/default';\nimport { DefaultAbstractNodeStyle } from '../../constants/node-style';\nimport { getAvailableProperty } from './common';\nimport { MindDefaultThemeColor, MindThemeColor } from '../../interfaces/theme-color';\nimport { AbstractNode } from '@plait/layouts';\nimport { isChildOfAbstract } from '../abstract/common';\n\nexport const getBranchColorByMindElement = (board: PlaitBoard, element: MindElement) => {\n    if (AbstractNode.isAbstract(element) || isChildOfAbstract(board, element)) {\n        return getAbstractBranchColor(board, element);\n    }\n\n    const branchColor = getAvailableProperty(board, element, 'branchColor') || getAvailableProperty(board, element, 'strokeColor');\n    return branchColor || getDefaultBranchColor(board, element);\n};\n\nexport const getBranchShapeByMindElement = (board: PlaitBoard, element: MindElement) => {\n    const branchShape = getAvailableProperty(board, element, 'branchShape');\n    return branchShape || BranchShape.bight;\n};\n\nexport const getBranchWidthByMindElement = (board: PlaitBoard, element: MindElement) => {\n    const branchWidth = getAvailableProperty(board, element, 'branchWidth') || getAvailableProperty(board, element, 'strokeWidth');\n    return branchWidth || STROKE_WIDTH;\n};\n\nexport const getAbstractBranchWidth = (board: PlaitBoard, element: MindElement) => {\n    if (!isNullOrUndefined(element.branchWidth)) {\n        return element.branchWidth as number;\n    }\n    return DefaultAbstractNodeStyle.branch.width;\n};\n\nexport const getAbstractBranchColor = (board: PlaitBoard, element: MindElement) => {\n    if (element.branchColor || element.strokeColor) {\n        return element.branchColor || element.strokeColor;\n    }\n    return DefaultAbstractNodeStyle.branch.color;\n};\n\nexport const getNextBranchColor = (board: PlaitBoard, root: MindElement) => {\n    const index = root.children.length;\n    return getDefaultBranchColorByIndex(board, index);\n};\n\nexport const getDefaultBranchColor = (board: PlaitBoard, element: MindElement) => {\n    const path = PlaitBoard.findPath(board, element);\n    return getDefaultBranchColorByIndex(board, path[1]);\n};\n\nexport const getDefaultBranchColorByIndex = (board: PlaitBoard, index: number) => {\n    const themeColor = getMindThemeColor(board);\n    const length = themeColor.branchColors.length;\n    const remainder = index % length;\n    return themeColor.branchColors[remainder];\n};\n\nexport const getMindThemeColor = (board: PlaitBoard) => {\n    const themeColors = PlaitBoard.getThemeColors(board);\n    const themeColor = themeColors.find(val => val.mode === board.theme.themeColorMode);\n    if (themeColor && MindThemeColor.isMindThemeColor(themeColor)) {\n        return themeColor;\n    } else {\n        return MindDefaultThemeColor;\n    }\n};\n","import { PlaitBoard } from '@plait/core';\nimport { MindElement, MindElementShape, PlaitMind } from '../../interfaces/element';\nimport { getAvailableProperty } from './common';\nimport { getDefaultBranchColor, getMindThemeColor } from './branch';\nimport { AbstractNode } from '@plait/layouts';\nimport { isChildOfAbstract } from '../abstract/common';\nimport { DefaultAbstractNodeStyle, DefaultNodeStyle } from '../../constants/node-style';\nimport { StrokeStyle } from '@plait/common';\n\nexport const getStrokeColorByElement = (board: PlaitBoard, element: MindElement) => {\n    if (PlaitMind.isMind(element)) {\n        const defaultRootStroke = getMindThemeColor(board).rootFill;\n        return element.strokeColor || defaultRootStroke;\n    }\n\n    if (AbstractNode.isAbstract(element) || isChildOfAbstract(board, element)) {\n        return element.strokeColor || DefaultAbstractNodeStyle.shape.strokeColor;\n    }\n\n    return getAvailableProperty(board, element, 'strokeColor') || getDefaultBranchColor(board, element);\n};\n\nexport const getStrokeStyleByElement = (board: PlaitBoard, element: MindElement) => {\n    return element.strokeStyle || StrokeStyle.solid;\n};\n\nexport const getStrokeWidthByElement = (board: PlaitBoard, element: MindElement) => {\n    const strokeWidth =\n        element.strokeWidth ||\n        (AbstractNode.isAbstract(element) ? DefaultAbstractNodeStyle.shape.strokeWidth : DefaultNodeStyle.shape.strokeWidth);\n    return strokeWidth;\n};\n\nexport const getFillByElement = (board: PlaitBoard, element: MindElement) => {\n    if (element.fill) {\n        return element.fill;\n    }\n    const defaultRootFill = getMindThemeColor(board).rootFill;\n    return element.isRoot ? defaultRootFill : DefaultNodeStyle.shape.fill;\n};\n\nexport const getShapeByElement = (board: PlaitBoard, element: MindElement): MindElementShape => {\n    const shape = getAvailableProperty(board, element, 'shape');\n    return shape || MindElementShape.roundRectangle;\n};\n","import { PlaitBoard, PlaitElement, getSelectedElements } from '@plait/core';\nimport { MindElement } from '../../interfaces/element';\nimport { getFirstTextManage } from '@plait/common';\n\nexport function editTopic(element: MindElement) {\n    const textManage = getFirstTextManage(element);\n    textManage?.edit(\n        () => {},\n        event => {\n            const keyboardEvent = event as KeyboardEvent;\n            return keyboardEvent.key === 'Enter' && !keyboardEvent.shiftKey;\n        }\n    );\n}\n\nexport const getSelectedMindElements = (board: PlaitBoard, elements?: PlaitElement[]) => {\n    const selectedElements = elements?.length ? elements : getSelectedElements(board);\n    return selectedElements.filter(value => MindElement.isMindElement(board, value)) as MindElement[];\n};\n","import { LayoutDirection, LayoutDirectionsMap, MindElement, PlaitMind } from '../interfaces';\nimport { isIndentedLayout, MindLayoutType } from '@plait/layouts';\n\nexport const getBranchDirectionsByLayouts = (branchLayouts: MindLayoutType[]) => {\n    const branchDirections: LayoutDirection[] = [];\n    branchLayouts.forEach(l => {\n        const directions = LayoutDirectionsMap[l];\n        directions.forEach(d => {\n            if (!branchDirections.includes(d) && !branchDirections.includes(getLayoutReverseDirection(d))) {\n                branchDirections.push(d);\n            }\n        });\n    });\n    return branchDirections;\n};\n\nexport const isCorrectLayout = (root: MindElement, layout: MindLayoutType) => {\n    const rootLayout = root.layout || getDefaultLayout();\n    return !getInCorrectLayoutDirection(rootLayout, layout);\n};\n\nexport const isMixedLayout = (parentLayout: MindLayoutType, layout: MindLayoutType) => {\n    return (!isIndentedLayout(parentLayout) && isIndentedLayout(layout)) || (isIndentedLayout(parentLayout) && !isIndentedLayout(layout));\n};\n\nexport const getInCorrectLayoutDirection = (rootLayout: MindLayoutType, layout: MindLayoutType) => {\n    const directions = LayoutDirectionsMap[rootLayout];\n    const subLayoutDirections = LayoutDirectionsMap[layout];\n    if (!subLayoutDirections) {\n        throw new Error(`unexpected layout: ${layout} on correct layout`);\n    }\n    return subLayoutDirections.find(d => directions.includes(getLayoutReverseDirection(d)));\n};\n\nexport const correctLayoutByDirection = (layout: MindLayoutType, direction: LayoutDirection) => {\n    const isHorizontal = direction === LayoutDirection.left || direction === LayoutDirection.right ? true : false;\n    let inverseDirectionLayout = MindLayoutType.standard;\n    switch (layout) {\n        case MindLayoutType.left:\n            inverseDirectionLayout = MindLayoutType.right;\n            break;\n        case MindLayoutType.right:\n            inverseDirectionLayout = MindLayoutType.left;\n            break;\n        case MindLayoutType.downward:\n            inverseDirectionLayout = MindLayoutType.upward;\n            break;\n        case MindLayoutType.upward:\n            inverseDirectionLayout = MindLayoutType.downward;\n            break;\n        case MindLayoutType.rightBottomIndented:\n            inverseDirectionLayout = isHorizontal ? MindLayoutType.leftBottomIndented : MindLayoutType.rightTopIndented;\n            break;\n        case MindLayoutType.leftBottomIndented:\n            inverseDirectionLayout = isHorizontal ? MindLayoutType.rightBottomIndented : MindLayoutType.leftTopIndented;\n            break;\n        case MindLayoutType.rightTopIndented:\n            inverseDirectionLayout = isHorizontal ? MindLayoutType.leftTopIndented : MindLayoutType.rightBottomIndented;\n            break;\n        case MindLayoutType.leftTopIndented:\n            inverseDirectionLayout = isHorizontal ? MindLayoutType.rightTopIndented : MindLayoutType.leftBottomIndented;\n            break;\n    }\n    return inverseDirectionLayout;\n};\n\nexport const getLayoutDirection = (root: MindElement) => {\n    const layout = root.layout || getDefaultLayout();\n    return LayoutDirectionsMap[layout];\n};\n\nexport const getDefaultLayout = () => {\n    return MindLayoutType.standard;\n};\n\nexport const getAvailableSubLayoutsByLayoutDirections = (directions: LayoutDirection[]): MindLayoutType[] => {\n    const result: MindLayoutType[] = [];\n    const reverseDirections = directions.map(getLayoutReverseDirection);\n    for (const key in MindLayoutType) {\n        const layout = MindLayoutType[key as keyof typeof MindLayoutType];\n        const layoutDirections = LayoutDirectionsMap[layout];\n        if (layoutDirections) {\n            const hasSameDirection = layoutDirections.some(d => directions.includes(d));\n            const hasReverseDirection = layoutDirections.some(r => reverseDirections.includes(r));\n            if (hasSameDirection && !hasReverseDirection) {\n                result.push(layout);\n            }\n        }\n    }\n    return result;\n};\n\nexport const getLayoutReverseDirection = (layoutDirection: LayoutDirection) => {\n    let reverseDirection = LayoutDirection.right;\n    switch (layoutDirection) {\n        case LayoutDirection.top:\n            reverseDirection = LayoutDirection.bottom;\n            break;\n        case LayoutDirection.bottom:\n            reverseDirection = LayoutDirection.top;\n            break;\n        case LayoutDirection.right:\n            reverseDirection = LayoutDirection.left;\n            break;\n        case LayoutDirection.left:\n            reverseDirection = LayoutDirection.right;\n            break;\n    }\n    return reverseDirection;\n};\n\nexport const getRootLayout = (root: MindElement) => {\n    return root.layout || getDefaultLayout();\n};\n","import {\n    ConnectingPosition,\n    LayoutNode,\n    LayoutOptions,\n    OriginNode,\n    isHorizontalLayout,\n    isHorizontalLogicLayout,\n    isIndentedLayout\n} from '@plait/layouts';\nimport { MindElement, MindElementShape } from '../../interfaces/element';\nimport { BASE } from '../../constants/default';\nimport { getRootLayout } from '../layout';\nimport { NodeSpace } from './node-space';\nimport { PlaitMindBoard } from '../../plugins/with-mind.board';\n\nexport const getLayoutOptions = (board: PlaitMindBoard) => {\n    function getMainAxle(element: MindElement, parent?: LayoutNode) {\n        if (element.isRoot) {\n            return BASE * 12;\n        }\n        if (parent && parent.isRoot()) {\n            return BASE * 3;\n        }\n        return BASE * 3;\n    }\n\n    function getSecondAxle(element: MindElement, parent?: LayoutNode) {\n        if (element.isRoot) {\n            return BASE * 12;\n        }\n        return BASE * 8.5;\n    }\n\n    return {\n        getHeight(element: MindElement) {\n            return NodeSpace.getNodeHeight(board, element);\n        },\n        getWidth(element: MindElement) {\n            return NodeSpace.getNodeWidth(board, element);\n        },\n        getHorizontalGap(element: MindElement, parent?: LayoutNode) {\n            const _layout = (parent && parent.layout) || getRootLayout(element);\n            const isHorizontal = isHorizontalLayout(_layout);\n            if (isIndentedLayout(_layout)) {\n                return BASE * 6;\n            }\n            if (!isHorizontal) {\n                return getMainAxle(element, parent);\n            } else {\n                return getSecondAxle(element, parent);\n            }\n        },\n        getVerticalGap(element: MindElement, parent?: LayoutNode) {\n            const _layout = (parent && parent.layout) || getRootLayout(element);\n            if (isIndentedLayout(_layout)) {\n                return BASE * 3.5;\n            }\n            const isHorizontal = isHorizontalLayout(_layout);\n            if (isHorizontal) {\n                return getMainAxle(element, parent);\n            } else {\n                return getSecondAxle(element, parent);\n            }\n        },\n        getVerticalConnectingPosition(element: MindElement, parent?: LayoutNode) {\n            if (element.shape === MindElementShape.underline && parent && isHorizontalLogicLayout(parent.layout)) {\n                return ConnectingPosition.bottom;\n            }\n            return undefined;\n        },\n        getExtendHeight(node: OriginNode) {\n            return 0;\n        },\n        getIndentedCrossLevelGap() {\n            return BASE * 1;\n        }\n    } as LayoutOptions;\n};\n","export const TOPIC_FONT_SIZE = 14;\n\nexport const ROOT_TOPIC_FONT_SIZE = 18;\n\nexport const TOPIC_DEFAULT_MAX_WORD_COUNT = 34;\n\nexport const NodeTopicThreshold = {\n    defaultTextMaxWidth: 34 * 14\n};\n","export const ABSTRACT_HANDLE_COLOR = '#6698FF80'; //primary color 50% opacity\nexport const ABSTRACT_INCLUDED_OUTLINE_OFFSET = 3.5;\nexport const ABSTRACT_HANDLE_LENGTH = 10;\n\nexport const ABSTRACT_HANDLE_MASK_WIDTH = 8;\n","import { getI18nValue, PlaitBoard } from '@plait/core';\nimport { MindI18nKey } from '../constants/default';\nimport { ROOT_TOPIC_FONT_SIZE, TOPIC_DEFAULT_MAX_WORD_COUNT, TOPIC_FONT_SIZE } from '../constants';\nimport { DEFAULT_FONT_FAMILY, measureElement, ParagraphElement } from '@plait/common';\n\nexport const MIND_CENTRAL_TEXT = '中心主题';\n\nexport const ABSTRACT_NODE_TEXT = '概要';\n\nexport const getDefaultMindNameText = (board: PlaitBoard) => {\n    return getI18nValue(board, MindI18nKey.mindCentralText, MIND_CENTRAL_TEXT);\n};\n\nexport const getAbstractNodeText = (board: PlaitBoard) => {\n    return getI18nValue(board, MindI18nKey.abstractNodeText, ABSTRACT_NODE_TEXT);\n};\n\nexport const getTopicSize = (board: PlaitBoard | null, isRoot: boolean, isBranch: boolean, topic: ParagraphElement, manualWidth?: number) => {\n    let fontFamily = DEFAULT_FONT_FAMILY;\n    let fontSize = TOPIC_FONT_SIZE;\n    if (isRoot) {\n        fontFamily = DEFAULT_FONT_FAMILY;\n        fontSize = ROOT_TOPIC_FONT_SIZE;\n    } else if (isBranch) {\n        fontFamily = DEFAULT_FONT_FAMILY;\n    }\n    const maxWidth = fontSize * TOPIC_DEFAULT_MAX_WORD_COUNT;\n    return measureElement(board, topic, { fontSize, fontFamily }, manualWidth ? manualWidth : maxWidth);\n};\n","import { PlaitBoard, Point, idCreator, isNullOrUndefined } from '@plait/core';\nimport { MindLayoutType } from '@plait/layouts';\nimport { BranchShape, MindElement, MindElementShape } from '../../interfaces/element';\nimport { Element } from 'slate';\nimport { NodeSpace } from '../space';\nimport { PlaitMindBoard } from '../../plugins/with-mind.board';\nimport { buildText } from '@plait/common';\nimport { getDefaultMindNameText, getTopicSize } from '../common';\n\nexport const createEmptyMind = (board: PlaitBoard, point: Point) => {\n    const text = getDefaultMindNameText(board);\n    const topicSize = getTopicSize(board, true, false, buildText(text));\n    const element = createMindElement(text, topicSize.width, topicSize.height, { layout: MindLayoutType.right });\n    element.isRoot = true;\n    element.type = 'mindmap';\n    const width = NodeSpace.getNodeWidth(board as PlaitMindBoard, element);\n    const height = NodeSpace.getNodeHeight(board as PlaitMindBoard, element);\n    element.points = [[point[0] - width / 2, point[1] - height / 2]];\n    return element;\n};\n\nexport const createMindElement = (text: string | Element, width: number, height: number, options: InheritAttribute) => {\n    const newElement: MindElement = {\n        id: idCreator(),\n        data: {\n            topic: buildText(text)\n        },\n        children: [],\n        width,\n        height\n    };\n\n    let key: keyof typeof options;\n    for (key in options) {\n        if (!isNullOrUndefined(options[key])) {\n            (newElement as any)[key] = options[key];\n        }\n    }\n\n    return newElement;\n};\n\nexport interface InheritAttribute {\n    fill?: string;\n    strokeColor?: string;\n    strokeWidth?: number;\n    strokeStyle?: number;\n    shape?: MindElementShape;\n    layout?: MindLayoutType;\n    branchColor?: string;\n    branchWidth?: number;\n    branchShape?: BranchShape;\n}\n\nexport const INHERIT_ATTRIBUTE_KEYS = [\n    'fill',\n    'strokeColor',\n    'strokeWidth',\n    'strokeStyle',\n    'shape',\n    'layout',\n    'branchColor',\n    'branchWidth',\n    'branchShape'\n];\n","import { addSelectedElement, clearSelectedElement, idCreator, Path, PlaitBoard, Transforms } from '@plait/core';\nimport { MindElement, PlaitMind } from '../interfaces/element';\nimport { editTopic } from './node/common';\nimport { createMindElement, INHERIT_ATTRIBUTE_KEYS, InheritAttribute } from './node/create-node';\nimport { MindNode } from '../interfaces/node';\nimport { PlaitMindBoard } from '../plugins/with-mind.board';\nimport { ROOT_TOPIC_FONT_SIZE, TOPIC_FONT_SIZE } from '../constants/node-topic-style';\nimport { TEXT_DEFAULT_HEIGHT } from '@plait/text-plugins';\n\nexport const getChildrenCount = (element: MindElement) => {\n    const count: number = element.children.reduce((p: number, c: MindElement) => {\n        return p + getChildrenCount(c);\n    }, 0);\n    return count + element.children.length;\n};\n\nexport const isChildElement = (origin: MindElement, child: MindElement) => {\n    let parent = MindElement.findParent(child);\n    while (parent) {\n        if (parent === origin) {\n            return true;\n        }\n        parent = MindElement.findParent(parent);\n    }\n    return false;\n};\n\nexport const getFirstLevelElement = (elements: MindElement[]) => {\n    let result: MindElement[] = [];\n    elements.forEach(element => {\n        const isChild = elements.some(node => {\n            return isChildElement(node, element);\n        });\n\n        if (!isChild) {\n            result.push(element);\n        }\n    });\n    return result;\n};\n\nexport const isChildRight = (parent: MindNode, child: MindNode) => {\n    return parent.x < child.x;\n};\n\nexport const isChildUp = (parent: MindNode, child: MindNode) => {\n    return parent.y > child.y;\n};\n\nexport const copyNewNode = (node: MindElement) => {\n    const newNode: MindElement = { ...node };\n    newNode.id = idCreator();\n    newNode.children = [];\n\n    for (const childNode of node.children) {\n        newNode.children.push(copyNewNode(childNode));\n    }\n    return newNode;\n};\n\nexport const insertMindElement = (board: PlaitMindBoard, inheritNode: MindElement, path: Path) => {\n    const newNode: InheritAttribute = {};\n    if (!inheritNode.isRoot) {\n        INHERIT_ATTRIBUTE_KEYS.forEach(attr => {\n            (newNode as any)[attr] = inheritNode[attr];\n        });\n        delete newNode.layout;\n    }\n    const newElement = createMindElement('', TOPIC_FONT_SIZE, TEXT_DEFAULT_HEIGHT, newNode);\n    Transforms.insertNode(board, newElement, path);\n    clearSelectedElement(board);\n    addSelectedElement(board, newElement);\n    setTimeout(() => {\n        editTopic(newElement);\n    });\n};\n\nexport const findLastChild = (child: MindNode) => {\n    let result = child;\n    while (result.children.length !== 0) {\n        result = result.children[result.children.length - 1];\n    }\n    return result;\n};\n\nexport const divideElementByParent = (elements: MindElement[]) => {\n    const abstractIncludedGroups = [];\n    const parentElements: MindElement[] = [];\n\n    for (let i = 0; i < elements.length; i++) {\n        const parent = MindElement.getParent(elements[i]);\n        const parentIndex = parentElements.indexOf(parent);\n        if (parentIndex === -1) {\n            parentElements.push(parent);\n            abstractIncludedGroups.push([elements[i]]);\n        } else {\n            abstractIncludedGroups[parentIndex].push(elements[i]);\n        }\n    }\n    return { parentElements, abstractIncludedGroups };\n};\n\nexport const getDefaultMindElementFontSize = (board: PlaitBoard, element: MindElement) => {\n    if (PlaitMind.isMind(element)) {\n        return ROOT_TOPIC_FONT_SIZE;\n    }\n    if (MindElement.isMindElement(board, element)) {\n        return TOPIC_FONT_SIZE;\n    }\n    throw new Error('can not find default font-size');\n};\n","import { BASE, WithMindPluginKey } from '../../constants/default';\nimport { PlaitMind } from '../../interfaces/element';\nimport { MindElement } from '../../interfaces/element';\nimport { EmojiData } from '../../interfaces/element-data';\nimport { WithMindOptions } from '../../interfaces/options';\nimport { PlaitMindBoard } from '../../plugins/with-mind.board';\nimport { getEmojisWidthHeight } from './emoji';\nimport { Element } from 'slate';\nimport { getStrokeWidthByElement } from '../node-style/shape';\nimport { getDefaultMindElementFontSize } from '../mind';\nimport { DEFAULT_FONT_SIZE, getFirstTextMarks, MarkTypes, PlaitMarkEditor } from '@plait/text-plugins';\nimport { DEFAULT_FONT_FAMILY, getElementSize, getFirstTextEditor } from '@plait/common';\nimport { NodeTopicThreshold } from '../../constants/node-topic-style';\n\nconst NodeDefaultSpace = {\n    horizontal: {\n        nodeAndText: BASE * 2.5,\n        emojiAndText: BASE * 1.5\n    },\n    vertical: {\n        nodeAndText: BASE,\n        nodeAndImage: BASE,\n        imageAndText: BASE * 1.5\n    }\n};\n\nconst RootDefaultSpace = {\n    horizontal: {\n        nodeAndText: BASE * 4,\n        emojiAndText: BASE * 2\n    },\n    vertical: {\n        nodeAndText: BASE * 2\n    }\n};\n\nconst getHorizontalSpaceBetweenNodeAndText = (board: PlaitMindBoard, element: MindElement) => {\n    const isMind = PlaitMind.isMind(element);\n    const nodeAndText = isMind ? RootDefaultSpace.horizontal.nodeAndText : NodeDefaultSpace.horizontal.nodeAndText;\n    const strokeWidth = getStrokeWidthByElement(board, element);\n    return nodeAndText + strokeWidth;\n};\n\nconst getVerticalSpaceBetweenNodeAndText = (board: PlaitMindBoard, element: MindElement) => {\n    const isMind = PlaitMind.isMind(element);\n    const strokeWidth = getStrokeWidthByElement(board, element);\n    const nodeAndText = isMind ? RootDefaultSpace.vertical.nodeAndText : NodeDefaultSpace.vertical.nodeAndText;\n    return nodeAndText + strokeWidth;\n};\n\nconst getSpaceEmojiAndText = (element: MindElement) => {\n    const isMind = PlaitMind.isMind(element);\n    const emojiAndText = isMind ? RootDefaultSpace.horizontal.emojiAndText : NodeDefaultSpace.horizontal.emojiAndText;\n    return emojiAndText;\n};\n\nexport const NodeSpace = {\n    getNodeWidth(board: PlaitMindBoard, element: MindElement) {\n        const nodeAndText = getHorizontalSpaceBetweenNodeAndText(board, element);\n        if (MindElement.hasEmojis(element)) {\n            return (\n                NodeSpace.getEmojiLeftSpace(board, element) +\n                getEmojisWidthHeight(board, element).width +\n                getSpaceEmojiAndText(element) +\n                NodeSpace.getTopicDynamicWidth(board, element) +\n                nodeAndText\n            );\n        }\n        return nodeAndText + NodeSpace.getTopicDynamicWidth(board, element) + nodeAndText;\n    },\n    getNodeHeight(board: PlaitMindBoard, element: MindElement) {\n        const topicSize = getElementSize(\n            board,\n            element.data.topic,\n            { fontSize: DEFAULT_FONT_SIZE, fontFamily: DEFAULT_FONT_FAMILY },\n            NodeSpace.getTopicMaxDynamicWidth(board, element)\n        );\n        const normalizedSize = normalizeWidthAndHeight(board, element, topicSize.width, topicSize.height);\n        const nodeAndText = getVerticalSpaceBetweenNodeAndText(board, element);\n        if (MindElement.hasImage(element)) {\n            return NodeSpace.getTextTopSpace(board, element) + normalizedSize.height + nodeAndText;\n        }\n        return nodeAndText + normalizedSize.height + nodeAndText;\n    },\n    getTopicDynamicWidth(board: PlaitMindBoard, element: MindElement) {\n        const topicSize = getElementSize(\n            board,\n            element.data.topic,\n            { fontSize: getDefaultMindElementFontSize(board, element), fontFamily: DEFAULT_FONT_FAMILY },\n            NodeSpace.getTopicMaxDynamicWidth(board, element)\n        );\n        const normalizedSize = normalizeWidthAndHeight(board, element, topicSize.width, topicSize.width);\n        const width = element.manualWidth || normalizedSize.width;\n        const imageWidth = MindElement.hasImage(element) ? element.data.image?.width : 0;\n        return Math.max(width, imageWidth);\n    },\n    getTopicHeight(board: PlaitMindBoard, element: MindElement) {\n        const topicSize = getElementSize(\n            board,\n            element.data.topic,\n            { fontSize: DEFAULT_FONT_SIZE, fontFamily: DEFAULT_FONT_FAMILY },\n            NodeSpace.getTopicMaxDynamicWidth(board, element)\n        );\n        const normalizedSize = normalizeWidthAndHeight(board, element, topicSize.width, topicSize.height);\n        return normalizedSize.height;\n    },\n    getTopicMaxDynamicWidth(board: PlaitMindBoard, element: MindElement) {\n        return Math.max(\n            NodeTopicThreshold.defaultTextMaxWidth,\n            element.manualWidth || 0,\n            MindElement.hasImage(element) ? element.data.image?.width : 0\n        );\n    },\n    /**\n     * use it when upload image first or resize image\n     */\n    getNodeNewDynamicWidth(board: PlaitMindBoard, element: MindElement, imageWidth: number) {\n        const width = element.manualWidth || element.width;\n        return Math.max(width, imageWidth);\n    },\n    getNodeResizableMinWidth(board: PlaitMindBoard, element: MindElement) {\n        const minTopicWidth = NodeSpace.getNodeTopicMinWidth(board, element);\n        if (MindElement.hasImage(element) && element.data.image.width > minTopicWidth) {\n            return element.data.image.width;\n        } else {\n            return minTopicWidth;\n        }\n    },\n    getNodeTopicMinWidth(board: PlaitMindBoard, element: MindElement) {\n        const defaultFontSize = getDefaultMindElementFontSize(board, element);\n        const firstText = getFirstTextMarks(element.data.topic);\n        const fontSize = (firstText[MarkTypes.fontSize] ? Number(firstText[MarkTypes.fontSize]) : null) || defaultFontSize;\n        return fontSize;\n    },\n    getTextLeftSpace(board: PlaitMindBoard, element: MindElement) {\n        const nodeAndText = getHorizontalSpaceBetweenNodeAndText(board, element);\n        if (MindElement.hasEmojis(element)) {\n            return NodeSpace.getEmojiLeftSpace(board, element) + getEmojisWidthHeight(board, element).width + getSpaceEmojiAndText(element);\n        } else {\n            return nodeAndText;\n        }\n    },\n    getTextTopSpace(board: PlaitMindBoard, element: MindElement) {\n        const nodeAndText = getVerticalSpaceBetweenNodeAndText(board, element);\n        if (MindElement.hasImage(element)) {\n            return NodeSpace.getImageTopSpace(board, element) + element.data.image.height + NodeDefaultSpace.vertical.imageAndText;\n        } else {\n            return nodeAndText;\n        }\n    },\n    getImageTopSpace(board: PlaitMindBoard, element: MindElement) {\n        const strokeWidth = getStrokeWidthByElement(board, element);\n        return strokeWidth + NodeDefaultSpace.vertical.nodeAndImage;\n    },\n    getEmojiLeftSpace(board: PlaitMindBoard, element: MindElement<EmojiData>) {\n        const options = board.getPluginOptions<WithMindOptions>(WithMindPluginKey);\n        const nodeAndText = getHorizontalSpaceBetweenNodeAndText(board, element);\n        return nodeAndText - options.emojiPadding;\n    },\n    getEmojiTopSpace(board: PlaitMindBoard, element: MindElement) {\n        const nodeAndText = getVerticalSpaceBetweenNodeAndText(board, element);\n        return nodeAndText;\n    }\n};\n\nexport const getFontSizeBySlateElement = (text: string | Element) => {\n    const defaultFontSize = DEFAULT_FONT_SIZE;\n    if (typeof text === 'string') {\n        return defaultFontSize;\n    }\n    const marks = PlaitMarkEditor.getMarksByElement(text);\n    const fontSize = (marks[MarkTypes.fontSize] as number) || defaultFontSize;\n    return fontSize;\n};\n\nexport const normalizeWidthAndHeight = (board: PlaitMindBoard, element: MindElement, width: number, height: number) => {\n    const minWidth = NodeSpace.getNodeTopicMinWidth(board, element);\n    const newWidth = width < minWidth ? minWidth : width;\n    return { width: newWidth, height };\n};\n","import { PlaitBoard, Point, RectangleClient, distanceBetweenPointAndRectangle } from '@plait/core';\nimport { MindNode } from '../../interfaces/node';\nimport { MindElement } from '../../interfaces/element';\nimport { NodeSpace } from '../space/node-space';\nimport { PlaitMindBoard } from '../../plugins/with-mind.board';\n\nexport function getRectangleByNode(node: MindNode): RectangleClient {\n    const x = node.x + node.hGap;\n    let y = node.y + node.vGap;\n    const width = node.width - node.hGap * 2;\n    const height = node.height - node.vGap * 2;\n    return {\n        x,\n        y,\n        width,\n        height\n    };\n}\n\nexport function getRectangleByElement(board: PlaitMindBoard, element: MindElement) {\n    const width = NodeSpace.getNodeWidth(board, element);\n    const height = NodeSpace.getNodeHeight(board, element);\n    const nodeRectangle = {\n        x: element.points![0][0],\n        y: element.points![0][1],\n        width,\n        height\n    };\n    return nodeRectangle;\n}\n\nexport function isHitMindElement(board: PlaitBoard, point: Point, element: MindElement) {\n    const node = MindElement.getNode(element);\n    if (node && distanceBetweenPointAndRectangle(point[0], point[1], getRectangleByNode(node)) === 0) {\n        return true;\n    } else {\n        return false;\n    }\n}\n","import { PlaitBoard, Point, RectangleClient } from '@plait/core';\nimport { MindElement } from '../../interfaces/element';\nimport { EmojiData } from '../../interfaces/element-data';\nimport { getRectangleByNode } from './node';\nimport { NodeSpace } from '../space/node-space';\nimport { getEmojisWidthHeight } from '../space/emoji';\nimport { PlaitMindBoard } from '../../plugins/with-mind.board';\n\nexport function getEmojiRectangle(board: PlaitMindBoard, element: MindElement<EmojiData>): RectangleClient {\n    let { x, y } = getRectangleByNode(MindElement.getNode(element));\n    x = x + NodeSpace.getEmojiLeftSpace(board, element);\n    const { width, height } = getEmojisWidthHeight(board, element);\n    return {\n        x,\n        y,\n        width,\n        height\n    };\n}\n\nexport function getEmojiForeignRectangle(board: PlaitMindBoard, element: MindElement<EmojiData>): RectangleClient {\n    let { x, y } = getRectangleByNode(MindElement.getNode(element));\n    x = x + NodeSpace.getEmojiLeftSpace(board, element);\n    const { width } = getEmojisWidthHeight(board, element);\n    return {\n        x,\n        y,\n        width,\n        height: NodeSpace.getNodeHeight(board, element)\n    };\n}\n\nexport const isHitEmojis = (board: PlaitBoard, element: MindElement<EmojiData>, point: Point) => {\n    return RectangleClient.isHit(RectangleClient.getRectangleByPoints([point, point]), getEmojiRectangle(board as PlaitMindBoard, element));\n};\n","import { MindElement } from '../../interfaces/element';\nimport { MindNode } from '../../interfaces/node';\nimport { PlaitMindBoard } from '../../plugins/with-mind.board';\nimport { NodeSpace } from '../space/node-space';\nimport { getRectangleByNode } from './node';\nimport { RectangleClient } from '@plait/core';\n\nexport function getTopicRectangleByNode(board: PlaitMindBoard, node: MindNode) {\n    let nodeRectangle = getRectangleByNode(node);\n    const result = getTopicRectangleByElement(board, nodeRectangle, node.origin);\n    return result;\n}\n\nexport function getTopicRectangleByElement(board: PlaitMindBoard, nodeRectangle: RectangleClient, element: MindElement) {\n    const x = nodeRectangle.x + NodeSpace.getTextLeftSpace(board, element);\n    const y = nodeRectangle.y + NodeSpace.getTextTopSpace(board, element);\n    const width = NodeSpace.getTopicDynamicWidth(board, element);\n    const height = NodeSpace.getTopicHeight(board, element);\n    return { height, width, x, y };\n}\n","import { PlaitBoard, Point, RectangleClient } from '@plait/core';\nimport { MindElement } from '../../interfaces/element';\nimport { ImageData } from '../../interfaces/element-data';\nimport { getRectangleByNode } from './node';\nimport { NodeSpace } from '../space/node-space';\nimport { PlaitMindBoard } from '../../plugins/with-mind.board';\nimport { RESIZE_HANDLE_DIAMETER, getRectangleResizeHandleRefs } from '@plait/common';\n\nexport function getImageForeignRectangle(board: PlaitMindBoard, element: MindElement<ImageData>): RectangleClient {\n    let { x, y } = getRectangleByNode(MindElement.getNode(element));\n    const elementWidth = element.manualWidth || element.width;\n\n    x =\n        elementWidth > element.data.image.width\n            ? x + NodeSpace.getTextLeftSpace(board, element) + (elementWidth - element.data.image.width) / 2\n            : x + NodeSpace.getTextLeftSpace(board, element);\n    y = NodeSpace.getImageTopSpace(board, element) + y;\n    const { width, height } = element.data.image!;\n    const rectangle = {\n        x,\n        y,\n        width,\n        height\n    };\n    return rectangle;\n}\n\nexport const isHitImage = (board: PlaitBoard, element: MindElement<ImageData>, point: Point) => {\n    const imageRectangle = getImageForeignRectangle(board as PlaitMindBoard, element);\n    const imageOutlineRectangle = RectangleClient.getOutlineRectangle(imageRectangle, -RESIZE_HANDLE_DIAMETER / 2);\n    return RectangleClient.isPointInRectangle(imageOutlineRectangle, point);\n};\n\nexport const getHitImageResizeHandleDirection = (board: PlaitBoard, element: MindElement<ImageData>, point: Point) => {\n    const imageRectangle = getImageForeignRectangle(board as PlaitMindBoard, element);\n    const resizeHandleRefs = getRectangleResizeHandleRefs(imageRectangle, RESIZE_HANDLE_DIAMETER);\n    const result = resizeHandleRefs.find(resizeHandleRef => {\n        return RectangleClient.isHit(RectangleClient.getRectangleByPoints([point, point]), resizeHandleRef.rectangle);\n    });\n    return result;\n};\n","import { PlaitBoard } from '@plait/core';\nimport { MindElement } from '../../interfaces/element';\nimport { Node } from 'slate';\nimport { MindLayoutType } from '@plait/layouts';\nimport { PlaitMindBoard } from '../../plugins/with-mind.board';\n\nexport const adjustRootToNode = (board: PlaitBoard, node: MindElement) => {\n    const newNode: MindElement = { ...node };\n    delete newNode.isRoot;\n    delete newNode.rightNodeCount;\n    delete newNode.type;\n    if (newNode.layout === MindLayoutType.standard) {\n        delete newNode.layout;\n    }\n    return newNode;\n};\n\nexport const adjustAbstractToNode = (node: MindElement) => {\n    const newNode: MindElement = { ...node };\n    delete newNode.start;\n    delete newNode.end;\n\n    return newNode;\n};\n\nexport const adjustNodeToRoot = (board: PlaitMindBoard, node: MindElement): MindElement => {\n    const newElement = { ...node };\n    if (!Node.string(newElement.data.topic)) {\n        newElement.data.topic = { children: [{ text: '思维导图' }] };\n    }\n    delete newElement?.strokeColor;\n    delete newElement?.fill;\n    delete newElement?.shape;\n    delete newElement?.strokeWidth;\n    delete newElement?.isCollapsed;\n    return {\n        ...newElement,\n        layout: newElement.layout ?? MindLayoutType.right,\n        isRoot: true,\n        type: 'mindmap'\n    };\n};\n","import { PlaitBoard, PlaitElement } from '@plait/core';\nimport { MindElement } from '../../interfaces/element';\nimport { ImageData } from '../../interfaces/element-data';\nimport { ImageGenerator, PlaitCommonElementRef, addElementOfFocusedImage, removeElementOfFocusedImage } from '@plait/common';\n\nexport const addImageFocus = (board: PlaitBoard, element: MindElement<ImageData>) => {\n    addElementOfFocusedImage(board, element);\n    const commonElementRef = PlaitElement.getElementRef<PlaitCommonElementRef>(element);\n    const imageGenerator = commonElementRef.getGenerator<ImageGenerator>(ImageGenerator.key);\n    imageGenerator.setFocus(element, true);\n};\n\nexport const removeImageFocus = (board: PlaitBoard, element: MindElement<ImageData>) => {\n    removeElementOfFocusedImage(board);\n    const commonElementRef = PlaitElement.getElementRef<PlaitCommonElementRef>(element);\n    const imageGenerator = commonElementRef.getGenerator<ImageGenerator>(ImageGenerator.key);\n    imageGenerator.setFocus(element, false);\n};\n","import { PlaitBoard } from '@plait/core';\nimport { MindElement } from '../../interfaces/element';\nimport { getFirstTextManage } from '@plait/common';\n\n/**\n * 1. return new node height if height changed\n * 2. new height is effected by zoom\n */\nexport const getNewNodeHeight = (board: PlaitBoard, element: MindElement, newNodeDynamicWidth: number) => {\n    const textManage = getFirstTextManage(element);\n    const { height } = textManage.getSize(undefined, newNodeDynamicWidth);\n    if (Math.abs(height - element.height) > 2) {\n        return height;\n    }\n    return undefined;\n};\n","import { getNonAbstractChildren, isStandardLayout } from '@plait/layouts';\nimport { MindElement, PlaitMind } from '../../interfaces/element';\nimport { Path, PlaitBoard, PlaitElement, setDragging } from '@plait/core';\nimport { getRootLayout } from '../layout';\nimport { DetectResult } from '../../interfaces/node';\n\nexport const addActiveOnDragOrigin = (activeElement: MindElement) => {\n    PlaitElement.getElementG(activeElement).classList.add('dragging-node');\n\n    !activeElement.isCollapsed &&\n        activeElement.children.forEach(child => {\n            addActiveOnDragOrigin(child);\n        });\n};\n\nexport const removeActiveOnDragOrigin = (activeElement: MindElement) => {\n    PlaitElement.getElementG(activeElement).classList.remove('dragging-node');\n    !activeElement.isCollapsed &&\n        activeElement.children.forEach(child => {\n            removeActiveOnDragOrigin(child);\n        });\n};\n\nexport const setMindDragging = (board: PlaitBoard, state: boolean) => {\n    setDragging(board, state);\n    if (state) {\n        PlaitBoard.getBoardContainer(board).classList.add('mind-node-dragging');\n    } else {\n        PlaitBoard.getBoardContainer(board).classList.remove('mind-node-dragging');\n    }\n};\n\nexport const hasPreviousOrNextOfDropPath = (\n    parent: MindElement,\n    dropTarget: {\n        target: MindElement;\n        detectResult: DetectResult;\n    },\n    dropPath: Path\n) => {\n    let children = getNonAbstractChildren(parent);\n\n    if (PlaitMind.isMind(parent) && isStandardLayout(getRootLayout(parent))) {\n        const isDropRight = isDropStandardRight(parent, dropTarget);\n\n        if (isDropRight) {\n            children = children.slice(0, parent.rightNodeCount!);\n        }\n        if (!isDropRight) {\n            children = children.slice(parent.rightNodeCount!, children.length);\n            dropPath = [...dropPath, dropPath[dropPath.length - 1] - parent.rightNodeCount!];\n        }\n    }\n\n    let hasPreviousNode = dropPath[dropPath.length - 1] !== 0;\n    let hasNextNode = dropPath[dropPath.length - 1] !== (children?.length || 0);\n\n    if (parent.isCollapsed) {\n        hasNextNode = false;\n        hasPreviousNode = false;\n    }\n\n    return {\n        hasPreviousNode,\n        hasNextNode\n    };\n};\n\nexport const isDropStandardRight = (\n    parent: MindElement,\n    dropTarget: {\n        target: MindElement;\n        detectResult: DetectResult;\n    }\n) => {\n    const target = dropTarget.target;\n\n    return (\n        (PlaitMind.isMind(parent) &&\n            isStandardLayout(getRootLayout(parent)) &&\n            parent.children.indexOf(target) !== -1 &&\n            parent.children.indexOf(target) < parent.rightNodeCount!) ||\n        (PlaitMind.isMind(target) && isStandardLayout(getRootLayout(target)) && dropTarget.detectResult === 'right')\n    );\n};\n","import { MindElement, PlaitMind } from '../../interfaces/element';\nimport { PlaitBoard, Point, depthFirstRecursion, Path, getIsRecursionFunc } from '@plait/core';\nimport { DetectResult, MindNode } from '../../interfaces/node';\nimport { getRectangleByNode } from '../position/node';\nimport { MindQueries } from '../../queries';\nimport { getRootLayout } from '../layout';\nimport {\n    MindLayoutType,\n    getNonAbstractChildren,\n    isHorizontalLogicLayout,\n    isIndentedLayout,\n    isStandardLayout,\n    isTopLayout,\n    isVerticalLogicLayout\n} from '@plait/layouts';\nimport { isBottomLayout, isRightLayout, isLeftLayout, AbstractNode } from '@plait/layouts';\nimport { isChildElement } from '../mind';\n\nexport const directionCorrector = (board: PlaitBoard, node: MindNode, detectResults: DetectResult[]): DetectResult[] | null => {\n    if (!node.origin.isRoot && !AbstractNode.isAbstract(node.origin)) {\n        const parentLayout = MindQueries.getCorrectLayoutByElement(board, node?.parent.origin as MindElement);\n        if (isStandardLayout(parentLayout)) {\n            const idx = node.parent.children.findIndex(x => x === node);\n            const isLeft = idx >= (node.parent.origin.rightNodeCount || 0);\n            return getAllowedDirection(detectResults, [isLeft ? 'right' : 'left']);\n        }\n\n        if (isLeftLayout(parentLayout)) {\n            return getAllowedDirection(detectResults, ['right']);\n        }\n\n        if (isRightLayout(parentLayout)) {\n            return getAllowedDirection(detectResults, ['left']);\n        }\n\n        if (parentLayout === MindLayoutType.upward) {\n            return getAllowedDirection(detectResults, ['bottom']);\n        }\n\n        if (parentLayout === MindLayoutType.downward) {\n            return getAllowedDirection(detectResults, ['top']);\n        }\n    } else {\n        const layout = MindQueries.getCorrectLayoutByElement(board, node?.origin as MindElement);\n        if (isStandardLayout(layout)) {\n            return getAllowedDirection(detectResults, ['top', 'bottom']);\n        }\n\n        if (layout === MindLayoutType.upward) {\n            return getAllowedDirection(detectResults, ['left', 'right', 'bottom']);\n        }\n\n        if (layout === MindLayoutType.downward) {\n            return getAllowedDirection(detectResults, ['left', 'right', 'top']);\n        }\n\n        if (isLeftLayout(layout)) {\n            return getAllowedDirection(detectResults, ['right', 'top', 'bottom']);\n        }\n\n        if (isRightLayout(layout)) {\n            return getAllowedDirection(detectResults, ['left', 'top', 'bottom']);\n        }\n    }\n\n    return null;\n};\n\nexport const getAllowedDirection = (detectResults: DetectResult[], illegalDirections: DetectResult[]): DetectResult[] | null => {\n    const directions = detectResults;\n    illegalDirections.forEach(item => {\n        const bottomDirectionIndex = directions.findIndex(direction => direction === item);\n        if (bottomDirectionIndex !== -1) {\n            directions.splice(bottomDirectionIndex, 1);\n        }\n    });\n    return directions.length ? directions : null;\n};\n\nexport const detectDropTarget = (\n    board: PlaitBoard,\n    detectPoint: Point,\n    dropTarget: { target: MindElement; detectResult: DetectResult } | null,\n    activeElements: MindElement[]\n) => {\n    let detectResult: DetectResult[] | null = null;\n    depthFirstRecursion(\n        (board as unknown) as MindElement,\n        element => {\n            if (!MindElement.isMindElement(board, element) || detectResult) {\n                return;\n            }\n            const node = MindElement.getNode(element);\n            const directions = directionDetector(node, detectPoint);\n            if (directions) {\n                detectResult = directionCorrector(board, node, directions);\n            }\n            dropTarget = null;\n            const isValid = activeElements.every(element => isValidTarget(element, node.origin));\n            if (detectResult && isValid) {\n                dropTarget = { target: node.origin, detectResult: detectResult[0] };\n            }\n        },\n        getIsRecursionFunc(board)\n    );\n    return dropTarget;\n};\n\nexport const directionDetector = (targetNode: MindNode, centerPoint: Point): DetectResult[] | null => {\n    const { x, y, width, height } = getRectangleByNode(targetNode);\n    const yCenter = y + height / 2;\n    const xCenter = x + width / 2;\n\n    const top = targetNode.y;\n    const bottom = targetNode.y + targetNode.height;\n    const left = targetNode.x;\n    const right = targetNode.x + targetNode.width;\n    const direction: DetectResult[] = [];\n\n    // x-axis\n    if (centerPoint[1] > y && centerPoint[1] < y + height) {\n        if (centerPoint[0] > left && centerPoint[0] < xCenter) {\n            direction.push('left');\n        }\n        if (centerPoint[0] > xCenter && centerPoint[0] < right) {\n            direction.push('right');\n        }\n        // Overlapping area, return in both directions\n        if ((centerPoint[0] > x && centerPoint[0] < xCenter) || (centerPoint[0] > xCenter && centerPoint[0] < x + width)) {\n            if (centerPoint[1] < yCenter) {\n                direction.push('top');\n            } else {\n                direction.push('bottom');\n            }\n        }\n        return direction.length ? direction : null;\n    }\n\n    // y-axis\n    if (centerPoint[0] > x && centerPoint[0] < x + width) {\n        if (centerPoint[1] > top && centerPoint[1] < yCenter) {\n            direction.push('top');\n        }\n        if (centerPoint[1] > yCenter && centerPoint[1] < bottom) {\n            direction.push('bottom');\n        }\n        if ((centerPoint[1] > y && centerPoint[1] < y + height) || (centerPoint[1] > yCenter && centerPoint[1] < y + height)) {\n            if (centerPoint[0] < xCenter) {\n                direction.push('left');\n            } else {\n                direction.push('right');\n            }\n        }\n        return direction.length ? direction : null;\n    }\n\n    return null;\n};\n\nexport const isValidTarget = (origin: MindElement, target: MindElement) => {\n    return origin !== target && !isChildElement(origin, target);\n};\n\nexport const getPathByDropTarget = (board: PlaitBoard, dropTarget: { target: MindElement; detectResult: DetectResult }) => {\n    let targetPath = PlaitBoard.findPath(board, dropTarget?.target);\n    const layout = PlaitMind.isMind(dropTarget?.target)\n        ? getRootLayout(dropTarget?.target)\n        : MindQueries.getCorrectLayoutByElement(board, MindElement.getParent(dropTarget?.target));\n    const children = getNonAbstractChildren(dropTarget.target);\n    if (isVerticalLogicLayout(layout)) {\n        if (dropTarget.detectResult === 'top' || dropTarget.detectResult === 'bottom') {\n            targetPath.push(children.length);\n        }\n        if (dropTarget.detectResult === 'right') {\n            targetPath = Path.next(targetPath);\n        }\n    }\n    if (isHorizontalLogicLayout(layout)) {\n        if (dropTarget.detectResult === 'right') {\n            if (PlaitMind.isMind(dropTarget?.target) && isStandardLayout(layout)) {\n                targetPath.push(dropTarget?.target.rightNodeCount!);\n            } else {\n                targetPath.push(children.length);\n            }\n        }\n        if (dropTarget.detectResult === 'left') {\n            targetPath.push(children.length);\n        }\n        if (dropTarget.detectResult === 'bottom') {\n            targetPath = Path.next(targetPath);\n        }\n    }\n    if (isIndentedLayout(layout)) {\n        if (isTopLayout(layout) && dropTarget.detectResult === 'top') {\n            targetPath = Path.next(targetPath);\n        }\n        if (isBottomLayout(layout) && dropTarget.detectResult === 'bottom') {\n            targetPath = Path.next(targetPath);\n        }\n        if (isLeftLayout(layout) && dropTarget.detectResult === 'left') {\n            targetPath.push(children.length);\n        }\n        if (isRightLayout(layout) && dropTarget.detectResult === 'right') {\n            targetPath.push(children.length);\n        }\n    }\n    return targetPath;\n};\n","import { MindNode } from '../../interfaces/node';\nimport { getRectangleByNode } from '../position/node';\nimport { PlaitBoard, RectangleClient, drawRoundRectangle } from '@plait/core';\nimport { getFillByElement, getStrokeColorByElement, getStrokeStyleByElement, getStrokeWidthByElement } from '../node-style/shape';\nimport { DefaultNodeStyle } from '../../constants/node-style';\nimport { MindElement } from '../../interfaces';\nimport { getStrokeLineDash } from '@plait/common';\n\nexport function drawRoundRectangleByNode(board: PlaitBoard, node: MindNode) {\n    const rectangle = getRectangleByNode(node);\n    return drawRoundRectangleByElement(board, rectangle, node.origin);\n}\n\nexport function drawRoundRectangleByElement(board: PlaitBoard, nodeRectangle: RectangleClient, element: MindElement) {\n    const fill = getFillByElement(board, element);\n    const stroke = getStrokeColorByElement(board, element);\n    const strokeWidth = getStrokeWidthByElement(board, element);\n    const strokeStyle = getStrokeStyleByElement(board, element);\n    const strokeLineDash = getStrokeLineDash(strokeStyle, strokeWidth);\n    const newNodeRectangle = RectangleClient.inflate(nodeRectangle, -strokeWidth);\n    const nodeG = drawRoundRectangle(\n        PlaitBoard.getRoughSVG(board),\n        newNodeRectangle.x,\n        newNodeRectangle.y,\n        newNodeRectangle.x + newNodeRectangle.width,\n        newNodeRectangle.y + newNodeRectangle.height,\n        {\n            stroke,\n            strokeWidth,\n            fill,\n            fillStyle: 'solid',\n            strokeLineDash\n        },\n        false,\n        DefaultNodeStyle.shape.rectangleRadius\n    );\n\n    return nodeG;\n}\n","export enum HorizontalPlacement {\n    left = 'left',\n    center = 'center',\n    right = 'right'\n}\n\nexport enum VerticalPlacement {\n    top = 'top',\n    middle = 'middle',\n    bottom = 'bottom'\n}\n\nexport type PointPlacement = [HorizontalPlacement, VerticalPlacement];\n","import { Point, RectangleClient } from '@plait/core';\nimport { MindNode } from '../interfaces/node';\nimport { LayoutDirection } from '../interfaces/layout';\nimport { HorizontalPlacement, PointPlacement, VerticalPlacement } from '../interfaces/types';\nimport { getXDistanceBetweenPoint } from '@plait/common';\n\nexport const getPointByPlacement = (client: RectangleClient, placement: PointPlacement): Point => {\n    let x = client.x;\n    let y = client.y;\n    if (placement[0] === HorizontalPlacement.center) {\n        x = client.x + client.width / 2;\n    }\n    if (placement[0] === HorizontalPlacement.right) {\n        x = client.x + client.width;\n    }\n    if (placement[1] === VerticalPlacement.middle) {\n        y = client.y + client.height / 2;\n    }\n    if (placement[1] === VerticalPlacement.bottom) {\n        y = client.y + client.height;\n    }\n    return [x, y];\n};\n\nexport interface PlacementRef {\n    placement: PointPlacement;\n    client: RectangleClient;\n}\n\nexport const getYDistanceBetweenPoint = (point1: Point, point2: Point, isHorizontalLayout: boolean) => {\n    getXDistanceBetweenPoint(point1, point2, !isHorizontalLayout);\n};\n\nexport const getLayoutDirection = (node: MindNode, isHorizontal: boolean) => {\n    if (isHorizontal) {\n        if (node.left) {\n            return LayoutDirection.left;\n        } else {\n            return LayoutDirection.right;\n        }\n    } else {\n        if (node.up) {\n            return LayoutDirection.top;\n        } else {\n            return LayoutDirection.bottom;\n        }\n    }\n};\n\nexport const transformPlacement = (placement: PointPlacement, direction: LayoutDirection) => {\n    // to left\n    if (direction === LayoutDirection.left) {\n        if (placement[0] === HorizontalPlacement.right) {\n            placement[0] = HorizontalPlacement.left;\n        } else if (placement[0] === HorizontalPlacement.left) {\n            placement[0] = HorizontalPlacement.right;\n        }\n    }\n    // to bottom\n    if (direction === LayoutDirection.bottom || direction === LayoutDirection.top) {\n        let horizontal = HorizontalPlacement.center;\n        let vertical = VerticalPlacement.middle;\n        if (placement[1] === VerticalPlacement.top) {\n            horizontal = HorizontalPlacement.left;\n        }\n        if (placement[1] === VerticalPlacement.bottom) {\n            horizontal = HorizontalPlacement.right;\n        }\n        if (placement[0] === HorizontalPlacement.left) {\n            vertical = VerticalPlacement.top;\n        }\n        if (placement[0] === HorizontalPlacement.right) {\n            vertical = VerticalPlacement.bottom;\n        }\n        placement[0] = horizontal;\n        placement[1] = vertical;\n    }\n    // to up\n    if (direction === LayoutDirection.top) {\n        if (placement[1] === VerticalPlacement.bottom) {\n            placement[1] = VerticalPlacement.top;\n        } else if (placement[1] === VerticalPlacement.top) {\n            placement[1] = VerticalPlacement.bottom;\n        }\n    }\n};\n","import { pointsOnBezierCurves } from 'points-on-curve';\nimport { MindNode } from '../../../interfaces/node';\nimport { PlaitBoard, Point, drawBezierPath, drawLinearPath } from '@plait/core';\nimport { getShapeByElement, getRectangleByNode, isChildUp, getStrokeStyleByElement } from '../..';\nimport { getBranchColorByMindElement, getBranchShapeByMindElement, getBranchWidthByMindElement } from '../../node-style/branch';\nimport { BranchShape, MindElementShape } from '../../../interfaces/element';\nimport { getStrokeLineDash, StrokeStyle } from '@plait/common';\n\nexport function drawIndentedLink(\n    board: PlaitBoard,\n    parent: MindNode,\n    child: MindNode,\n    needDrawUnderline = true,\n    defaultStrokeColor: string | null = null,\n    defaultStrokeWidth?: number,\n    defaultStrokeStyle?: StrokeStyle\n) {\n    const branchShape = getBranchShapeByMindElement(board, parent.origin);\n    const branchWidth = defaultStrokeWidth || getBranchWidthByMindElement(board, child.origin);\n    const branchColor = defaultStrokeColor || getBranchColorByMindElement(board, child.origin);\n    const strokeStyle = defaultStrokeStyle || getStrokeStyleByElement(board, child.origin);\n\n    const isUnderlineShape = (getShapeByElement(board, child.origin) as MindElementShape) === MindElementShape.underline;\n    let beginX,\n        beginY,\n        endX,\n        endY,\n        beginNode = parent,\n        endNode = child;\n    const beginRectangle = getRectangleByNode(beginNode);\n    const endRectangle = getRectangleByNode(endNode);\n\n    beginX = beginNode.x + beginNode.width / 2;\n    beginY = isChildUp(parent, child) ? beginRectangle.y : beginRectangle.y + beginRectangle.height;\n    endX = parent.left ? endNode.x + endNode.hGap + endRectangle.width : endNode.x + endNode.hGap;\n    endY = isUnderlineShape ? endNode.y + endNode.height - endNode.vGap : endNode.y + endNode.height / 2;\n\n    let plusMinus = isChildUp(parent, child) ? (parent.left ? [-1, -1] : [1, -1]) : parent.left ? [-1, 1] : [1, 1];\n\n    let curve: Point[] = [\n        [beginX, beginY],\n        [beginX, beginY],\n        [beginX, beginY],\n        [beginX, endY - (endNode.hGap * 3 * plusMinus[1]) / 5],\n        [beginX, endY - (endNode.hGap * plusMinus[1]) / 5],\n        [beginX + (endNode.hGap * plusMinus[0]) / 4, endY],\n        [beginX + (endNode.hGap * plusMinus[0] * 3) / 5, endY],\n        isUnderlineShape && needDrawUnderline ? [endX + (endNode.width - endNode.hGap * 2) * plusMinus[0], endY] : [endX, endY],\n        isUnderlineShape && needDrawUnderline ? [endX + (endNode.width - endNode.hGap * 2) * plusMinus[0], endY] : [endX, endY],\n        isUnderlineShape && needDrawUnderline ? [endX + (endNode.width - endNode.hGap * 2) * plusMinus[0], endY] : [endX, endY]\n    ];\n    const strokeLineDash = getStrokeLineDash(strokeStyle, branchWidth);\n    if (branchShape === BranchShape.polyline) {\n        const polylinePoints = [\n            [beginX, beginY],\n            [beginX, endY],\n            [endX, endY],\n            isUnderlineShape && needDrawUnderline ? [endX + (endNode.width - endNode.hGap * 2) * plusMinus[0], endY] : [endX, endY]\n        ];\n\n        return drawLinearPath(polylinePoints as Point[], { stroke: branchColor, strokeWidth: branchWidth, strokeLineDash });\n    }\n\n    const points = pointsOnBezierCurves(curve, 0.001);\n    return drawBezierPath(points as Point[], { stroke: branchColor, strokeWidth: branchWidth, strokeLineDash });\n}\n","import { pointsOnBezierCurves } from 'points-on-curve';\nimport { MindNode } from '../../../interfaces/node';\nimport { Direction, PlaitBoard, Point, drawLinearPath, setStrokeLinecap } from '@plait/core';\nimport { getRectangleByNode, getShapeByElement, getStrokeStyleByElement } from '../..';\nimport { getLayoutDirection, getPointByPlacement, transformPlacement } from '../../point-placement';\nimport { HorizontalPlacement, PointPlacement, VerticalPlacement } from '../../../interfaces/types';\nimport { getBranchColorByMindElement, getBranchShapeByMindElement, getBranchWidthByMindElement } from '../../node-style/branch';\nimport { BranchShape, MindElementShape } from '../../../interfaces/element';\nimport { getStrokeLineDash, moveXOfPoint, StrokeStyle } from '@plait/common';\n\nexport function drawLogicLink(\n    board: PlaitBoard,\n    parent: MindNode,\n    node: MindNode,\n    isHorizontal: boolean,\n    defaultStrokeColor: string | null = null,\n    defaultStrokeWidth?: number,\n    defaultStrokeStyle?: StrokeStyle\n) {\n    const branchShape = getBranchShapeByMindElement(board, parent.origin);\n    const branchColor = defaultStrokeColor || getBranchColorByMindElement(board, node.origin);\n    const branchWidth = defaultStrokeWidth || getBranchWidthByMindElement(board, node.origin);\n    const strokeStyle = defaultStrokeStyle || getStrokeStyleByElement(board, node.origin);\n    const hasStraightLine = branchShape === BranchShape.polyline ? true : !parent.origin.isRoot;\n    const parentShape = getShapeByElement(board, parent.origin);\n    const shape = getShapeByElement(board, node.origin);\n    const hasUnderlineShape = shape === MindElementShape.underline;\n    const hasUnderlineShapeOfParent = parentShape === MindElementShape.underline;\n    const nodeClient = getRectangleByNode(node);\n    const parentClient = getRectangleByNode(parent);\n    const linkDirection = getLayoutDirection(node, isHorizontal);\n\n    // ① ensure begin placement and end placement\n    // begin placement represent parent connector position and end placement represent child connector\n    const beginPlacement: PointPlacement = [HorizontalPlacement.right, VerticalPlacement.middle];\n    const endPlacement: PointPlacement = [HorizontalPlacement.left, VerticalPlacement.middle];\n\n    transformPlacement(beginPlacement, linkDirection);\n    transformPlacement(endPlacement, linkDirection);\n\n    // underline shape and horizontal\n    if (isHorizontal && hasUnderlineShapeOfParent && !parent.origin.isRoot) {\n        beginPlacement[1] = VerticalPlacement.bottom;\n    }\n    if (isHorizontal && hasUnderlineShape) {\n        endPlacement[1] = VerticalPlacement.bottom;\n    }\n\n    let beginPoint = getPointByPlacement(parentClient, beginPlacement);\n    let endPoint = getPointByPlacement(nodeClient, endPlacement);\n\n    // ② Determine the convex straight line\n    const straightLineDistance = 8;\n    const beginPoint2 = hasStraightLine\n        ? moveXOfPoint(beginPoint, straightLineDistance, linkDirection as unknown as Direction)\n        : beginPoint;\n    let straightLine: Point[] = hasStraightLine ? [beginPoint, beginPoint2, beginPoint2] : [];\n\n    // ③ Determine the curve\n    const beginBufferDistance = (parent.hGap + node.hGap) / 3;\n    const endBufferDistance = -(parent.hGap + node.hGap) / 2.4;\n    let curve: Point[] = [\n        beginPoint2,\n        moveXOfPoint(beginPoint2, beginBufferDistance, linkDirection as unknown as Direction),\n        moveXOfPoint(endPoint, endBufferDistance, linkDirection as unknown as Direction),\n        endPoint\n    ];\n\n    // ④ underline shape and horizontal\n    const underlineEnd = moveXOfPoint(endPoint, nodeClient.width, linkDirection as unknown as Direction);\n    const underline: Point[] = hasUnderlineShape && isHorizontal ? [underlineEnd, underlineEnd, underlineEnd] : [];\n    const points = pointsOnBezierCurves([...straightLine, ...curve, ...underline]);\n    const strokeLineDash = getStrokeLineDash(strokeStyle, branchWidth);\n    let linkG: SVGGElement;\n    if (branchShape === BranchShape.polyline) {\n        const buffer = 8;\n        const movePoint = moveXOfPoint(beginPoint2, buffer, linkDirection as unknown as Direction);\n        const polylinePoints = [\n            ...straightLine,\n            movePoint,\n            isHorizontal ? [movePoint[0], endPoint[1]] : [endPoint[0], movePoint[1]],\n            endPoint,\n            ...underline\n        ];\n        linkG = drawLinearPath(polylinePoints as Point[], { stroke: branchColor, strokeWidth: branchWidth, strokeLineDash });\n    } else {\n        linkG = PlaitBoard.getRoughSVG(board).curve(points as any, { stroke: branchColor, strokeWidth: branchWidth, strokeLineDash });\n    }\n    if (strokeStyle === StrokeStyle.dotted) {\n        setStrokeLinecap(linkG, 'round');\n    }\n    return linkG;\n}\n","import { PlaitBoard } from '@plait/core';\nimport { drawIndentedLink } from './indented-link';\nimport { drawLogicLink } from './logic-link';\nimport { MindElement } from '../../../interfaces/element';\nimport { MindNode } from '../../../interfaces/node';\nimport { StrokeStyle } from '@plait/common';\n\nexport function drawLink(\n    board: PlaitBoard,\n    parentNode: MindNode,\n    node: MindNode,\n    isHorizontal: boolean,\n    needDrawUnderline?: boolean,\n    defaultStrokeColor?: string,\n    defaultStrokeWidth?: number,\n    defaultStrokeStyle?: StrokeStyle\n) {\n    return MindElement.isIndentedLayout(parentNode.origin)\n        ? drawIndentedLink(board, parentNode, node, needDrawUnderline, defaultStrokeColor, defaultStrokeWidth, defaultStrokeStyle)\n        : drawLogicLink(board, parentNode, node, isHorizontal, defaultStrokeColor, defaultStrokeWidth, defaultStrokeStyle);\n}\n","import { EmojiData, EmojiItem, MindElement } from '../interfaces';\nimport { PlaitBoard, createForeignObject, createG } from '@plait/core';\nimport { getEmojiFontSize } from '../utils/space/emoji';\nimport { getEmojiForeignRectangle } from '../utils/position/emoji';\nimport { PlaitMindBoard } from '../plugins/with-mind.board';\nimport { EmojiComponentRef, EmojiProps, PlaitMindEmojiBoard } from '../emoji/with-emoji';\n\nexport const FOREIGN_OBJECT_EMOJI_CLASS_NAME = 'foreign-object-emoji';\n\nclass EmojiGenerator {\n    emojiComponentRef: EmojiComponentRef | null = null;\n\n    constructor(private board: PlaitMindEmojiBoard & PlaitBoard) {}\n\n    draw(container: Element | DocumentFragment, emoji: EmojiItem, element: MindElement<EmojiData>) {\n        this.destroy();\n        const props: EmojiProps = {\n            board: this.board,\n            emojiItem: emoji,\n            element,\n            fontSize: getEmojiFontSize(element)\n        };\n        this.emojiComponentRef = this.board.renderEmoji(container, props);\n    }\n\n    destroy() {\n        if (this.emojiComponentRef) {\n            this.emojiComponentRef.destroy();\n            this.emojiComponentRef = null;\n        }\n    }\n}\n\nexport class NodeEmojisGenerator {\n    static key = 'node-emojis-generator';\n\n    emojiGenerators: EmojiGenerator[] = [];\n\n    g?: SVGGElement;\n\n    constructor(private board: PlaitMindBoard) {}\n\n    drawEmojis(element: MindElement) {\n        this.destroy();\n        if (MindElement.hasEmojis(element)) {\n            this.g = createG();\n            this.g.classList.add('emojis');\n            const foreignRectangle = getEmojiForeignRectangle(this.board, element);\n            const foreignObject = createForeignObject(\n                foreignRectangle.x,\n                foreignRectangle.y,\n                foreignRectangle.width,\n                foreignRectangle.height\n            );\n            foreignObject.classList.add(FOREIGN_OBJECT_EMOJI_CLASS_NAME);\n            this.g.append(foreignObject);\n            const container = document.createElement('div');\n            container.classList.add('node-emojis-container');\n            foreignObject.append(container);\n            this.emojiGenerators = element.data.emojis.map(emojiItem => {\n                const drawer = new EmojiGenerator((this.board as unknown) as PlaitBoard & PlaitMindEmojiBoard);\n                drawer.draw(container, emojiItem, element);\n                return drawer;\n            });\n            return this.g;\n        }\n        return undefined;\n    }\n\n    destroy() {\n        if (this.g) {\n            this.g.remove();\n        }\n        this.emojiGenerators.forEach(drawer => drawer.destroy());\n        this.emojiGenerators = [];\n    }\n}\n","import { drawRoundRectangleByNode } from './node-shape';\nimport { BASE, PRIMARY_COLOR, STROKE_WIDTH } from '../../constants';\nimport { DetectResult, LayoutDirection, MindElement, MindNode, PlaitMind } from '../../interfaces';\nimport { getRectangleByNode } from '../position/node';\nimport { PlaitBoard, Point, drawRoundRectangle, createG, Path, PlaitNode, PlaitElement, updateForeignObject, Direction } from '@plait/core';\nimport { MindQueries } from '../../queries';\nimport { isHorizontalLayout, isIndentedLayout, isStandardLayout, isTopLayout, MindLayoutType } from '@plait/layouts';\nimport { getTopicRectangleByNode } from '../position/topic';\nimport { HorizontalPlacement, PointPlacement, VerticalPlacement } from '../../interfaces/types';\nimport { getLayoutDirection, getPointByPlacement, transformPlacement } from '../point-placement';\nimport { PlaitMindBoard } from '../../plugins/with-mind.board';\nimport { hasPreviousOrNextOfDropPath } from '../dnd/common';\nimport { drawLink } from './node-link/draw-link';\nimport { getEmojiForeignRectangle } from '../position/emoji';\nimport { getImageForeignRectangle } from '../position';\nimport { ImageGenerator, PlaitCommonElementRef, getFirstTextManage, moveXOfPoint, moveYOfPoint } from '@plait/common';\nimport { NodeEmojisGenerator } from '../../generators/node-emojis.generator';\n\nexport const drawFakeDragNode = (board: PlaitBoard, element: MindElement, offsetX: number, offsetY: number) => {\n    const ref = PlaitElement.getElementRef<PlaitCommonElementRef>(element);\n    const mindNode = MindElement.getNode(element);\n    const dragFakeNodeG = createG();\n    dragFakeNodeG.classList.add('dragging', 'fake-node', 'plait-board-attached');\n\n    const fakeDraggingNode: MindNode = {\n        ...mindNode,\n        children: [],\n        x: mindNode.x + offsetX,\n        y: mindNode.y + offsetY\n    };\n    const textRectangle = getTopicRectangleByNode(board as PlaitMindBoard, mindNode);\n    const fakeNodeG = drawRoundRectangleByNode(board, fakeDraggingNode);\n\n    const richtextG = getFirstTextManage(element).g.cloneNode(true) as SVGGElement;\n    updateForeignObject(richtextG, textRectangle.width, textRectangle.height, textRectangle.x + offsetX, textRectangle.y + offsetY);\n\n    dragFakeNodeG?.append(fakeNodeG);\n    dragFakeNodeG?.append(richtextG);\n\n    // draw emojis\n    if (MindElement.hasEmojis(element)) {\n        const nodeEmojisGenerator = ref.getGenerator<NodeEmojisGenerator>(NodeEmojisGenerator.key);\n        const fakeEmojisG = (nodeEmojisGenerator.g as SVGGElement).cloneNode(true) as SVGGElement;\n        const foreignRectangle = getEmojiForeignRectangle(board as PlaitMindBoard, element);\n        updateForeignObject(\n            fakeEmojisG,\n            foreignRectangle.width,\n            foreignRectangle.height,\n            foreignRectangle.x + offsetX,\n            foreignRectangle.y + offsetY\n        );\n        dragFakeNodeG?.append(fakeEmojisG);\n    }\n\n    if (MindElement.hasImage(element)) {\n        const imageGenerator = ref.getGenerator<ImageGenerator>(ImageGenerator.key);\n        const fakeImageG = (imageGenerator.g as SVGGElement).cloneNode(true) as SVGGElement;\n        const foreignRectangle = getImageForeignRectangle(board as PlaitMindBoard, element);\n        updateForeignObject(\n            fakeImageG,\n            foreignRectangle.width,\n            foreignRectangle.height,\n            foreignRectangle.x + offsetX,\n            foreignRectangle.y + offsetY\n        );\n        dragFakeNodeG?.append(fakeImageG);\n    }\n    return dragFakeNodeG;\n};\n\nexport const drawFakeDropNode = (\n    board: PlaitBoard,\n    dropTarget: {\n        target: MindElement;\n        detectResult: DetectResult;\n    },\n    path: Path\n) => {\n    const target = dropTarget.target;\n    const fakeDropNodeG = createG();\n    const parent = PlaitNode.get(board, Path.parent(path)) as MindElement;\n    const layout = MindQueries.getLayoutByElement(parent) as MindLayoutType;\n    const isHorizontal = isHorizontalLayout(layout);\n    const { hasNextNode, hasPreviousNode } = hasPreviousOrNextOfDropPath(parent, dropTarget, path);\n\n    const width = 30;\n    const height = 12;\n    let fakeNode: MindNode, centerPoint: Point, basicNode: MindNode, linkDirection: LayoutDirection;\n\n    if (!hasPreviousNode && !hasNextNode) {\n        const parentNode = MindElement.getNode(parent);\n        const parentRect = getRectangleByNode(parentNode);\n\n        linkDirection = getLayoutDirection(parentNode, isHorizontal);\n        basicNode = parentNode;\n\n        if (PlaitMind.isMind(target) && isStandardLayout(layout)) {\n            if (dropTarget.detectResult === 'left') {\n                linkDirection = LayoutDirection.left;\n                basicNode.left = true;\n            } else {\n                linkDirection = LayoutDirection.right;\n                basicNode.left = false;\n            }\n        }\n\n        const placement: PointPlacement = [HorizontalPlacement.right, VerticalPlacement.middle];\n        transformPlacement(placement, linkDirection);\n        const parentCenterPoint = getPointByPlacement(parentRect, placement);\n\n        if (isIndentedLayout(layout)) {\n            const placement: PointPlacement = [\n                HorizontalPlacement.center,\n                isTopLayout(layout) ? VerticalPlacement.top : VerticalPlacement.bottom\n            ];\n            const parentCenterPoint = getPointByPlacement(parentRect, placement);\n\n            centerPoint = moveXOfPoint(parentCenterPoint, height, linkDirection as unknown as Direction);\n            centerPoint[1] = isTopLayout(layout) ? centerPoint[1] - height : centerPoint[1] + height;\n        } else {\n            centerPoint = moveXOfPoint(parentCenterPoint, width, linkDirection as unknown as Direction);\n        }\n    } else if (!hasPreviousNode && hasNextNode) {\n        const nextElement = PlaitNode.get(board, path) as MindElement;\n        basicNode = MindElement.getNode(nextElement);\n        const nextRect = getRectangleByNode(basicNode);\n        linkDirection = getLayoutDirection(basicNode, isHorizontal);\n\n        const placement: PointPlacement = [HorizontalPlacement.left, VerticalPlacement.top];\n\n        transformPlacement(placement, linkDirection);\n\n        let offset = -height;\n        if (MindElement.isIndentedLayout(parent)) {\n            offset = isTopLayout(layout) ? offset / 2 + basicNode.height - basicNode.vGap : 0;\n        }\n\n        centerPoint = getPointByPlacement(nextRect, placement);\n        centerPoint = moveYOfPoint(centerPoint, offset, linkDirection as unknown as Direction);\n    } else if (hasPreviousNode && !hasNextNode) {\n        const previousElement = PlaitNode.get(board, Path.previous(path)) as MindElement;\n        basicNode = MindElement.getNode(previousElement);\n        const previousRect = getRectangleByNode(basicNode);\n        linkDirection = getLayoutDirection(basicNode, isHorizontal);\n\n        const placement: PointPlacement = [HorizontalPlacement.left, VerticalPlacement.bottom];\n\n        transformPlacement(placement, linkDirection);\n\n        let offset = height;\n        if (MindElement.isIndentedLayout(parent)) {\n            offset = isTopLayout(layout) ? -offset - (basicNode.height - basicNode.vGap) : offset;\n        }\n        centerPoint = getPointByPlacement(previousRect, placement);\n        centerPoint = moveYOfPoint(centerPoint, offset, linkDirection as unknown as Direction);\n    } else {\n        const previousElement = PlaitNode.get(board, Path.previous(path)) as MindElement;\n        basicNode = MindElement.getNode(previousElement);\n        const previousRect = getRectangleByNode(basicNode);\n\n        const nextElement = PlaitNode.get(board, path) as MindElement;\n        const nextNode = MindElement.getNode(nextElement);\n        const nextRect = getRectangleByNode(nextNode);\n\n        const beginPlacement: PointPlacement = [HorizontalPlacement.left, VerticalPlacement.bottom];\n        const endPlacement: PointPlacement = [HorizontalPlacement.left, VerticalPlacement.top];\n        linkDirection = getLayoutDirection(basicNode, isHorizontal);\n\n        transformPlacement(beginPlacement, linkDirection);\n        transformPlacement(endPlacement, linkDirection);\n\n        const previousPoint = getPointByPlacement(previousRect, beginPlacement);\n        const nextPoint = getPointByPlacement(nextRect, endPlacement);\n\n        centerPoint = [(previousPoint[0] + nextPoint[0]) / 2, (previousPoint[1] + nextPoint[1]) / 2];\n    }\n\n    let cornerPoint = centerPoint,\n        oppositePoint = centerPoint;\n\n    const offsetY = isHorizontal ? height : width;\n    const offsetX = isHorizontal ? width : height;\n\n    cornerPoint = moveYOfPoint(cornerPoint, -offsetY / 2, linkDirection! as unknown as Direction);\n\n    oppositePoint = moveYOfPoint(oppositePoint, offsetY / 2, linkDirection! as unknown as Direction);\n    oppositePoint = moveXOfPoint(oppositePoint, offsetX, linkDirection! as unknown as Direction);\n\n    const x = Math.min(cornerPoint[0], oppositePoint[0]);\n    const y = Math.min(cornerPoint[1], oppositePoint[1]);\n\n    fakeNode = {\n        ...basicNode!,\n        x,\n        y,\n        width,\n        height,\n        hGap: MindElement.isIndentedLayout(parent) ? BASE * 4 + (basicNode.origin.strokeWidth || STROKE_WIDTH) : 0,\n        vGap: MindElement.isIndentedLayout(parent) ? BASE : 0\n    };\n\n    const fakeRectangleG = drawRoundRectangle(\n        PlaitBoard.getRoughSVG(board),\n        fakeNode!.x,\n        fakeNode!.y,\n        fakeNode!.x + width,\n        fakeNode!.y + height,\n        {\n            stroke: PRIMARY_COLOR,\n            strokeWidth: 2,\n            fill: PRIMARY_COLOR,\n            fillStyle: 'solid'\n        }\n    );\n\n    const link = drawLink(board, MindElement.getNode(parent), fakeNode, isHorizontal, false, PRIMARY_COLOR, STROKE_WIDTH);\n    fakeDropNodeG?.appendChild(link);\n    fakeDropNodeG?.appendChild(fakeRectangleG);\n\n    return fakeDropNodeG;\n};\n","import { PlaitOptionsBoard } from '@plait/core';\nimport { MindElement } from '../interfaces/element';\nimport { AbstractNode } from '@plait/layouts';\n\nexport enum AbstractHandlePosition {\n    start = 'start',\n    end = 'end'\n}\n\nexport enum AbstractResizeState {\n    start = 'start',\n    resizing = 'resizing',\n    end = 'end'\n}\n\nexport interface PlaitAbstractBoard extends PlaitOptionsBoard {\n    onAbstractResize?: (state: AbstractResizeState) => void;\n}\n\nexport type AbstractRefs = Map<MindElement, Pick<AbstractNode, 'start' | 'end'>>;\n","import {\n    createG,\n    Direction,\n    getRectangleByElements,\n    PlaitBoard,\n    RectangleClient,\n    setStrokeLinecap,\n    toActiveRectangleFromViewBoxRectangle\n} from '@plait/core';\nimport { PRIMARY_COLOR } from '../../constants';\nimport { ABSTRACT_HANDLE_COLOR, ABSTRACT_HANDLE_LENGTH, ABSTRACT_INCLUDED_OUTLINE_OFFSET } from '../../constants/abstract-node';\nimport { RoughSVG } from 'roughjs/bin/svg';\nimport { MindElement } from '../../interfaces';\nimport { MindLayoutType, isHorizontalLayout } from '@plait/layouts';\nimport { MindQueries } from '../../queries';\nimport { getLayoutDirection, getPointByPlacement, transformPlacement } from '../point-placement';\nimport { HorizontalPlacement, PointPlacement, VerticalPlacement } from '../../interfaces/types';\nimport { getRectangleByResizingLocation } from '../abstract/resize';\nimport { AbstractHandlePosition } from '../../plugins/with-abstract-resize.board';\nimport { Options } from 'roughjs/bin/core';\nimport { moveXOfPoint } from '@plait/common';\n\nexport function drawAbstractIncludedOutline(\n    board: PlaitBoard,\n    roughSVG: RoughSVG,\n    element: MindElement,\n    activeHandlePosition?: AbstractHandlePosition,\n    resizingLocation?: number\n) {\n    const abstractIncludedG = createG();\n\n    const parentElement = MindElement.getParent(element);\n    const nodeLayout = MindQueries.getCorrectLayoutByElement(board, element) as MindLayoutType;\n    const isHorizontal = isHorizontalLayout(nodeLayout);\n\n    const includedElements = parentElement.children.slice(element.start!, element.end! + 1);\n    const abstractRectangle = getRectangleByElements(board, includedElements, true);\n    const activeAbstractRectangle = toActiveRectangleFromViewBoxRectangle(board, abstractRectangle);\n    let activeAbstractOutlineRectangle = RectangleClient.getOutlineRectangle(activeAbstractRectangle, -ABSTRACT_INCLUDED_OUTLINE_OFFSET);\n\n    if (resizingLocation) {\n        activeAbstractOutlineRectangle = getRectangleByResizingLocation(\n            activeAbstractOutlineRectangle,\n            resizingLocation,\n            activeHandlePosition!,\n            isHorizontal\n        );\n    }\n\n    const rectangle = drawAbstractRoundRectangle(\n        roughSVG,\n        activeAbstractOutlineRectangle.x,\n        activeAbstractOutlineRectangle.y,\n        activeAbstractOutlineRectangle.x + activeAbstractOutlineRectangle.width,\n        activeAbstractOutlineRectangle.y + activeAbstractOutlineRectangle.height,\n        isHorizontal,\n        {\n            stroke: PRIMARY_COLOR,\n            strokeWidth: 1,\n            fillStyle: 'solid'\n        }\n    );\n\n    const startPlacement = [HorizontalPlacement.center, VerticalPlacement.top] as PointPlacement;\n    const endPlacement = [HorizontalPlacement.center, VerticalPlacement.bottom] as PointPlacement;\n\n    const linkDirection = getLayoutDirection(MindElement.getNode(element), isHorizontal);\n\n    transformPlacement(startPlacement, linkDirection);\n    transformPlacement(endPlacement, linkDirection);\n\n    let startCenterPoint = getPointByPlacement(activeAbstractOutlineRectangle, startPlacement);\n    let endCenterPoint = getPointByPlacement(activeAbstractOutlineRectangle, endPlacement);\n\n    const startPoint1 = moveXOfPoint(startCenterPoint, -ABSTRACT_HANDLE_LENGTH / 2, linkDirection as unknown as Direction);\n    const startPoint2 = moveXOfPoint(startCenterPoint, ABSTRACT_HANDLE_LENGTH / 2, linkDirection as unknown as Direction);\n\n    const endPoint1 = moveXOfPoint(endCenterPoint, -ABSTRACT_HANDLE_LENGTH / 2, linkDirection as unknown as Direction);\n    const endPoint2 = moveXOfPoint(endCenterPoint, ABSTRACT_HANDLE_LENGTH / 2, linkDirection as unknown as Direction);\n\n    const startHandle = roughSVG.line(\n        startPoint1[0],\n        startPoint1[1],\n        startPoint2[0],\n        startPoint2[1],\n        getHandleOption(activeHandlePosition === AbstractHandlePosition.start)\n    );\n\n    const endHandle = roughSVG.line(\n        endPoint1[0],\n        endPoint1[1],\n        endPoint2[0],\n        endPoint2[1],\n        getHandleOption(activeHandlePosition === AbstractHandlePosition.end)\n    );\n\n    handleBoardClass(board, activeHandlePosition, isHorizontal);\n\n    setStrokeLinecap(startHandle, 'round');\n    setStrokeLinecap(endHandle, 'round');\n\n    abstractIncludedG.append(startHandle);\n    abstractIncludedG.append(endHandle);\n    abstractIncludedG.append(rectangle);\n\n    return abstractIncludedG;\n}\n\nexport function getHandleOption(isHover: boolean) {\n    return isHover\n        ? {\n              stroke: PRIMARY_COLOR,\n              strokeWidth: 4,\n              fillStyle: 'solid'\n          }\n        : {\n              stroke: ABSTRACT_HANDLE_COLOR,\n              strokeWidth: 3,\n              fillStyle: 'solid'\n          };\n}\n\nfunction handleBoardClass(board: PlaitBoard, activeHandlePosition: AbstractHandlePosition | undefined, isHorizontal: boolean) {\n    if (activeHandlePosition) {\n        if (isHorizontal) {\n            PlaitBoard.getBoardContainer(board).classList.add('abstract-resizing-horizontal');\n        } else {\n            PlaitBoard.getBoardContainer(board).classList.add('abstract-resizing-vertical');\n        }\n    } else {\n        PlaitBoard.getBoardContainer(board).classList.remove('abstract-resizing-horizontal');\n        PlaitBoard.getBoardContainer(board).classList.remove('abstract-resizing-vertical');\n    }\n}\n\nexport function drawAbstractRoundRectangle(\n    rs: RoughSVG,\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    isHorizontal: boolean,\n    options: Options\n) {\n    const width = Math.abs(x1 - x2);\n    const height = Math.abs(y1 - y2);\n\n    const radius = 5;\n    const handleGap = 4;\n    const handleLength = 10;\n\n    const handleSpace = handleLength + handleGap * 2;\n\n    if (isHorizontal) {\n        const handleSideLine = (width - handleSpace - radius * 2) / 2;\n        const sideLine = height - radius * 2;\n        return rs.path(\n            `M${x1 + radius},${y1}\n            l${handleSideLine},0\n            m${handleSpace},0\n            l${handleSideLine},0\n            a${radius},${radius},0,0,1,${radius},${radius}\n            l0,${sideLine}\n            a${radius},${radius},0,0,1,-${radius},${radius}\n            l-${handleSideLine},0\n            m-${handleSpace},0\n            l-${handleSideLine},0\n            a${radius},${radius},0,0,1,-${radius},-${radius}\n            l0,-${sideLine}\n            a${radius},${radius},0,0,1,${radius},-${radius}`,\n            options\n        );\n    } else {\n        const handleSideLine = (height - handleSpace - radius * 2) / 2;\n        const sideLine = width - radius * 2;\n        return rs.path(\n            `M${x1 + radius},${y1}\n            l${sideLine},0\n            a${radius},${radius},0,0,1,${radius},${radius}\n            l0,${handleSideLine}\n            m0,${handleSpace}\n            l0,${handleSideLine}\n            a${radius},${radius},0,0,1,-${radius},${radius}\n            l-${sideLine},0\n            a${radius},${radius},0,0,1,-${radius},-${radius}\n            l0,-${handleSideLine}\n            m0,-${handleSpace}\n            l0,-${handleSideLine}\n            a${radius},${radius},0,0,1,${radius},-${radius}`,\n            options\n        );\n    }\n}\n","import {\n    ACTIVE_STROKE_WIDTH,\n    PlaitBoard,\n    RectangleClient,\n    SELECTION_RECTANGLE_CLASS_NAME,\n    createG,\n    drawRoundRectangle,\n    toActiveRectangleFromViewBoxRectangle\n} from '@plait/core';\nimport { MindElement, BaseData } from '../interfaces';\nimport { getRectangleByNode } from '../utils/position/node';\nimport { PRIMARY_COLOR } from '../constants/default';\nimport { AbstractNode } from '@plait/layouts';\nimport { drawAbstractIncludedOutline } from '../utils/draw/abstract-outline';\nimport { AbstractHandlePosition } from '../plugins/with-abstract-resize.board';\nimport { DefaultNodeStyle } from '../constants/node-style';\nimport { getStrokeWidthByElement } from '../utils/node-style/shape';\nimport { Generator } from '@plait/common';\n\nexport interface ActiveData {\n    selected: boolean;\n}\n\nexport class NodeActiveGenerator extends Generator<MindElement, ActiveData> {\n    static key = 'mind-node-active';\n\n    abstractOutlineG?: SVGGElement;\n\n    canDraw(element: MindElement<BaseData>, data: ActiveData): boolean {\n        if (data.selected) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    draw(element: MindElement<BaseData>, data: ActiveData): SVGGElement {\n        const activeG = createG();\n        const node = MindElement.getNode(element);\n        const rectangle = getRectangleByNode(node);\n        const activeRectangle1 = toActiveRectangleFromViewBoxRectangle(this.board, rectangle);\n        const strokeWidth = getStrokeWidthByElement(this.board, element);\n        const activeStrokeWidth = ACTIVE_STROKE_WIDTH;\n        const activeRectangleWithInflated = RectangleClient.inflate(activeRectangle1, activeStrokeWidth);\n        const strokeG = drawRoundRectangle(\n            PlaitBoard.getRoughSVG(this.board),\n            activeRectangleWithInflated.x,\n            activeRectangleWithInflated.y,\n            activeRectangleWithInflated.x + activeRectangleWithInflated.width,\n            activeRectangleWithInflated.y + activeRectangleWithInflated.height,\n            { stroke: PRIMARY_COLOR, strokeWidth: activeStrokeWidth, fill: '' },\n            true,\n            DefaultNodeStyle.shape.rectangleRadius + (activeStrokeWidth + strokeWidth) / 2\n        );\n        if (AbstractNode.isAbstract(element)) {\n            this.abstractOutlineG = drawAbstractIncludedOutline(this.board, PlaitBoard.getRoughSVG(this.board), element);\n            activeG.append(this.abstractOutlineG);\n            strokeG.classList.add('abstract-element');\n        }\n        activeG.appendChild(strokeG);\n        activeG.classList.add(SELECTION_RECTANGLE_CLASS_NAME);\n        return activeG;\n    }\n\n    updateAbstractOutline(element: MindElement, activeHandlePosition?: AbstractHandlePosition, resizingLocation?: number) {\n        const abstractOutlineG = drawAbstractIncludedOutline(\n            this.board,\n            PlaitBoard.getRoughSVG(this.board),\n            element,\n            activeHandlePosition,\n            resizingLocation\n        );\n        if (this.abstractOutlineG) {\n            this.abstractOutlineG.replaceWith(abstractOutlineG);\n            this.abstractOutlineG = abstractOutlineG;\n        }\n    }\n}\n","import { PlaitBoard, PlaitElement, Point, RectangleClient, getRectangleByElements, getSelectedElements } from '@plait/core';\nimport { MindElement } from '../../interfaces';\nimport { AbstractNode, LayoutNode, MindLayoutType, isHorizontalLayout } from '@plait/layouts';\nimport { ABSTRACT_HANDLE_MASK_WIDTH, ABSTRACT_INCLUDED_OUTLINE_OFFSET } from '../../constants/abstract-node';\nimport { MindQueries } from '../../queries';\nimport { getCorrectStartEnd } from '@plait/layouts';\nimport { MindNodeComponent } from '../../mind-node.component';\nimport { AbstractHandlePosition } from '../../plugins/with-abstract-resize.board';\nimport { PlaitCommonElementRef } from '@plait/common';\nimport { NodeActiveGenerator } from '../../generators/node-active.generator';\n\nexport const getRectangleByResizingLocation = (\n    abstractRectangle: RectangleClient,\n    location: number,\n    activeHandlePosition: AbstractHandlePosition,\n    isHorizontal: boolean\n) => {\n    if (isHorizontal) {\n        if (activeHandlePosition === AbstractHandlePosition.start) {\n            return {\n                ...abstractRectangle,\n                y: location,\n                height: abstractRectangle.height + abstractRectangle.y - location\n            };\n        } else {\n            return {\n                ...abstractRectangle,\n                height: location - abstractRectangle.y\n            };\n        }\n    } else {\n        if (activeHandlePosition === AbstractHandlePosition.start) {\n            return {\n                ...abstractRectangle,\n                x: location,\n                width: abstractRectangle.width + abstractRectangle.x - location\n            };\n        } else {\n            return {\n                ...abstractRectangle,\n                width: location - abstractRectangle.x\n            };\n        }\n    }\n};\n\nexport const getLocationScope = (\n    board: PlaitBoard,\n    handlePosition: AbstractHandlePosition,\n    parentChildren: MindElement[],\n    element: MindElement,\n    parent: LayoutNode,\n    isHorizontal: boolean\n) => {\n    const node = (MindElement.getNode(element) as unknown) as LayoutNode;\n    const { start, end } = getCorrectStartEnd(node.origin as AbstractNode, parent);\n\n    const startNode = parentChildren[start];\n    const endNode = parentChildren[end];\n\n    if (handlePosition === AbstractHandlePosition.start) {\n        const abstractNode = parentChildren.filter(child => AbstractNode.isAbstract(child) && child.end < element.start!);\n        let minNode;\n\n        if (abstractNode.length) {\n            const index = abstractNode\n                .map(node => {\n                    const { end } = getCorrectStartEnd(node as AbstractNode, parent);\n                    return end;\n                })\n                .sort((a, b) => b - a)[0];\n            minNode = parentChildren[index + 1];\n        } else {\n            minNode = parentChildren[0];\n        }\n\n        const minNodeRectangle = getRectangleByElements(board, [minNode], true);\n        const endNodeRectangle = getRectangleByElements(board, [endNode], false);\n\n        if (isHorizontal) {\n            return {\n                max: endNodeRectangle.y - ABSTRACT_INCLUDED_OUTLINE_OFFSET,\n                min: minNodeRectangle.y - ABSTRACT_INCLUDED_OUTLINE_OFFSET\n            };\n        } else {\n            return {\n                max: endNodeRectangle.x - ABSTRACT_INCLUDED_OUTLINE_OFFSET,\n                min: minNodeRectangle.x - ABSTRACT_INCLUDED_OUTLINE_OFFSET\n            };\n        }\n    } else {\n        const abstractNode = parentChildren.filter(child => AbstractNode.isAbstract(child) && child.start > element.end!);\n        let maxNode;\n\n        if (abstractNode.length) {\n            const index = abstractNode\n                .map(node => {\n                    const { start } = getCorrectStartEnd(node as AbstractNode, parent);\n                    return start;\n                })\n                .sort((a, b) => a - b)[0];\n            maxNode = parentChildren[index - 1];\n        } else {\n            const children = parentChildren.filter(child => !AbstractNode.isAbstract(child));\n            maxNode = parentChildren[children.length - 1];\n        }\n\n        const maxNodeRectangle = getRectangleByElements(board, [maxNode], true);\n        const startNodeRectangle = getRectangleByElements(board, [startNode], false);\n\n        if (isHorizontal) {\n            return {\n                max: maxNodeRectangle.y + maxNodeRectangle.height + ABSTRACT_INCLUDED_OUTLINE_OFFSET,\n                min: startNodeRectangle.y + startNodeRectangle.height + ABSTRACT_INCLUDED_OUTLINE_OFFSET\n            };\n        } else {\n            return {\n                max: maxNodeRectangle.x + maxNodeRectangle.width + ABSTRACT_INCLUDED_OUTLINE_OFFSET,\n                min: startNodeRectangle.x + startNodeRectangle.width + ABSTRACT_INCLUDED_OUTLINE_OFFSET\n            };\n        }\n    }\n};\n\nexport const getHitAbstractHandle = (board: PlaitBoard, element: MindElement, point: Point) => {\n    const nodeLayout = MindQueries.getCorrectLayoutByElement(board, element) as MindLayoutType;\n    const isHorizontal = isHorizontalLayout(nodeLayout);\n\n    const parentElement = MindElement.getParent(element);\n    const includedElements = parentElement.children.slice(element.start!, element.end! + 1);\n    let abstractRectangle = getRectangleByElements(board, includedElements, true);\n    abstractRectangle = RectangleClient.getOutlineRectangle(abstractRectangle, -ABSTRACT_INCLUDED_OUTLINE_OFFSET);\n\n    const startHandleRec = getAbstractHandleRectangle(abstractRectangle, isHorizontal, AbstractHandlePosition.start);\n    const endHandleRec = getAbstractHandleRectangle(abstractRectangle, isHorizontal, AbstractHandlePosition.end);\n\n    const pointRec = RectangleClient.getRectangleByPoints([point, point]);\n    if (RectangleClient.isHit(pointRec, startHandleRec)) return AbstractHandlePosition.start;\n    if (RectangleClient.isHit(pointRec, endHandleRec)) return AbstractHandlePosition.end;\n    return undefined;\n};\n\nexport const getAbstractHandleRectangle = (rectangle: RectangleClient, isHorizontal: boolean, position: AbstractHandlePosition) => {\n    let result;\n    if (position === AbstractHandlePosition.start) {\n        const location = isHorizontal ? rectangle.y : rectangle.x;\n\n        result = getRectangleByResizingLocation(\n            rectangle,\n            location + ABSTRACT_HANDLE_MASK_WIDTH / 2,\n            AbstractHandlePosition.end,\n            isHorizontal\n        );\n        result = getRectangleByResizingLocation(result, location - ABSTRACT_HANDLE_MASK_WIDTH / 2, position, isHorizontal);\n    } else {\n        const location = isHorizontal ? rectangle.y + rectangle.height : rectangle.x + rectangle.width;\n\n        result = getRectangleByResizingLocation(\n            rectangle,\n            location - ABSTRACT_HANDLE_MASK_WIDTH / 2,\n            AbstractHandlePosition.start,\n            isHorizontal\n        );\n        result = getRectangleByResizingLocation(result, location + ABSTRACT_HANDLE_MASK_WIDTH / 2, position, isHorizontal);\n    }\n    return result;\n};\n\nexport function findLocationLeftIndex(board: PlaitBoard, parentChildren: MindElement[], location: number, isHorizontal: boolean) {\n    const children = parentChildren.filter(child => {\n        return !AbstractNode.isAbstract(child);\n    });\n    const recArray = children.map(child => {\n        return getRectangleByElements(board, [child], false);\n    });\n\n    const firstRec = getRectangleByElements(board, [children[0]], true);\n    const fakeLeftRec = {\n        x: firstRec.x - firstRec.width,\n        y: firstRec.y - firstRec.height,\n        width: firstRec.width,\n        height: firstRec.height\n    };\n    const lastRec = getRectangleByElements(board, [children[children.length - 1]], true);\n    const fakeRightRec = {\n        x: lastRec.x + lastRec.width,\n        y: lastRec.y + lastRec.height,\n        width: lastRec.width,\n        height: lastRec.height\n    };\n\n    recArray.push(fakeRightRec);\n    recArray.unshift(fakeLeftRec);\n\n    for (let i = 0; i < recArray.length - 1; i++) {\n        const recXOrY = isHorizontal ? recArray[i].y : recArray[i].x;\n        const recWidthOrHeight = isHorizontal ? recArray[i].height : recArray[i].width;\n\n        if (\n            location >= recXOrY + recWidthOrHeight / 2 &&\n            location <= recArray[i + 1][isHorizontal ? 'y' : 'x'] + recArray[i + 1][isHorizontal ? 'height' : 'width'] / 2\n        ) {\n            return i - 1;\n        }\n    }\n    return 0;\n}\n\nexport function handleTouchedAbstract(board: PlaitBoard, touchedAbstract: MindElement | undefined, endPoint: Point) {\n    let touchedHandle;\n    const abstract = (getSelectedElements(board).filter(element => AbstractNode.isAbstract(element)) as MindElement[]).find(element => {\n        touchedHandle = getHitAbstractHandle(board, element as MindElement, endPoint);\n        return touchedHandle;\n    });\n\n    if (touchedAbstract === abstract) {\n        return touchedAbstract;\n    }\n\n    if (touchedAbstract) {\n        const ref = PlaitElement.getElementRef<PlaitCommonElementRef>(touchedAbstract);\n        const activeGenerator = ref.getGenerator<NodeActiveGenerator>(NodeActiveGenerator.key);\n        activeGenerator.updateAbstractOutline(touchedAbstract);\n        touchedAbstract = undefined;\n    }\n\n    if (abstract) {\n        touchedAbstract = abstract;\n        const ref = PlaitElement.getElementRef<PlaitCommonElementRef>(touchedAbstract);\n        const activeGenerator = ref.getGenerator<NodeActiveGenerator>(NodeActiveGenerator.key);\n        activeGenerator.updateAbstractOutline(touchedAbstract, touchedHandle);\n    }\n\n    return touchedAbstract;\n}\n","import { Path, PlaitBoard, PlaitNode } from '@plait/core';\nimport { MindElement } from '../../interfaces/element';\nimport { getRootLayout } from '../layout';\nimport { MindLayoutType } from '@plait/layouts';\n\nexport const isInRightBranchOfStandardLayout = (selectedElement: MindElement) => {\n    const parentElement = MindElement.findParent(selectedElement);\n    if (parentElement) {\n        const nodeIndex: number = parentElement.children.findIndex(item => item.id === selectedElement.id);\n        if (\n            parentElement.isRoot &&\n            getRootLayout(parentElement) === MindLayoutType.standard &&\n            parentElement.rightNodeCount &&\n            nodeIndex <= parentElement.rightNodeCount - 1\n        ) {\n            return true;\n        }\n    }\n    return false;\n};\n\nexport interface RightNodeCountRef {\n    path: Path;\n    rightNodeCount: number;\n}\n\nexport const insertElementHandleRightNodeCount = (\n    board: PlaitBoard,\n    path: Path,\n    insertCount: number,\n    effectedRightNodeCount: RightNodeCountRef[] = []\n) => {\n    let index = effectedRightNodeCount.findIndex(ref => Path.equals(ref.path, path));\n    const mind = PlaitNode.get(board, path) as MindElement;\n    if (index === -1) {\n        effectedRightNodeCount.push({ path, rightNodeCount: mind.rightNodeCount! + insertCount });\n    } else {\n        effectedRightNodeCount[index].rightNodeCount += insertCount;\n    }\n    return effectedRightNodeCount;\n};\n\nexport const deleteElementsHandleRightNodeCount = (\n    board: PlaitBoard,\n    deletableElements: MindElement[],\n    effectedRightNodeCount: RightNodeCountRef[] = []\n) => {\n    deletableElements.forEach(element => {\n        if (isInRightBranchOfStandardLayout(element)) {\n            const mind = MindElement.getParent(element);\n            const path = PlaitBoard.findPath(board, mind);\n            let index = effectedRightNodeCount.findIndex(ref => Path.equals(ref.path, path));\n            if (index === -1) {\n                effectedRightNodeCount.push({ path, rightNodeCount: mind.rightNodeCount! - 1 });\n            } else {\n                effectedRightNodeCount[index].rightNodeCount -= 1;\n            }\n        }\n    });\n    return effectedRightNodeCount;\n};\n","import { PlaitBoard, PlaitElement } from '@plait/core';\nimport { getNonAbstractChildren } from '@plait/layouts';\nimport { Path } from 'slate';\n\nexport function findNewChildNodePath(board: PlaitBoard, element: PlaitElement) {\n    const children = getNonAbstractChildren(element);\n    return PlaitBoard.findPath(board, element).concat(children.length);\n}\n\nexport function findNewSiblingNodePath(board: PlaitBoard, element: PlaitElement) {\n    const path = PlaitBoard.findPath(board, element);\n    return Path.next(path);\n}\n","import { PlaitBoard } from '@plait/core';\nimport { MindElement, PlaitMind } from '../interfaces';\nimport { correctLayoutByDirection, getInCorrectLayoutDirection, getRootLayout } from '../utils';\nimport { AbstractNode, MindLayoutType, getAbstractLayout } from '@plait/layouts';\n\n/**\n * get correctly layout：\n * 1. root is standard -> left or right\n * 2. correct layout by incorrect layout direction\n * @param element\n */\nexport const getCorrectLayoutByElement = (board: PlaitBoard, element: MindElement) => {\n    const ancestors = MindElement.getAncestors(board, element) as MindElement[];\n    ancestors.unshift(element);\n    const root = ancestors[ancestors.length - 1];\n    let rootLayout = getRootLayout(root);\n\n    if (PlaitMind.isMind(element)) {\n        return rootLayout;\n    }\n\n    const node = MindElement.getNode(element);\n    let correctRootLayout = rootLayout;\n    if (rootLayout === MindLayoutType.standard) {\n        correctRootLayout = node.left ? MindLayoutType.left : MindLayoutType.right;\n    }\n\n    let layout = null;\n    const elementWithLayout = ancestors.find(value => value.layout || AbstractNode.isAbstract(value));\n    if (elementWithLayout) {\n        if (AbstractNode.isAbstract(elementWithLayout)) {\n            const parent = MindElement.getParent(elementWithLayout);\n            const parentLayout = getCorrectLayoutByElement(board, parent);\n            layout = getAbstractLayout(parentLayout);\n        } else {\n            layout = elementWithLayout?.layout;\n        }\n    }\n\n    if (layout === MindLayoutType.standard || !layout) {\n        return correctRootLayout;\n    } else {\n        const incorrectDirection = getInCorrectLayoutDirection(correctRootLayout, layout);\n        if (incorrectDirection) {\n            return correctLayoutByDirection(layout, incorrectDirection);\n        } else {\n            return layout;\n        }\n    }\n};\n","import { MindElement } from '../interfaces';\nimport { MindLayoutType } from '@plait/layouts';\nimport { getCorrectLayoutByElement } from './get-correct-layout-by-element';\nimport { PlaitBoard } from '@plait/core';\n\nexport const getBranchLayouts = (board: PlaitBoard, element: MindElement) => {\n    const layouts: MindLayoutType[] = [];\n    if (element.layout) {\n        // TODO: getCorrectLayoutByElement Contains recursive operations. getBranchLayouts itself also has recursive operations and needs to be optimized.\n        layouts.unshift(getCorrectLayoutByElement(board, element));\n    }\n    let parent = MindElement.findParent(element);\n    while (parent) {\n        if (parent.layout) {\n            layouts.unshift(parent.layout);\n        }\n        parent = MindElement.findParent(parent);\n    }\n    return layouts;\n};\n","import { MindElement } from '../interfaces';\nimport { getAvailableSubLayoutsByLayoutDirections, getBranchDirectionsByLayouts } from '../utils';\nimport { MindLayoutType } from '@plait/layouts';\nimport { getBranchLayouts } from './get-branch-layouts';\nimport { PlaitBoard } from '@plait/core';\n\nexport const getAvailableSubLayoutsByElement = (board: PlaitBoard, element: MindElement) => {\n    const parentElement = MindElement.findParent(element);\n    if (parentElement) {\n        const branchLayouts = getBranchLayouts(board, parentElement);\n        if (branchLayouts[0] === MindLayoutType.standard) {\n            const node = MindElement.getNode(element);\n            branchLayouts[0] = node.left ? MindLayoutType.left : MindLayoutType.right;\n        }\n        const currentLayoutDirections = getBranchDirectionsByLayouts(branchLayouts);\n        let availableSubLayouts = getAvailableSubLayoutsByLayoutDirections(currentLayoutDirections);\n        const parentLayout = [branchLayouts[branchLayouts.length - 1]];\n        const parentDirections = getBranchDirectionsByLayouts(parentLayout);\n        const parentAvailableSubLayouts = getAvailableSubLayoutsByLayoutDirections(parentDirections);\n\n        availableSubLayouts = availableSubLayouts.filter(layout =>\n            parentAvailableSubLayouts.some(parentAvailableSubLayout => parentAvailableSubLayout === layout)\n        );\n        return availableSubLayouts;\n    }\n    return undefined;\n};\n","import { MindElement, PlaitMind } from '../interfaces';\nimport { AbstractNode, MindLayoutType, getAbstractLayout } from '@plait/layouts';\nimport { getDefaultLayout } from '../utils/layout';\n\nexport const getLayoutByElement = (element: MindElement): MindLayoutType => {\n    const layout = element.layout;\n    if (layout) {\n        return layout;\n    }\n\n    const parent = !PlaitMind.isMind(element) && MindElement.getParent(element);\n\n    if (AbstractNode.isAbstract(element) && parent) {\n        return getAbstractLayout(getLayoutByElement(parent));\n    }\n\n    if (parent) {\n        return getLayoutByElement(parent);\n    }\n\n    return getDefaultLayout();\n};\n","import { getAvailableSubLayoutsByElement } from './get-available-sublayouts-by-element';\nimport { getBranchLayouts } from './get-branch-layouts';\nimport { getCorrectLayoutByElement } from './get-correct-layout-by-element';\nimport { getLayoutByElement } from './get-layout-by-element';\n\nexport const MindQueries = {\n    getAvailableSubLayoutsByElement,\n    getBranchLayouts,\n    getLayoutByElement,\n    getCorrectLayoutByElement\n};\n","import { isIndentedLayout, MindLayoutType } from '@plait/layouts';\nimport { isNullOrUndefined, NODE_TO_PARENT, Path, PlaitBoard, PlaitElement, PlaitNode, Point } from '@plait/core';\nimport { MindQueries } from '../queries';\nimport { ELEMENT_TO_NODE } from '../utils';\nimport { BaseData, EmojiData, ImageData } from './element-data';\nimport { StrokeStyle } from '@plait/common';\n\nexport interface MindElement<T = BaseData> extends PlaitElement {\n    data: T;\n    children: MindElement[];\n    rightNodeCount?: number;\n    width: number;\n    manualWidth?: number;\n    height: number;\n    isRoot?: boolean;\n\n    // node style attributes\n    fill?: string;\n    strokeColor?: string;\n    strokeWidth?: number;\n    strokeStyle?: StrokeStyle;\n    shape?: MindElementShape;\n\n    // link style attributes\n    branchColor?: string;\n    branchWidth?: number;\n    branchShape?: BranchShape;\n\n    // layout\n    layout?: MindLayoutType;\n    isCollapsed?: boolean;\n\n    start?: number;\n    end?: number;\n}\n\nexport interface PlaitMind extends MindElement {\n    type: 'mindmap';\n    points: Point[];\n}\n\nexport const PlaitMind = {\n    isMind: (value: any): value is PlaitMind => {\n        return value.type === 'mindmap';\n    }\n};\n\nexport const MindElement = {\n    hasLayout(value: MindElement, layout: MindLayoutType) {\n        const _layout = MindQueries.getLayoutByElement(value);\n        return _layout === layout;\n    },\n    isIndentedLayout(value: MindElement) {\n        const _layout = MindQueries.getLayoutByElement(value) as MindLayoutType;\n        return isIndentedLayout(_layout);\n    },\n    isMindElement(board: PlaitBoard, element: PlaitElement): element is MindElement {\n        // Design error: The type of the element should be identified based on type.\n        // Now it is very awkward whether it is dynamically calculated(query root node) or using other characteristic attributes(current).\n        // Using dynamically calculated will cause more issue like pasting from clipboard, finding elements by id(isRecursion)\n        if (element.data && element.data.topic && !isNullOrUndefined(element.width) && !isNullOrUndefined(element.height)) {\n            return true;\n        } else {\n            return false;\n        }\n    },\n    getParent(node: MindElement) {\n        if (PlaitMind.isMind(node)) {\n            throw new Error('mind root node can not get parent');\n        }\n        const parent = NODE_TO_PARENT.get(node) as MindElement;\n        return parent;\n    },\n    findParent(node: MindElement) {\n        if (PlaitMind.isMind(node)) {\n            return undefined;\n        }\n        const parent = NODE_TO_PARENT.get(node) as MindElement;\n        return parent;\n    },\n    getRoot(board: PlaitBoard, element: MindElement) {\n        const path = PlaitBoard.findPath(board, element);\n        return PlaitNode.get(board, path.slice(0, 1)) as PlaitMind;\n    },\n    getAncestors(board: PlaitBoard, element: MindElement) {\n        const path = PlaitBoard.findPath(board, element);\n        const parents: PlaitElement[] = [];\n        for (const p of Path.ancestors(path, { reverse: true })) {\n            const n = PlaitNode.get(board, p);\n            if (n && !PlaitBoard.isBoard(n)) {\n                parents.push(n);\n            }\n        }\n        return parents;\n    },\n    getNode(element: MindElement) {\n        const node = ELEMENT_TO_NODE.get(element);\n        if (!node) {\n            throw new Error(`can not get node from ${JSON.stringify(element)}`);\n        }\n        return node;\n    },\n    findParentNode(element: MindElement) {\n        if (PlaitMind.isMind(element)) {\n            return undefined;\n        }\n        const parent = MindElement.getParent(element);\n        return MindElement.getNode(parent);\n    },\n    hasEmojis(element: MindElement): element is MindElement<EmojiData> {\n        if (element.data.emojis) {\n            return true;\n        } else {\n            return false;\n        }\n    },\n    hasImage(element: MindElement): element is MindElement<ImageData> {\n        if (element.data.image) {\n            return true;\n        } else {\n            return false;\n        }\n    },\n    getEmojis(element: MindElement<EmojiData>) {\n        return element.data.emojis;\n    }\n};\n\nexport enum MindElementShape {\n    roundRectangle = 'round-rectangle',\n    underline = 'underline'\n}\n\nexport enum BranchShape {\n    bight = 'bight',\n    polyline = 'polyline'\n}\n","import { Direction, PlaitBoard, createG, drawLinearPath, getRectangleByElements } from '@plait/core';\nimport { MindNode } from '../../../interfaces/node';\nimport { getRectangleByNode } from '../../position/node';\nimport { HorizontalPlacement, PointPlacement, VerticalPlacement } from '../../../interfaces/types';\nimport { getLayoutDirection, getPointByPlacement, transformPlacement } from '../../point-placement';\nimport { getAbstractBranchColor, getAbstractBranchWidth, getBranchShapeByMindElement } from '../../node-style/branch';\nimport { BranchShape } from '../../../interfaces/element';\nimport { getStrokeStyleByElement } from '../../node-style';\nimport { getStrokeLineDash, getXDistanceBetweenPoint, moveXOfPoint } from '@plait/common';\n\nexport function drawAbstractLink(board: PlaitBoard, node: MindNode, isHorizontal: boolean) {\n    const linkPadding = 15;\n    const branchWidth = getAbstractBranchWidth(board, node.origin);\n    const branchColor = getAbstractBranchColor(board, node.origin);\n    const strokeStyle = getStrokeStyleByElement(board, node.origin);\n    const parent = node.parent;\n    const branchShape = getBranchShapeByMindElement(board, node.origin);\n    const abstractRectangle = getRectangleByNode(node);\n    let includedElements = parent.children.slice(node.origin.start, node.origin.end! + 1).map(node => {\n        return node.origin;\n    });\n    const includedElementsRectangle = getRectangleByElements(board, includedElements, true);\n\n    const linkDirection = getLayoutDirection(node, isHorizontal);\n    const bezierBeginPlacement = [HorizontalPlacement.right, VerticalPlacement.top] as PointPlacement;\n    const bezierEndPlacement = [HorizontalPlacement.right, VerticalPlacement.bottom] as PointPlacement;\n    const abstractConnectorPlacement = [HorizontalPlacement.left, VerticalPlacement.middle] as PointPlacement;\n\n    transformPlacement(bezierBeginPlacement, linkDirection);\n    transformPlacement(bezierEndPlacement, linkDirection);\n    transformPlacement(abstractConnectorPlacement, linkDirection);\n\n    let bezierBeginPoint = getPointByPlacement(includedElementsRectangle, bezierBeginPlacement);\n    let bezierEndPoint = getPointByPlacement(includedElementsRectangle, bezierEndPlacement);\n    let abstractConnectorPoint = getPointByPlacement(abstractRectangle, abstractConnectorPlacement);\n    let curveDistance = getXDistanceBetweenPoint(abstractConnectorPoint, bezierBeginPoint, isHorizontal) - linkPadding * 2;\n    bezierBeginPoint = moveXOfPoint(bezierBeginPoint, linkPadding, linkDirection as unknown as Direction);\n    let c1 = moveXOfPoint(bezierBeginPoint, curveDistance, linkDirection as unknown as Direction);\n    bezierEndPoint = moveXOfPoint(bezierEndPoint, linkPadding, linkDirection as unknown as Direction);\n    let c2 = moveXOfPoint(bezierEndPoint, curveDistance, linkDirection as unknown as Direction);\n    let bezierConnectorPoint = moveXOfPoint(abstractConnectorPoint, -linkPadding, linkDirection as unknown as Direction);\n    const strokeLineDash = getStrokeLineDash(strokeStyle, branchWidth);\n    if (branchShape === BranchShape.polyline) {\n        const g = createG();\n        const polyline = drawLinearPath([bezierBeginPoint, c1, bezierConnectorPoint, c2, bezierEndPoint], {\n            stroke: branchColor,\n            strokeWidth: branchWidth\n        });\n        const straightLine = drawLinearPath([abstractConnectorPoint, bezierConnectorPoint], {\n            stroke: branchColor,\n            strokeWidth: branchWidth,\n            strokeLineDash\n        });\n\n        g.appendChild(polyline);\n        g.appendChild(straightLine);\n\n        return g;\n    }\n\n    const link = PlaitBoard.getRoughSVG(board).path(\n        `M${bezierBeginPoint[0]},${bezierBeginPoint[1]} Q${c1[0]},${c1[1]} ${bezierConnectorPoint[0]},${bezierConnectorPoint[1]} Q${c2[0]},${c2[1]} ${bezierEndPoint[0]},${bezierEndPoint[1]} M${abstractConnectorPoint[0]},${abstractConnectorPoint[1]} L${bezierConnectorPoint[0]},${bezierConnectorPoint[1]}`,\n        {\n            stroke: branchColor,\n            strokeWidth: branchWidth,\n            strokeLineDash\n        }\n    );\n    return link;\n}\n","import { Path, PlaitBoard, PlaitElement, Transforms, addSelectedElement, clearSelectedElement } from '@plait/core';\nimport { AbstractRefs } from '../plugins/with-abstract-resize.board';\nimport { MindElement, PlaitMind } from '../interfaces/element';\nimport { AbstractNode, isStandardLayout } from '@plait/layouts';\nimport { divideElementByParent, getFirstLevelElement } from '../utils/mind';\nimport { MindQueries } from '../queries';\nimport { DefaultAbstractNodeStyle } from '../constants/node-style';\nimport { createMindElement } from '../utils/node/create-node';\nimport { getAbstractNodeText, getTopicSize } from '../utils/common';\nimport { buildText } from '@plait/common';\n\nexport const setAbstractsByRefs = (board: PlaitBoard, abstractRefs: AbstractRefs) => {\n    abstractRefs.forEach((newProperty, element) => {\n        const start = element.start! + newProperty.start;\n        const end = element.end! + newProperty.end;\n        const path = PlaitBoard.findPath(board, element as MindElement);\n\n        if (start > end) {\n            Transforms.removeNode(board, path);\n        } else {\n            Transforms.setNode(board, { start, end }, path);\n        }\n    });\n};\n\nexport const setAbstractByStandardLayout = (board: PlaitBoard, element: MindElement) => {\n    const rightNodeCount = element.rightNodeCount!;\n    const abstract = element.children.find((child) => {\n        return AbstractNode.isAbstract(child) && child.end >= rightNodeCount && child.start < rightNodeCount;\n    });\n\n    if (abstract) {\n        const path = PlaitBoard.findPath(board, abstract);\n        Transforms.setNode(board, { end: rightNodeCount - 1 }, path);\n    }\n};\n\nexport const insertAbstract = (board: PlaitBoard, elements: PlaitElement[]) => {\n    let elementGroup = getFirstLevelElement(elements as MindElement[]);\n    const { parentElements, abstractIncludedGroups } = divideElementByParent(elementGroup);\n\n    abstractIncludedGroups.forEach((group, index) => {\n        const groupParent = parentElements[index];\n        setAbstractByElements(board, groupParent, group);\n    });\n};\n\nconst setAbstractByElements = (board: PlaitBoard, groupParent: MindElement, group: MindElement[]) => {\n    const indexArray = group.map((child) => groupParent!.children.indexOf(child)).sort((a, b) => a - b);\n    const rightNodeCount = groupParent?.rightNodeCount;\n    const start = indexArray[0],\n        end = indexArray[indexArray.length - 1];\n\n    if (\n        isStandardLayout(MindQueries.getLayoutByElement(groupParent)) &&\n        rightNodeCount &&\n        start < rightNodeCount &&\n        end >= rightNodeCount\n    ) {\n        const childrenLength = groupParent.children.length;\n        const path = [...PlaitBoard.findPath(board, groupParent), childrenLength];\n        const leftChildren = indexArray.filter((index) => index >= rightNodeCount);\n        const rightChildren = indexArray.filter((index) => index < rightNodeCount);\n        insertAbstractNode(board, path, rightChildren[0], rightChildren[rightChildren.length - 1]);\n        insertAbstractNode(board, Path.next(path), leftChildren[0], leftChildren[leftChildren.length - 1]);\n    } else {\n        const path = [...PlaitBoard.findPath(board, groupParent), groupParent.children.length];\n        insertAbstractNode(board, path, start, end);\n    }\n};\n\nconst insertAbstractNode = (board: PlaitBoard, path: Path, start: number, end: number) => {\n    const abstractNodeText = getAbstractNodeText(board);\n    const { width, height } = getTopicSize(board, false, false, buildText(abstractNodeText));\n    const mindElement = createMindElement(abstractNodeText, width, height, {\n        strokeWidth: DefaultAbstractNodeStyle.branch.width,\n        branchWidth: DefaultAbstractNodeStyle.branch.width\n    });\n\n    mindElement.start = start;\n    mindElement.end = end;\n\n    Transforms.insertNode(board, mindElement, path);\n\n    clearSelectedElement(board);\n    addSelectedElement(board, mindElement);\n};\n","import { Element, Path } from 'slate';\nimport { MindElement, PlaitMind } from '../interfaces/element';\nimport { PlaitBoard, PlaitHistoryBoard, PlaitNode, Transforms, removeSelectedElement } from '@plait/core';\nimport { AbstractRef, getRelativeStartEndByAbstractRef, insertElementHandleAbstract } from '../utils/abstract/common';\nimport { RightNodeCountRef, insertElementHandleRightNodeCount, isInRightBranchOfStandardLayout } from '../utils/node/right-node-count';\nimport { normalizeWidthAndHeight } from '../utils/space/node-space';\nimport { PlaitMindBoard } from '../plugins/with-mind.board';\nimport { findNewChildNodePath, findNewSiblingNodePath, insertMindElement } from '../utils';\nimport { setAbstractsByRefs } from './abstract-node';\nimport { AbstractNode } from '@plait/layouts';\n\nexport const setTopic = (board: PlaitMindBoard, element: MindElement, topic: Element, width: number, height: number) => {\n    const newElement = {\n        data: { ...element.data, topic },\n        ...normalizeWidthAndHeight(board, element, width, height)\n    } as MindElement;\n    const path = PlaitBoard.findPath(board, element);\n    Transforms.setNode(board, newElement, path);\n};\n\nexport const setNodeManualWidth = (board: PlaitMindBoard, element: MindElement, width: number, height: number) => {\n    const path = PlaitBoard.findPath(board, element);\n    const { width: normalizedWidth, height: normalizedHeight } = normalizeWidthAndHeight(board, element, width, height);\n    const newElement = { manualWidth: normalizedWidth, height: normalizedHeight } as MindElement;\n    Transforms.setNode(board, newElement, path);\n};\n\nexport const setTopicSize = (board: PlaitMindBoard, element: MindElement, width: number, height: number) => {\n    const newElement = {\n        ...normalizeWidthAndHeight(board, element, width, height)\n    };\n    let isEqualWidth = Math.ceil(element.width) === Math.ceil(newElement.width);\n    let isEqualHeight = Math.ceil(element.height) === Math.ceil(newElement.height);\n    if (element.manualWidth) {\n        isEqualWidth = true;\n    }\n    if (!isEqualWidth || !isEqualHeight) {\n        const path = PlaitBoard.findPath(board, element);\n        Transforms.setNode(board, newElement, path);\n    }\n};\n\nexport const insertNodes = (board: PlaitBoard, elements: MindElement[], path: Path) => {\n    const pathRef = board.pathRef(path);\n    elements.forEach((element) => {\n        if (pathRef.current) {\n            Transforms.insertNode(board, element, pathRef.current);\n        }\n    });\n    pathRef.unref();\n};\n\nexport const insertAbstractNodes = (board: PlaitBoard, validAbstractRefs: AbstractRef[], elements: MindElement[], path: Path) => {\n    const parent = PlaitNode.get(board, Path.parent(path));\n    const abstractPath = [...Path.parent(path), parent.children?.length!];\n    const abstracts = validAbstractRefs.map((refs) => {\n        const { start, end } = getRelativeStartEndByAbstractRef(refs, elements);\n        return {\n            ...refs.abstract,\n            start: start + path[path.length - 1],\n            end: end + path[path.length - 1]\n        };\n    });\n\n    insertNodes(board, abstracts, abstractPath);\n};\n\nexport const setRightNodeCountByRefs = (board: PlaitBoard, refs: RightNodeCountRef[]) => {\n    refs.forEach((ref) => {\n        Transforms.setNode(board, { rightNodeCount: ref.rightNodeCount }, ref.path);\n    });\n};\n\nexport const insertChildNode = (board: PlaitMindBoard, element: MindElement) => {\n    if (MindElement.isMindElement(board, element)) {\n        removeSelectedElement(board, element);\n        const targetElementPath = PlaitBoard.findPath(board, element);\n        if (element.isCollapsed) {\n            const newElement: Partial<MindElement> = { isCollapsed: false };\n            PlaitHistoryBoard.withoutSaving(board, () => {\n                Transforms.setNode(board, newElement, targetElementPath);\n            });\n        }\n        insertMindElement(board, element, findNewChildNodePath(board, element));\n    }\n};\n\nexport const insertSiblingNode = (board: PlaitMindBoard, element: MindElement) => {\n    if (MindElement.isMindElement(board, element) && !PlaitMind.isMind(element) && !AbstractNode.isAbstract(element)) {\n        const path = PlaitBoard.findPath(board, element);\n        if (isInRightBranchOfStandardLayout(element)) {\n            const refs = insertElementHandleRightNodeCount(board, path.slice(0, 1), 1);\n            setRightNodeCountByRefs(board, refs);\n        }\n        const abstractRefs = insertElementHandleAbstract(board, Path.next(path));\n        setAbstractsByRefs(board, abstractRefs);\n        insertMindElement(board, element, findNewSiblingNodePath(board, element));\n    }\n};\n\nexport const insertMind = (board: PlaitMindBoard, mind: MindElement) => {\n    Transforms.insertNode(board, mind, [board.children.length]);\n    Transforms.addSelectionWithTemporaryElements(board, [mind]);\n};\n","import { MindElement } from '../interfaces/element';\nimport { PlaitBoard, Transforms } from '@plait/core';\nimport { EmojiData, EmojiItem } from '../interfaces/element-data';\n\nexport const addEmoji = (board: PlaitBoard, element: MindElement, emojiItem: EmojiItem) => {\n    const emojis = element.data.emojis || [];\n    const newEmojis = [...emojis];\n    newEmojis.push(emojiItem);\n    const newElement = {\n        data: { ...element.data, emojis: newEmojis }\n    } as MindElement;\n    const path = PlaitBoard.findPath(board, element);\n    Transforms.setNode(board, newElement, path);\n};\n\nexport const removeEmoji = (board: PlaitBoard, element: MindElement<EmojiData>, emojiItem: EmojiItem) => {\n    const emojis = element.data.emojis.filter(value => value !== emojiItem);\n    const newElement = {\n        data: { topic: element.data.topic }\n    } as MindElement;\n\n    if (MindElement.hasImage(element)) {\n        newElement.data.image = element.data.image;\n    }\n\n    if (emojis.length > 0) {\n        newElement.data.emojis = emojis;\n    }\n    const path = PlaitBoard.findPath(board, element);\n    Transforms.setNode(board, newElement, path);\n};\n\nexport const replaceEmoji = (board: PlaitBoard, element: MindElement<EmojiData>, oldEmoji: EmojiItem, newEmoji: EmojiItem) => {\n    const newElement = {\n        data: { ...element.data }\n    } as MindElement;\n    const newEmojis = element.data.emojis.map(value => {\n        if (value === oldEmoji) {\n            return newEmoji;\n        }\n        return value;\n    });\n    newElement.data.emojis = newEmojis;\n    const path = PlaitBoard.findPath(board, element);\n    Transforms.setNode(board, newElement, path);\n};\n","import { PlaitBoard, Transforms } from '@plait/core';\nimport { ImageData, MindElement } from '../interfaces';\nimport { removeImageFocus } from '../utils/node/image';\nimport { NodeSpace } from '../utils/space/node-space';\nimport { PlaitMindBoard } from '../plugins/with-mind.board';\nimport { getNewNodeHeight } from '../utils/node/dynamic-width';\nimport { CommonImageItem } from '@plait/common';\n\nexport const removeImage = (board: PlaitBoard, element: MindElement<ImageData>) => {\n    removeImageFocus(board, element);\n    const newElement = {\n        data: { ...element.data }\n    } as MindElement;\n    delete newElement.data.image;\n    const path = PlaitBoard.findPath(board, element);\n    const newDynamicWidth = NodeSpace.getNodeNewDynamicWidth(board as PlaitMindBoard, element, 0);\n    const newHeight = getNewNodeHeight(board as PlaitMindBoard, element, newDynamicWidth);\n    if (newHeight) {\n        newElement.height = newHeight;\n    }\n    Transforms.setNode(board, newElement, path);\n};\n\nexport const setImage = (board: PlaitBoard, element: MindElement, imageItem: CommonImageItem) => {\n    const newElement = {\n        data: { ...element.data, image: imageItem }\n    };\n    const newDynamicWidth = NodeSpace.getNodeNewDynamicWidth(board as PlaitMindBoard, element, imageItem.width);\n    const newHeight = getNewNodeHeight(board as PlaitMindBoard, element, newDynamicWidth);\n    if (newHeight) {\n        (newElement as MindElement).height = newHeight;\n    }\n    const path = PlaitBoard.findPath(board, element);\n    Transforms.setNode(board, newElement, path);\n};\n","import { PlaitBoard, Path, PlaitNode, Transforms } from '@plait/core';\nimport { isHorizontalLogicLayout, isVerticalLogicLayout, MindLayoutType } from '@plait/layouts';\n\nexport const correctLogicLayoutNode = (board: PlaitBoard, layout: MindLayoutType, path: Path) => {\n    const node = PlaitNode.get(board, path);\n    if (node && layout) {\n        node.children?.forEach((value: PlaitNode, index) => {\n            if (value.layout) {\n                if (\n                    (isHorizontalLogicLayout(layout) && isVerticalLogicLayout(value.layout)) ||\n                    (isVerticalLogicLayout(layout) && isHorizontalLogicLayout(value.layout))\n                ) {\n                    Transforms.setNode(board, { layout: null }, [...path, index]);\n                }\n                if (value.children?.length) {\n                    correctLogicLayoutNode(board, layout, [...path, index]);\n                }\n            }\n        });\n    }\n};\n","import { Path, PlaitBoard, PlaitNode, Transforms } from '@plait/core';\nimport { MindLayoutType, isStandardLayout } from '@plait/layouts';\nimport { PropertyTransforms } from '@plait/common';\nimport { BranchShape, MindElementShape, MindElement, PlaitMind } from '../interfaces';\nimport { correctLogicLayoutNode } from './layout';\nimport { setAbstractByStandardLayout } from './abstract-node';\n\nexport const setLayout = (board: PlaitBoard, type: MindLayoutType) => {\n    const callback = (element: MindElement, path: Path) => {\n        if (MindElement.isMindElement(board, element)) {\n            correctLogicLayoutNode(board, type, path);\n            const element = PlaitNode.get(board, path) as MindElement;\n            if (PlaitMind.isMind(element) && isStandardLayout(type)) {\n                let properties = { rightNodeCount: element.children.length / 2 };\n                Transforms.setNode(board, properties, path);\n                setAbstractByStandardLayout(board, element);\n            }\n            Transforms.setNode(board, { layout: type }, path);\n        }\n    };\n    PropertyTransforms.setProperty<MindElement>(board, {}, { callback });\n};\n\nexport const setShape = (board: PlaitBoard, shape: MindElementShape) => {\n    PropertyTransforms.setProperty(board, { shape });\n};\n\nexport const setBranchShape = (board: PlaitBoard, branchShape: BranchShape) => {\n    PropertyTransforms.setProperty(board, { branchShape });\n};\n\nexport const setBranchWidth = (board: PlaitBoard, branchWidth: number) => {\n    PropertyTransforms.setProperty(board, { branchWidth });\n};\n\nexport const setBranchColor = (board: PlaitBoard, branchColor: string) => {\n    PropertyTransforms.setProperty(board, { branchColor });\n};\n","import { insertAbstract, setAbstractsByRefs, setAbstractByStandardLayout } from './abstract-node';\nimport {\n    setTopic,\n    setTopicSize,\n    insertNodes,\n    insertAbstractNodes,\n    setRightNodeCountByRefs,\n    setNodeManualWidth,\n    insertChildNode,\n    insertSiblingNode,\n    insertMind\n} from './node';\nimport { addEmoji, removeEmoji, replaceEmoji } from './emoji';\nimport { removeImage, setImage } from './image';\nimport { setShape, setBranchShape, setBranchWidth, setLayout, setBranchColor } from './property';\n\nexport const MindTransforms = {\n    setLayout,\n    setShape,\n    setBranchShape,\n    setBranchWidth,\n    setBranchColor,\n    setTopic,\n    setTopicSize,\n    setNodeManualWidth,\n    addEmoji,\n    removeEmoji,\n    replaceEmoji,\n    insertAbstract,\n    setAbstractsByRefs,\n    setAbstractByStandardLayout,\n    insertNodes,\n    insertAbstractNodes,\n    setRightNodeCountByRefs,\n    removeImage,\n    setImage,\n    insertChildNode,\n    insertSiblingNode,\n    insertMind\n};\n","import { Generator } from '@plait/common';\nimport { MindElement, MindElementShape } from '../interfaces/element';\nimport { getRectangleByNode } from '../utils/position/node';\nimport { MindNode } from '../interfaces/node';\nimport { drawRoundRectangleByElement } from '../utils/draw/node-shape';\nimport { getShapeByElement } from '../utils/node-style/shape';\nimport { PlaitBoard } from '@plait/core';\n\nexport interface ShapeData {\n    node: MindNode;\n}\n\nexport class NodeShapeGenerator extends Generator<MindElement, ShapeData> {\n    constructor(board: PlaitBoard) {\n        super(board, { prepend: true });\n    }\n\n    canDraw(element: MindElement, data: ShapeData): boolean {\n        const shape = getShapeByElement(this.board, element);\n        if (shape === MindElementShape.roundRectangle) {\n            return true;\n        }\n        return false;\n    }\n\n    draw(element: MindElement, data: ShapeData) {\n        const rectangle = getRectangleByNode(data.node);\n        return drawRoundRectangleByElement(this.board, rectangle, data.node.origin);\n    }\n}\n","import {\n    Direction,\n    PlaitBoard,\n    Point,\n    createG,\n    createText,\n    getSelectedElements,\n    isDragging,\n    isMovingElements,\n    isSelectedElement,\n    isSelectionMoving,\n    rgbaToHEX,\n    setStrokeLinecap\n} from '@plait/core';\nimport { MindElement, BaseData, PlaitMind, MindElementShape, LayoutDirection } from '../interfaces';\nimport { getRectangleByNode } from '../utils/position/node';\nimport { getShapeByElement } from '../utils/node-style/shape';\nimport {\n    NODE_MORE_ICON_DIAMETER,\n    NODE_MORE_LINE_DISTANCE,\n    NODE_MORE_STROKE_WIDTH,\n    NODE_ADD_CIRCLE_COLOR,\n    NODE_ADD_INNER_CROSS_COLOR,\n    NODE_ADD_HOVER_COLOR,\n    NODE_MORE_BRIDGE_DISTANCE\n} from '../constants/default';\nimport { MindLayoutType, isHorizontalLayout, isIndentedLayout, isTopLayout } from '@plait/layouts';\nimport { MindQueries } from '../queries';\nimport { getBranchColorByMindElement } from '../utils/node-style/branch';\nimport { getLayoutDirection, getPointByPlacement, transformPlacement } from '../utils/point-placement';\nimport { HorizontalPlacement, PointPlacement, VerticalPlacement } from '../interfaces/types';\nimport { buildText, DEFAULT_FONT_FAMILY, Generator, isResizing, measureElement, moveXOfPoint, TRANSPARENT } from '@plait/common';\nimport { getChildrenCount } from '../utils/mind';\nimport { FontSizes } from '@plait/text-plugins';\n\nexport interface NodeMoreExtraData {\n    isSelected: boolean;\n    isHovered?: boolean;\n    isHoveredCollapseArea?: boolean;\n    isHoveredExpandArea?: boolean;\n    isHoveredAddArea?: boolean;\n    isShowCollapseAnimation?: boolean;\n    isShowAddAnimation?: boolean;\n}\n\nexport class NodeMoreGenerator extends Generator<MindElement, NodeMoreExtraData> {\n    static key = 'mind-node-more';\n\n    collapseOrAddG: SVGGElement | undefined | null;\n\n    expandG: SVGGElement | undefined | null;\n\n    canDraw(element: MindElement<BaseData>, extraData: NodeMoreExtraData): boolean {\n        if (\n            ((extraData?.isHovered || extraData?.isHoveredCollapseArea || extraData?.isHoveredAddArea) && canHandleNodeMore(this.board)) ||\n            (extraData?.isSelected && isLastSelectedMindElement(this.board, element) && canHandleNodeMore(this.board)) ||\n            element.isCollapsed\n        ) {\n            return true;\n        }\n        return false;\n    }\n\n    draw(element: MindElement<BaseData>, extraData: NodeMoreExtraData): SVGGElement {\n        const moreGContainer = createG();\n        const stroke = getBranchColorByMindElement(this.board, element);\n        const layoutDirection = getNodeMoreLayoutDirection(this.board, element);\n        const moreStartAndEnd = getMoreStartAndEnd(this.board, element, layoutDirection);\n        const collapseOrExpandCenter = moveXOfPoint(\n            moreStartAndEnd[1],\n            NODE_MORE_ICON_DIAMETER / 2,\n            layoutDirection as unknown as Direction\n        );\n        const hasChildren = element.children.length > 0;\n        const isShowCollapseOrAdd =\n            !element.isCollapsed &&\n            (isSelectedElement(this.board, element) ||\n                !!extraData?.isHovered ||\n                !!extraData?.isHoveredCollapseArea ||\n                !!extraData?.isHoveredAddArea);\n        const isShowCollapse = isShowCollapseOrAdd && hasChildren && !PlaitMind.isMind(element);\n        const isShowAdd = isShowCollapseOrAdd && !PlaitBoard.isReadonly(this.board);\n        const addCenter =\n            (isShowCollapseOrAdd && getAddCenterByCollapseOrExpandCenter(element, collapseOrExpandCenter, layoutDirection)) || null;\n        this.toggleCollapseOrAdd(\n            collapseOrExpandCenter,\n            addCenter,\n            stroke,\n            moreGContainer,\n            isShowCollapse,\n            isShowAdd,\n            !!extraData?.isHoveredAddArea,\n            !!extraData?.isShowCollapseAnimation,\n            !!extraData?.isShowAddAnimation\n        );\n        this.toggleExpandBadge(\n            element,\n            moreStartAndEnd,\n            collapseOrExpandCenter,\n            stroke,\n            moreGContainer,\n            !!element.isCollapsed,\n            !!extraData?.isHoveredExpandArea\n        );\n        return moreGContainer;\n    }\n\n    toggleCollapseOrAdd(\n        center: Point,\n        addCenter: Point | null,\n        stroke: string,\n        parentG: SVGGElement,\n        isShowCollapse: boolean,\n        isShowAdd: boolean,\n        isHoveredAddArea: boolean,\n        isShowCollapseAnimation: boolean,\n        isShowAddAnimation: boolean\n    ) {\n        this.collapseOrAddG?.remove();\n        if (!isShowCollapse && !isShowAdd) {\n            return;\n        }\n        this.collapseOrAddG = createG();\n        if (isShowCollapse) {\n            const collapseG = createG();\n            this.collapseOrAddG.appendChild(collapseG);\n            collapseG.classList.add('collapse-button');\n            if (isShowCollapseAnimation) {\n                collapseG.classList.add('animated');\n            }\n            const collapseCircle = PlaitBoard.getRoughSVG(this.board).circle(center[0], center[1], NODE_MORE_ICON_DIAMETER, {\n                fill: '#fff',\n                stroke,\n                strokeWidth: NODE_MORE_STROKE_WIDTH,\n                fillStyle: 'solid'\n            });\n            const start = moveXOfPoint(center, -NODE_MORE_BRIDGE_DISTANCE / 2);\n            const end = moveXOfPoint(center, NODE_MORE_BRIDGE_DISTANCE / 2);\n            const collapseLine = PlaitBoard.getRoughSVG(this.board).line(start[0], start[1], end[0], end[1], {\n                fill: '#fff',\n                stroke,\n                strokeWidth: NODE_MORE_STROKE_WIDTH,\n                fillStyle: 'solid'\n            });\n            collapseG.appendChild(collapseCircle);\n            collapseG.appendChild(collapseLine);\n            setStrokeLinecap(collapseLine, 'round');\n        }\n        if (isShowAdd && addCenter) {\n            const addG = createG();\n            this.collapseOrAddG.appendChild(addG);\n            addG.classList.add('add-button');\n            if (isShowAddAnimation) {\n                addG.classList.add('animated');\n            }\n            const circle = PlaitBoard.getRoughSVG(this.board).circle(\n                addCenter[0],\n                addCenter[1],\n                NODE_MORE_ICON_DIAMETER + NODE_MORE_STROKE_WIDTH,\n                {\n                    fill: isHoveredAddArea ? NODE_ADD_HOVER_COLOR : NODE_ADD_CIRCLE_COLOR,\n                    stroke: TRANSPARENT,\n                    fillStyle: 'solid'\n                }\n            );\n            const hLineBeginPoint = [addCenter[0] - NODE_MORE_BRIDGE_DISTANCE / 2, addCenter[1]];\n            const hLineEndPoint = [addCenter[0] + NODE_MORE_BRIDGE_DISTANCE / 2, addCenter[1]];\n            const vLineBeginPoint = [addCenter[0], addCenter[1] - NODE_MORE_BRIDGE_DISTANCE / 2];\n            const vLineEndPoint = [addCenter[0], addCenter[1] + NODE_MORE_BRIDGE_DISTANCE / 2];\n\n            const innerCrossHLine = PlaitBoard.getRoughSVG(this.board).line(\n                hLineBeginPoint[0],\n                hLineBeginPoint[1],\n                hLineEndPoint[0],\n                hLineEndPoint[1],\n                {\n                    stroke: NODE_ADD_INNER_CROSS_COLOR,\n                    strokeWidth: NODE_MORE_STROKE_WIDTH\n                }\n            );\n            setStrokeLinecap(innerCrossHLine, 'round');\n            const innerCrossVLine = PlaitBoard.getRoughSVG(this.board).line(\n                vLineBeginPoint[0],\n                vLineBeginPoint[1],\n                vLineEndPoint[0],\n                vLineEndPoint[1],\n                {\n                    stroke: NODE_ADD_INNER_CROSS_COLOR,\n                    strokeWidth: NODE_MORE_STROKE_WIDTH\n                }\n            );\n            setStrokeLinecap(innerCrossVLine, 'round');\n            addG.appendChild(circle);\n            addG.appendChild(innerCrossHLine);\n            addG.appendChild(innerCrossVLine);\n        }\n        parentG.appendChild(this.collapseOrAddG);\n    }\n\n    toggleExpandBadge(\n        element: MindElement,\n        moreStartAndEnd: [Point, Point],\n        center: Point,\n        stroke: string,\n        parentG: SVGGElement,\n        isCollapsed: boolean,\n        isHoveredExpandIcon: boolean\n    ) {\n        this.expandG?.remove();\n        if (!isCollapsed) {\n            return;\n        }\n        this.expandG = createG();\n        this.expandG.classList.add('expanded-button');\n        const endWithWidth = moreStartAndEnd[1];\n        const moreLine = PlaitBoard.getRoughSVG(this.board).line(\n            moreStartAndEnd[0][0],\n            moreStartAndEnd[0][1],\n            endWithWidth[0],\n            endWithWidth[1],\n            {\n                fill: stroke,\n                stroke,\n                fillStyle: 'solid',\n                strokeWidth: NODE_MORE_STROKE_WIDTH\n            }\n        );\n        const backgroundColor = isHoveredExpandIcon ? rgbaToHEX(stroke, 0.4) : rgbaToHEX(stroke, 0.2);\n        const badgeBackground = PlaitBoard.getRoughSVG(this.board).circle(\n            center[0],\n            center[1],\n            NODE_MORE_ICON_DIAMETER + NODE_MORE_STROKE_WIDTH,\n            {\n                fill: backgroundColor,\n                stroke: TRANSPARENT,\n                fillStyle: 'solid'\n            }\n        );\n        const childrenCount = getChildrenCount(element);\n        let text = `${childrenCount}`;\n        let y = center[1] + 4.5;\n        if (childrenCount >= 99) {\n            text = '...';\n            y = center[1] + 1;\n        }\n        const { width, height } = measureElement(this.board, buildText(text), {\n            fontSize: Number(FontSizes.fontSize12),\n            fontFamily: DEFAULT_FONT_FAMILY\n        });\n        const badgeText = createText(center[0] - width / 2, y, stroke, `${text}`);\n        badgeText.setAttribute('style', `font-size: ${Number(FontSizes.fontSize12)}px;`);\n        this.expandG.appendChild(moreLine);\n        this.expandG.appendChild(badgeBackground);\n        this.expandG.appendChild(badgeText);\n        parentG.appendChild(this.expandG);\n    }\n}\n\nexport const getCollapseAndAddCenterPoint = (board: PlaitBoard, element: MindElement) => {\n    const layoutDirection = getNodeMoreLayoutDirection(board, element);\n    const [startPoint, endPoint] = getMoreStartAndEnd(board, element, layoutDirection);\n    const collapseCenter = moveXOfPoint(endPoint, NODE_MORE_ICON_DIAMETER / 2, layoutDirection as unknown as Direction);\n    const addCenter = getAddCenterByCollapseOrExpandCenter(element, collapseCenter, layoutDirection);\n    return { collapseCenter, addCenter };\n};\n\nexport const getAddCenterByCollapseOrExpandCenter = (\n    target: MindElement,\n    collapseOrExpandCenter: Point,\n    layoutDirection: LayoutDirection\n) => {\n    let addCenter = collapseOrExpandCenter;\n    if (target.children?.length > 0 && !PlaitMind.isMind(target)) {\n        addCenter = moveXOfPoint(addCenter, NODE_MORE_LINE_DISTANCE + NODE_MORE_ICON_DIAMETER, layoutDirection as unknown as Direction);\n    }\n    return addCenter;\n};\n\nexport const getNodeMoreLayoutDirection = (board: PlaitBoard, element: MindElement) => {\n    const node = MindElement.getNode(element);\n    const layout = MindQueries.getLayoutByElement(element) as MindLayoutType;\n    const isHorizontal = isHorizontalLayout(layout);\n    let layoutDirection = getLayoutDirection(node, isHorizontal);\n    if (isIndentedLayout(layout)) {\n        layoutDirection = isTopLayout(layout) ? LayoutDirection.top : LayoutDirection.bottom;\n    }\n    return layoutDirection;\n};\n\nexport const getMoreStartAndEnd = (board: PlaitBoard, element: MindElement, linkLineDirection: LayoutDirection) => {\n    const node = MindElement.getNode(element);\n    const isUnderlineShape = getShapeByElement(board, element) === MindElementShape.underline;\n    const nodeClient = getRectangleByNode(node);\n    let placement: PointPlacement = [HorizontalPlacement.right, VerticalPlacement.middle];\n    transformPlacement(placement, linkLineDirection);\n    // underline shape and horizontal\n    const layout = MindQueries.getLayoutByElement(element) as MindLayoutType;\n    const isHorizontal = isHorizontalLayout(layout);\n    if (isHorizontal && isUnderlineShape && !element.isRoot) {\n        placement[1] = VerticalPlacement.bottom;\n    }\n    let startPoint = getPointByPlacement(nodeClient, placement);\n    const endPoint = moveXOfPoint(startPoint, NODE_MORE_LINE_DISTANCE, linkLineDirection as unknown as Direction);\n    return [startPoint, endPoint] as [Point, Point];\n};\n\nexport const isLastSelectedMindElement = (board: PlaitBoard, element: MindElement) => {\n    const selectedElements = getSelectedElements(board);\n    const selectedMindElements = selectedElements.filter((element) => MindElement.isMindElement(board, element)).reverse();\n    return selectedMindElements[selectedMindElements.length - 1] === element;\n};\n\nexport const canHandleNodeMore = (board: PlaitBoard) => {\n    return !isResizing(board) && !isSelectionMoving(board) && !isDragging(board) && !isMovingElements(board);\n};\n","import { PlaitBoard, NODE_TO_INDEX, PlaitPluginElementContext, OnContextChanged, RectangleClient } from '@plait/core';\nimport { isHorizontalLayout, AbstractNode, MindLayoutType } from '@plait/layouts';\nimport { RoughSVG } from 'roughjs/bin/svg';\nimport { MindElement, PlaitMind } from './interfaces/element';\nimport { MindNode } from './interfaces/node';\nimport { MindQueries } from './queries';\nimport { ELEMENT_TO_NODE } from './utils/weak-maps';\nimport { drawAbstractLink } from './utils/draw/node-link/abstract-link';\nimport { NodeEmojisGenerator } from './generators/node-emojis.generator';\nimport { MindTransforms } from './transforms';\nimport { PlaitMindBoard } from './plugins/with-mind.board';\nimport { drawLink } from './utils/draw/node-link/draw-link';\nimport { getTopicRectangleByNode } from './utils/position/topic';\nimport { NodeActiveGenerator } from './generators/node-active.generator';\nimport { NodeSpace } from './utils/space/node-space';\nimport { NodeTopicThreshold } from './constants/node-topic-style';\nimport {\n    CommonElementFlavour,\n    ImageGenerator,\n    TextManage,\n    TextManageChangeData,\n    WithTextPluginKey,\n    WithTextPluginOptions\n} from '@plait/common';\nimport { NodeShapeGenerator } from './generators/node-shape.generator';\nimport { getImageForeignRectangle } from './utils';\nimport { ImageData } from './interfaces';\nimport { NodeMoreGenerator } from './generators/node-more.generator';\n\nexport class MindNodeComponent\n    extends CommonElementFlavour<MindElement, PlaitMindBoard>\n    implements OnContextChanged<MindElement, PlaitMindBoard>\n{\n    roughSVG!: RoughSVG;\n\n    node!: MindNode;\n\n    index!: number;\n\n    shapeG: SVGGElement | null = null;\n\n    linkLineG?: SVGGElement;\n\n    nodeEmojisGenerator!: NodeEmojisGenerator;\n\n    nodeShapeGenerator!: NodeShapeGenerator;\n\n    imageGenerator!: ImageGenerator<MindElement<ImageData>>;\n\n    activeGenerator!: NodeActiveGenerator;\n\n    nodeMoreGenerator!: NodeMoreGenerator;\n\n    get textManage() {\n        return this.getRef().getTextManages()[0];\n    }\n\n    constructor() {\n        super();\n    }\n\n    initializeGenerator() {\n        this.nodeShapeGenerator = new NodeShapeGenerator(this.board);\n        this.nodeEmojisGenerator = new NodeEmojisGenerator(this.board);\n        this.activeGenerator = new NodeActiveGenerator(this.board);\n        this.nodeMoreGenerator = new NodeMoreGenerator(this.board);\n        this.imageGenerator = new ImageGenerator<MindElement<ImageData>>(this.board, {\n            getRectangle: (element: MindElement<ImageData>) => {\n                return getImageForeignRectangle(this.board as PlaitMindBoard, element);\n            },\n            getImageItem: (element: MindElement<ImageData>) => {\n                return element.data.image;\n            }\n        });\n        const plugins = (this.board.getPluginOptions<WithTextPluginOptions>(WithTextPluginKey) || {}).textPlugins;\n        const textManage = new TextManage(this.board, {\n            getRectangle: () => {\n                const rect = getTopicRectangleByNode(this.board, this.node);\n                return rect;\n            },\n            onChange: (data: TextManageChangeData) => {\n                const width = data.width;\n                const height = data.height;\n                if (data.newText) {\n                    MindTransforms.setTopic(this.board, this.element, data.newText as MindElement, width, height);\n                } else {\n                    MindTransforms.setTopicSize(this.board, this.element, width, height);\n                }\n            },\n            getMaxWidth: () => {\n                return NodeSpace.getTopicMaxDynamicWidth(this.board, this.element);\n            },\n            textPlugins: plugins || []\n        });\n        this.getRef().addGenerator(NodeActiveGenerator.key, this.activeGenerator);\n        this.getRef().addGenerator(NodeEmojisGenerator.key, this.nodeEmojisGenerator);\n        this.getRef().addGenerator(ImageGenerator.key, this.imageGenerator);\n        this.getRef().addGenerator(NodeMoreGenerator.key, this.nodeMoreGenerator);\n        this.getRef().initializeTextManage(textManage);\n        this.getRef().updateActiveSection = () => {\n            this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {\n                selected: this.selected\n            });\n        };\n    }\n\n    initialize(): void {\n        super.initialize();\n        this.initializeGenerator();\n        this.node = MindElement.getNode(this.element);\n        this.index = NODE_TO_INDEX.get(this.element) || 0;\n        this.roughSVG = PlaitBoard.getRoughSVG(this.board);\n        this.nodeShapeGenerator.processDrawing(this.element, this.getElementG(), { node: this.node });\n        this.drawLink();\n        this.drawTopic();\n        this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {\n            selected: this.selected\n        });\n        this.nodeMoreGenerator.processDrawing(this.element, this.getElementG());\n        this.drawEmojis();\n        this.imageGenerator.processDrawing(this.element as MindElement<ImageData>, this.getElementG());\n        if (PlaitMind.isMind(this.context.parent)) {\n            this.getElementG().classList.add('branch');\n        }\n    }\n\n    onContextChanged(\n        value: PlaitPluginElementContext<MindElement, PlaitMindBoard>,\n        previous: PlaitPluginElementContext<MindElement, PlaitMindBoard>\n    ) {\n        const newNode = MindElement.getNode(value.element);\n        const isEqualNode = RectangleClient.isEqual(this.node, newNode);\n        this.node = newNode;\n        if (!isEqualNode || value.element !== previous.element || value.hasThemeChanged) {\n            this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {\n                selected: this.selected\n            });\n            this.nodeMoreGenerator.processDrawing(this.element, this.getElementG(), { isSelected: this.selected });\n            this.nodeShapeGenerator.processDrawing(this.element, this.getElementG(), { node: this.node });\n            this.drawLink();\n            this.drawEmojis();\n            if (!MindElement.hasImage(previous.element) && MindElement.hasImage(this.element)) {\n                this.imageGenerator.processDrawing(this.element, this.getElementG());\n            }\n            if (MindElement.hasImage(previous.element) && MindElement.hasImage(this.element)) {\n                this.imageGenerator.updateImage(\n                    this.getElementG(),\n                    previous.element as MindElement<ImageData>,\n                    value.element as MindElement<ImageData>\n                );\n            }\n            if (MindElement.hasImage(previous.element) && !MindElement.hasImage(this.element)) {\n                this.imageGenerator.destroy();\n            }\n            this.updateTopic();\n        } else {\n            const hasSameSelected = value.selected === previous.selected;\n            const hasSameParent = value.parent === previous.parent;\n            if (!hasSameSelected || value.selected) {\n                this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {\n                    selected: this.selected\n                });\n                this.nodeMoreGenerator.processDrawing(this.element, this.getElementG(), {\n                    isSelected: this.selected\n                });\n            }\n            if (!hasSameParent) {\n                this.drawLink();\n            }\n        }\n    }\n\n    drawEmojis() {\n        const g = this.nodeEmojisGenerator.drawEmojis(this.element);\n        if (g) {\n            this.getElementG().append(g);\n        }\n    }\n\n    drawLink() {\n        if (PlaitMind.isMind(this.element)) {\n            return;\n        }\n\n        const parent = MindElement.getParent(this.element);\n        const parentNode = MindElement.getNode(parent);\n\n        if (this.linkLineG) {\n            this.linkLineG.remove();\n        }\n\n        const layout = MindQueries.getLayoutByElement(parent) as MindLayoutType;\n        if (AbstractNode.isAbstract(this.node.origin)) {\n            this.linkLineG = drawAbstractLink(this.board, this.node, isHorizontalLayout(layout));\n        } else {\n            this.linkLineG = drawLink(this.board, parentNode, this.node, isHorizontalLayout(layout));\n        }\n        this.getElementG().append(this.linkLineG);\n    }\n\n    drawTopic() {\n        this.textManage.draw(this.element.data.topic);\n        this.getElementG().append(this.textManage.g);\n    }\n\n    updateTopic() {\n        this.textManage.updateText(this.element.data.topic);\n        this.textManage.updateRectangle();\n    }\n\n    trackBy = (index: number, node: MindNode) => {\n        return node.origin.id;\n    };\n\n    destroy(): void {\n        super.destroy();\n        this.nodeEmojisGenerator.destroy();\n        this.imageGenerator.destroy();\n        this.activeGenerator.destroy();\n        if (ELEMENT_TO_NODE.get(this.element) === this.node) {\n            ELEMENT_TO_NODE.delete(this.element);\n        }\n        this.getRef().destroyTextManage();\n    }\n}\n","import { PlaitMind } from './interfaces/element';\nimport { MindNode } from './interfaces/node';\nimport { BeforeContextChange, PlaitPluginElementContext, depthFirstRecursion, isDebug } from '@plait/core';\nimport { GlobalLayout, OriginNode } from '@plait/layouts';\nimport { ELEMENT_TO_NODE } from './utils/weak-maps';\nimport { MindNodeComponent } from './mind-node.component';\nimport { getLayoutOptions } from './utils/space/layout-options';\nimport { getDefaultLayout } from './utils/layout';\n\nexport class PlaitMindComponent extends MindNodeComponent implements BeforeContextChange<PlaitMind> {\n    root!: MindNode;\n\n    initialize(): void {\n        this.updateMindLayout();\n        super.initialize();\n        this.getElementG().classList.add('root');\n    }\n\n    beforeContextChange(value: PlaitPluginElementContext<PlaitMind>) {\n        if (value.element !== this.element && this.initialized) {\n            this.updateMindLayout(value.element);\n        }\n    }\n\n    updateMindLayout(element = this.element) {\n        const mindLayoutType = element.layout || getDefaultLayout();\n        this.root = GlobalLayout.layout(\n            element as unknown as OriginNode,\n            getLayoutOptions(this.board),\n            mindLayoutType\n        ) as unknown as MindNode;\n        this.updateMindNodeLocation(element as PlaitMind);\n    }\n\n    updateMindNodeLocation(element: PlaitMind) {\n        const { x, y, hGap, vGap } = this.root;\n        const offsetX = x + hGap;\n        const offsetY = y + vGap;\n        depthFirstRecursion<MindNode>(this.root, (node) => {\n            node.x = node.x - offsetX + element.points[0][0];\n            node.y = node.y - offsetY + element.points[0][1];\n            ELEMENT_TO_NODE.set(node.origin, node);\n        });\n    }\n}\n","import {\n    distanceBetweenPointAndPoint,\n    Path,\n    PlaitBoard,\n    Point,\n    Transforms,\n    getSelectedElements,\n    depthFirstRecursion,\n    createG,\n    PlaitNode,\n    PlaitPointerType,\n    isMainPointer,\n    CoreTransforms,\n    getHitElementByPoint,\n    toHostPoint,\n    toViewBoxPoint,\n    isDragging\n} from '@plait/core';\nimport { AbstractNode, getNonAbstractChildren } from '@plait/layouts';\nimport { MindElement, PlaitMind } from '../interfaces/element';\nimport { DetectResult } from '../interfaces/node';\nimport {\n    deleteElementHandleAbstract,\n    deleteElementsHandleRightNodeCount,\n    getCorrespondingAbstract,\n    getFirstLevelElement,\n    getOverallAbstracts,\n    getValidAbstractRefs,\n    insertElementHandleAbstract,\n    insertElementHandleRightNodeCount\n} from '../utils';\nimport { addActiveOnDragOrigin, isDropStandardRight, removeActiveOnDragOrigin, setMindDragging } from '../utils/dnd/common';\nimport { detectDropTarget, getPathByDropTarget } from '../utils/dnd/detector';\nimport { drawFakeDragNode, drawFakeDropNode } from '../utils/draw/node-dnd';\nimport { MindTransforms } from '../transforms';\nimport { adjustAbstractToNode } from '../utils/node/adjust-node';\n\nconst DRAG_MOVE_BUFFER = 5;\n\nexport const withNodeDnd = (board: PlaitBoard) => {\n    const { pointerDown, pointerMove, globalPointerUp } = board;\n\n    let activeElements: MindElement[] = [];\n    let correspondingElements: MindElement[] = [];\n    let startPoint: Point;\n    let dragFakeNodeG: SVGGElement | undefined;\n    let fakeDropNodeG: SVGGElement | undefined;\n    let dropTarget: { target: MindElement; detectResult: DetectResult } | null = null;\n    let targetPath: Path;\n\n    board.pointerDown = (event: PointerEvent) => {\n        if (\n            PlaitBoard.isReadonly(board) ||\n            PlaitBoard.hasBeenTextEditing(board) ||\n            !PlaitBoard.isPointer(board, PlaitPointerType.selection) ||\n            !isMainPointer(event)\n        ) {\n            pointerDown(event);\n            return;\n        }\n        const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n        const selectedElements = getSelectedElements(board);\n        const hitElement = getHitElementByPoint(board, point);\n        if (\n            hitElement &&\n            MindElement.isMindElement(board, hitElement) &&\n            !PlaitMind.isMind(hitElement) &&\n            !AbstractNode.isAbstract(hitElement)\n        ) {\n            const targetElements = selectedElements.filter(\n                element => MindElement.isMindElement(board, element) && !element.isRoot && !AbstractNode.isAbstract(element)\n            ) as MindElement[];\n            const isMultipleSelection = selectedElements.length > 0 && selectedElements.includes(hitElement);\n            if (isMultipleSelection) {\n                activeElements = targetElements;\n                startPoint = point;\n            } else {\n                activeElements = [hitElement];\n                startPoint = point;\n            }\n        }\n\n        if (activeElements.length) {\n            correspondingElements = getOverallAbstracts(board, activeElements);\n        }\n\n        pointerDown(event);\n    };\n\n    board.pointerMove = (event: PointerEvent) => {\n        if (!board.options.readonly && activeElements.length && startPoint) {\n            const endPoint = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n            const distance = distanceBetweenPointAndPoint(startPoint[0], startPoint[1], endPoint[0], endPoint[1]);\n            if (distance < DRAG_MOVE_BUFFER) {\n                return;\n            }\n\n            setMindDragging(board, true);\n\n            fakeDropNodeG?.remove();\n            const detectPoint = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n            dropTarget = detectDropTarget(board, detectPoint, dropTarget, [...activeElements, ...correspondingElements]);\n            if (dropTarget?.target) {\n                targetPath = getPathByDropTarget(board, dropTarget);\n\n                fakeDropNodeG = drawFakeDropNode(board, dropTarget, targetPath);\n                PlaitBoard.getHost(board).appendChild(fakeDropNodeG);\n            }\n\n            const offsetX = endPoint[0] - startPoint[0];\n            const offsetY = endPoint[1] - startPoint[1];\n            dragFakeNodeG?.remove();\n            dragFakeNodeG = createG();\n            [...activeElements, ...correspondingElements].forEach(element => {\n                addActiveOnDragOrigin(element);\n            });\n            activeElements.forEach(element => {\n                const nodeG = drawFakeDragNode(board, element, offsetX, offsetY);\n                dragFakeNodeG?.appendChild(nodeG);\n            });\n\n            PlaitBoard.getHost(board).appendChild(dragFakeNodeG);\n            return;\n        }\n\n        pointerMove(event);\n    };\n\n    board.globalPointerUp = (event: PointerEvent) => {\n        const firstLevelElements = getFirstLevelElement(activeElements);\n        if (!board.options.readonly && firstLevelElements.length) {\n            firstLevelElements.push(...correspondingElements);\n            if (isDragging(board)) {\n                firstLevelElements.forEach(element => {\n                    removeActiveOnDragOrigin(element);\n                });\n            }\n            if (dropTarget) {\n                const targetPathRef = board.pathRef(targetPath);\n                const targetPreviousPathRef = Path.hasPrevious(targetPath) && board.pathRef(Path.previous(targetPath));\n                const targetElementPathRef = board.pathRef(PlaitBoard.findPath(board, dropTarget.target));\n                let abstractRefs = getValidAbstractRefs(board, firstLevelElements);\n                const normalElements = firstLevelElements\n                    .filter(element => !abstractRefs.some(refs => refs.abstract === element))\n                    .map(element => {\n                        if (AbstractNode.isAbstract(element)) {\n                            return adjustAbstractToNode(element);\n                        }\n                        return element;\n                    });\n\n                const hasPreviousNode = targetPath[targetPath.length - 1] !== 0;\n                if (hasPreviousNode) {\n                    const previousElement = PlaitNode.get(board, Path.previous(targetPath)) as MindElement;\n                    const correspondingAbstract = getCorrespondingAbstract(previousElement);\n                    const targetHasCorrespondAbstract =\n                        correspondingAbstract && correspondingAbstract.end !== targetPath[targetPath.length - 1] - 1;\n                    if (targetHasCorrespondAbstract) {\n                        const adjustedNode = abstractRefs.map(ref => {\n                            return adjustAbstractToNode(ref.abstract);\n                        });\n                        normalElements.push(...adjustedNode);\n                        abstractRefs = [];\n                    }\n                }\n\n                const effectedAbstracts = deleteElementHandleAbstract(board, firstLevelElements);\n                insertElementHandleAbstract(board, targetPath, normalElements.length, false, effectedAbstracts);\n                MindTransforms.setAbstractsByRefs(board, effectedAbstracts);\n\n                let refs = deleteElementsHandleRightNodeCount(board, firstLevelElements);\n                const parent = PlaitNode.get(board, Path.parent(targetPath)) as MindElement;\n                const shouldChangeRoot = isDropStandardRight(parent, dropTarget);\n                if (shouldChangeRoot && targetElementPathRef.current) {\n                    refs = insertElementHandleRightNodeCount(board, targetElementPathRef.current.slice(0, 1), normalElements.length, refs);\n                }\n\n                MindTransforms.setRightNodeCountByRefs(board, refs);\n                CoreTransforms.removeElements(board, firstLevelElements);\n\n                let insertPath = targetPathRef.current;\n                const parentPath = Path.parent(targetPathRef.current || targetPath);\n                if (!insertPath) {\n                    // When the insertion position and the selected node position are the same, the recorded previousPath is used\n                    const previousPath = targetPreviousPathRef && targetPreviousPathRef.unref();\n                    if (previousPath) {\n                        insertPath = Path.next(previousPath);\n                    } else {\n                        const parent = PlaitNode.get(board, parentPath);\n                        const children = getNonAbstractChildren(parent);\n                        insertPath = [...parentPath, children.length || 0];\n                    }\n                }\n\n                MindTransforms.insertNodes(board, normalElements, insertPath);\n\n                if (abstractRefs.length) {\n                    MindTransforms.insertAbstractNodes(board, abstractRefs, normalElements, insertPath);\n                }\n\n                if (\n                    targetElementPathRef.current &&\n                    targetPathRef.current &&\n                    Path.isAncestor(targetElementPathRef.current, targetPathRef.current) &&\n                    dropTarget.target.isCollapsed\n                ) {\n                    Transforms.setNode(board, { isCollapsed: false }, targetElementPathRef.current);\n                }\n                targetElementPathRef.unref();\n                targetPathRef.unref();\n\n                let setActiveElements: MindElement[] = [];\n                depthFirstRecursion((board as unknown) as MindElement, node => {\n                    const isSelected = activeElements.some(element => element.id === node.id);\n                    if (isSelected) {\n                        setActiveElements.push(node);\n                    }\n                });\n\n                Transforms.addSelectionWithTemporaryElements(board, setActiveElements);\n            }\n            setMindDragging(board, false);\n            activeElements = [];\n            dragFakeNodeG?.remove();\n            dragFakeNodeG = undefined;\n            fakeDropNodeG?.remove();\n            fakeDropNodeG = undefined;\n            dropTarget = null;\n        }\n        globalPointerUp(event);\n    };\n\n    return board;\n};\n","import {\n    BOARD_TO_HOST,\n    PlaitBoard,\n    PlaitElement,\n    PlaitPlugin,\n    Point,\n    Transforms,\n    getSelectedElements,\n    isMainPointer,\n    toActivePointFromViewBoxPoint,\n    toHostPoint,\n    toViewBoxPoint\n} from '@plait/core';\nimport { AbstractNode, LayoutNode, MindLayoutType, isHorizontalLayout, isStandardLayout } from '@plait/layouts';\nimport { MindElement } from '../interfaces';\nimport { findLocationLeftIndex, getHitAbstractHandle, getLocationScope, handleTouchedAbstract } from '../utils/abstract/resize';\nimport { separateChildren } from '../utils/abstract/common';\nimport { AbstractHandlePosition, AbstractResizeState, PlaitAbstractBoard } from './with-abstract-resize.board';\nimport { MindQueries } from '../queries';\nimport { PlaitCommonElementRef } from '@plait/common';\nimport { NodeActiveGenerator } from '../generators/node-active.generator';\n\nexport const withAbstract: PlaitPlugin = (board: PlaitBoard) => {\n    const newBoard = board as PlaitBoard & PlaitAbstractBoard;\n\n    const { pointerDown, pointerMove, pointerUp } = board;\n    let activeAbstractElement: MindElement | undefined;\n    let abstractHandlePosition: AbstractHandlePosition | undefined;\n    let touchedAbstract: MindElement | undefined;\n    let startPoint: Point | undefined;\n    let newProperty: { end: number } | { start: number } | undefined;\n\n    board.pointerDown = (event: PointerEvent) => {\n        if (!isMainPointer(event) || PlaitBoard.isReadonly(board)) {\n            pointerDown(event);\n            return;\n        }\n\n        const activeAbstractElements = getSelectedElements(board).filter((element) => AbstractNode.isAbstract(element)) as MindElement[];\n        const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n\n        activeAbstractElement = activeAbstractElements.find((element) => {\n            abstractHandlePosition = getHitAbstractHandle(board, element as MindElement, point);\n            return abstractHandlePosition;\n        });\n\n        if (activeAbstractElement) {\n            if (newBoard?.onAbstractResize) {\n                newBoard.onAbstractResize(AbstractResizeState.start);\n            }\n            startPoint = point;\n            return;\n        }\n\n        pointerDown(event);\n    };\n\n    board.pointerMove = (event: PointerEvent) => {\n        getSelectedElements(board);\n        const endPoint = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n\n        touchedAbstract = handleTouchedAbstract(board, touchedAbstract, endPoint);\n\n        if (abstractHandlePosition && activeAbstractElement) {\n            const nodeLayout = MindQueries.getCorrectLayoutByElement(board, activeAbstractElement as MindElement) as MindLayoutType;\n            const isHorizontal = isHorizontalLayout(nodeLayout);\n            const parentElement = MindElement.getParent(activeAbstractElement);\n\n            let children = parentElement.children;\n\n            const parentLayout = MindQueries.getLayoutByElement(parentElement);\n            if (isStandardLayout(parentLayout)) {\n                const rightNodeCount = parentElement.rightNodeCount!;\n                const { leftChildren, rightChildren } = separateChildren(parentElement);\n                if ((activeAbstractElement as MindElement).end! < rightNodeCount) {\n                    children = rightChildren;\n                }\n                if ((activeAbstractElement as MindElement).start! >= rightNodeCount) {\n                    children = leftChildren;\n                }\n            }\n\n            if (newBoard?.onAbstractResize) {\n                newBoard.onAbstractResize(AbstractResizeState.resizing);\n            }\n\n            const resizingLocation = isHorizontal ? endPoint[1] : endPoint[0];\n            const parent = MindElement.getNode(parentElement) as unknown as LayoutNode;\n            const scope = getLocationScope(board, abstractHandlePosition, children, activeAbstractElement, parent, isHorizontal);\n            const location = Math.min(scope.max, Math.max(scope.min, resizingLocation));\n            let locationIndex = findLocationLeftIndex(board, children, location, isHorizontal);\n\n            const isPropertyUnchanged =\n                (abstractHandlePosition === AbstractHandlePosition.start &&\n                    locationIndex + 1 === (activeAbstractElement as MindElement).start!) ||\n                (abstractHandlePosition === AbstractHandlePosition.end && locationIndex === (activeAbstractElement as MindElement).end!);\n\n            if (isPropertyUnchanged) {\n                newProperty = undefined;\n            } else {\n                if (isStandardLayout(parent.layout)) {\n                    const rightNodeCount = parent.origin.rightNodeCount;\n                    let start = activeAbstractElement.start!;\n                    if (start >= rightNodeCount) {\n                        locationIndex += rightNodeCount;\n                    }\n                }\n\n                newProperty =\n                    abstractHandlePosition === AbstractHandlePosition.start ? { start: locationIndex + 1 } : { end: locationIndex };\n            }\n            const ref = PlaitElement.getElementRef<PlaitCommonElementRef>(activeAbstractElement);\n            const activeGenerator = ref.getGenerator<NodeActiveGenerator>(NodeActiveGenerator.key);\n            const activeLocation = toActivePointFromViewBoxPoint(board, [location, location]);\n            activeGenerator.updateAbstractOutline(\n                activeAbstractElement,\n                abstractHandlePosition,\n                isHorizontal ? activeLocation[1] : activeLocation[0]\n            );\n        }\n        pointerMove(event);\n    };\n\n    board.pointerUp = (event: PointerEvent) => {\n        startPoint = undefined;\n        abstractHandlePosition = undefined;\n        if (activeAbstractElement) {\n            if (newBoard?.onAbstractResize) {\n                newBoard.onAbstractResize(AbstractResizeState.end);\n            }\n\n            if (newProperty) {\n                const path = PlaitBoard.findPath(board, activeAbstractElement);\n                Transforms.setNode(board, newProperty, path);\n            } else {\n                const ref = PlaitElement.getElementRef<PlaitCommonElementRef>(activeAbstractElement);\n                const activeGenerator = ref.getGenerator<NodeActiveGenerator>(NodeActiveGenerator.key);\n                activeGenerator.updateAbstractOutline(activeAbstractElement);\n            }\n            activeAbstractElement = undefined;\n            return;\n        }\n        pointerUp(event);\n    };\n    return board;\n};\n","import { PlaitBoard, PlaitOptionsBoard } from '@plait/core';\nimport { PlaitMindBoard } from './with-mind.board';\nimport { WithMindOptions } from '../interfaces/options';\nimport { WithMindPluginKey } from '../constants/default';\n\nexport const withMindExtend = (board: PlaitBoard) => {\n    const newBoard = board as PlaitBoard & PlaitMindBoard;\n\n    (board as PlaitOptionsBoard).setPluginOptions<WithMindOptions>(WithMindPluginKey, { spaceBetweenEmojis: 4, emojiPadding: 0 });\n\n    return newBoard;\n};\n","import {\n    BoardTransforms,\n    PlaitBoard,\n    PlaitPointerType,\n    createG,\n    getSelectedElements,\n    throttleRAF,\n    toHostPoint,\n    toViewBoxPoint\n} from '@plait/core';\nimport { PlaitMindBoard } from './with-mind.board';\nimport { MindPointerType } from '../interfaces/pointer';\nimport { getRectangleByElement, getTopicRectangleByElement } from '../utils';\nimport { drawRoundRectangleByElement } from '../utils/draw/node-shape';\nimport { createEmptyMind } from '../utils/node/create-node';\nimport { MindElement } from '../interfaces';\nimport { BoardCreationMode, TextManage, isDndMode, isDrawingMode, setCreationMode } from '@plait/common';\nimport { MindTransforms } from '../transforms';\n\nconst DefaultHotkey = 'm';\n\nexport interface FakeCreateNodeRef {\n    g: SVGGElement;\n    nodeG: SVGGElement;\n    textManage: TextManage;\n}\n\nexport const withCreateMind = (board: PlaitBoard) => {\n    const newBoard = board as PlaitBoard & PlaitMindBoard;\n    const { keyDown, pointerDown, pointerMove, pointerUp } = board;\n    let fakeCreateNodeRef: FakeCreateNodeRef | null = null;\n    let emptyMind: MindElement | null = null;\n\n    newBoard.pointerDown = (event: PointerEvent) => {\n        const isMindPointer = PlaitBoard.isPointer<MindPointerType | PlaitPointerType>(board, MindPointerType.mind);\n        if (!PlaitBoard.isReadonly(board) && isDrawingMode(board) && isMindPointer) {\n            const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n            const emptyMind = createEmptyMind(newBoard, point);\n            MindTransforms.insertMind(board as PlaitMindBoard, emptyMind);\n            BoardTransforms.updatePointerType(board, PlaitPointerType.selection);\n            return;\n        }\n        pointerDown(event);\n    };\n\n    newBoard.pointerMove = (event: PointerEvent) => {\n        if (PlaitBoard.isReadonly(board)) {\n            pointerMove(event);\n            return;\n        }\n        const isMindPointer = PlaitBoard.isPointer<MindPointerType | PlaitPointerType>(board, MindPointerType.mind);\n        if (isDndMode(board) && isMindPointer) {\n            throttleRAF(board, 'with-mind-create', () => {\n                let movingPoint = PlaitBoard.getMovingPointInBoard(board);\n\n                if (movingPoint) {\n                    movingPoint = toViewBoxPoint(newBoard, toHostPoint(board, movingPoint[0], movingPoint[1]));\n                    emptyMind = createEmptyMind(newBoard, movingPoint);\n                    const nodeRectangle = getRectangleByElement(newBoard, emptyMind);\n                    const nodeG = drawRoundRectangleByElement(board, nodeRectangle, emptyMind);\n                    const topicRectangle = getTopicRectangleByElement(newBoard, nodeRectangle, emptyMind);\n                    if (!fakeCreateNodeRef) {\n                        const textManage = new TextManage(board, {\n                            getRectangle: () => {\n                                return topicRectangle;\n                            }\n                        });\n                        textManage.draw(emptyMind!.data.topic);\n                        fakeCreateNodeRef = {\n                            g: createG(),\n                            nodeG,\n                            textManage\n                        };\n                        fakeCreateNodeRef.g.classList.add('root');\n                        fakeCreateNodeRef.g.setAttribute('plait-mind-temporary', 'true');\n                        PlaitBoard.getHost(board).append(fakeCreateNodeRef.g);\n                        fakeCreateNodeRef.g.append(...[fakeCreateNodeRef.nodeG, textManage.g]);\n                    } else {\n                        fakeCreateNodeRef.textManage.updateRectangle(topicRectangle);\n                        fakeCreateNodeRef.nodeG.remove();\n                        fakeCreateNodeRef.nodeG = nodeG;\n                        fakeCreateNodeRef.g.append(nodeG);\n                        fakeCreateNodeRef.g.append(fakeCreateNodeRef.textManage.g);\n                    }\n                }\n            });\n        } else {\n            destroy();\n        }\n        pointerMove(event);\n    };\n\n    newBoard.pointerUp = (event: PointerEvent) => {\n        if (emptyMind) {\n            MindTransforms.insertMind(board as PlaitMindBoard, emptyMind);\n            BoardTransforms.updatePointerType(board, PlaitPointerType.selection);\n            emptyMind = null;\n            destroy();\n            return;\n        }\n        pointerUp(event);\n    };\n\n    board.keyDown = (event: KeyboardEvent) => {\n        if (PlaitBoard.isReadonly(board) || getSelectedElements(board).length > 0) {\n            keyDown(event);\n            return;\n        }\n        if (event.key === DefaultHotkey && !PlaitBoard.isPointer(board, MindPointerType.mind)) {\n            BoardTransforms.updatePointerType(board, MindPointerType.mind);\n            setCreationMode(board, BoardCreationMode.drawing);\n            event.preventDefault();\n            return;\n        }\n        keyDown(event);\n    };\n\n    function destroy() {\n        if (fakeCreateNodeRef) {\n            fakeCreateNodeRef.textManage.destroy();\n            fakeCreateNodeRef.g.remove();\n            fakeCreateNodeRef = null;\n        }\n    }\n\n    return newBoard;\n};\n","import { PlaitBoard, Transforms, getSelectedElements } from '@plait/core';\nimport { MindElement, PlaitMind } from '../interfaces';\nimport { AbstractNode } from '@plait/layouts';\nimport { MindTransforms } from '../transforms';\nimport { editTopic } from '../utils/node/common';\nimport { PlaitMindBoard } from './with-mind.board';\nimport { isSpaceHotkey, isExpandHotkey, isTabHotkey, isEnterHotkey, isVirtualKey, isDelete, getFirstTextManage } from '@plait/common';\nimport { isHotkey } from 'is-hotkey';\n\nexport const withMindHotkey = (baseBoard: PlaitBoard) => {\n    const board = baseBoard as PlaitBoard & PlaitMindBoard;\n    const { keyDown, globalKeyDown } = board;\n\n    board.keyDown = (event: KeyboardEvent) => {\n        const selectedElements = getSelectedElements(board);\n        const isSingleSelection = selectedElements.length === 1;\n        const isSingleMindElement = selectedElements.length === 1 && MindElement.isMindElement(board, selectedElements[0]);\n        const targetElement = selectedElements[0] as MindElement;\n\n        if (isExpandHotkey(event) && isSingleMindElement && !PlaitMind.isMind(targetElement)) {\n            if (targetElement.children && targetElement.children.length > 0) {\n                Transforms.setNode(\n                    board,\n                    { isCollapsed: targetElement.isCollapsed ? false : true },\n                    PlaitBoard.findPath(board, targetElement)\n                );\n                return;\n            }\n        }\n\n        if (!PlaitBoard.isReadonly(board)) {\n            if (isTabHotkey(event) && isSingleMindElement) {\n                event.preventDefault();\n                MindTransforms.insertChildNode(board, targetElement);\n                return;\n            }\n\n            if (\n                isEnterHotkey(event) &&\n                isSingleMindElement &&\n                !PlaitMind.isMind(targetElement) &&\n                !AbstractNode.isAbstract(targetElement)\n            ) {\n                MindTransforms.insertSiblingNode(board, targetElement);\n                return;\n            }\n\n            if (\n                !isVirtualKey(event) &&\n                !isDelete(event) &&\n                !isSpaceHotkey(event) &&\n                isSingleSelection &&\n                MindElement.isMindElement(board, targetElement)\n            ) {\n                event.preventDefault();\n                editTopic(targetElement);\n                return;\n            }\n        }\n\n        keyDown(event);\n    };\n\n    board.globalKeyDown = (event: KeyboardEvent) => {\n        if (PlaitBoard.isFocus(board) && PlaitBoard.hasBeenTextEditing(board)) {\n            if (isHotkey('mod+z', event)) {\n                const { history } = board;\n                const { undos } = history;\n                const previousOp =  undos.length > 0 ? undos[undos.length - 1][0] : undefined;\n                if (previousOp && previousOp.type === 'insert_node' && MindElement.isMindElement(board, previousOp.node) && getFirstTextManage(previousOp.node).isEditing) {\n                    board.undo();\n                }\n            }\n        }\n        globalKeyDown(event);\n    };\n\n    return board;\n};\n","import {\n    depthFirstRecursion,\n    getIsRecursionFunc,\n    isSelectedElement,\n    PlaitBoard,\n    PlaitElement,\n    RectangleClient,\n    throttleRAF,\n    toHostPoint,\n    toViewBoxPoint,\n    Transforms\n} from '@plait/core';\nimport { MindElement, PlaitMind } from '../interfaces';\nimport { findNewChildNodePath, insertMindElement, isHitMindElement } from '../utils';\nimport { PlaitCommonElementRef } from '@plait/common';\nimport { canHandleNodeMore, getCollapseAndAddCenterPoint, NodeMoreGenerator } from '../generators/node-more.generator';\nimport { NODE_MORE_ICON_DIAMETER } from '../constants/default';\nimport { PlaitMindBoard } from './with-mind.board';\n\nexport interface NodeMoreRef {\n    target: MindElement;\n    isHovered: boolean;\n    isHoveredCollapseArea: boolean;\n    isHoveredExpandArea: boolean;\n    isHoveredAddArea: boolean;\n}\n\nexport const withNodeMore = (board: PlaitBoard) => {\n    const { pointerMove, pointerLeave, pointerUp } = board;\n    let nodeMoreRef: NodeMoreRef | null = null;\n\n    board.pointerMove = (event: PointerEvent) => {\n        if (canHandleNodeMore(board)) {\n            throttleRAF(board, 'with-mind-node-hover-hit-test', () => {\n                // target has been deleted\n                if (nodeMoreRef && !PlaitElement.hasMounted(nodeMoreRef.target)) {\n                    nodeMoreRef = null;\n                }\n                const newNodeMoreRef = getNodeMoreRef(board, event.x, event.y);\n\n                if (nodeMoreRef && newNodeMoreRef && nodeMoreRef.target === newNodeMoreRef.target) {\n                    return;\n                }\n\n                if (nodeMoreRef) {\n                    toggleHoveredNodeCallback({\n                        target: nodeMoreRef.target,\n                        isHovered: false,\n                        isHoveredCollapseArea: false,\n                        isHoveredExpandArea: false,\n                        isHoveredAddArea: false\n                    });\n                }\n\n                if (newNodeMoreRef) {\n                    toggleHoveredNodeCallback(newNodeMoreRef);\n                    if (nodeMoreRef) {\n                        nodeMoreRef.target = newNodeMoreRef.target;\n                    } else {\n                        nodeMoreRef = newNodeMoreRef;\n                    }\n                } else {\n                    nodeMoreRef = null;\n                }\n            });\n        }\n        pointerMove(event);\n    };\n\n    board.pointerUp = (event: PointerEvent) => {\n        if (nodeMoreRef && (nodeMoreRef.isHoveredCollapseArea || nodeMoreRef.isHoveredExpandArea)) {\n            const isCollapsed = !nodeMoreRef.target.isCollapsed;\n            const newElement: Partial<MindElement> = { isCollapsed };\n            const path = PlaitBoard.findPath(board, nodeMoreRef.target);\n            Transforms.setNode(board, newElement, path);\n            setTimeout(() => {\n                const newNodeMoreRef = getNodeMoreRef(board, event.x, event.y);\n                if (newNodeMoreRef) {\n                    toggleHoveredNodeCallback(newNodeMoreRef);\n                    nodeMoreRef = newNodeMoreRef;\n                } else {\n                    nodeMoreRef = null;\n                }\n            }, 0);\n            return;\n        }\n        if (nodeMoreRef && nodeMoreRef.isHoveredAddArea && !PlaitBoard.isReadonly(board)) {\n            if (nodeMoreRef) {\n                const path = findNewChildNodePath(board, nodeMoreRef.target);\n                insertMindElement(board as PlaitMindBoard, nodeMoreRef.target, path);\n            }\n            return;\n        }\n        pointerUp(event);\n    };\n\n    const toggleHoveredNodeCallback = (ref: NodeMoreRef) => {\n        const elementRef = PlaitElement.getElementRef<PlaitCommonElementRef>(ref.target);\n        const nodeMoreGenerator = elementRef?.getGenerator<NodeMoreGenerator>(NodeMoreGenerator.key);\n        if (nodeMoreGenerator) {\n            const g = PlaitElement.getElementG(ref.target);\n            nodeMoreGenerator.processDrawing(ref.target, g, {\n                isHovered: ref.isHovered,\n                isHoveredCollapseArea: ref.isHoveredCollapseArea,\n                isHoveredExpandArea: ref.isHoveredExpandArea,\n                isSelected: isSelectedElement(board, ref.target),\n                isHoveredAddArea: ref.isHoveredAddArea,\n                isShowCollapseAnimation: (ref.isHovered || ref.isHoveredCollapseArea) && !isSelectedElement(board, ref.target),\n                isShowAddAnimation: (ref.isHovered || ref.isHoveredAddArea) && !isSelectedElement(board, ref.target)\n            });\n        }\n    };\n\n    board.pointerLeave = (event: PointerEvent) => {\n        if (nodeMoreRef) {\n            toggleHoveredNodeCallback({\n                target: nodeMoreRef.target,\n                isHovered: false,\n                isHoveredCollapseArea: false,\n                isHoveredExpandArea: false,\n                isHoveredAddArea: false\n            });\n        }\n        nodeMoreRef = null;\n        pointerLeave(event);\n    };\n\n    return board;\n};\n\nconst getNodeMoreRef = (board: PlaitBoard, x: number, y: number) => {\n    let target: MindElement | null = null;\n    let isHovered = false;\n    let isHoveredCollapseArea = false;\n    let isHoveredExpandArea = false;\n    let isHoveredAddArea = false;\n    const point = toViewBoxPoint(board, toHostPoint(board, x, y));\n    depthFirstRecursion(\n        board as unknown as MindElement,\n        (element) => {\n            if (target) {\n                return;\n            }\n            if (!MindElement.isMindElement(board, element)) {\n                return;\n            }\n            const isMind = PlaitMind.isMind(element);\n            const isHitElement = isHitMindElement(board, point, element);\n            let isHitCollapseOrExpand = false;\n            let isHitAdd = false;\n            const { collapseCenter, addCenter } = getCollapseAndAddCenterPoint(board, element);\n            const collapseOrExpandIconRectangle =\n                !isMind && RectangleClient.getRectangleByCenterPoint(collapseCenter, NODE_MORE_ICON_DIAMETER, NODE_MORE_ICON_DIAMETER);\n            isHitCollapseOrExpand =\n                collapseOrExpandIconRectangle &&\n                RectangleClient.isHit(RectangleClient.getRectangleByPoints([point, point]), collapseOrExpandIconRectangle);\n            const addIconRectangle = RectangleClient.getRectangleByCenterPoint(addCenter, NODE_MORE_ICON_DIAMETER, NODE_MORE_ICON_DIAMETER);\n            isHitAdd = RectangleClient.isHit(RectangleClient.getRectangleByPoints([point, point]), addIconRectangle);\n            if (isHitElement || isHitCollapseOrExpand || isHitAdd) {\n                isHovered = isHitElement;\n                if (element.children.length > 0) {\n                    if (element.isCollapsed) {\n                        isHoveredExpandArea = isHitCollapseOrExpand;\n                    } else {\n                        isHoveredCollapseArea = isHitCollapseOrExpand;\n                    }\n                }\n                isHoveredAddArea = isHitAdd;\n                target = element;\n            }\n        },\n        getIsRecursionFunc(board),\n        true\n    );\n    if (!target) {\n        return null;\n    }\n    return {\n        target,\n        isHovered,\n        isHoveredCollapseArea,\n        isHoveredExpandArea,\n        isHoveredAddArea\n    } as NodeMoreRef;\n};\n","import {\n    PlaitBoard,\n    isMainPointer,\n    PlaitOptionsBoard,\n    hotkeys,\n    PlaitPointerType,\n    addSelectedElement,\n    Point,\n    getSelectedElements,\n    RectangleClient,\n    getHitElementByPoint,\n    temporaryDisableSelection,\n    WritableClipboardType,\n    toHostPoint,\n    toViewBoxPoint,\n    WritableClipboardContext,\n    createClipboardContext,\n    ClipboardData,\n    isContextmenu,\n    PlaitElement,\n    WritableClipboardOperationType\n} from '@plait/core';\nimport { MindElement } from '../interfaces';\nimport { ImageData } from '../interfaces/element-data';\nimport { addImageFocus, removeImageFocus } from '../utils/node/image';\nimport { isHitImage } from '../utils';\nimport { MindTransforms } from '../transforms';\nimport { acceptImageTypes, buildImage, getElementOfFocusedImage, ImageGenerator, PlaitCommonElementRef } from '@plait/common';\nimport { DEFAULT_MIND_IMAGE_WIDTH } from '../constants';\n\nexport const withNodeImage = (board: PlaitBoard) => {\n    const { keyDown, pointerUp, globalPointerUp, buildFragment, insertFragment, deleteFragment, afterChange } = board;\n\n    board.pointerUp = (event: PointerEvent) => {\n        const elementOfFocusedImage = getElementOfFocusedImage(board);\n        if (\n            elementOfFocusedImage &&\n            MindElement.isMindElement(board, elementOfFocusedImage) &&\n            !isContextmenu(event) &&\n            (PlaitBoard.isReadonly(board) || !isMainPointer(event) || !PlaitBoard.isPointer(board, PlaitPointerType.selection))\n        ) {\n            removeImageFocus(board, elementOfFocusedImage as MindElement<ImageData>);\n            pointerUp(event);\n            return;\n        }\n        if (PlaitBoard.isReadonly(board)) {\n            pointerUp(event);\n            return;\n        }\n        const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n        const hitElement = getHitElementByPoint(board, point);\n        const isHitImageResult =\n            hitElement &&\n            MindElement.isMindElement(board, hitElement) &&\n            MindElement.hasImage(hitElement) &&\n            isHitImage(board, hitElement as MindElement<ImageData>, point);\n        if (isHitImageResult && elementOfFocusedImage && hitElement === elementOfFocusedImage) {\n            temporaryDisableSelection(board as PlaitOptionsBoard);\n            pointerUp(event);\n            return;\n        }\n        if (elementOfFocusedImage && MindElement.isMindElement(board, elementOfFocusedImage)) {\n            removeImageFocus(board, elementOfFocusedImage as MindElement<ImageData>);\n        }\n        if (isHitImageResult && hitElement) {\n            temporaryDisableSelection(board as PlaitOptionsBoard);\n            addImageFocus(board, hitElement as MindElement<ImageData>);\n        }\n        pointerUp(event);\n    };\n\n    board.keyDown = (event: KeyboardEvent) => {\n        const selectedImageElement = getElementOfFocusedImage(board);\n        if (!PlaitBoard.isReadonly(board) && selectedImageElement && (hotkeys.isDeleteBackward(event) || hotkeys.isDeleteForward(event))) {\n            addSelectedElement(board, selectedImageElement);\n            MindTransforms.removeImage(board, selectedImageElement as MindElement<ImageData>);\n            return;\n        }\n        keyDown(event);\n    };\n\n    board.globalPointerUp = (event: PointerEvent) => {\n        if (PlaitBoard.isFocus(board)) {\n            const isInBoard = event.target instanceof Node && PlaitBoard.getBoardContainer(board).contains(event.target);\n            const selectedImageElement = getElementOfFocusedImage(board);\n            // Clear image selection when mouse board outside area\n            if (selectedImageElement && MindElement.isMindElement(board, selectedImageElement) && !isInBoard) {\n                removeImageFocus(board, selectedImageElement as MindElement<ImageData>);\n            }\n        }\n        globalPointerUp(event);\n    };\n\n    board.buildFragment = (\n        clipboardContext: WritableClipboardContext | null,\n        rectangle: RectangleClient | null,\n        operationType: WritableClipboardOperationType,\n        originData?: PlaitElement[]\n    ) => {\n        const selectedImageElement = getElementOfFocusedImage(board) as MindElement<ImageData>;\n        if (selectedImageElement) {\n            clipboardContext = createClipboardContext(WritableClipboardType.medias, [selectedImageElement.data.image], '');\n        }\n        return buildFragment(clipboardContext, rectangle, operationType, originData);\n    };\n\n    board.deleteFragment = (elements: PlaitElement[]) => {\n        const selectedImageElement = getElementOfFocusedImage(board);\n        if (selectedImageElement) {\n            MindTransforms.removeImage(board, selectedImageElement as MindElement<ImageData>);\n        }\n        deleteFragment(elements);\n    };\n\n    board.insertFragment = (clipboardData: ClipboardData | null, targetPoint: Point, operationType?: WritableClipboardOperationType) => {\n        const selectedElements = getSelectedElements(board);\n        const isSelectedImage = !!getElementOfFocusedImage(board);\n        const isSingleSelection = selectedElements.length === 1 && MindElement.isMindElement(board, selectedElements[0]);\n        if (isSelectedImage || isSingleSelection) {\n            if (clipboardData?.files?.length) {\n                const acceptImageArray = acceptImageTypes.map((type) => 'image/' + type);\n                const selectedElement = (selectedElements[0] || getElementOfFocusedImage(board)) as MindElement;\n                if (acceptImageArray.includes(clipboardData.files[0].type)) {\n                    const imageFile = clipboardData.files[0];\n                    buildImage(board, imageFile, DEFAULT_MIND_IMAGE_WIDTH, (imageItem) => {\n                        MindTransforms.setImage(board, selectedElement, imageItem);\n                    });\n                    return;\n                }\n            }\n            if (clipboardData?.medias?.length) {\n                const selectedElement = (selectedElements[0] || getElementOfFocusedImage(board)) as MindElement;\n                MindTransforms.setImage(board, selectedElement, clipboardData.medias[0]);\n                return;\n            }\n        }\n        insertFragment(clipboardData, targetPoint, operationType);\n    };\n\n    board.afterChange = () => {\n        afterChange();\n        const selectedImageElement = getElementOfFocusedImage(board);\n        if (selectedImageElement && MindElement.isMindElement(board, selectedImageElement)) {\n            const commonElementRef = PlaitElement.getElementRef<PlaitCommonElementRef>(selectedImageElement);\n            const imageGenerator = commonElementRef.getGenerator<ImageGenerator>(ImageGenerator.key);\n            imageGenerator.setFocus(selectedImageElement, true);\n        }\n    };\n\n    return board;\n};\n","import {\n    Path,\n    PlaitBoard,\n    PlaitNode,\n    Point,\n    RectangleClient,\n    ResizeCursorClass,\n    distanceBetweenPointAndRectangle,\n    getSelectedElements\n} from '@plait/core';\nimport { MindElement } from '../interfaces/element';\nimport { getRectangleByNode } from '../utils/position/node';\nimport { NodeSpace } from '../utils/space/node-space';\nimport { PlaitMindBoard } from './with-mind.board';\nimport { MindTransforms } from '../transforms';\nimport { RESIZE_HANDLE_BUFFER_DISTANCE } from '../constants/default';\nimport { ResizeRef, ResizeState, TextManage, WithResizeOptions, getFirstTextManage, withResize } from '@plait/common';\n\ninterface TargetElementRef {\n    minWidth: number;\n    currentWidth: number;\n    path: Path;\n    textManage: TextManage;\n}\n\nexport const withNodeResize = (board: PlaitBoard) => {\n    let targetElementRef: TargetElementRef | null = null;\n    const options: WithResizeOptions<MindElement, null> = {\n        key: 'mind-node',\n        canResize: () => {\n            return true;\n        },\n        hitTest: (point: Point) => {\n            const newTargetElement = getSelectedTarget(board as PlaitMindBoard, point);\n            if (newTargetElement) {\n                return {\n                    element: newTargetElement,\n                    handle: null,\n                    cursorClass: ResizeCursorClass.ew\n                };\n            }\n            return null;\n        },\n        beforeResize: (resizeRef: ResizeRef<MindElement, null>) => {\n            targetElementRef = {\n                minWidth: NodeSpace.getNodeResizableMinWidth(board as PlaitMindBoard, resizeRef.element),\n                currentWidth: NodeSpace.getTopicDynamicWidth(board as PlaitMindBoard, resizeRef.element),\n                path: PlaitBoard.findPath(board, resizeRef.element),\n                textManage: getFirstTextManage(resizeRef.element)\n            };\n        },\n        onResize: (resizeRef: ResizeRef<MindElement, null>, resizeState: ResizeState) => {\n            let resizedWidth = targetElementRef!.currentWidth + Point.getOffsetX(resizeState.startPoint, resizeState.endPoint);\n            if (resizedWidth <= targetElementRef!.minWidth) {\n                resizedWidth = targetElementRef!.minWidth;\n            }\n            const newTarget = PlaitNode.get<MindElement>(board, targetElementRef!.path);\n            if (newTarget && NodeSpace.getNodeTopicMinWidth(board as PlaitMindBoard, newTarget) !== resizedWidth) {\n                targetElementRef!.textManage.updateRectangleWidth(resizedWidth);\n                const { height } = targetElementRef!.textManage.getSize(undefined, resizedWidth);\n                MindTransforms.setNodeManualWidth(board as PlaitMindBoard, newTarget, resizedWidth, height);\n            }\n        },\n        afterResize: (resizeRef: ResizeRef<MindElement, null>) => {\n            targetElementRef = null;\n        }\n    };\n    withResize<MindElement, null>(board, options);\n    return board;\n};\n\nexport const getSelectedTarget = (board: PlaitMindBoard, point: Point) => {\n    const selectedElements = getSelectedElements(board).filter((value) => MindElement.isMindElement(board, value)) as MindElement[];\n    if (selectedElements.length > 0) {\n        const target = selectedElements.find((value) => {\n            const rectangle = getResizeActiveRectangle(board, value);\n            return distanceBetweenPointAndRectangle(point[0], point[1], rectangle) <= 0;\n        });\n        return target ? target : null;\n    }\n    return null;\n};\n\nexport const getResizeActiveRectangle = (board: PlaitBoard, element: MindElement): RectangleClient => {\n    const node = MindElement.getNode(element);\n    const rectangle = getRectangleByNode(node);\n    return {\n        x: rectangle.x + rectangle.width - RESIZE_HANDLE_BUFFER_DISTANCE,\n        y: rectangle.y,\n        width: RESIZE_HANDLE_BUFFER_DISTANCE * 2,\n        height: rectangle.height\n    };\n};\n","import { PlaitBoard, Point, PlaitNode, Path } from '@plait/core';\nimport { MindElement } from '../interfaces';\nimport { ImageData } from '../interfaces/element-data';\nimport { getHitImageResizeHandleDirection } from '../utils';\nimport {\n    ResizeHandle,\n    ResizeRef,\n    ResizeState,\n    WithResizeOptions,\n    addElementOfFocusedImage,\n    getElementOfFocusedImage,\n    withResize\n} from '@plait/common';\nimport { MindTransforms } from '../transforms';\n\nexport const withNodeImageResize = (board: PlaitBoard) => {\n    const options: WithResizeOptions<MindElement<ImageData>> = {\n        key: 'mind-node-image',\n        canResize: () => {\n            return true;\n        },\n        hitTest: (point: Point) => {\n            const elementOfFocusedImage = getElementOfFocusedImage(board);\n            const selectedMindElement =\n                elementOfFocusedImage && MindElement.isMindElement(board, elementOfFocusedImage) ? elementOfFocusedImage : undefined;\n            if (selectedMindElement) {\n                const result = getHitImageResizeHandleDirection(board, selectedMindElement as MindElement<ImageData>, point);\n                if (result) {\n                    return {\n                        element: selectedMindElement as MindElement<ImageData>,\n                        handle: result.handle as ResizeHandle,\n                        cursorClass: result.cursorClass\n                    };\n                }\n            }\n            return null;\n        },\n        onResize: (resizeRef: ResizeRef<MindElement<ImageData>>, resizeState: ResizeState) => {\n            const offsetX = Point.getOffsetX(resizeState.startPoint, resizeState.endPoint);\n            const originWidth = resizeRef.element.data.image.width;\n            const originHeight = resizeRef.element.data.image.height;\n            const path = resizeRef.path as Path;\n            let width = originWidth + offsetX;\n            if (width <= 100) {\n                width = 100;\n            }\n            const ratio = originWidth / originHeight;\n            const height = width / ratio;\n            const imageItem = { ...resizeRef.element.data.image, width, height };\n            MindTransforms.setImage(board, PlaitNode.get(board, path), imageItem);\n            addElementOfFocusedImage(board, PlaitNode.get(board, path));\n        }\n    };\n\n    withResize<MindElement<ImageData>>(board, options);\n\n    return board;\n};\n","import { getSelectedElements, Path, PlaitBoard, PlaitElement, Point, Transforms, WritableClipboardOperationType } from '@plait/core';\nimport { MindElement, PlaitMind } from '../interfaces';\nimport { copyNewNode } from './mind';\nimport { getRectangleByNode } from './position/node';\nimport { AbstractNode, getNonAbstractChildren } from '@plait/layouts';\nimport { getRelativeStartEndByAbstractRef, getOverallAbstracts, getValidAbstractRefs } from './abstract/common';\nimport { createMindElement } from './node/create-node';\nimport { adjustAbstractToNode, adjustNodeToRoot, adjustRootToNode } from './node/adjust-node';\nimport { Element } from 'slate';\nimport { findNewChildNodePath } from './path';\nimport { PlaitMindBoard } from '../plugins/with-mind.board';\nimport { getFontSizeBySlateElement } from './space/node-space';\nimport { buildText } from '@plait/common';\nimport { getTopicSize } from './common';\n\nexport const buildClipboardData = (board: PlaitBoard, selectedElements: MindElement[], startPoint: Point) => {\n    let result: MindElement[] = [];\n\n    // get overall abstract\n    const overallAbstracts = getOverallAbstracts(board, selectedElements) as MindElement[];\n    // get valid abstract refs\n    const validAbstractRefs = getValidAbstractRefs(board, [...selectedElements, ...overallAbstracts]);\n\n    // keep correct order\n    const newSelectedElements = selectedElements.filter((value) => !validAbstractRefs.find((ref) => ref.abstract === value));\n    newSelectedElements.push(...validAbstractRefs.map((value) => value.abstract));\n\n    const selectedMindNodes = newSelectedElements.map((value) => MindElement.getNode(value));\n    newSelectedElements.forEach((element, index) => {\n        // handle relative location\n        const nodeRectangle = getRectangleByNode(selectedMindNodes[index]);\n        const points = [[nodeRectangle.x - startPoint[0], nodeRectangle.y - startPoint[1]]] as Point[];\n\n        // handle invalid abstract\n        const abstractRef = validAbstractRefs.find((ref) => ref.abstract === element);\n        if (AbstractNode.isAbstract(element) && abstractRef) {\n            const { start, end } = getRelativeStartEndByAbstractRef(abstractRef, newSelectedElements);\n            result.push({\n                ...element,\n                points,\n                start,\n                end\n            });\n        } else {\n            if (AbstractNode.isAbstract(element)) {\n                let newElement = { ...element, points } as MindElement;\n                delete newElement.start;\n                delete newElement.end;\n                result.push(newElement);\n            } else {\n                result.push({\n                    ...element,\n                    points: points\n                });\n            }\n        }\n    });\n    return result;\n};\n\nexport const insertClipboardData = (\n    board: PlaitMindBoard,\n    elements: PlaitElement[],\n    targetPoint: Point,\n    operationType?: WritableClipboardOperationType\n) => {\n    let newElement: MindElement, path: Path;\n    const selectedElements = getSelectedElements(board);\n    let newELements: PlaitElement[] = [];\n\n    const hasTargetParent = selectedElements.length === 1;\n    const targetParent = selectedElements[0];\n    const targetParentPath = targetParent && PlaitBoard.findPath(board, targetParent);\n    const nonAbstractChildrenLength = targetParent && getNonAbstractChildren(targetParent).length;\n\n    elements.forEach((item: PlaitElement, index: number) => {\n        newElement = copyNewNode(item as MindElement);\n        if (hasTargetParent && operationType !== WritableClipboardOperationType.duplicate) {\n            if (item.isRoot) {\n                newElement = adjustRootToNode(board, newElement);\n                const { width, height } = getTopicSizeByElement(board, newElement, targetParent as MindElement);\n                newElement.width = width;\n                newElement.height = height;\n            }\n            // handle abstract start and end\n            if (AbstractNode.isAbstract(newElement)) {\n                newElement.start = newElement.start + nonAbstractChildrenLength;\n                newElement.end = newElement.end + nonAbstractChildrenLength;\n            }\n            path = [...targetParentPath, nonAbstractChildrenLength + index];\n        } else {\n            const point: Point = [targetPoint[0] + item.points![0][0], targetPoint[1] + item.points![0][1]];\n            newElement.points = [point];\n            if (AbstractNode.isAbstract(item)) {\n                newElement = adjustAbstractToNode(newElement);\n            }\n            if (!item.isRoot) {\n                newElement = adjustNodeToRoot(board, newElement);\n                const { width, height } = getTopicSizeByElement(board, newElement);\n                newElement.width = width;\n                newElement.height = height;\n            }\n            path = [board.children.length];\n        }\n        newELements.push(newElement);\n        Transforms.insertNode(board, newElement, path);\n        return;\n    });\n    Transforms.addSelectionWithTemporaryElements(board, newELements);\n};\n\nexport const insertClipboardText = (board: PlaitMindBoard, targetParent: PlaitElement, text: string | Element) => {\n    const { width, height } = getTopicSize(board, false, PlaitMind.isMind(targetParent), buildText(text));\n    const newElement = createMindElement(text, Math.max(width, getFontSizeBySlateElement(text)), height, {});\n    Transforms.insertNode(board, newElement, findNewChildNodePath(board, targetParent));\n    Transforms.addSelectionWithTemporaryElements(board, [newElement]);\n};\n\nexport const getTopicSizeByElement = (board: PlaitBoard, element: MindElement, parentElement?: MindElement) => {\n    return getTopicSize(\n        board,\n        PlaitMind.isMind(element),\n        (parentElement && PlaitMind.isMind(parentElement)) || false,\n        element.data.topic,\n        element.manualWidth\n    );\n};\n","import {\n    ClipboardData,\n    Path,\n    PlaitBoard,\n    PlaitElement,\n    PlaitNode,\n    Point,\n    RectangleClient,\n    WritableClipboardContext,\n    WritableClipboardOperationType,\n    WritableClipboardType,\n    addOrCreateClipboardContext,\n    addSelectedElement\n} from '@plait/core';\nimport { MindElement } from '../interfaces';\nimport { AbstractNode } from '@plait/layouts';\nimport { getFirstLevelElement } from '../utils/mind';\nimport { deleteElementsHandleRightNodeCount } from '../utils/node/right-node-count';\nimport { MindTransforms } from '../transforms';\nimport { deleteElementHandleAbstract } from '../utils/abstract/common';\nimport { getSelectedMindElements } from '../utils/node/common';\nimport { PlaitMindBoard } from './with-mind.board';\nimport { buildClipboardData, insertClipboardData, insertClipboardText } from '../utils/clipboard';\nimport { buildText, getElementsText } from '@plait/common';\n\nexport const withMindFragment = (baseBoard: PlaitBoard) => {\n    const board = baseBoard as PlaitBoard & PlaitMindBoard;\n    let firstLevelElements: MindElement[] | null;\n    const { getDeletedFragment, insertFragment, buildFragment, deleteFragment } = board;\n\n    board.getDeletedFragment = (data: PlaitElement[]) => {\n        const targetMindElements = getSelectedMindElements(board);\n        if (targetMindElements.length) {\n            firstLevelElements = getFirstLevelElement(targetMindElements).reverse();\n            const abstractRefs = deleteElementHandleAbstract(board, firstLevelElements);\n            MindTransforms.setAbstractsByRefs(board, abstractRefs);\n            const refs = deleteElementsHandleRightNodeCount(board, targetMindElements);\n            MindTransforms.setRightNodeCountByRefs(board, refs);\n            const deletableElements = getFirstLevelElement(targetMindElements);\n            data.push(...deletableElements);\n        }\n        return getDeletedFragment(data);\n    };\n\n    board.deleteFragment = (elements: PlaitElement[]) => {\n        deleteFragment(elements);\n        if (firstLevelElements) {\n            const nextSelected = getNextSelectedElement(board, firstLevelElements);\n            if (nextSelected) {\n                addSelectedElement(board, nextSelected);\n            }\n            firstLevelElements = null;\n        }\n    };\n\n    board.buildFragment = (\n        clipboardContext: WritableClipboardContext | null,\n        rectangle: RectangleClient | null,\n        operationType: WritableClipboardOperationType,\n        originData?: PlaitElement[]\n    ) => {\n        const targetMindElements = getSelectedMindElements(board, originData);\n        const firstLevelElements = getFirstLevelElement(targetMindElements);\n        if (firstLevelElements.length) {\n            const elements = buildClipboardData(board, firstLevelElements, rectangle ? [rectangle.x, rectangle.y] : [0, 0]);\n            const text = getElementsText(targetMindElements);\n            const addition: WritableClipboardContext = {\n                text,\n                type: WritableClipboardType.elements,\n                elements: elements\n            };\n            clipboardContext = addOrCreateClipboardContext(clipboardContext, addition);\n        }\n        return buildFragment(clipboardContext, rectangle, operationType, originData);\n    };\n\n    board.insertFragment = (clipboardData: ClipboardData | null, targetPoint: Point, operationType?: WritableClipboardOperationType) => {\n        if (clipboardData?.elements?.length) {\n            const mindElements = clipboardData.elements?.filter(value => MindElement.isMindElement(board, value));\n            if (mindElements && mindElements.length > 0) {\n                insertClipboardData(board, mindElements, targetPoint, operationType);\n            }\n        }\n        if (clipboardData?.text) {\n            const mindElements = getSelectedMindElements(board);\n            if (mindElements.length === 1) {\n                insertClipboardText(board, mindElements[0], buildText(clipboardData.text));\n                return;\n            }\n        }\n\n        insertFragment(clipboardData, targetPoint, operationType);\n    };\n\n    return board;\n};\n\nexport const getNextSelectedElement = (board: PlaitBoard, firstLevelElements: MindElement[]) => {\n    let activeElement: MindElement | undefined;\n    const firstLevelElement = firstLevelElements[0];\n    const firstLevelElementPath = PlaitBoard.findPath(board, firstLevelElement);\n\n    let nextSelectedPath = firstLevelElementPath;\n    if (Path.hasPrevious(firstLevelElementPath)) {\n        nextSelectedPath = Path.previous(firstLevelElementPath);\n    }\n\n    if (AbstractNode.isAbstract(firstLevelElement)) {\n        const parent = MindElement.getParent(firstLevelElement);\n        if (!firstLevelElements.includes(parent.children[firstLevelElement.start])) {\n            activeElement = parent.children[firstLevelElement.start];\n        }\n    }\n\n    try {\n        if (!activeElement) {\n            activeElement = PlaitNode.get<MindElement>(board, nextSelectedPath);\n        }\n    } catch (error) {}\n\n    const firstElement = firstLevelElements[0];\n    const firstElementParent = MindElement.findParent(firstElement);\n    const hasSameParent = firstLevelElements.every(element => {\n        return MindElement.findParent(element) === firstElementParent;\n    });\n    if (firstElementParent && hasSameParent && !activeElement) {\n        activeElement = firstElementParent;\n    }\n    return activeElement;\n};\n","import { PlaitBoard } from '@plait/core';\nimport { RenderComponentRef } from '@plait/common';\nimport { EmojiData, EmojiItem } from '../interfaces/element-data';\nimport { MindElement } from '../interfaces/element';\n\nexport interface PlaitMindEmojiBoard {\n    renderEmoji: (container: Element | DocumentFragment, props: EmojiProps) => EmojiComponentRef;\n}\n\nexport const withEmoji = <T extends PlaitBoard = PlaitBoard>(board: T) => {\n    const newBoard = board as T & PlaitMindEmojiBoard;\n\n    newBoard.renderEmoji = (container: Element | DocumentFragment, props: EmojiProps) => {\n        throw new Error('No implementation for renderEmoji method.');\n    };\n    return newBoard;\n};\n\nexport type EmojiComponentRef = RenderComponentRef<EmojiProps>;\n\nexport interface EmojiProps {\n    board: PlaitBoard;\n    emojiItem: EmojiItem;\n    element: MindElement<EmojiData>;\n    fontSize: number;\n}\n","import { isNullOrUndefined } from '@plait/core';\nimport { MindElement } from '../interfaces/element';\nimport { ParagraphElement } from '@plait/common';\n\nexport const isNormalizedData = (element: MindElement) => {\n    if (!element.data || !element.data.topic) {\n        return false;\n    }\n    return true;\n};\n\nexport const isNormalizedWidthAndHeight = (element: MindElement) => {\n    if (isNullOrUndefined(element.width) || isNullOrUndefined(element.height)) {\n        return false;\n    }\n    return true;\n};\n\nexport const fixMindElementData = (element: MindElement) => {\n    const emptyTopic = {\n        children: [\n            {\n                text: ''\n            }\n        ]\n    } as ParagraphElement;\n    if (!element.data) {\n        const data = {\n            topic: emptyTopic\n        };\n        element.data = data;\n    } else if (!element.data.topic) {\n        element.data.topic = emptyTopic;\n    }\n};\n\nexport const fixMindElementWidthAndHeight = (element: MindElement) => {\n    if (isNullOrUndefined(element.width)) {\n        element.width = 56;\n    }\n    if (isNullOrUndefined(element.height)) {\n        element.width = 20;\n    }\n};\n","import {\n    PlaitBoard,\n    PlaitPluginElementContext,\n    RectangleClient,\n    Transforms,\n    Selection,\n    depthFirstRecursion,\n    PlaitElement,\n    getIsRecursionFunc,\n    Point,\n    toHostPoint,\n    toViewBoxPoint\n} from '@plait/core';\nimport { MindElement, PlaitMind } from '../interfaces';\nimport { PlaitMindComponent } from '../mind.component';\nimport { MindNodeComponent } from '../mind-node.component';\nimport { getRectangleByNode, isHitMindElement } from '../utils/position/node';\nimport { withNodeDnd } from './with-node-dnd';\nimport { editTopic } from '../utils/node/common';\nimport { withAbstract } from './with-abstract-resize';\nimport { withMindExtend } from './with-mind-extend';\nimport { withCreateMind } from './with-mind-create';\nimport { withMindHotkey } from './with-mind-hotkey';\nimport { withNodeMore } from './with-node-more';\nimport { withNodeImage } from './with-node-image';\nimport { PlaitMindBoard } from './with-mind.board';\nimport { withNodeResize } from './with-node-resize';\nimport { withNodeImageResize } from './with-node-image-resize';\nimport { withMindFragment } from './with-mind-fragment';\nimport { withEmoji } from '../emoji/with-emoji';\nimport { fixMindElementData, fixMindElementWidthAndHeight, isNormalizedData, isNormalizedWidthAndHeight } from '../utils/normalize';\n\nexport const withMind = (baseBoard: PlaitBoard) => {\n    const board = baseBoard as PlaitBoard & PlaitMindBoard;\n    const {\n        drawElement,\n        dblClick,\n        isRectangleHit,\n        isHit,\n        getRectangle,\n        isMovable,\n        isRecursion,\n        isAlign,\n        isImageBindingAllowed,\n        canAddToGroup,\n        canSetZIndex,\n        isExpanded,\n        getOneHitElement,\n        normalizeElement\n    } = board;\n\n    board.normalizeElement = (context: PlaitPluginElementContext) => {\n        if (PlaitMind.isMind(context.element)) {\n            depthFirstRecursion(context.element, (node) => {\n                if (!isNormalizedData(node)) {\n                    fixMindElementData(node);\n                }\n                if (!isNormalizedWidthAndHeight(node)) {\n                    fixMindElementWidthAndHeight(node);\n                }\n            });\n        }\n        normalizeElement(context);\n    };\n\n    board.drawElement = (context: PlaitPluginElementContext) => {\n        if (PlaitMind.isMind(context.element)) {\n            return PlaitMindComponent;\n        } else if (MindElement.isMindElement(board, context.element)) {\n            return MindNodeComponent;\n        }\n        return drawElement(context);\n    };\n\n    board.applyTheme = (element: PlaitElement) => {\n        const mindElement = element as MindElement;\n        const shouldClearProperty =\n            !PlaitBoard.isBoard(element) && (mindElement?.branchColor || mindElement?.fill || mindElement?.strokeColor);\n        if (PlaitMind.isMind(element) && shouldClearProperty) {\n            const path = PlaitBoard.findPath(board, element);\n            Transforms.setNode(board, { fill: null, strokeColor: null, branchColor: null }, path);\n        }\n    };\n\n    board.getRectangle = (element) => {\n        if (MindElement.isMindElement(board, element)) {\n            if (!PlaitElement.hasMounted(element)) {\n                console.error('mind element has not been mounted');\n            }\n            return getRectangleByNode(MindElement.getNode(element));\n        }\n        return getRectangle(element);\n    };\n\n    board.canAddToGroup = (element: PlaitElement) => {\n        if (MindElement.isMindElement(board, element) && !element.isRoot) {\n            return false;\n        }\n        return canAddToGroup(element);\n    };\n\n    board.canSetZIndex = (element: PlaitElement) => {\n        if (MindElement.isMindElement(board, element) && !element.isRoot) {\n            return false;\n        }\n        return canSetZIndex(element);\n    };\n\n    board.isRecursion = (element) => {\n        if (MindElement.isMindElement(board, element) && element.isCollapsed) {\n            return false;\n        }\n        return isRecursion(element);\n    };\n\n    board.isRectangleHit = (element, selection: Selection) => {\n        if (MindElement.isMindElement(board, element)) {\n            const client = getRectangleByNode(MindElement.getNode(element));\n            const isHit = RectangleClient.isHit(RectangleClient.getRectangleByPoints([selection.anchor, selection.focus]), client);\n            return isHit;\n        }\n        return isRectangleHit(element, selection);\n    };\n\n    board.isHit = (element, point: Point, isStrict?: boolean) => {\n        if (MindElement.isMindElement(board, element)) {\n            const client = getRectangleByNode(MindElement.getNode(element));\n            const isHit = RectangleClient.isHit(RectangleClient.getRectangleByPoints([point, point]), client);\n            return isHit;\n        }\n        return isHit(element, point, isStrict);\n    };\n\n    board.getOneHitElement = (elements) => {\n        const isAllMindElements = elements.every((item) => MindElement.isMindElement(board, item));\n        if (isAllMindElements) {\n            return elements[0];\n        }\n        return getOneHitElement(elements);\n    };\n\n    board.isMovable = (element) => {\n        if (PlaitMind.isMind(element) && element.isRoot) {\n            return true;\n        }\n        return isMovable(element);\n    };\n\n    board.isImageBindingAllowed = (element) => {\n        if (MindElement.isMindElement(board, element)) {\n            return true;\n        }\n        return isImageBindingAllowed(element);\n    };\n\n    board.isAlign = (element: PlaitElement) => {\n        if (PlaitMind.isMind(element) && element.isRoot) {\n            return true;\n        }\n        return isAlign(element);\n    };\n\n    board.isExpanded = (element: PlaitElement) => {\n        if (MindElement.isMindElement(board, element) && !PlaitMind.isMind(element)) {\n            return !element.isCollapsed;\n        }\n        return isExpanded(element);\n    };\n\n    board.dblClick = (event: MouseEvent) => {\n        if (PlaitBoard.isReadonly(board)) {\n            dblClick(event);\n            return;\n        }\n        const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n        board.children\n            .filter((value) => PlaitMind.isMind(value))\n            .forEach((mindMap) => {\n                depthFirstRecursion<MindElement>(\n                    mindMap as MindElement,\n                    (node) => {\n                        if (!PlaitBoard.hasBeenTextEditing(board) && isHitMindElement(board, point, node)) {\n                            editTopic(node);\n                        }\n                    },\n                    getIsRecursionFunc(board)\n                );\n            });\n        if (PlaitBoard.hasBeenTextEditing(board)) {\n            return;\n        }\n        dblClick(event);\n    };\n\n    return withEmoji(\n        withNodeResize(\n            withNodeImageResize(\n                withNodeImage(\n                    withNodeMore(withMindFragment(withMindHotkey(withMindExtend(withCreateMind(withAbstract(withNodeDnd(board)))))))\n                )\n            )\n        )\n    );\n};\n","import { EmojiData, EmojiItem } from '../interfaces/element-data';\nimport { PlaitBoard } from '@plait/core';\nimport { MindElement } from '../interfaces';\n\nexport abstract class MindEmojiBaseComponent {\n    fontSize: number = 14;\n\n    emojiItem!: EmojiItem;\n\n    board!: PlaitBoard;\n\n    element!: MindElement<EmojiData>;\n\n    abstract nativeElement(): HTMLElement;\n}\n","/*\n * Public API Surface of mind\n */\n\nexport * from './mind.component';\nexport * from './mind-node.component';\nexport * from './utils';\nexport * from './interfaces';\nexport * from './plugins/with-mind';\nexport * from './plugins/with-mind-extend';\nexport * from './constants';\nexport * from './queries/index';\nexport * from './transforms/index';\nexport * from './emoji';\nexport * from './plugins/with-mind.board';\nexport * from './plugins/with-abstract-resize.board';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":["getLayoutDirection","Node","Path"],"mappings":"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"}