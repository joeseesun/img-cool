import { DEFAULT_COLOR, DefaultThemeColor, ColorfulThemeColor, SoftThemeColor, RetroThemeColor, DarkThemeColor, StarryThemeColor, rgbaToHEX, PlaitElement, PlaitNode, Path, isNullOrUndefined, PlaitBoard, getSelectedElements, getI18nValue, idCreator, Transforms, clearSelectedElement, addSelectedElement, distanceBetweenPointAndRectangle, RectangleClient, setDragging, depthFirstRecursion, getIsRecursionFunc, drawRoundRectangle, drawLinearPath, drawBezierPath, setStrokeLinecap, createG, createForeignObject, updateForeignObject, getRectangleByElements, toActiveRectangleFromViewBoxRectangle, ACTIVE_STROKE_WIDTH, SELECTION_RECTANGLE_CLASS_NAME, NODE_TO_PARENT, removeSelectedElement, PlaitHistoryBoard, isSelectedElement, createText, isSelectionMoving, isDragging, isMovingElements, NODE_TO_INDEX, PlaitPointerType, isMainPointer, toViewBoxPoint, toHostPoint, getHitElementByPoint, distanceBetweenPointAndPoint, CoreTransforms, toActivePointFromViewBoxPoint, BoardTransforms, throttleRAF, isContextmenu, temporaryDisableSelection, hotkeys, createClipboardContext, WritableClipboardType, Point, ResizeCursorClass, WritableClipboardOperationType, addOrCreateClipboardContext } from '@plait/core';
import { MindLayoutType, AbstractNode, isIndentedLayout, isHorizontalLogicLayout, ConnectingPosition, isHorizontalLayout, getNonAbstractChildren, isStandardLayout, isLeftLayout, isRightLayout, isVerticalLogicLayout, isTopLayout, isBottomLayout, getCorrectStartEnd, getAbstractLayout, GlobalLayout } from '@plait/layouts';
import { StrokeStyle, getFirstTextManage, DEFAULT_FONT_FAMILY, measureElement, buildText, getElementSize, RESIZE_HANDLE_DIAMETER, getRectangleResizeHandleRefs, addElementOfFocusedImage, ImageGenerator, removeElementOfFocusedImage, getStrokeLineDash, getXDistanceBetweenPoint, moveXOfPoint, moveYOfPoint, Generator, PropertyTransforms, TRANSPARENT, isResizing, CommonElementFlavour, WithTextPluginKey, TextManage, isDrawingMode, isDndMode, setCreationMode, BoardCreationMode, isExpandHotkey, isTabHotkey, isEnterHotkey, isVirtualKey, isDelete, isSpaceHotkey, getElementOfFocusedImage, acceptImageTypes, buildImage, withResize, getElementsText } from '@plait/common';
import { TEXT_DEFAULT_HEIGHT, getFirstTextMarks, MarkTypes, DEFAULT_FONT_SIZE, PlaitMarkEditor, FontSizes } from '@plait/text-plugins';
import { Node as Node$1, Path as Path$1 } from 'slate';
import { pointsOnBezierCurves } from 'points-on-curve';
import { isHotkey } from 'is-hotkey';

const ELEMENT_TO_NODE = new WeakMap();

const MindNode = {
    get(root, path) {
        let node = root;
        for (let i = 0; i < path.length; i++) {
            const p = path[i];
            if (!node || !node.children || !node.children[p]) {
                throw new Error(`Cannot find a descendant at path [${path}]`);
            }
            node = node.children[p];
        }
        return node;
    }
};

var LayoutDirection;
(function (LayoutDirection) {
    LayoutDirection["top"] = "top";
    LayoutDirection["right"] = "right";
    LayoutDirection["bottom"] = "bottom";
    LayoutDirection["left"] = "left";
})(LayoutDirection || (LayoutDirection = {}));
const LayoutDirectionsMap = {
    [MindLayoutType.right]: [LayoutDirection.right],
    [MindLayoutType.left]: [LayoutDirection.left],
    [MindLayoutType.upward]: [LayoutDirection.top],
    [MindLayoutType.downward]: [LayoutDirection.bottom],
    [MindLayoutType.rightBottomIndented]: [LayoutDirection.right, LayoutDirection.bottom],
    [MindLayoutType.rightTopIndented]: [LayoutDirection.right, LayoutDirection.top],
    [MindLayoutType.leftBottomIndented]: [LayoutDirection.left, LayoutDirection.bottom],
    [MindLayoutType.leftTopIndented]: [LayoutDirection.left, LayoutDirection.top]
};

var MindPointerType;
(function (MindPointerType) {
    MindPointerType["mind"] = "mind";
})(MindPointerType || (MindPointerType = {}));

const DEFAULT_BRANCH_COLORS = [
    '#A287E0',
    '#6E80DB',
    '#6DC4C4',
    '#E0B75E',
    '#B1C675',
    '#77C386',
    '#C18976',
    '#E48484',
    '#E582D4',
    '#6AB1E4'
];
const COLORFUL_BRANCH_COLORS = [
    '#F94239',
    '#FF8612',
    '#F3D222',
    '#B3D431',
    '#00BC7B',
    '#06ADBF',
    '#476BFF',
    '#4E49BE',
    '#8957E5',
    '#FE5DA1'
];
const SOFT_BRANCH_COLORS = [
    '#6D89C1',
    '#F2BDC7',
    '#B796D9',
    '#5BA683',
    '#B3D431 ',
    '#F2DC6C',
    '#F7C98D',
    '#60B4D1',
    '#838F9E',
    '#C1A381'
];
const RETRO_BRANCH_COLORS = [
    '#459476',
    '#9A894F',
    '#D48444',
    '#E9C358 ',
    '#4B9D9D',
    '#C14C41',
    '#827086 ',
    '#60718D',
    '#D38183',
    '#9DC19D'
];
const DARK_BRANCH_COLORS = [
    '#3DD1AE',
    '#F6C659',
    '#A9E072',
    '#FF877B ',
    '#F693E7',
    '#5DCFFF',
    '#868AF6',
    '#4C6DC7',
    '#D97C26',
    '#268FAC'
];
const STARRY_BRANCH_COLORS = [
    '#E46C57',
    '#579360',
    '#B98339',
    '#3A62D1 ',
    '#B883B7',
    '#42ABE5',
    '#2B9D8F',
    '#A4705E',
    '#265833',
    '#787865'
];

const MindDefaultThemeColor = {
    ...DefaultThemeColor,
    branchColors: DEFAULT_BRANCH_COLORS,
    rootFill: '#f5f5f5',
    rootTextColor: DEFAULT_COLOR
};
const MindColorfulThemeColor = {
    ...ColorfulThemeColor,
    branchColors: COLORFUL_BRANCH_COLORS,
    rootFill: DEFAULT_COLOR,
    rootTextColor: '#FFFFFF'
};
const MindSoftThemeColor = {
    ...SoftThemeColor,
    branchColors: SOFT_BRANCH_COLORS,
    rootFill: '#FFFFFF',
    rootTextColor: DEFAULT_COLOR
};
const MindRetroThemeColor = {
    ...RetroThemeColor,
    branchColors: RETRO_BRANCH_COLORS,
    rootFill: '#153D5D',
    rootTextColor: '#FFFFFF'
};
const MindDarkThemeColor = {
    ...DarkThemeColor,
    branchColors: DARK_BRANCH_COLORS,
    rootFill: '#FFFFFF',
    rootTextColor: DEFAULT_COLOR
};
const MindStarryThemeColor = {
    ...StarryThemeColor,
    branchColors: STARRY_BRANCH_COLORS,
    rootFill: '#FFFFFF',
    rootTextColor: DEFAULT_COLOR
};
const MindThemeColors = [
    MindDefaultThemeColor,
    MindColorfulThemeColor,
    MindSoftThemeColor,
    MindRetroThemeColor,
    MindDarkThemeColor,
    MindStarryThemeColor
];
const MindThemeColor = {
    isMindThemeColor(value) {
        if (value.branchColors && value.rootFill && value.rootTextColor) {
            return true;
        }
        else {
            return false;
        }
    }
};

const WithMindPluginKey = 'plait-mind-plugin-key';
const BASE = 4;
const PRIMARY_COLOR = '#6698FF';
const GRAY_COLOR = '#AAAAAA';
const STROKE_WIDTH = 2;
const RESIZE_HANDLE_BUFFER_DISTANCE = 8;
const NODE_MORE_LINE_DISTANCE = 10;
const NODE_MORE_STROKE_WIDTH = 2;
const NODE_MORE_ICON_DIAMETER = 20;
const NODE_MORE_BRIDGE_DISTANCE = 10;
const NODE_ADD_CIRCLE_COLOR = rgbaToHEX('#000000', 0.2);
const NODE_ADD_HOVER_COLOR = '#6698FF';
const NODE_ADD_INNER_CROSS_COLOR = 'white';
const DEFAULT_MIND_IMAGE_WIDTH = 240;
var MindI18nKey;
(function (MindI18nKey) {
    MindI18nKey["mindCentralText"] = "mind-center-text";
    MindI18nKey["abstractNodeText"] = "abstract-node-text";
})(MindI18nKey || (MindI18nKey = {}));

function getEmojisWidthHeight(board, element) {
    const options = board.getPluginOptions(WithMindPluginKey);
    const count = element.data.emojis.length;
    const fontSize = getEmojiFontSize(element);
    return {
        width: fontSize * count + count * 2 * options.emojiPadding + (count - 1) * options.spaceBetweenEmojis,
        height: element.height
    };
}
function getEmojiFontSize(element) {
    if (PlaitMind.isMind(element)) {
        return 18 + 2;
    }
    else {
        return 14 + 2;
    }
}

const getAvailableProperty = (board, element, propertyKey) => {
    return element[propertyKey];
};

const DefaultAbstractNodeStyle = {
    branch: { color: GRAY_COLOR, width: 2 },
    shape: {
        strokeColor: GRAY_COLOR,
        strokeWidth: 2
    }
};
const DefaultNodeStyle = {
    branch: {
        width: 2
    },
    shape: {
        rectangleRadius: 4,
        strokeWidth: 2,
        fill: 'none'
    }
};

const separateChildren = (parentElement) => {
    const rightNodeCount = parentElement.rightNodeCount;
    const children = parentElement.children;
    let rightChildren = [], leftChildren = [];
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (AbstractNode.isAbstract(child) && child.end < rightNodeCount) {
            rightChildren.push(child);
            continue;
        }
        if (AbstractNode.isAbstract(child) && child.start >= rightNodeCount) {
            leftChildren.push(child);
            continue;
        }
        if (i < rightNodeCount) {
            rightChildren.push(child);
        }
        else {
            leftChildren.push(child);
        }
    }
    return { leftChildren, rightChildren };
};
const isSetAbstract = (element) => {
    return !!getCorrespondingAbstract(element);
};
const canSetAbstract = (element) => {
    return !PlaitElement.isRootElement(element) && !AbstractNode.isAbstract(element) && !isSetAbstract(element);
};
const getCorrespondingAbstract = (element) => {
    const parent = MindElement.findParent(element);
    if (!parent)
        return undefined;
    const elementIndex = parent.children.indexOf(element);
    return parent.children.find(child => {
        return AbstractNode.isAbstract(child) && elementIndex >= child.start && elementIndex <= child.end;
    });
};
const getBehindAbstracts = (element) => {
    const parent = MindElement.findParent(element);
    if (!parent)
        return [];
    const index = parent.children.indexOf(element);
    return parent.children.filter(child => AbstractNode.isAbstract(child) && child.start > index);
};
/**
 * return corresponding abstract that is not child of elements
 */
const getOverallAbstracts = (board, elements) => {
    const overallAbstracts = [];
    elements
        .filter(value => !AbstractNode.isAbstract(value) && !PlaitMind.isMind(value))
        .forEach(value => {
        const abstract = getCorrespondingAbstract(value);
        if (abstract && elements.indexOf(abstract) === -1 && overallAbstracts.indexOf(abstract) === -1) {
            const { start, end } = abstract;
            const parent = MindElement.getParent(value);
            const isOverall = parent.children.slice(start, end + 1).every(includedElement => elements.indexOf(includedElement) > -1);
            if (isOverall) {
                overallAbstracts.push(abstract);
            }
        }
    });
    return overallAbstracts;
};
/**
 * abstract node is valid when elements contains at least one element it is referenced with
 */
const getValidAbstractRefs = (board, elements) => {
    const validAbstractRefs = [];
    elements
        .filter(value => !AbstractNode.isAbstract(value) && !PlaitMind.isMind(value))
        .forEach(value => {
        const abstract = getCorrespondingAbstract(value);
        if (abstract && elements.indexOf(abstract) > 0) {
            const index = validAbstractRefs.findIndex(value => value.abstract === abstract);
            if (index === -1) {
                validAbstractRefs.push({
                    abstract: abstract,
                    references: [value]
                });
            }
            else {
                validAbstractRefs[index].references.push(value);
            }
        }
    });
    return validAbstractRefs;
};
function getRelativeStartEndByAbstractRef(abstractRef, elements) {
    const start = elements.indexOf(abstractRef.references[0]);
    const end = elements.indexOf(abstractRef.references[abstractRef.references.length - 1]);
    return { start, end };
}
const insertElementHandleAbstract = (board, path, step = 1, 
// This distinguishes between dragging and adding to the last node summarized in the abstract node
isExtendPreviousNode = true, effectedAbstracts = new Map()) => {
    const parent = PlaitNode.parent(board, path);
    const hasPreviousNode = path[path.length - 1] !== 0;
    let behindAbstracts;
    if (!hasPreviousNode) {
        behindAbstracts = parent.children.filter(child => AbstractNode.isAbstract(child));
    }
    else {
        const selectedElement = PlaitNode.get(board, Path.previous(path));
        behindAbstracts = getBehindAbstracts(selectedElement);
    }
    if (behindAbstracts.length) {
        behindAbstracts.forEach(abstract => {
            let newProperties = effectedAbstracts.get(abstract);
            if (!newProperties) {
                newProperties = { start: 0, end: 0 };
                effectedAbstracts.set(abstract, newProperties);
            }
            newProperties.start = newProperties.start + step;
            newProperties.end = newProperties.end + step;
        });
    }
    if (!hasPreviousNode) {
        return effectedAbstracts;
    }
    const selectedElement = PlaitNode.get(board, Path.previous(path));
    const correspondingAbstract = getCorrespondingAbstract(selectedElement);
    const isDragToLast = !isExtendPreviousNode && correspondingAbstract && correspondingAbstract.end === path[path.length - 1] - 1;
    if (correspondingAbstract && !isDragToLast) {
        let newProperties = effectedAbstracts.get(correspondingAbstract);
        if (!newProperties) {
            newProperties = { start: 0, end: 0 };
            effectedAbstracts.set(correspondingAbstract, newProperties);
        }
        newProperties.end = newProperties.end + step;
    }
    return effectedAbstracts;
};
const deleteElementHandleAbstract = (board, deletableElements, effectedAbstracts = new Map()) => {
    deletableElements.forEach(node => {
        if (!PlaitMind.isMind(node)) {
            const behindAbstracts = getBehindAbstracts(node).filter(abstract => !deletableElements.includes(abstract));
            if (behindAbstracts.length) {
                behindAbstracts.forEach(abstract => {
                    let newProperties = effectedAbstracts.get(abstract);
                    if (!newProperties) {
                        newProperties = { start: 0, end: 0 };
                        effectedAbstracts.set(abstract, newProperties);
                    }
                    newProperties.start = newProperties.start - 1;
                    newProperties.end = newProperties.end - 1;
                });
            }
            const correspondingAbstract = getCorrespondingAbstract(node);
            if (correspondingAbstract && !deletableElements.includes(correspondingAbstract)) {
                let newProperties = effectedAbstracts.get(correspondingAbstract);
                if (!newProperties) {
                    newProperties = { start: 0, end: 0 };
                    effectedAbstracts.set(correspondingAbstract, newProperties);
                }
                newProperties.end = newProperties.end - 1;
            }
        }
    });
    return effectedAbstracts;
};
const isChildOfAbstract = (board, element) => {
    const ancestors = MindElement.getAncestors(board, element);
    return !!ancestors.find(value => AbstractNode.isAbstract(value));
};

/**
 * Processing of branch color, width, style, etc. of the mind node
 */
const getBranchColorByMindElement = (board, element) => {
    if (AbstractNode.isAbstract(element) || isChildOfAbstract(board, element)) {
        return getAbstractBranchColor(board, element);
    }
    const branchColor = getAvailableProperty(board, element, 'branchColor') || getAvailableProperty(board, element, 'strokeColor');
    return branchColor || getDefaultBranchColor(board, element);
};
const getBranchShapeByMindElement = (board, element) => {
    const branchShape = getAvailableProperty(board, element, 'branchShape');
    return branchShape || BranchShape.bight;
};
const getBranchWidthByMindElement = (board, element) => {
    const branchWidth = getAvailableProperty(board, element, 'branchWidth') || getAvailableProperty(board, element, 'strokeWidth');
    return branchWidth || STROKE_WIDTH;
};
const getAbstractBranchWidth = (board, element) => {
    if (!isNullOrUndefined(element.branchWidth)) {
        return element.branchWidth;
    }
    return DefaultAbstractNodeStyle.branch.width;
};
const getAbstractBranchColor = (board, element) => {
    if (element.branchColor || element.strokeColor) {
        return element.branchColor || element.strokeColor;
    }
    return DefaultAbstractNodeStyle.branch.color;
};
const getNextBranchColor = (board, root) => {
    const index = root.children.length;
    return getDefaultBranchColorByIndex(board, index);
};
const getDefaultBranchColor = (board, element) => {
    const path = PlaitBoard.findPath(board, element);
    return getDefaultBranchColorByIndex(board, path[1]);
};
const getDefaultBranchColorByIndex = (board, index) => {
    const themeColor = getMindThemeColor(board);
    const length = themeColor.branchColors.length;
    const remainder = index % length;
    return themeColor.branchColors[remainder];
};
const getMindThemeColor = (board) => {
    const themeColors = PlaitBoard.getThemeColors(board);
    const themeColor = themeColors.find(val => val.mode === board.theme.themeColorMode);
    if (themeColor && MindThemeColor.isMindThemeColor(themeColor)) {
        return themeColor;
    }
    else {
        return MindDefaultThemeColor;
    }
};

const getStrokeColorByElement = (board, element) => {
    if (PlaitMind.isMind(element)) {
        const defaultRootStroke = getMindThemeColor(board).rootFill;
        return element.strokeColor || defaultRootStroke;
    }
    if (AbstractNode.isAbstract(element) || isChildOfAbstract(board, element)) {
        return element.strokeColor || DefaultAbstractNodeStyle.shape.strokeColor;
    }
    return getAvailableProperty(board, element, 'strokeColor') || getDefaultBranchColor(board, element);
};
const getStrokeStyleByElement = (board, element) => {
    return element.strokeStyle || StrokeStyle.solid;
};
const getStrokeWidthByElement = (board, element) => {
    const strokeWidth = element.strokeWidth ||
        (AbstractNode.isAbstract(element) ? DefaultAbstractNodeStyle.shape.strokeWidth : DefaultNodeStyle.shape.strokeWidth);
    return strokeWidth;
};
const getFillByElement = (board, element) => {
    if (element.fill) {
        return element.fill;
    }
    const defaultRootFill = getMindThemeColor(board).rootFill;
    return element.isRoot ? defaultRootFill : DefaultNodeStyle.shape.fill;
};
const getShapeByElement = (board, element) => {
    const shape = getAvailableProperty(board, element, 'shape');
    return shape || MindElementShape.roundRectangle;
};

function editTopic(element) {
    const textManage = getFirstTextManage(element);
    textManage?.edit(() => { }, event => {
        const keyboardEvent = event;
        return keyboardEvent.key === 'Enter' && !keyboardEvent.shiftKey;
    });
}
const getSelectedMindElements = (board, elements) => {
    const selectedElements = elements?.length ? elements : getSelectedElements(board);
    return selectedElements.filter(value => MindElement.isMindElement(board, value));
};

const getBranchDirectionsByLayouts = (branchLayouts) => {
    const branchDirections = [];
    branchLayouts.forEach(l => {
        const directions = LayoutDirectionsMap[l];
        directions.forEach(d => {
            if (!branchDirections.includes(d) && !branchDirections.includes(getLayoutReverseDirection(d))) {
                branchDirections.push(d);
            }
        });
    });
    return branchDirections;
};
const isCorrectLayout = (root, layout) => {
    const rootLayout = root.layout || getDefaultLayout();
    return !getInCorrectLayoutDirection(rootLayout, layout);
};
const isMixedLayout = (parentLayout, layout) => {
    return (!isIndentedLayout(parentLayout) && isIndentedLayout(layout)) || (isIndentedLayout(parentLayout) && !isIndentedLayout(layout));
};
const getInCorrectLayoutDirection = (rootLayout, layout) => {
    const directions = LayoutDirectionsMap[rootLayout];
    const subLayoutDirections = LayoutDirectionsMap[layout];
    if (!subLayoutDirections) {
        throw new Error(`unexpected layout: ${layout} on correct layout`);
    }
    return subLayoutDirections.find(d => directions.includes(getLayoutReverseDirection(d)));
};
const correctLayoutByDirection = (layout, direction) => {
    const isHorizontal = direction === LayoutDirection.left || direction === LayoutDirection.right ? true : false;
    let inverseDirectionLayout = MindLayoutType.standard;
    switch (layout) {
        case MindLayoutType.left:
            inverseDirectionLayout = MindLayoutType.right;
            break;
        case MindLayoutType.right:
            inverseDirectionLayout = MindLayoutType.left;
            break;
        case MindLayoutType.downward:
            inverseDirectionLayout = MindLayoutType.upward;
            break;
        case MindLayoutType.upward:
            inverseDirectionLayout = MindLayoutType.downward;
            break;
        case MindLayoutType.rightBottomIndented:
            inverseDirectionLayout = isHorizontal ? MindLayoutType.leftBottomIndented : MindLayoutType.rightTopIndented;
            break;
        case MindLayoutType.leftBottomIndented:
            inverseDirectionLayout = isHorizontal ? MindLayoutType.rightBottomIndented : MindLayoutType.leftTopIndented;
            break;
        case MindLayoutType.rightTopIndented:
            inverseDirectionLayout = isHorizontal ? MindLayoutType.leftTopIndented : MindLayoutType.rightBottomIndented;
            break;
        case MindLayoutType.leftTopIndented:
            inverseDirectionLayout = isHorizontal ? MindLayoutType.rightTopIndented : MindLayoutType.leftBottomIndented;
            break;
    }
    return inverseDirectionLayout;
};
const getLayoutDirection$1 = (root) => {
    const layout = root.layout || getDefaultLayout();
    return LayoutDirectionsMap[layout];
};
const getDefaultLayout = () => {
    return MindLayoutType.standard;
};
const getAvailableSubLayoutsByLayoutDirections = (directions) => {
    const result = [];
    const reverseDirections = directions.map(getLayoutReverseDirection);
    for (const key in MindLayoutType) {
        const layout = MindLayoutType[key];
        const layoutDirections = LayoutDirectionsMap[layout];
        if (layoutDirections) {
            const hasSameDirection = layoutDirections.some(d => directions.includes(d));
            const hasReverseDirection = layoutDirections.some(r => reverseDirections.includes(r));
            if (hasSameDirection && !hasReverseDirection) {
                result.push(layout);
            }
        }
    }
    return result;
};
const getLayoutReverseDirection = (layoutDirection) => {
    let reverseDirection = LayoutDirection.right;
    switch (layoutDirection) {
        case LayoutDirection.top:
            reverseDirection = LayoutDirection.bottom;
            break;
        case LayoutDirection.bottom:
            reverseDirection = LayoutDirection.top;
            break;
        case LayoutDirection.right:
            reverseDirection = LayoutDirection.left;
            break;
        case LayoutDirection.left:
            reverseDirection = LayoutDirection.right;
            break;
    }
    return reverseDirection;
};
const getRootLayout = (root) => {
    return root.layout || getDefaultLayout();
};

const getLayoutOptions = (board) => {
    function getMainAxle(element, parent) {
        if (element.isRoot) {
            return BASE * 12;
        }
        if (parent && parent.isRoot()) {
            return BASE * 3;
        }
        return BASE * 3;
    }
    function getSecondAxle(element, parent) {
        if (element.isRoot) {
            return BASE * 12;
        }
        return BASE * 8.5;
    }
    return {
        getHeight(element) {
            return NodeSpace.getNodeHeight(board, element);
        },
        getWidth(element) {
            return NodeSpace.getNodeWidth(board, element);
        },
        getHorizontalGap(element, parent) {
            const _layout = (parent && parent.layout) || getRootLayout(element);
            const isHorizontal = isHorizontalLayout(_layout);
            if (isIndentedLayout(_layout)) {
                return BASE * 6;
            }
            if (!isHorizontal) {
                return getMainAxle(element, parent);
            }
            else {
                return getSecondAxle(element, parent);
            }
        },
        getVerticalGap(element, parent) {
            const _layout = (parent && parent.layout) || getRootLayout(element);
            if (isIndentedLayout(_layout)) {
                return BASE * 3.5;
            }
            const isHorizontal = isHorizontalLayout(_layout);
            if (isHorizontal) {
                return getMainAxle(element, parent);
            }
            else {
                return getSecondAxle(element, parent);
            }
        },
        getVerticalConnectingPosition(element, parent) {
            if (element.shape === MindElementShape.underline && parent && isHorizontalLogicLayout(parent.layout)) {
                return ConnectingPosition.bottom;
            }
            return undefined;
        },
        getExtendHeight(node) {
            return 0;
        },
        getIndentedCrossLevelGap() {
            return BASE * 1;
        }
    };
};

const TOPIC_FONT_SIZE = 14;
const ROOT_TOPIC_FONT_SIZE = 18;
const TOPIC_DEFAULT_MAX_WORD_COUNT = 34;
const NodeTopicThreshold = {
    defaultTextMaxWidth: 34 * 14
};

const ABSTRACT_HANDLE_COLOR = '#6698FF80'; //primary color 50% opacity
const ABSTRACT_INCLUDED_OUTLINE_OFFSET = 3.5;
const ABSTRACT_HANDLE_LENGTH = 10;
const ABSTRACT_HANDLE_MASK_WIDTH = 8;

const MIND_CENTRAL_TEXT = '中心主题';
const ABSTRACT_NODE_TEXT = '概要';
const getDefaultMindNameText = (board) => {
    return getI18nValue(board, MindI18nKey.mindCentralText, MIND_CENTRAL_TEXT);
};
const getAbstractNodeText = (board) => {
    return getI18nValue(board, MindI18nKey.abstractNodeText, ABSTRACT_NODE_TEXT);
};
const getTopicSize = (board, isRoot, isBranch, topic, manualWidth) => {
    let fontFamily = DEFAULT_FONT_FAMILY;
    let fontSize = TOPIC_FONT_SIZE;
    if (isRoot) {
        fontFamily = DEFAULT_FONT_FAMILY;
        fontSize = ROOT_TOPIC_FONT_SIZE;
    }
    else if (isBranch) {
        fontFamily = DEFAULT_FONT_FAMILY;
    }
    const maxWidth = fontSize * TOPIC_DEFAULT_MAX_WORD_COUNT;
    return measureElement(board, topic, { fontSize, fontFamily }, manualWidth ? manualWidth : maxWidth);
};

const createEmptyMind = (board, point) => {
    const text = getDefaultMindNameText(board);
    const topicSize = getTopicSize(board, true, false, buildText(text));
    const element = createMindElement(text, topicSize.width, topicSize.height, { layout: MindLayoutType.right });
    element.isRoot = true;
    element.type = 'mindmap';
    const width = NodeSpace.getNodeWidth(board, element);
    const height = NodeSpace.getNodeHeight(board, element);
    element.points = [[point[0] - width / 2, point[1] - height / 2]];
    return element;
};
const createMindElement = (text, width, height, options) => {
    const newElement = {
        id: idCreator(),
        data: {
            topic: buildText(text)
        },
        children: [],
        width,
        height
    };
    let key;
    for (key in options) {
        if (!isNullOrUndefined(options[key])) {
            newElement[key] = options[key];
        }
    }
    return newElement;
};
const INHERIT_ATTRIBUTE_KEYS = [
    'fill',
    'strokeColor',
    'strokeWidth',
    'strokeStyle',
    'shape',
    'layout',
    'branchColor',
    'branchWidth',
    'branchShape'
];

const getChildrenCount = (element) => {
    const count = element.children.reduce((p, c) => {
        return p + getChildrenCount(c);
    }, 0);
    return count + element.children.length;
};
const isChildElement = (origin, child) => {
    let parent = MindElement.findParent(child);
    while (parent) {
        if (parent === origin) {
            return true;
        }
        parent = MindElement.findParent(parent);
    }
    return false;
};
const getFirstLevelElement = (elements) => {
    let result = [];
    elements.forEach(element => {
        const isChild = elements.some(node => {
            return isChildElement(node, element);
        });
        if (!isChild) {
            result.push(element);
        }
    });
    return result;
};
const isChildRight = (parent, child) => {
    return parent.x < child.x;
};
const isChildUp = (parent, child) => {
    return parent.y > child.y;
};
const copyNewNode = (node) => {
    const newNode = { ...node };
    newNode.id = idCreator();
    newNode.children = [];
    for (const childNode of node.children) {
        newNode.children.push(copyNewNode(childNode));
    }
    return newNode;
};
const insertMindElement = (board, inheritNode, path) => {
    const newNode = {};
    if (!inheritNode.isRoot) {
        INHERIT_ATTRIBUTE_KEYS.forEach(attr => {
            newNode[attr] = inheritNode[attr];
        });
        delete newNode.layout;
    }
    const newElement = createMindElement('', TOPIC_FONT_SIZE, TEXT_DEFAULT_HEIGHT, newNode);
    Transforms.insertNode(board, newElement, path);
    clearSelectedElement(board);
    addSelectedElement(board, newElement);
    setTimeout(() => {
        editTopic(newElement);
    });
};
const findLastChild = (child) => {
    let result = child;
    while (result.children.length !== 0) {
        result = result.children[result.children.length - 1];
    }
    return result;
};
const divideElementByParent = (elements) => {
    const abstractIncludedGroups = [];
    const parentElements = [];
    for (let i = 0; i < elements.length; i++) {
        const parent = MindElement.getParent(elements[i]);
        const parentIndex = parentElements.indexOf(parent);
        if (parentIndex === -1) {
            parentElements.push(parent);
            abstractIncludedGroups.push([elements[i]]);
        }
        else {
            abstractIncludedGroups[parentIndex].push(elements[i]);
        }
    }
    return { parentElements, abstractIncludedGroups };
};
const getDefaultMindElementFontSize = (board, element) => {
    if (PlaitMind.isMind(element)) {
        return ROOT_TOPIC_FONT_SIZE;
    }
    if (MindElement.isMindElement(board, element)) {
        return TOPIC_FONT_SIZE;
    }
    throw new Error('can not find default font-size');
};

const NodeDefaultSpace = {
    horizontal: {
        nodeAndText: BASE * 2.5,
        emojiAndText: BASE * 1.5
    },
    vertical: {
        nodeAndText: BASE,
        nodeAndImage: BASE,
        imageAndText: BASE * 1.5
    }
};
const RootDefaultSpace = {
    horizontal: {
        nodeAndText: BASE * 4,
        emojiAndText: BASE * 2
    },
    vertical: {
        nodeAndText: BASE * 2
    }
};
const getHorizontalSpaceBetweenNodeAndText = (board, element) => {
    const isMind = PlaitMind.isMind(element);
    const nodeAndText = isMind ? RootDefaultSpace.horizontal.nodeAndText : NodeDefaultSpace.horizontal.nodeAndText;
    const strokeWidth = getStrokeWidthByElement(board, element);
    return nodeAndText + strokeWidth;
};
const getVerticalSpaceBetweenNodeAndText = (board, element) => {
    const isMind = PlaitMind.isMind(element);
    const strokeWidth = getStrokeWidthByElement(board, element);
    const nodeAndText = isMind ? RootDefaultSpace.vertical.nodeAndText : NodeDefaultSpace.vertical.nodeAndText;
    return nodeAndText + strokeWidth;
};
const getSpaceEmojiAndText = (element) => {
    const isMind = PlaitMind.isMind(element);
    const emojiAndText = isMind ? RootDefaultSpace.horizontal.emojiAndText : NodeDefaultSpace.horizontal.emojiAndText;
    return emojiAndText;
};
const NodeSpace = {
    getNodeWidth(board, element) {
        const nodeAndText = getHorizontalSpaceBetweenNodeAndText(board, element);
        if (MindElement.hasEmojis(element)) {
            return (NodeSpace.getEmojiLeftSpace(board, element) +
                getEmojisWidthHeight(board, element).width +
                getSpaceEmojiAndText(element) +
                NodeSpace.getTopicDynamicWidth(board, element) +
                nodeAndText);
        }
        return nodeAndText + NodeSpace.getTopicDynamicWidth(board, element) + nodeAndText;
    },
    getNodeHeight(board, element) {
        const topicSize = getElementSize(board, element.data.topic, { fontSize: DEFAULT_FONT_SIZE, fontFamily: DEFAULT_FONT_FAMILY }, NodeSpace.getTopicMaxDynamicWidth(board, element));
        const normalizedSize = normalizeWidthAndHeight(board, element, topicSize.width, topicSize.height);
        const nodeAndText = getVerticalSpaceBetweenNodeAndText(board, element);
        if (MindElement.hasImage(element)) {
            return NodeSpace.getTextTopSpace(board, element) + normalizedSize.height + nodeAndText;
        }
        return nodeAndText + normalizedSize.height + nodeAndText;
    },
    getTopicDynamicWidth(board, element) {
        const topicSize = getElementSize(board, element.data.topic, { fontSize: getDefaultMindElementFontSize(board, element), fontFamily: DEFAULT_FONT_FAMILY }, NodeSpace.getTopicMaxDynamicWidth(board, element));
        const normalizedSize = normalizeWidthAndHeight(board, element, topicSize.width, topicSize.width);
        const width = element.manualWidth || normalizedSize.width;
        const imageWidth = MindElement.hasImage(element) ? element.data.image?.width : 0;
        return Math.max(width, imageWidth);
    },
    getTopicHeight(board, element) {
        const topicSize = getElementSize(board, element.data.topic, { fontSize: DEFAULT_FONT_SIZE, fontFamily: DEFAULT_FONT_FAMILY }, NodeSpace.getTopicMaxDynamicWidth(board, element));
        const normalizedSize = normalizeWidthAndHeight(board, element, topicSize.width, topicSize.height);
        return normalizedSize.height;
    },
    getTopicMaxDynamicWidth(board, element) {
        return Math.max(NodeTopicThreshold.defaultTextMaxWidth, element.manualWidth || 0, MindElement.hasImage(element) ? element.data.image?.width : 0);
    },
    /**
     * use it when upload image first or resize image
     */
    getNodeNewDynamicWidth(board, element, imageWidth) {
        const width = element.manualWidth || element.width;
        return Math.max(width, imageWidth);
    },
    getNodeResizableMinWidth(board, element) {
        const minTopicWidth = NodeSpace.getNodeTopicMinWidth(board, element);
        if (MindElement.hasImage(element) && element.data.image.width > minTopicWidth) {
            return element.data.image.width;
        }
        else {
            return minTopicWidth;
        }
    },
    getNodeTopicMinWidth(board, element) {
        const defaultFontSize = getDefaultMindElementFontSize(board, element);
        const firstText = getFirstTextMarks(element.data.topic);
        const fontSize = (firstText[MarkTypes.fontSize] ? Number(firstText[MarkTypes.fontSize]) : null) || defaultFontSize;
        return fontSize;
    },
    getTextLeftSpace(board, element) {
        const nodeAndText = getHorizontalSpaceBetweenNodeAndText(board, element);
        if (MindElement.hasEmojis(element)) {
            return NodeSpace.getEmojiLeftSpace(board, element) + getEmojisWidthHeight(board, element).width + getSpaceEmojiAndText(element);
        }
        else {
            return nodeAndText;
        }
    },
    getTextTopSpace(board, element) {
        const nodeAndText = getVerticalSpaceBetweenNodeAndText(board, element);
        if (MindElement.hasImage(element)) {
            return NodeSpace.getImageTopSpace(board, element) + element.data.image.height + NodeDefaultSpace.vertical.imageAndText;
        }
        else {
            return nodeAndText;
        }
    },
    getImageTopSpace(board, element) {
        const strokeWidth = getStrokeWidthByElement(board, element);
        return strokeWidth + NodeDefaultSpace.vertical.nodeAndImage;
    },
    getEmojiLeftSpace(board, element) {
        const options = board.getPluginOptions(WithMindPluginKey);
        const nodeAndText = getHorizontalSpaceBetweenNodeAndText(board, element);
        return nodeAndText - options.emojiPadding;
    },
    getEmojiTopSpace(board, element) {
        const nodeAndText = getVerticalSpaceBetweenNodeAndText(board, element);
        return nodeAndText;
    }
};
const getFontSizeBySlateElement = (text) => {
    const defaultFontSize = DEFAULT_FONT_SIZE;
    if (typeof text === 'string') {
        return defaultFontSize;
    }
    const marks = PlaitMarkEditor.getMarksByElement(text);
    const fontSize = marks[MarkTypes.fontSize] || defaultFontSize;
    return fontSize;
};
const normalizeWidthAndHeight = (board, element, width, height) => {
    const minWidth = NodeSpace.getNodeTopicMinWidth(board, element);
    const newWidth = width < minWidth ? minWidth : width;
    return { width: newWidth, height };
};

function getRectangleByNode(node) {
    const x = node.x + node.hGap;
    let y = node.y + node.vGap;
    const width = node.width - node.hGap * 2;
    const height = node.height - node.vGap * 2;
    return {
        x,
        y,
        width,
        height
    };
}
function getRectangleByElement(board, element) {
    const width = NodeSpace.getNodeWidth(board, element);
    const height = NodeSpace.getNodeHeight(board, element);
    const nodeRectangle = {
        x: element.points[0][0],
        y: element.points[0][1],
        width,
        height
    };
    return nodeRectangle;
}
function isHitMindElement(board, point, element) {
    const node = MindElement.getNode(element);
    if (node && distanceBetweenPointAndRectangle(point[0], point[1], getRectangleByNode(node)) === 0) {
        return true;
    }
    else {
        return false;
    }
}

function getEmojiRectangle(board, element) {
    let { x, y } = getRectangleByNode(MindElement.getNode(element));
    x = x + NodeSpace.getEmojiLeftSpace(board, element);
    const { width, height } = getEmojisWidthHeight(board, element);
    return {
        x,
        y,
        width,
        height
    };
}
function getEmojiForeignRectangle(board, element) {
    let { x, y } = getRectangleByNode(MindElement.getNode(element));
    x = x + NodeSpace.getEmojiLeftSpace(board, element);
    const { width } = getEmojisWidthHeight(board, element);
    return {
        x,
        y,
        width,
        height: NodeSpace.getNodeHeight(board, element)
    };
}
const isHitEmojis = (board, element, point) => {
    return RectangleClient.isHit(RectangleClient.getRectangleByPoints([point, point]), getEmojiRectangle(board, element));
};

function getTopicRectangleByNode(board, node) {
    let nodeRectangle = getRectangleByNode(node);
    const result = getTopicRectangleByElement(board, nodeRectangle, node.origin);
    return result;
}
function getTopicRectangleByElement(board, nodeRectangle, element) {
    const x = nodeRectangle.x + NodeSpace.getTextLeftSpace(board, element);
    const y = nodeRectangle.y + NodeSpace.getTextTopSpace(board, element);
    const width = NodeSpace.getTopicDynamicWidth(board, element);
    const height = NodeSpace.getTopicHeight(board, element);
    return { height, width, x, y };
}

function getImageForeignRectangle(board, element) {
    let { x, y } = getRectangleByNode(MindElement.getNode(element));
    const elementWidth = element.manualWidth || element.width;
    x =
        elementWidth > element.data.image.width
            ? x + NodeSpace.getTextLeftSpace(board, element) + (elementWidth - element.data.image.width) / 2
            : x + NodeSpace.getTextLeftSpace(board, element);
    y = NodeSpace.getImageTopSpace(board, element) + y;
    const { width, height } = element.data.image;
    const rectangle = {
        x,
        y,
        width,
        height
    };
    return rectangle;
}
const isHitImage = (board, element, point) => {
    const imageRectangle = getImageForeignRectangle(board, element);
    const imageOutlineRectangle = RectangleClient.getOutlineRectangle(imageRectangle, -RESIZE_HANDLE_DIAMETER / 2);
    return RectangleClient.isPointInRectangle(imageOutlineRectangle, point);
};
const getHitImageResizeHandleDirection = (board, element, point) => {
    const imageRectangle = getImageForeignRectangle(board, element);
    const resizeHandleRefs = getRectangleResizeHandleRefs(imageRectangle, RESIZE_HANDLE_DIAMETER);
    const result = resizeHandleRefs.find(resizeHandleRef => {
        return RectangleClient.isHit(RectangleClient.getRectangleByPoints([point, point]), resizeHandleRef.rectangle);
    });
    return result;
};

const adjustRootToNode = (board, node) => {
    const newNode = { ...node };
    delete newNode.isRoot;
    delete newNode.rightNodeCount;
    delete newNode.type;
    if (newNode.layout === MindLayoutType.standard) {
        delete newNode.layout;
    }
    return newNode;
};
const adjustAbstractToNode = (node) => {
    const newNode = { ...node };
    delete newNode.start;
    delete newNode.end;
    return newNode;
};
const adjustNodeToRoot = (board, node) => {
    const newElement = { ...node };
    if (!Node$1.string(newElement.data.topic)) {
        newElement.data.topic = { children: [{ text: '思维导图' }] };
    }
    delete newElement?.strokeColor;
    delete newElement?.fill;
    delete newElement?.shape;
    delete newElement?.strokeWidth;
    delete newElement?.isCollapsed;
    return {
        ...newElement,
        layout: newElement.layout ?? MindLayoutType.right,
        isRoot: true,
        type: 'mindmap'
    };
};

const addImageFocus = (board, element) => {
    addElementOfFocusedImage(board, element);
    const commonElementRef = PlaitElement.getElementRef(element);
    const imageGenerator = commonElementRef.getGenerator(ImageGenerator.key);
    imageGenerator.setFocus(element, true);
};
const removeImageFocus = (board, element) => {
    removeElementOfFocusedImage(board);
    const commonElementRef = PlaitElement.getElementRef(element);
    const imageGenerator = commonElementRef.getGenerator(ImageGenerator.key);
    imageGenerator.setFocus(element, false);
};

/**
 * 1. return new node height if height changed
 * 2. new height is effected by zoom
 */
const getNewNodeHeight = (board, element, newNodeDynamicWidth) => {
    const textManage = getFirstTextManage(element);
    const { height } = textManage.getSize(undefined, newNodeDynamicWidth);
    if (Math.abs(height - element.height) > 2) {
        return height;
    }
    return undefined;
};

const addActiveOnDragOrigin = (activeElement) => {
    PlaitElement.getElementG(activeElement).classList.add('dragging-node');
    !activeElement.isCollapsed &&
        activeElement.children.forEach(child => {
            addActiveOnDragOrigin(child);
        });
};
const removeActiveOnDragOrigin = (activeElement) => {
    PlaitElement.getElementG(activeElement).classList.remove('dragging-node');
    !activeElement.isCollapsed &&
        activeElement.children.forEach(child => {
            removeActiveOnDragOrigin(child);
        });
};
const setMindDragging = (board, state) => {
    setDragging(board, state);
    if (state) {
        PlaitBoard.getBoardContainer(board).classList.add('mind-node-dragging');
    }
    else {
        PlaitBoard.getBoardContainer(board).classList.remove('mind-node-dragging');
    }
};
const hasPreviousOrNextOfDropPath = (parent, dropTarget, dropPath) => {
    let children = getNonAbstractChildren(parent);
    if (PlaitMind.isMind(parent) && isStandardLayout(getRootLayout(parent))) {
        const isDropRight = isDropStandardRight(parent, dropTarget);
        if (isDropRight) {
            children = children.slice(0, parent.rightNodeCount);
        }
        if (!isDropRight) {
            children = children.slice(parent.rightNodeCount, children.length);
            dropPath = [...dropPath, dropPath[dropPath.length - 1] - parent.rightNodeCount];
        }
    }
    let hasPreviousNode = dropPath[dropPath.length - 1] !== 0;
    let hasNextNode = dropPath[dropPath.length - 1] !== (children?.length || 0);
    if (parent.isCollapsed) {
        hasNextNode = false;
        hasPreviousNode = false;
    }
    return {
        hasPreviousNode,
        hasNextNode
    };
};
const isDropStandardRight = (parent, dropTarget) => {
    const target = dropTarget.target;
    return ((PlaitMind.isMind(parent) &&
        isStandardLayout(getRootLayout(parent)) &&
        parent.children.indexOf(target) !== -1 &&
        parent.children.indexOf(target) < parent.rightNodeCount) ||
        (PlaitMind.isMind(target) && isStandardLayout(getRootLayout(target)) && dropTarget.detectResult === 'right'));
};

const directionCorrector = (board, node, detectResults) => {
    if (!node.origin.isRoot && !AbstractNode.isAbstract(node.origin)) {
        const parentLayout = MindQueries.getCorrectLayoutByElement(board, node?.parent.origin);
        if (isStandardLayout(parentLayout)) {
            const idx = node.parent.children.findIndex(x => x === node);
            const isLeft = idx >= (node.parent.origin.rightNodeCount || 0);
            return getAllowedDirection(detectResults, [isLeft ? 'right' : 'left']);
        }
        if (isLeftLayout(parentLayout)) {
            return getAllowedDirection(detectResults, ['right']);
        }
        if (isRightLayout(parentLayout)) {
            return getAllowedDirection(detectResults, ['left']);
        }
        if (parentLayout === MindLayoutType.upward) {
            return getAllowedDirection(detectResults, ['bottom']);
        }
        if (parentLayout === MindLayoutType.downward) {
            return getAllowedDirection(detectResults, ['top']);
        }
    }
    else {
        const layout = MindQueries.getCorrectLayoutByElement(board, node?.origin);
        if (isStandardLayout(layout)) {
            return getAllowedDirection(detectResults, ['top', 'bottom']);
        }
        if (layout === MindLayoutType.upward) {
            return getAllowedDirection(detectResults, ['left', 'right', 'bottom']);
        }
        if (layout === MindLayoutType.downward) {
            return getAllowedDirection(detectResults, ['left', 'right', 'top']);
        }
        if (isLeftLayout(layout)) {
            return getAllowedDirection(detectResults, ['right', 'top', 'bottom']);
        }
        if (isRightLayout(layout)) {
            return getAllowedDirection(detectResults, ['left', 'top', 'bottom']);
        }
    }
    return null;
};
const getAllowedDirection = (detectResults, illegalDirections) => {
    const directions = detectResults;
    illegalDirections.forEach(item => {
        const bottomDirectionIndex = directions.findIndex(direction => direction === item);
        if (bottomDirectionIndex !== -1) {
            directions.splice(bottomDirectionIndex, 1);
        }
    });
    return directions.length ? directions : null;
};
const detectDropTarget = (board, detectPoint, dropTarget, activeElements) => {
    let detectResult = null;
    depthFirstRecursion(board, element => {
        if (!MindElement.isMindElement(board, element) || detectResult) {
            return;
        }
        const node = MindElement.getNode(element);
        const directions = directionDetector(node, detectPoint);
        if (directions) {
            detectResult = directionCorrector(board, node, directions);
        }
        dropTarget = null;
        const isValid = activeElements.every(element => isValidTarget(element, node.origin));
        if (detectResult && isValid) {
            dropTarget = { target: node.origin, detectResult: detectResult[0] };
        }
    }, getIsRecursionFunc(board));
    return dropTarget;
};
const directionDetector = (targetNode, centerPoint) => {
    const { x, y, width, height } = getRectangleByNode(targetNode);
    const yCenter = y + height / 2;
    const xCenter = x + width / 2;
    const top = targetNode.y;
    const bottom = targetNode.y + targetNode.height;
    const left = targetNode.x;
    const right = targetNode.x + targetNode.width;
    const direction = [];
    // x-axis
    if (centerPoint[1] > y && centerPoint[1] < y + height) {
        if (centerPoint[0] > left && centerPoint[0] < xCenter) {
            direction.push('left');
        }
        if (centerPoint[0] > xCenter && centerPoint[0] < right) {
            direction.push('right');
        }
        // Overlapping area, return in both directions
        if ((centerPoint[0] > x && centerPoint[0] < xCenter) || (centerPoint[0] > xCenter && centerPoint[0] < x + width)) {
            if (centerPoint[1] < yCenter) {
                direction.push('top');
            }
            else {
                direction.push('bottom');
            }
        }
        return direction.length ? direction : null;
    }
    // y-axis
    if (centerPoint[0] > x && centerPoint[0] < x + width) {
        if (centerPoint[1] > top && centerPoint[1] < yCenter) {
            direction.push('top');
        }
        if (centerPoint[1] > yCenter && centerPoint[1] < bottom) {
            direction.push('bottom');
        }
        if ((centerPoint[1] > y && centerPoint[1] < y + height) || (centerPoint[1] > yCenter && centerPoint[1] < y + height)) {
            if (centerPoint[0] < xCenter) {
                direction.push('left');
            }
            else {
                direction.push('right');
            }
        }
        return direction.length ? direction : null;
    }
    return null;
};
const isValidTarget = (origin, target) => {
    return origin !== target && !isChildElement(origin, target);
};
const getPathByDropTarget = (board, dropTarget) => {
    let targetPath = PlaitBoard.findPath(board, dropTarget?.target);
    const layout = PlaitMind.isMind(dropTarget?.target)
        ? getRootLayout(dropTarget?.target)
        : MindQueries.getCorrectLayoutByElement(board, MindElement.getParent(dropTarget?.target));
    const children = getNonAbstractChildren(dropTarget.target);
    if (isVerticalLogicLayout(layout)) {
        if (dropTarget.detectResult === 'top' || dropTarget.detectResult === 'bottom') {
            targetPath.push(children.length);
        }
        if (dropTarget.detectResult === 'right') {
            targetPath = Path.next(targetPath);
        }
    }
    if (isHorizontalLogicLayout(layout)) {
        if (dropTarget.detectResult === 'right') {
            if (PlaitMind.isMind(dropTarget?.target) && isStandardLayout(layout)) {
                targetPath.push(dropTarget?.target.rightNodeCount);
            }
            else {
                targetPath.push(children.length);
            }
        }
        if (dropTarget.detectResult === 'left') {
            targetPath.push(children.length);
        }
        if (dropTarget.detectResult === 'bottom') {
            targetPath = Path.next(targetPath);
        }
    }
    if (isIndentedLayout(layout)) {
        if (isTopLayout(layout) && dropTarget.detectResult === 'top') {
            targetPath = Path.next(targetPath);
        }
        if (isBottomLayout(layout) && dropTarget.detectResult === 'bottom') {
            targetPath = Path.next(targetPath);
        }
        if (isLeftLayout(layout) && dropTarget.detectResult === 'left') {
            targetPath.push(children.length);
        }
        if (isRightLayout(layout) && dropTarget.detectResult === 'right') {
            targetPath.push(children.length);
        }
    }
    return targetPath;
};

function drawRoundRectangleByNode(board, node) {
    const rectangle = getRectangleByNode(node);
    return drawRoundRectangleByElement(board, rectangle, node.origin);
}
function drawRoundRectangleByElement(board, nodeRectangle, element) {
    const fill = getFillByElement(board, element);
    const stroke = getStrokeColorByElement(board, element);
    const strokeWidth = getStrokeWidthByElement(board, element);
    const strokeStyle = getStrokeStyleByElement(board, element);
    const strokeLineDash = getStrokeLineDash(strokeStyle, strokeWidth);
    const newNodeRectangle = RectangleClient.inflate(nodeRectangle, -strokeWidth);
    const nodeG = drawRoundRectangle(PlaitBoard.getRoughSVG(board), newNodeRectangle.x, newNodeRectangle.y, newNodeRectangle.x + newNodeRectangle.width, newNodeRectangle.y + newNodeRectangle.height, {
        stroke,
        strokeWidth,
        fill,
        fillStyle: 'solid',
        strokeLineDash
    }, false, DefaultNodeStyle.shape.rectangleRadius);
    return nodeG;
}

var HorizontalPlacement;
(function (HorizontalPlacement) {
    HorizontalPlacement["left"] = "left";
    HorizontalPlacement["center"] = "center";
    HorizontalPlacement["right"] = "right";
})(HorizontalPlacement || (HorizontalPlacement = {}));
var VerticalPlacement;
(function (VerticalPlacement) {
    VerticalPlacement["top"] = "top";
    VerticalPlacement["middle"] = "middle";
    VerticalPlacement["bottom"] = "bottom";
})(VerticalPlacement || (VerticalPlacement = {}));

const getPointByPlacement = (client, placement) => {
    let x = client.x;
    let y = client.y;
    if (placement[0] === HorizontalPlacement.center) {
        x = client.x + client.width / 2;
    }
    if (placement[0] === HorizontalPlacement.right) {
        x = client.x + client.width;
    }
    if (placement[1] === VerticalPlacement.middle) {
        y = client.y + client.height / 2;
    }
    if (placement[1] === VerticalPlacement.bottom) {
        y = client.y + client.height;
    }
    return [x, y];
};
const getYDistanceBetweenPoint = (point1, point2, isHorizontalLayout) => {
    getXDistanceBetweenPoint(point1, point2, !isHorizontalLayout);
};
const getLayoutDirection = (node, isHorizontal) => {
    if (isHorizontal) {
        if (node.left) {
            return LayoutDirection.left;
        }
        else {
            return LayoutDirection.right;
        }
    }
    else {
        if (node.up) {
            return LayoutDirection.top;
        }
        else {
            return LayoutDirection.bottom;
        }
    }
};
const transformPlacement = (placement, direction) => {
    // to left
    if (direction === LayoutDirection.left) {
        if (placement[0] === HorizontalPlacement.right) {
            placement[0] = HorizontalPlacement.left;
        }
        else if (placement[0] === HorizontalPlacement.left) {
            placement[0] = HorizontalPlacement.right;
        }
    }
    // to bottom
    if (direction === LayoutDirection.bottom || direction === LayoutDirection.top) {
        let horizontal = HorizontalPlacement.center;
        let vertical = VerticalPlacement.middle;
        if (placement[1] === VerticalPlacement.top) {
            horizontal = HorizontalPlacement.left;
        }
        if (placement[1] === VerticalPlacement.bottom) {
            horizontal = HorizontalPlacement.right;
        }
        if (placement[0] === HorizontalPlacement.left) {
            vertical = VerticalPlacement.top;
        }
        if (placement[0] === HorizontalPlacement.right) {
            vertical = VerticalPlacement.bottom;
        }
        placement[0] = horizontal;
        placement[1] = vertical;
    }
    // to up
    if (direction === LayoutDirection.top) {
        if (placement[1] === VerticalPlacement.bottom) {
            placement[1] = VerticalPlacement.top;
        }
        else if (placement[1] === VerticalPlacement.top) {
            placement[1] = VerticalPlacement.bottom;
        }
    }
};

function drawIndentedLink(board, parent, child, needDrawUnderline = true, defaultStrokeColor = null, defaultStrokeWidth, defaultStrokeStyle) {
    const branchShape = getBranchShapeByMindElement(board, parent.origin);
    const branchWidth = defaultStrokeWidth || getBranchWidthByMindElement(board, child.origin);
    const branchColor = defaultStrokeColor || getBranchColorByMindElement(board, child.origin);
    const strokeStyle = defaultStrokeStyle || getStrokeStyleByElement(board, child.origin);
    const isUnderlineShape = getShapeByElement(board, child.origin) === MindElementShape.underline;
    let beginX, beginY, endX, endY, beginNode = parent, endNode = child;
    const beginRectangle = getRectangleByNode(beginNode);
    const endRectangle = getRectangleByNode(endNode);
    beginX = beginNode.x + beginNode.width / 2;
    beginY = isChildUp(parent, child) ? beginRectangle.y : beginRectangle.y + beginRectangle.height;
    endX = parent.left ? endNode.x + endNode.hGap + endRectangle.width : endNode.x + endNode.hGap;
    endY = isUnderlineShape ? endNode.y + endNode.height - endNode.vGap : endNode.y + endNode.height / 2;
    let plusMinus = isChildUp(parent, child) ? (parent.left ? [-1, -1] : [1, -1]) : parent.left ? [-1, 1] : [1, 1];
    let curve = [
        [beginX, beginY],
        [beginX, beginY],
        [beginX, beginY],
        [beginX, endY - (endNode.hGap * 3 * plusMinus[1]) / 5],
        [beginX, endY - (endNode.hGap * plusMinus[1]) / 5],
        [beginX + (endNode.hGap * plusMinus[0]) / 4, endY],
        [beginX + (endNode.hGap * plusMinus[0] * 3) / 5, endY],
        isUnderlineShape && needDrawUnderline ? [endX + (endNode.width - endNode.hGap * 2) * plusMinus[0], endY] : [endX, endY],
        isUnderlineShape && needDrawUnderline ? [endX + (endNode.width - endNode.hGap * 2) * plusMinus[0], endY] : [endX, endY],
        isUnderlineShape && needDrawUnderline ? [endX + (endNode.width - endNode.hGap * 2) * plusMinus[0], endY] : [endX, endY]
    ];
    const strokeLineDash = getStrokeLineDash(strokeStyle, branchWidth);
    if (branchShape === BranchShape.polyline) {
        const polylinePoints = [
            [beginX, beginY],
            [beginX, endY],
            [endX, endY],
            isUnderlineShape && needDrawUnderline ? [endX + (endNode.width - endNode.hGap * 2) * plusMinus[0], endY] : [endX, endY]
        ];
        return drawLinearPath(polylinePoints, { stroke: branchColor, strokeWidth: branchWidth, strokeLineDash });
    }
    const points = pointsOnBezierCurves(curve, 0.001);
    return drawBezierPath(points, { stroke: branchColor, strokeWidth: branchWidth, strokeLineDash });
}

function drawLogicLink(board, parent, node, isHorizontal, defaultStrokeColor = null, defaultStrokeWidth, defaultStrokeStyle) {
    const branchShape = getBranchShapeByMindElement(board, parent.origin);
    const branchColor = defaultStrokeColor || getBranchColorByMindElement(board, node.origin);
    const branchWidth = defaultStrokeWidth || getBranchWidthByMindElement(board, node.origin);
    const strokeStyle = defaultStrokeStyle || getStrokeStyleByElement(board, node.origin);
    const hasStraightLine = branchShape === BranchShape.polyline ? true : !parent.origin.isRoot;
    const parentShape = getShapeByElement(board, parent.origin);
    const shape = getShapeByElement(board, node.origin);
    const hasUnderlineShape = shape === MindElementShape.underline;
    const hasUnderlineShapeOfParent = parentShape === MindElementShape.underline;
    const nodeClient = getRectangleByNode(node);
    const parentClient = getRectangleByNode(parent);
    const linkDirection = getLayoutDirection(node, isHorizontal);
    // ① ensure begin placement and end placement
    // begin placement represent parent connector position and end placement represent child connector
    const beginPlacement = [HorizontalPlacement.right, VerticalPlacement.middle];
    const endPlacement = [HorizontalPlacement.left, VerticalPlacement.middle];
    transformPlacement(beginPlacement, linkDirection);
    transformPlacement(endPlacement, linkDirection);
    // underline shape and horizontal
    if (isHorizontal && hasUnderlineShapeOfParent && !parent.origin.isRoot) {
        beginPlacement[1] = VerticalPlacement.bottom;
    }
    if (isHorizontal && hasUnderlineShape) {
        endPlacement[1] = VerticalPlacement.bottom;
    }
    let beginPoint = getPointByPlacement(parentClient, beginPlacement);
    let endPoint = getPointByPlacement(nodeClient, endPlacement);
    // ② Determine the convex straight line
    const straightLineDistance = 8;
    const beginPoint2 = hasStraightLine
        ? moveXOfPoint(beginPoint, straightLineDistance, linkDirection)
        : beginPoint;
    let straightLine = hasStraightLine ? [beginPoint, beginPoint2, beginPoint2] : [];
    // ③ Determine the curve
    const beginBufferDistance = (parent.hGap + node.hGap) / 3;
    const endBufferDistance = -(parent.hGap + node.hGap) / 2.4;
    let curve = [
        beginPoint2,
        moveXOfPoint(beginPoint2, beginBufferDistance, linkDirection),
        moveXOfPoint(endPoint, endBufferDistance, linkDirection),
        endPoint
    ];
    // ④ underline shape and horizontal
    const underlineEnd = moveXOfPoint(endPoint, nodeClient.width, linkDirection);
    const underline = hasUnderlineShape && isHorizontal ? [underlineEnd, underlineEnd, underlineEnd] : [];
    const points = pointsOnBezierCurves([...straightLine, ...curve, ...underline]);
    const strokeLineDash = getStrokeLineDash(strokeStyle, branchWidth);
    let linkG;
    if (branchShape === BranchShape.polyline) {
        const buffer = 8;
        const movePoint = moveXOfPoint(beginPoint2, buffer, linkDirection);
        const polylinePoints = [
            ...straightLine,
            movePoint,
            isHorizontal ? [movePoint[0], endPoint[1]] : [endPoint[0], movePoint[1]],
            endPoint,
            ...underline
        ];
        linkG = drawLinearPath(polylinePoints, { stroke: branchColor, strokeWidth: branchWidth, strokeLineDash });
    }
    else {
        linkG = PlaitBoard.getRoughSVG(board).curve(points, { stroke: branchColor, strokeWidth: branchWidth, strokeLineDash });
    }
    if (strokeStyle === StrokeStyle.dotted) {
        setStrokeLinecap(linkG, 'round');
    }
    return linkG;
}

function drawLink(board, parentNode, node, isHorizontal, needDrawUnderline, defaultStrokeColor, defaultStrokeWidth, defaultStrokeStyle) {
    return MindElement.isIndentedLayout(parentNode.origin)
        ? drawIndentedLink(board, parentNode, node, needDrawUnderline, defaultStrokeColor, defaultStrokeWidth, defaultStrokeStyle)
        : drawLogicLink(board, parentNode, node, isHorizontal, defaultStrokeColor, defaultStrokeWidth, defaultStrokeStyle);
}

const FOREIGN_OBJECT_EMOJI_CLASS_NAME = 'foreign-object-emoji';
class EmojiGenerator {
    constructor(board) {
        this.board = board;
        this.emojiComponentRef = null;
    }
    draw(container, emoji, element) {
        this.destroy();
        const props = {
            board: this.board,
            emojiItem: emoji,
            element,
            fontSize: getEmojiFontSize(element)
        };
        this.emojiComponentRef = this.board.renderEmoji(container, props);
    }
    destroy() {
        if (this.emojiComponentRef) {
            this.emojiComponentRef.destroy();
            this.emojiComponentRef = null;
        }
    }
}
class NodeEmojisGenerator {
    static { this.key = 'node-emojis-generator'; }
    constructor(board) {
        this.board = board;
        this.emojiGenerators = [];
    }
    drawEmojis(element) {
        this.destroy();
        if (MindElement.hasEmojis(element)) {
            this.g = createG();
            this.g.classList.add('emojis');
            const foreignRectangle = getEmojiForeignRectangle(this.board, element);
            const foreignObject = createForeignObject(foreignRectangle.x, foreignRectangle.y, foreignRectangle.width, foreignRectangle.height);
            foreignObject.classList.add(FOREIGN_OBJECT_EMOJI_CLASS_NAME);
            this.g.append(foreignObject);
            const container = document.createElement('div');
            container.classList.add('node-emojis-container');
            foreignObject.append(container);
            this.emojiGenerators = element.data.emojis.map(emojiItem => {
                const drawer = new EmojiGenerator(this.board);
                drawer.draw(container, emojiItem, element);
                return drawer;
            });
            return this.g;
        }
        return undefined;
    }
    destroy() {
        if (this.g) {
            this.g.remove();
        }
        this.emojiGenerators.forEach(drawer => drawer.destroy());
        this.emojiGenerators = [];
    }
}

const drawFakeDragNode = (board, element, offsetX, offsetY) => {
    const ref = PlaitElement.getElementRef(element);
    const mindNode = MindElement.getNode(element);
    const dragFakeNodeG = createG();
    dragFakeNodeG.classList.add('dragging', 'fake-node', 'plait-board-attached');
    const fakeDraggingNode = {
        ...mindNode,
        children: [],
        x: mindNode.x + offsetX,
        y: mindNode.y + offsetY
    };
    const textRectangle = getTopicRectangleByNode(board, mindNode);
    const fakeNodeG = drawRoundRectangleByNode(board, fakeDraggingNode);
    const richtextG = getFirstTextManage(element).g.cloneNode(true);
    updateForeignObject(richtextG, textRectangle.width, textRectangle.height, textRectangle.x + offsetX, textRectangle.y + offsetY);
    dragFakeNodeG?.append(fakeNodeG);
    dragFakeNodeG?.append(richtextG);
    // draw emojis
    if (MindElement.hasEmojis(element)) {
        const nodeEmojisGenerator = ref.getGenerator(NodeEmojisGenerator.key);
        const fakeEmojisG = nodeEmojisGenerator.g.cloneNode(true);
        const foreignRectangle = getEmojiForeignRectangle(board, element);
        updateForeignObject(fakeEmojisG, foreignRectangle.width, foreignRectangle.height, foreignRectangle.x + offsetX, foreignRectangle.y + offsetY);
        dragFakeNodeG?.append(fakeEmojisG);
    }
    if (MindElement.hasImage(element)) {
        const imageGenerator = ref.getGenerator(ImageGenerator.key);
        const fakeImageG = imageGenerator.g.cloneNode(true);
        const foreignRectangle = getImageForeignRectangle(board, element);
        updateForeignObject(fakeImageG, foreignRectangle.width, foreignRectangle.height, foreignRectangle.x + offsetX, foreignRectangle.y + offsetY);
        dragFakeNodeG?.append(fakeImageG);
    }
    return dragFakeNodeG;
};
const drawFakeDropNode = (board, dropTarget, path) => {
    const target = dropTarget.target;
    const fakeDropNodeG = createG();
    const parent = PlaitNode.get(board, Path.parent(path));
    const layout = MindQueries.getLayoutByElement(parent);
    const isHorizontal = isHorizontalLayout(layout);
    const { hasNextNode, hasPreviousNode } = hasPreviousOrNextOfDropPath(parent, dropTarget, path);
    const width = 30;
    const height = 12;
    let fakeNode, centerPoint, basicNode, linkDirection;
    if (!hasPreviousNode && !hasNextNode) {
        const parentNode = MindElement.getNode(parent);
        const parentRect = getRectangleByNode(parentNode);
        linkDirection = getLayoutDirection(parentNode, isHorizontal);
        basicNode = parentNode;
        if (PlaitMind.isMind(target) && isStandardLayout(layout)) {
            if (dropTarget.detectResult === 'left') {
                linkDirection = LayoutDirection.left;
                basicNode.left = true;
            }
            else {
                linkDirection = LayoutDirection.right;
                basicNode.left = false;
            }
        }
        const placement = [HorizontalPlacement.right, VerticalPlacement.middle];
        transformPlacement(placement, linkDirection);
        const parentCenterPoint = getPointByPlacement(parentRect, placement);
        if (isIndentedLayout(layout)) {
            const placement = [
                HorizontalPlacement.center,
                isTopLayout(layout) ? VerticalPlacement.top : VerticalPlacement.bottom
            ];
            const parentCenterPoint = getPointByPlacement(parentRect, placement);
            centerPoint = moveXOfPoint(parentCenterPoint, height, linkDirection);
            centerPoint[1] = isTopLayout(layout) ? centerPoint[1] - height : centerPoint[1] + height;
        }
        else {
            centerPoint = moveXOfPoint(parentCenterPoint, width, linkDirection);
        }
    }
    else if (!hasPreviousNode && hasNextNode) {
        const nextElement = PlaitNode.get(board, path);
        basicNode = MindElement.getNode(nextElement);
        const nextRect = getRectangleByNode(basicNode);
        linkDirection = getLayoutDirection(basicNode, isHorizontal);
        const placement = [HorizontalPlacement.left, VerticalPlacement.top];
        transformPlacement(placement, linkDirection);
        let offset = -height;
        if (MindElement.isIndentedLayout(parent)) {
            offset = isTopLayout(layout) ? offset / 2 + basicNode.height - basicNode.vGap : 0;
        }
        centerPoint = getPointByPlacement(nextRect, placement);
        centerPoint = moveYOfPoint(centerPoint, offset, linkDirection);
    }
    else if (hasPreviousNode && !hasNextNode) {
        const previousElement = PlaitNode.get(board, Path.previous(path));
        basicNode = MindElement.getNode(previousElement);
        const previousRect = getRectangleByNode(basicNode);
        linkDirection = getLayoutDirection(basicNode, isHorizontal);
        const placement = [HorizontalPlacement.left, VerticalPlacement.bottom];
        transformPlacement(placement, linkDirection);
        let offset = height;
        if (MindElement.isIndentedLayout(parent)) {
            offset = isTopLayout(layout) ? -offset - (basicNode.height - basicNode.vGap) : offset;
        }
        centerPoint = getPointByPlacement(previousRect, placement);
        centerPoint = moveYOfPoint(centerPoint, offset, linkDirection);
    }
    else {
        const previousElement = PlaitNode.get(board, Path.previous(path));
        basicNode = MindElement.getNode(previousElement);
        const previousRect = getRectangleByNode(basicNode);
        const nextElement = PlaitNode.get(board, path);
        const nextNode = MindElement.getNode(nextElement);
        const nextRect = getRectangleByNode(nextNode);
        const beginPlacement = [HorizontalPlacement.left, VerticalPlacement.bottom];
        const endPlacement = [HorizontalPlacement.left, VerticalPlacement.top];
        linkDirection = getLayoutDirection(basicNode, isHorizontal);
        transformPlacement(beginPlacement, linkDirection);
        transformPlacement(endPlacement, linkDirection);
        const previousPoint = getPointByPlacement(previousRect, beginPlacement);
        const nextPoint = getPointByPlacement(nextRect, endPlacement);
        centerPoint = [(previousPoint[0] + nextPoint[0]) / 2, (previousPoint[1] + nextPoint[1]) / 2];
    }
    let cornerPoint = centerPoint, oppositePoint = centerPoint;
    const offsetY = isHorizontal ? height : width;
    const offsetX = isHorizontal ? width : height;
    cornerPoint = moveYOfPoint(cornerPoint, -offsetY / 2, linkDirection);
    oppositePoint = moveYOfPoint(oppositePoint, offsetY / 2, linkDirection);
    oppositePoint = moveXOfPoint(oppositePoint, offsetX, linkDirection);
    const x = Math.min(cornerPoint[0], oppositePoint[0]);
    const y = Math.min(cornerPoint[1], oppositePoint[1]);
    fakeNode = {
        ...basicNode,
        x,
        y,
        width,
        height,
        hGap: MindElement.isIndentedLayout(parent) ? BASE * 4 + (basicNode.origin.strokeWidth || STROKE_WIDTH) : 0,
        vGap: MindElement.isIndentedLayout(parent) ? BASE : 0
    };
    const fakeRectangleG = drawRoundRectangle(PlaitBoard.getRoughSVG(board), fakeNode.x, fakeNode.y, fakeNode.x + width, fakeNode.y + height, {
        stroke: PRIMARY_COLOR,
        strokeWidth: 2,
        fill: PRIMARY_COLOR,
        fillStyle: 'solid'
    });
    const link = drawLink(board, MindElement.getNode(parent), fakeNode, isHorizontal, false, PRIMARY_COLOR, STROKE_WIDTH);
    fakeDropNodeG?.appendChild(link);
    fakeDropNodeG?.appendChild(fakeRectangleG);
    return fakeDropNodeG;
};

var AbstractHandlePosition;
(function (AbstractHandlePosition) {
    AbstractHandlePosition["start"] = "start";
    AbstractHandlePosition["end"] = "end";
})(AbstractHandlePosition || (AbstractHandlePosition = {}));
var AbstractResizeState;
(function (AbstractResizeState) {
    AbstractResizeState["start"] = "start";
    AbstractResizeState["resizing"] = "resizing";
    AbstractResizeState["end"] = "end";
})(AbstractResizeState || (AbstractResizeState = {}));

function drawAbstractIncludedOutline(board, roughSVG, element, activeHandlePosition, resizingLocation) {
    const abstractIncludedG = createG();
    const parentElement = MindElement.getParent(element);
    const nodeLayout = MindQueries.getCorrectLayoutByElement(board, element);
    const isHorizontal = isHorizontalLayout(nodeLayout);
    const includedElements = parentElement.children.slice(element.start, element.end + 1);
    const abstractRectangle = getRectangleByElements(board, includedElements, true);
    const activeAbstractRectangle = toActiveRectangleFromViewBoxRectangle(board, abstractRectangle);
    let activeAbstractOutlineRectangle = RectangleClient.getOutlineRectangle(activeAbstractRectangle, -ABSTRACT_INCLUDED_OUTLINE_OFFSET);
    if (resizingLocation) {
        activeAbstractOutlineRectangle = getRectangleByResizingLocation(activeAbstractOutlineRectangle, resizingLocation, activeHandlePosition, isHorizontal);
    }
    const rectangle = drawAbstractRoundRectangle(roughSVG, activeAbstractOutlineRectangle.x, activeAbstractOutlineRectangle.y, activeAbstractOutlineRectangle.x + activeAbstractOutlineRectangle.width, activeAbstractOutlineRectangle.y + activeAbstractOutlineRectangle.height, isHorizontal, {
        stroke: PRIMARY_COLOR,
        strokeWidth: 1,
        fillStyle: 'solid'
    });
    const startPlacement = [HorizontalPlacement.center, VerticalPlacement.top];
    const endPlacement = [HorizontalPlacement.center, VerticalPlacement.bottom];
    const linkDirection = getLayoutDirection(MindElement.getNode(element), isHorizontal);
    transformPlacement(startPlacement, linkDirection);
    transformPlacement(endPlacement, linkDirection);
    let startCenterPoint = getPointByPlacement(activeAbstractOutlineRectangle, startPlacement);
    let endCenterPoint = getPointByPlacement(activeAbstractOutlineRectangle, endPlacement);
    const startPoint1 = moveXOfPoint(startCenterPoint, -ABSTRACT_HANDLE_LENGTH / 2, linkDirection);
    const startPoint2 = moveXOfPoint(startCenterPoint, ABSTRACT_HANDLE_LENGTH / 2, linkDirection);
    const endPoint1 = moveXOfPoint(endCenterPoint, -ABSTRACT_HANDLE_LENGTH / 2, linkDirection);
    const endPoint2 = moveXOfPoint(endCenterPoint, ABSTRACT_HANDLE_LENGTH / 2, linkDirection);
    const startHandle = roughSVG.line(startPoint1[0], startPoint1[1], startPoint2[0], startPoint2[1], getHandleOption(activeHandlePosition === AbstractHandlePosition.start));
    const endHandle = roughSVG.line(endPoint1[0], endPoint1[1], endPoint2[0], endPoint2[1], getHandleOption(activeHandlePosition === AbstractHandlePosition.end));
    handleBoardClass(board, activeHandlePosition, isHorizontal);
    setStrokeLinecap(startHandle, 'round');
    setStrokeLinecap(endHandle, 'round');
    abstractIncludedG.append(startHandle);
    abstractIncludedG.append(endHandle);
    abstractIncludedG.append(rectangle);
    return abstractIncludedG;
}
function getHandleOption(isHover) {
    return isHover
        ? {
            stroke: PRIMARY_COLOR,
            strokeWidth: 4,
            fillStyle: 'solid'
        }
        : {
            stroke: ABSTRACT_HANDLE_COLOR,
            strokeWidth: 3,
            fillStyle: 'solid'
        };
}
function handleBoardClass(board, activeHandlePosition, isHorizontal) {
    if (activeHandlePosition) {
        if (isHorizontal) {
            PlaitBoard.getBoardContainer(board).classList.add('abstract-resizing-horizontal');
        }
        else {
            PlaitBoard.getBoardContainer(board).classList.add('abstract-resizing-vertical');
        }
    }
    else {
        PlaitBoard.getBoardContainer(board).classList.remove('abstract-resizing-horizontal');
        PlaitBoard.getBoardContainer(board).classList.remove('abstract-resizing-vertical');
    }
}
function drawAbstractRoundRectangle(rs, x1, y1, x2, y2, isHorizontal, options) {
    const width = Math.abs(x1 - x2);
    const height = Math.abs(y1 - y2);
    const radius = 5;
    const handleGap = 4;
    const handleLength = 10;
    const handleSpace = handleLength + handleGap * 2;
    if (isHorizontal) {
        const handleSideLine = (width - handleSpace - radius * 2) / 2;
        const sideLine = height - radius * 2;
        return rs.path(`M${x1 + radius},${y1}
            l${handleSideLine},0
            m${handleSpace},0
            l${handleSideLine},0
            a${radius},${radius},0,0,1,${radius},${radius}
            l0,${sideLine}
            a${radius},${radius},0,0,1,-${radius},${radius}
            l-${handleSideLine},0
            m-${handleSpace},0
            l-${handleSideLine},0
            a${radius},${radius},0,0,1,-${radius},-${radius}
            l0,-${sideLine}
            a${radius},${radius},0,0,1,${radius},-${radius}`, options);
    }
    else {
        const handleSideLine = (height - handleSpace - radius * 2) / 2;
        const sideLine = width - radius * 2;
        return rs.path(`M${x1 + radius},${y1}
            l${sideLine},0
            a${radius},${radius},0,0,1,${radius},${radius}
            l0,${handleSideLine}
            m0,${handleSpace}
            l0,${handleSideLine}
            a${radius},${radius},0,0,1,-${radius},${radius}
            l-${sideLine},0
            a${radius},${radius},0,0,1,-${radius},-${radius}
            l0,-${handleSideLine}
            m0,-${handleSpace}
            l0,-${handleSideLine}
            a${radius},${radius},0,0,1,${radius},-${radius}`, options);
    }
}

class NodeActiveGenerator extends Generator {
    static { this.key = 'mind-node-active'; }
    canDraw(element, data) {
        if (data.selected) {
            return true;
        }
        else {
            return false;
        }
    }
    draw(element, data) {
        const activeG = createG();
        const node = MindElement.getNode(element);
        const rectangle = getRectangleByNode(node);
        const activeRectangle1 = toActiveRectangleFromViewBoxRectangle(this.board, rectangle);
        const strokeWidth = getStrokeWidthByElement(this.board, element);
        const activeStrokeWidth = ACTIVE_STROKE_WIDTH;
        const activeRectangleWithInflated = RectangleClient.inflate(activeRectangle1, activeStrokeWidth);
        const strokeG = drawRoundRectangle(PlaitBoard.getRoughSVG(this.board), activeRectangleWithInflated.x, activeRectangleWithInflated.y, activeRectangleWithInflated.x + activeRectangleWithInflated.width, activeRectangleWithInflated.y + activeRectangleWithInflated.height, { stroke: PRIMARY_COLOR, strokeWidth: activeStrokeWidth, fill: '' }, true, DefaultNodeStyle.shape.rectangleRadius + (activeStrokeWidth + strokeWidth) / 2);
        if (AbstractNode.isAbstract(element)) {
            this.abstractOutlineG = drawAbstractIncludedOutline(this.board, PlaitBoard.getRoughSVG(this.board), element);
            activeG.append(this.abstractOutlineG);
            strokeG.classList.add('abstract-element');
        }
        activeG.appendChild(strokeG);
        activeG.classList.add(SELECTION_RECTANGLE_CLASS_NAME);
        return activeG;
    }
    updateAbstractOutline(element, activeHandlePosition, resizingLocation) {
        const abstractOutlineG = drawAbstractIncludedOutline(this.board, PlaitBoard.getRoughSVG(this.board), element, activeHandlePosition, resizingLocation);
        if (this.abstractOutlineG) {
            this.abstractOutlineG.replaceWith(abstractOutlineG);
            this.abstractOutlineG = abstractOutlineG;
        }
    }
}

const getRectangleByResizingLocation = (abstractRectangle, location, activeHandlePosition, isHorizontal) => {
    if (isHorizontal) {
        if (activeHandlePosition === AbstractHandlePosition.start) {
            return {
                ...abstractRectangle,
                y: location,
                height: abstractRectangle.height + abstractRectangle.y - location
            };
        }
        else {
            return {
                ...abstractRectangle,
                height: location - abstractRectangle.y
            };
        }
    }
    else {
        if (activeHandlePosition === AbstractHandlePosition.start) {
            return {
                ...abstractRectangle,
                x: location,
                width: abstractRectangle.width + abstractRectangle.x - location
            };
        }
        else {
            return {
                ...abstractRectangle,
                width: location - abstractRectangle.x
            };
        }
    }
};
const getLocationScope = (board, handlePosition, parentChildren, element, parent, isHorizontal) => {
    const node = MindElement.getNode(element);
    const { start, end } = getCorrectStartEnd(node.origin, parent);
    const startNode = parentChildren[start];
    const endNode = parentChildren[end];
    if (handlePosition === AbstractHandlePosition.start) {
        const abstractNode = parentChildren.filter(child => AbstractNode.isAbstract(child) && child.end < element.start);
        let minNode;
        if (abstractNode.length) {
            const index = abstractNode
                .map(node => {
                const { end } = getCorrectStartEnd(node, parent);
                return end;
            })
                .sort((a, b) => b - a)[0];
            minNode = parentChildren[index + 1];
        }
        else {
            minNode = parentChildren[0];
        }
        const minNodeRectangle = getRectangleByElements(board, [minNode], true);
        const endNodeRectangle = getRectangleByElements(board, [endNode], false);
        if (isHorizontal) {
            return {
                max: endNodeRectangle.y - ABSTRACT_INCLUDED_OUTLINE_OFFSET,
                min: minNodeRectangle.y - ABSTRACT_INCLUDED_OUTLINE_OFFSET
            };
        }
        else {
            return {
                max: endNodeRectangle.x - ABSTRACT_INCLUDED_OUTLINE_OFFSET,
                min: minNodeRectangle.x - ABSTRACT_INCLUDED_OUTLINE_OFFSET
            };
        }
    }
    else {
        const abstractNode = parentChildren.filter(child => AbstractNode.isAbstract(child) && child.start > element.end);
        let maxNode;
        if (abstractNode.length) {
            const index = abstractNode
                .map(node => {
                const { start } = getCorrectStartEnd(node, parent);
                return start;
            })
                .sort((a, b) => a - b)[0];
            maxNode = parentChildren[index - 1];
        }
        else {
            const children = parentChildren.filter(child => !AbstractNode.isAbstract(child));
            maxNode = parentChildren[children.length - 1];
        }
        const maxNodeRectangle = getRectangleByElements(board, [maxNode], true);
        const startNodeRectangle = getRectangleByElements(board, [startNode], false);
        if (isHorizontal) {
            return {
                max: maxNodeRectangle.y + maxNodeRectangle.height + ABSTRACT_INCLUDED_OUTLINE_OFFSET,
                min: startNodeRectangle.y + startNodeRectangle.height + ABSTRACT_INCLUDED_OUTLINE_OFFSET
            };
        }
        else {
            return {
                max: maxNodeRectangle.x + maxNodeRectangle.width + ABSTRACT_INCLUDED_OUTLINE_OFFSET,
                min: startNodeRectangle.x + startNodeRectangle.width + ABSTRACT_INCLUDED_OUTLINE_OFFSET
            };
        }
    }
};
const getHitAbstractHandle = (board, element, point) => {
    const nodeLayout = MindQueries.getCorrectLayoutByElement(board, element);
    const isHorizontal = isHorizontalLayout(nodeLayout);
    const parentElement = MindElement.getParent(element);
    const includedElements = parentElement.children.slice(element.start, element.end + 1);
    let abstractRectangle = getRectangleByElements(board, includedElements, true);
    abstractRectangle = RectangleClient.getOutlineRectangle(abstractRectangle, -ABSTRACT_INCLUDED_OUTLINE_OFFSET);
    const startHandleRec = getAbstractHandleRectangle(abstractRectangle, isHorizontal, AbstractHandlePosition.start);
    const endHandleRec = getAbstractHandleRectangle(abstractRectangle, isHorizontal, AbstractHandlePosition.end);
    const pointRec = RectangleClient.getRectangleByPoints([point, point]);
    if (RectangleClient.isHit(pointRec, startHandleRec))
        return AbstractHandlePosition.start;
    if (RectangleClient.isHit(pointRec, endHandleRec))
        return AbstractHandlePosition.end;
    return undefined;
};
const getAbstractHandleRectangle = (rectangle, isHorizontal, position) => {
    let result;
    if (position === AbstractHandlePosition.start) {
        const location = isHorizontal ? rectangle.y : rectangle.x;
        result = getRectangleByResizingLocation(rectangle, location + ABSTRACT_HANDLE_MASK_WIDTH / 2, AbstractHandlePosition.end, isHorizontal);
        result = getRectangleByResizingLocation(result, location - ABSTRACT_HANDLE_MASK_WIDTH / 2, position, isHorizontal);
    }
    else {
        const location = isHorizontal ? rectangle.y + rectangle.height : rectangle.x + rectangle.width;
        result = getRectangleByResizingLocation(rectangle, location - ABSTRACT_HANDLE_MASK_WIDTH / 2, AbstractHandlePosition.start, isHorizontal);
        result = getRectangleByResizingLocation(result, location + ABSTRACT_HANDLE_MASK_WIDTH / 2, position, isHorizontal);
    }
    return result;
};
function findLocationLeftIndex(board, parentChildren, location, isHorizontal) {
    const children = parentChildren.filter(child => {
        return !AbstractNode.isAbstract(child);
    });
    const recArray = children.map(child => {
        return getRectangleByElements(board, [child], false);
    });
    const firstRec = getRectangleByElements(board, [children[0]], true);
    const fakeLeftRec = {
        x: firstRec.x - firstRec.width,
        y: firstRec.y - firstRec.height,
        width: firstRec.width,
        height: firstRec.height
    };
    const lastRec = getRectangleByElements(board, [children[children.length - 1]], true);
    const fakeRightRec = {
        x: lastRec.x + lastRec.width,
        y: lastRec.y + lastRec.height,
        width: lastRec.width,
        height: lastRec.height
    };
    recArray.push(fakeRightRec);
    recArray.unshift(fakeLeftRec);
    for (let i = 0; i < recArray.length - 1; i++) {
        const recXOrY = isHorizontal ? recArray[i].y : recArray[i].x;
        const recWidthOrHeight = isHorizontal ? recArray[i].height : recArray[i].width;
        if (location >= recXOrY + recWidthOrHeight / 2 &&
            location <= recArray[i + 1][isHorizontal ? 'y' : 'x'] + recArray[i + 1][isHorizontal ? 'height' : 'width'] / 2) {
            return i - 1;
        }
    }
    return 0;
}
function handleTouchedAbstract(board, touchedAbstract, endPoint) {
    let touchedHandle;
    const abstract = getSelectedElements(board).filter(element => AbstractNode.isAbstract(element)).find(element => {
        touchedHandle = getHitAbstractHandle(board, element, endPoint);
        return touchedHandle;
    });
    if (touchedAbstract === abstract) {
        return touchedAbstract;
    }
    if (touchedAbstract) {
        const ref = PlaitElement.getElementRef(touchedAbstract);
        const activeGenerator = ref.getGenerator(NodeActiveGenerator.key);
        activeGenerator.updateAbstractOutline(touchedAbstract);
        touchedAbstract = undefined;
    }
    if (abstract) {
        touchedAbstract = abstract;
        const ref = PlaitElement.getElementRef(touchedAbstract);
        const activeGenerator = ref.getGenerator(NodeActiveGenerator.key);
        activeGenerator.updateAbstractOutline(touchedAbstract, touchedHandle);
    }
    return touchedAbstract;
}

const isInRightBranchOfStandardLayout = (selectedElement) => {
    const parentElement = MindElement.findParent(selectedElement);
    if (parentElement) {
        const nodeIndex = parentElement.children.findIndex(item => item.id === selectedElement.id);
        if (parentElement.isRoot &&
            getRootLayout(parentElement) === MindLayoutType.standard &&
            parentElement.rightNodeCount &&
            nodeIndex <= parentElement.rightNodeCount - 1) {
            return true;
        }
    }
    return false;
};
const insertElementHandleRightNodeCount = (board, path, insertCount, effectedRightNodeCount = []) => {
    let index = effectedRightNodeCount.findIndex(ref => Path.equals(ref.path, path));
    const mind = PlaitNode.get(board, path);
    if (index === -1) {
        effectedRightNodeCount.push({ path, rightNodeCount: mind.rightNodeCount + insertCount });
    }
    else {
        effectedRightNodeCount[index].rightNodeCount += insertCount;
    }
    return effectedRightNodeCount;
};
const deleteElementsHandleRightNodeCount = (board, deletableElements, effectedRightNodeCount = []) => {
    deletableElements.forEach(element => {
        if (isInRightBranchOfStandardLayout(element)) {
            const mind = MindElement.getParent(element);
            const path = PlaitBoard.findPath(board, mind);
            let index = effectedRightNodeCount.findIndex(ref => Path.equals(ref.path, path));
            if (index === -1) {
                effectedRightNodeCount.push({ path, rightNodeCount: mind.rightNodeCount - 1 });
            }
            else {
                effectedRightNodeCount[index].rightNodeCount -= 1;
            }
        }
    });
    return effectedRightNodeCount;
};

function findNewChildNodePath(board, element) {
    const children = getNonAbstractChildren(element);
    return PlaitBoard.findPath(board, element).concat(children.length);
}
function findNewSiblingNodePath(board, element) {
    const path = PlaitBoard.findPath(board, element);
    return Path$1.next(path);
}

/**
 * get correctly layout：
 * 1. root is standard -> left or right
 * 2. correct layout by incorrect layout direction
 * @param element
 */
const getCorrectLayoutByElement = (board, element) => {
    const ancestors = MindElement.getAncestors(board, element);
    ancestors.unshift(element);
    const root = ancestors[ancestors.length - 1];
    let rootLayout = getRootLayout(root);
    if (PlaitMind.isMind(element)) {
        return rootLayout;
    }
    const node = MindElement.getNode(element);
    let correctRootLayout = rootLayout;
    if (rootLayout === MindLayoutType.standard) {
        correctRootLayout = node.left ? MindLayoutType.left : MindLayoutType.right;
    }
    let layout = null;
    const elementWithLayout = ancestors.find(value => value.layout || AbstractNode.isAbstract(value));
    if (elementWithLayout) {
        if (AbstractNode.isAbstract(elementWithLayout)) {
            const parent = MindElement.getParent(elementWithLayout);
            const parentLayout = getCorrectLayoutByElement(board, parent);
            layout = getAbstractLayout(parentLayout);
        }
        else {
            layout = elementWithLayout?.layout;
        }
    }
    if (layout === MindLayoutType.standard || !layout) {
        return correctRootLayout;
    }
    else {
        const incorrectDirection = getInCorrectLayoutDirection(correctRootLayout, layout);
        if (incorrectDirection) {
            return correctLayoutByDirection(layout, incorrectDirection);
        }
        else {
            return layout;
        }
    }
};

const getBranchLayouts = (board, element) => {
    const layouts = [];
    if (element.layout) {
        // TODO: getCorrectLayoutByElement Contains recursive operations. getBranchLayouts itself also has recursive operations and needs to be optimized.
        layouts.unshift(getCorrectLayoutByElement(board, element));
    }
    let parent = MindElement.findParent(element);
    while (parent) {
        if (parent.layout) {
            layouts.unshift(parent.layout);
        }
        parent = MindElement.findParent(parent);
    }
    return layouts;
};

const getAvailableSubLayoutsByElement = (board, element) => {
    const parentElement = MindElement.findParent(element);
    if (parentElement) {
        const branchLayouts = getBranchLayouts(board, parentElement);
        if (branchLayouts[0] === MindLayoutType.standard) {
            const node = MindElement.getNode(element);
            branchLayouts[0] = node.left ? MindLayoutType.left : MindLayoutType.right;
        }
        const currentLayoutDirections = getBranchDirectionsByLayouts(branchLayouts);
        let availableSubLayouts = getAvailableSubLayoutsByLayoutDirections(currentLayoutDirections);
        const parentLayout = [branchLayouts[branchLayouts.length - 1]];
        const parentDirections = getBranchDirectionsByLayouts(parentLayout);
        const parentAvailableSubLayouts = getAvailableSubLayoutsByLayoutDirections(parentDirections);
        availableSubLayouts = availableSubLayouts.filter(layout => parentAvailableSubLayouts.some(parentAvailableSubLayout => parentAvailableSubLayout === layout));
        return availableSubLayouts;
    }
    return undefined;
};

const getLayoutByElement = (element) => {
    const layout = element.layout;
    if (layout) {
        return layout;
    }
    const parent = !PlaitMind.isMind(element) && MindElement.getParent(element);
    if (AbstractNode.isAbstract(element) && parent) {
        return getAbstractLayout(getLayoutByElement(parent));
    }
    if (parent) {
        return getLayoutByElement(parent);
    }
    return getDefaultLayout();
};

const MindQueries = {
    getAvailableSubLayoutsByElement,
    getBranchLayouts,
    getLayoutByElement,
    getCorrectLayoutByElement
};

const PlaitMind = {
    isMind: (value) => {
        return value.type === 'mindmap';
    }
};
const MindElement = {
    hasLayout(value, layout) {
        const _layout = MindQueries.getLayoutByElement(value);
        return _layout === layout;
    },
    isIndentedLayout(value) {
        const _layout = MindQueries.getLayoutByElement(value);
        return isIndentedLayout(_layout);
    },
    isMindElement(board, element) {
        // Design error: The type of the element should be identified based on type.
        // Now it is very awkward whether it is dynamically calculated(query root node) or using other characteristic attributes(current).
        // Using dynamically calculated will cause more issue like pasting from clipboard, finding elements by id(isRecursion)
        if (element.data && element.data.topic && !isNullOrUndefined(element.width) && !isNullOrUndefined(element.height)) {
            return true;
        }
        else {
            return false;
        }
    },
    getParent(node) {
        if (PlaitMind.isMind(node)) {
            throw new Error('mind root node can not get parent');
        }
        const parent = NODE_TO_PARENT.get(node);
        return parent;
    },
    findParent(node) {
        if (PlaitMind.isMind(node)) {
            return undefined;
        }
        const parent = NODE_TO_PARENT.get(node);
        return parent;
    },
    getRoot(board, element) {
        const path = PlaitBoard.findPath(board, element);
        return PlaitNode.get(board, path.slice(0, 1));
    },
    getAncestors(board, element) {
        const path = PlaitBoard.findPath(board, element);
        const parents = [];
        for (const p of Path.ancestors(path, { reverse: true })) {
            const n = PlaitNode.get(board, p);
            if (n && !PlaitBoard.isBoard(n)) {
                parents.push(n);
            }
        }
        return parents;
    },
    getNode(element) {
        const node = ELEMENT_TO_NODE.get(element);
        if (!node) {
            throw new Error(`can not get node from ${JSON.stringify(element)}`);
        }
        return node;
    },
    findParentNode(element) {
        if (PlaitMind.isMind(element)) {
            return undefined;
        }
        const parent = MindElement.getParent(element);
        return MindElement.getNode(parent);
    },
    hasEmojis(element) {
        if (element.data.emojis) {
            return true;
        }
        else {
            return false;
        }
    },
    hasImage(element) {
        if (element.data.image) {
            return true;
        }
        else {
            return false;
        }
    },
    getEmojis(element) {
        return element.data.emojis;
    }
};
var MindElementShape;
(function (MindElementShape) {
    MindElementShape["roundRectangle"] = "round-rectangle";
    MindElementShape["underline"] = "underline";
})(MindElementShape || (MindElementShape = {}));
var BranchShape;
(function (BranchShape) {
    BranchShape["bight"] = "bight";
    BranchShape["polyline"] = "polyline";
})(BranchShape || (BranchShape = {}));

function drawAbstractLink(board, node, isHorizontal) {
    const linkPadding = 15;
    const branchWidth = getAbstractBranchWidth(board, node.origin);
    const branchColor = getAbstractBranchColor(board, node.origin);
    const strokeStyle = getStrokeStyleByElement(board, node.origin);
    const parent = node.parent;
    const branchShape = getBranchShapeByMindElement(board, node.origin);
    const abstractRectangle = getRectangleByNode(node);
    let includedElements = parent.children.slice(node.origin.start, node.origin.end + 1).map(node => {
        return node.origin;
    });
    const includedElementsRectangle = getRectangleByElements(board, includedElements, true);
    const linkDirection = getLayoutDirection(node, isHorizontal);
    const bezierBeginPlacement = [HorizontalPlacement.right, VerticalPlacement.top];
    const bezierEndPlacement = [HorizontalPlacement.right, VerticalPlacement.bottom];
    const abstractConnectorPlacement = [HorizontalPlacement.left, VerticalPlacement.middle];
    transformPlacement(bezierBeginPlacement, linkDirection);
    transformPlacement(bezierEndPlacement, linkDirection);
    transformPlacement(abstractConnectorPlacement, linkDirection);
    let bezierBeginPoint = getPointByPlacement(includedElementsRectangle, bezierBeginPlacement);
    let bezierEndPoint = getPointByPlacement(includedElementsRectangle, bezierEndPlacement);
    let abstractConnectorPoint = getPointByPlacement(abstractRectangle, abstractConnectorPlacement);
    let curveDistance = getXDistanceBetweenPoint(abstractConnectorPoint, bezierBeginPoint, isHorizontal) - linkPadding * 2;
    bezierBeginPoint = moveXOfPoint(bezierBeginPoint, linkPadding, linkDirection);
    let c1 = moveXOfPoint(bezierBeginPoint, curveDistance, linkDirection);
    bezierEndPoint = moveXOfPoint(bezierEndPoint, linkPadding, linkDirection);
    let c2 = moveXOfPoint(bezierEndPoint, curveDistance, linkDirection);
    let bezierConnectorPoint = moveXOfPoint(abstractConnectorPoint, -linkPadding, linkDirection);
    const strokeLineDash = getStrokeLineDash(strokeStyle, branchWidth);
    if (branchShape === BranchShape.polyline) {
        const g = createG();
        const polyline = drawLinearPath([bezierBeginPoint, c1, bezierConnectorPoint, c2, bezierEndPoint], {
            stroke: branchColor,
            strokeWidth: branchWidth
        });
        const straightLine = drawLinearPath([abstractConnectorPoint, bezierConnectorPoint], {
            stroke: branchColor,
            strokeWidth: branchWidth,
            strokeLineDash
        });
        g.appendChild(polyline);
        g.appendChild(straightLine);
        return g;
    }
    const link = PlaitBoard.getRoughSVG(board).path(`M${bezierBeginPoint[0]},${bezierBeginPoint[1]} Q${c1[0]},${c1[1]} ${bezierConnectorPoint[0]},${bezierConnectorPoint[1]} Q${c2[0]},${c2[1]} ${bezierEndPoint[0]},${bezierEndPoint[1]} M${abstractConnectorPoint[0]},${abstractConnectorPoint[1]} L${bezierConnectorPoint[0]},${bezierConnectorPoint[1]}`, {
        stroke: branchColor,
        strokeWidth: branchWidth,
        strokeLineDash
    });
    return link;
}

const setAbstractsByRefs = (board, abstractRefs) => {
    abstractRefs.forEach((newProperty, element) => {
        const start = element.start + newProperty.start;
        const end = element.end + newProperty.end;
        const path = PlaitBoard.findPath(board, element);
        if (start > end) {
            Transforms.removeNode(board, path);
        }
        else {
            Transforms.setNode(board, { start, end }, path);
        }
    });
};
const setAbstractByStandardLayout = (board, element) => {
    const rightNodeCount = element.rightNodeCount;
    const abstract = element.children.find((child) => {
        return AbstractNode.isAbstract(child) && child.end >= rightNodeCount && child.start < rightNodeCount;
    });
    if (abstract) {
        const path = PlaitBoard.findPath(board, abstract);
        Transforms.setNode(board, { end: rightNodeCount - 1 }, path);
    }
};
const insertAbstract = (board, elements) => {
    let elementGroup = getFirstLevelElement(elements);
    const { parentElements, abstractIncludedGroups } = divideElementByParent(elementGroup);
    abstractIncludedGroups.forEach((group, index) => {
        const groupParent = parentElements[index];
        setAbstractByElements(board, groupParent, group);
    });
};
const setAbstractByElements = (board, groupParent, group) => {
    const indexArray = group.map((child) => groupParent.children.indexOf(child)).sort((a, b) => a - b);
    const rightNodeCount = groupParent?.rightNodeCount;
    const start = indexArray[0], end = indexArray[indexArray.length - 1];
    if (isStandardLayout(MindQueries.getLayoutByElement(groupParent)) &&
        rightNodeCount &&
        start < rightNodeCount &&
        end >= rightNodeCount) {
        const childrenLength = groupParent.children.length;
        const path = [...PlaitBoard.findPath(board, groupParent), childrenLength];
        const leftChildren = indexArray.filter((index) => index >= rightNodeCount);
        const rightChildren = indexArray.filter((index) => index < rightNodeCount);
        insertAbstractNode(board, path, rightChildren[0], rightChildren[rightChildren.length - 1]);
        insertAbstractNode(board, Path.next(path), leftChildren[0], leftChildren[leftChildren.length - 1]);
    }
    else {
        const path = [...PlaitBoard.findPath(board, groupParent), groupParent.children.length];
        insertAbstractNode(board, path, start, end);
    }
};
const insertAbstractNode = (board, path, start, end) => {
    const abstractNodeText = getAbstractNodeText(board);
    const { width, height } = getTopicSize(board, false, false, buildText(abstractNodeText));
    const mindElement = createMindElement(abstractNodeText, width, height, {
        strokeWidth: DefaultAbstractNodeStyle.branch.width,
        branchWidth: DefaultAbstractNodeStyle.branch.width
    });
    mindElement.start = start;
    mindElement.end = end;
    Transforms.insertNode(board, mindElement, path);
    clearSelectedElement(board);
    addSelectedElement(board, mindElement);
};

const setTopic = (board, element, topic, width, height) => {
    const newElement = {
        data: { ...element.data, topic },
        ...normalizeWidthAndHeight(board, element, width, height)
    };
    const path = PlaitBoard.findPath(board, element);
    Transforms.setNode(board, newElement, path);
};
const setNodeManualWidth = (board, element, width, height) => {
    const path = PlaitBoard.findPath(board, element);
    const { width: normalizedWidth, height: normalizedHeight } = normalizeWidthAndHeight(board, element, width, height);
    const newElement = { manualWidth: normalizedWidth, height: normalizedHeight };
    Transforms.setNode(board, newElement, path);
};
const setTopicSize = (board, element, width, height) => {
    const newElement = {
        ...normalizeWidthAndHeight(board, element, width, height)
    };
    let isEqualWidth = Math.ceil(element.width) === Math.ceil(newElement.width);
    let isEqualHeight = Math.ceil(element.height) === Math.ceil(newElement.height);
    if (element.manualWidth) {
        isEqualWidth = true;
    }
    if (!isEqualWidth || !isEqualHeight) {
        const path = PlaitBoard.findPath(board, element);
        Transforms.setNode(board, newElement, path);
    }
};
const insertNodes = (board, elements, path) => {
    const pathRef = board.pathRef(path);
    elements.forEach((element) => {
        if (pathRef.current) {
            Transforms.insertNode(board, element, pathRef.current);
        }
    });
    pathRef.unref();
};
const insertAbstractNodes = (board, validAbstractRefs, elements, path) => {
    const parent = PlaitNode.get(board, Path$1.parent(path));
    const abstractPath = [...Path$1.parent(path), parent.children?.length];
    const abstracts = validAbstractRefs.map((refs) => {
        const { start, end } = getRelativeStartEndByAbstractRef(refs, elements);
        return {
            ...refs.abstract,
            start: start + path[path.length - 1],
            end: end + path[path.length - 1]
        };
    });
    insertNodes(board, abstracts, abstractPath);
};
const setRightNodeCountByRefs = (board, refs) => {
    refs.forEach((ref) => {
        Transforms.setNode(board, { rightNodeCount: ref.rightNodeCount }, ref.path);
    });
};
const insertChildNode = (board, element) => {
    if (MindElement.isMindElement(board, element)) {
        removeSelectedElement(board, element);
        const targetElementPath = PlaitBoard.findPath(board, element);
        if (element.isCollapsed) {
            const newElement = { isCollapsed: false };
            PlaitHistoryBoard.withoutSaving(board, () => {
                Transforms.setNode(board, newElement, targetElementPath);
            });
        }
        insertMindElement(board, element, findNewChildNodePath(board, element));
    }
};
const insertSiblingNode = (board, element) => {
    if (MindElement.isMindElement(board, element) && !PlaitMind.isMind(element) && !AbstractNode.isAbstract(element)) {
        const path = PlaitBoard.findPath(board, element);
        if (isInRightBranchOfStandardLayout(element)) {
            const refs = insertElementHandleRightNodeCount(board, path.slice(0, 1), 1);
            setRightNodeCountByRefs(board, refs);
        }
        const abstractRefs = insertElementHandleAbstract(board, Path$1.next(path));
        setAbstractsByRefs(board, abstractRefs);
        insertMindElement(board, element, findNewSiblingNodePath(board, element));
    }
};
const insertMind = (board, mind) => {
    Transforms.insertNode(board, mind, [board.children.length]);
    Transforms.addSelectionWithTemporaryElements(board, [mind]);
};

const addEmoji = (board, element, emojiItem) => {
    const emojis = element.data.emojis || [];
    const newEmojis = [...emojis];
    newEmojis.push(emojiItem);
    const newElement = {
        data: { ...element.data, emojis: newEmojis }
    };
    const path = PlaitBoard.findPath(board, element);
    Transforms.setNode(board, newElement, path);
};
const removeEmoji = (board, element, emojiItem) => {
    const emojis = element.data.emojis.filter(value => value !== emojiItem);
    const newElement = {
        data: { topic: element.data.topic }
    };
    if (MindElement.hasImage(element)) {
        newElement.data.image = element.data.image;
    }
    if (emojis.length > 0) {
        newElement.data.emojis = emojis;
    }
    const path = PlaitBoard.findPath(board, element);
    Transforms.setNode(board, newElement, path);
};
const replaceEmoji = (board, element, oldEmoji, newEmoji) => {
    const newElement = {
        data: { ...element.data }
    };
    const newEmojis = element.data.emojis.map(value => {
        if (value === oldEmoji) {
            return newEmoji;
        }
        return value;
    });
    newElement.data.emojis = newEmojis;
    const path = PlaitBoard.findPath(board, element);
    Transforms.setNode(board, newElement, path);
};

const removeImage = (board, element) => {
    removeImageFocus(board, element);
    const newElement = {
        data: { ...element.data }
    };
    delete newElement.data.image;
    const path = PlaitBoard.findPath(board, element);
    const newDynamicWidth = NodeSpace.getNodeNewDynamicWidth(board, element, 0);
    const newHeight = getNewNodeHeight(board, element, newDynamicWidth);
    if (newHeight) {
        newElement.height = newHeight;
    }
    Transforms.setNode(board, newElement, path);
};
const setImage = (board, element, imageItem) => {
    const newElement = {
        data: { ...element.data, image: imageItem }
    };
    const newDynamicWidth = NodeSpace.getNodeNewDynamicWidth(board, element, imageItem.width);
    const newHeight = getNewNodeHeight(board, element, newDynamicWidth);
    if (newHeight) {
        newElement.height = newHeight;
    }
    const path = PlaitBoard.findPath(board, element);
    Transforms.setNode(board, newElement, path);
};

const correctLogicLayoutNode = (board, layout, path) => {
    const node = PlaitNode.get(board, path);
    if (node && layout) {
        node.children?.forEach((value, index) => {
            if (value.layout) {
                if ((isHorizontalLogicLayout(layout) && isVerticalLogicLayout(value.layout)) ||
                    (isVerticalLogicLayout(layout) && isHorizontalLogicLayout(value.layout))) {
                    Transforms.setNode(board, { layout: null }, [...path, index]);
                }
                if (value.children?.length) {
                    correctLogicLayoutNode(board, layout, [...path, index]);
                }
            }
        });
    }
};

const setLayout = (board, type) => {
    const callback = (element, path) => {
        if (MindElement.isMindElement(board, element)) {
            correctLogicLayoutNode(board, type, path);
            const element = PlaitNode.get(board, path);
            if (PlaitMind.isMind(element) && isStandardLayout(type)) {
                let properties = { rightNodeCount: element.children.length / 2 };
                Transforms.setNode(board, properties, path);
                setAbstractByStandardLayout(board, element);
            }
            Transforms.setNode(board, { layout: type }, path);
        }
    };
    PropertyTransforms.setProperty(board, {}, { callback });
};
const setShape = (board, shape) => {
    PropertyTransforms.setProperty(board, { shape });
};
const setBranchShape = (board, branchShape) => {
    PropertyTransforms.setProperty(board, { branchShape });
};
const setBranchWidth = (board, branchWidth) => {
    PropertyTransforms.setProperty(board, { branchWidth });
};
const setBranchColor = (board, branchColor) => {
    PropertyTransforms.setProperty(board, { branchColor });
};

const MindTransforms = {
    setLayout,
    setShape,
    setBranchShape,
    setBranchWidth,
    setBranchColor,
    setTopic,
    setTopicSize,
    setNodeManualWidth,
    addEmoji,
    removeEmoji,
    replaceEmoji,
    insertAbstract,
    setAbstractsByRefs,
    setAbstractByStandardLayout,
    insertNodes,
    insertAbstractNodes,
    setRightNodeCountByRefs,
    removeImage,
    setImage,
    insertChildNode,
    insertSiblingNode,
    insertMind
};

class NodeShapeGenerator extends Generator {
    constructor(board) {
        super(board, { prepend: true });
    }
    canDraw(element, data) {
        const shape = getShapeByElement(this.board, element);
        if (shape === MindElementShape.roundRectangle) {
            return true;
        }
        return false;
    }
    draw(element, data) {
        const rectangle = getRectangleByNode(data.node);
        return drawRoundRectangleByElement(this.board, rectangle, data.node.origin);
    }
}

class NodeMoreGenerator extends Generator {
    static { this.key = 'mind-node-more'; }
    canDraw(element, extraData) {
        if (((extraData?.isHovered || extraData?.isHoveredCollapseArea || extraData?.isHoveredAddArea) && canHandleNodeMore(this.board)) ||
            (extraData?.isSelected && isLastSelectedMindElement(this.board, element) && canHandleNodeMore(this.board)) ||
            element.isCollapsed) {
            return true;
        }
        return false;
    }
    draw(element, extraData) {
        const moreGContainer = createG();
        const stroke = getBranchColorByMindElement(this.board, element);
        const layoutDirection = getNodeMoreLayoutDirection(this.board, element);
        const moreStartAndEnd = getMoreStartAndEnd(this.board, element, layoutDirection);
        const collapseOrExpandCenter = moveXOfPoint(moreStartAndEnd[1], NODE_MORE_ICON_DIAMETER / 2, layoutDirection);
        const hasChildren = element.children.length > 0;
        const isShowCollapseOrAdd = !element.isCollapsed &&
            (isSelectedElement(this.board, element) ||
                !!extraData?.isHovered ||
                !!extraData?.isHoveredCollapseArea ||
                !!extraData?.isHoveredAddArea);
        const isShowCollapse = isShowCollapseOrAdd && hasChildren && !PlaitMind.isMind(element);
        const isShowAdd = isShowCollapseOrAdd && !PlaitBoard.isReadonly(this.board);
        const addCenter = (isShowCollapseOrAdd && getAddCenterByCollapseOrExpandCenter(element, collapseOrExpandCenter, layoutDirection)) || null;
        this.toggleCollapseOrAdd(collapseOrExpandCenter, addCenter, stroke, moreGContainer, isShowCollapse, isShowAdd, !!extraData?.isHoveredAddArea, !!extraData?.isShowCollapseAnimation, !!extraData?.isShowAddAnimation);
        this.toggleExpandBadge(element, moreStartAndEnd, collapseOrExpandCenter, stroke, moreGContainer, !!element.isCollapsed, !!extraData?.isHoveredExpandArea);
        return moreGContainer;
    }
    toggleCollapseOrAdd(center, addCenter, stroke, parentG, isShowCollapse, isShowAdd, isHoveredAddArea, isShowCollapseAnimation, isShowAddAnimation) {
        this.collapseOrAddG?.remove();
        if (!isShowCollapse && !isShowAdd) {
            return;
        }
        this.collapseOrAddG = createG();
        if (isShowCollapse) {
            const collapseG = createG();
            this.collapseOrAddG.appendChild(collapseG);
            collapseG.classList.add('collapse-button');
            if (isShowCollapseAnimation) {
                collapseG.classList.add('animated');
            }
            const collapseCircle = PlaitBoard.getRoughSVG(this.board).circle(center[0], center[1], NODE_MORE_ICON_DIAMETER, {
                fill: '#fff',
                stroke,
                strokeWidth: NODE_MORE_STROKE_WIDTH,
                fillStyle: 'solid'
            });
            const start = moveXOfPoint(center, -NODE_MORE_BRIDGE_DISTANCE / 2);
            const end = moveXOfPoint(center, NODE_MORE_BRIDGE_DISTANCE / 2);
            const collapseLine = PlaitBoard.getRoughSVG(this.board).line(start[0], start[1], end[0], end[1], {
                fill: '#fff',
                stroke,
                strokeWidth: NODE_MORE_STROKE_WIDTH,
                fillStyle: 'solid'
            });
            collapseG.appendChild(collapseCircle);
            collapseG.appendChild(collapseLine);
            setStrokeLinecap(collapseLine, 'round');
        }
        if (isShowAdd && addCenter) {
            const addG = createG();
            this.collapseOrAddG.appendChild(addG);
            addG.classList.add('add-button');
            if (isShowAddAnimation) {
                addG.classList.add('animated');
            }
            const circle = PlaitBoard.getRoughSVG(this.board).circle(addCenter[0], addCenter[1], NODE_MORE_ICON_DIAMETER + NODE_MORE_STROKE_WIDTH, {
                fill: isHoveredAddArea ? NODE_ADD_HOVER_COLOR : NODE_ADD_CIRCLE_COLOR,
                stroke: TRANSPARENT,
                fillStyle: 'solid'
            });
            const hLineBeginPoint = [addCenter[0] - NODE_MORE_BRIDGE_DISTANCE / 2, addCenter[1]];
            const hLineEndPoint = [addCenter[0] + NODE_MORE_BRIDGE_DISTANCE / 2, addCenter[1]];
            const vLineBeginPoint = [addCenter[0], addCenter[1] - NODE_MORE_BRIDGE_DISTANCE / 2];
            const vLineEndPoint = [addCenter[0], addCenter[1] + NODE_MORE_BRIDGE_DISTANCE / 2];
            const innerCrossHLine = PlaitBoard.getRoughSVG(this.board).line(hLineBeginPoint[0], hLineBeginPoint[1], hLineEndPoint[0], hLineEndPoint[1], {
                stroke: NODE_ADD_INNER_CROSS_COLOR,
                strokeWidth: NODE_MORE_STROKE_WIDTH
            });
            setStrokeLinecap(innerCrossHLine, 'round');
            const innerCrossVLine = PlaitBoard.getRoughSVG(this.board).line(vLineBeginPoint[0], vLineBeginPoint[1], vLineEndPoint[0], vLineEndPoint[1], {
                stroke: NODE_ADD_INNER_CROSS_COLOR,
                strokeWidth: NODE_MORE_STROKE_WIDTH
            });
            setStrokeLinecap(innerCrossVLine, 'round');
            addG.appendChild(circle);
            addG.appendChild(innerCrossHLine);
            addG.appendChild(innerCrossVLine);
        }
        parentG.appendChild(this.collapseOrAddG);
    }
    toggleExpandBadge(element, moreStartAndEnd, center, stroke, parentG, isCollapsed, isHoveredExpandIcon) {
        this.expandG?.remove();
        if (!isCollapsed) {
            return;
        }
        this.expandG = createG();
        this.expandG.classList.add('expanded-button');
        const endWithWidth = moreStartAndEnd[1];
        const moreLine = PlaitBoard.getRoughSVG(this.board).line(moreStartAndEnd[0][0], moreStartAndEnd[0][1], endWithWidth[0], endWithWidth[1], {
            fill: stroke,
            stroke,
            fillStyle: 'solid',
            strokeWidth: NODE_MORE_STROKE_WIDTH
        });
        const backgroundColor = isHoveredExpandIcon ? rgbaToHEX(stroke, 0.4) : rgbaToHEX(stroke, 0.2);
        const badgeBackground = PlaitBoard.getRoughSVG(this.board).circle(center[0], center[1], NODE_MORE_ICON_DIAMETER + NODE_MORE_STROKE_WIDTH, {
            fill: backgroundColor,
            stroke: TRANSPARENT,
            fillStyle: 'solid'
        });
        const childrenCount = getChildrenCount(element);
        let text = `${childrenCount}`;
        let y = center[1] + 4.5;
        if (childrenCount >= 99) {
            text = '...';
            y = center[1] + 1;
        }
        const { width, height } = measureElement(this.board, buildText(text), {
            fontSize: Number(FontSizes.fontSize12),
            fontFamily: DEFAULT_FONT_FAMILY
        });
        const badgeText = createText(center[0] - width / 2, y, stroke, `${text}`);
        badgeText.setAttribute('style', `font-size: ${Number(FontSizes.fontSize12)}px;`);
        this.expandG.appendChild(moreLine);
        this.expandG.appendChild(badgeBackground);
        this.expandG.appendChild(badgeText);
        parentG.appendChild(this.expandG);
    }
}
const getCollapseAndAddCenterPoint = (board, element) => {
    const layoutDirection = getNodeMoreLayoutDirection(board, element);
    const [startPoint, endPoint] = getMoreStartAndEnd(board, element, layoutDirection);
    const collapseCenter = moveXOfPoint(endPoint, NODE_MORE_ICON_DIAMETER / 2, layoutDirection);
    const addCenter = getAddCenterByCollapseOrExpandCenter(element, collapseCenter, layoutDirection);
    return { collapseCenter, addCenter };
};
const getAddCenterByCollapseOrExpandCenter = (target, collapseOrExpandCenter, layoutDirection) => {
    let addCenter = collapseOrExpandCenter;
    if (target.children?.length > 0 && !PlaitMind.isMind(target)) {
        addCenter = moveXOfPoint(addCenter, NODE_MORE_LINE_DISTANCE + NODE_MORE_ICON_DIAMETER, layoutDirection);
    }
    return addCenter;
};
const getNodeMoreLayoutDirection = (board, element) => {
    const node = MindElement.getNode(element);
    const layout = MindQueries.getLayoutByElement(element);
    const isHorizontal = isHorizontalLayout(layout);
    let layoutDirection = getLayoutDirection(node, isHorizontal);
    if (isIndentedLayout(layout)) {
        layoutDirection = isTopLayout(layout) ? LayoutDirection.top : LayoutDirection.bottom;
    }
    return layoutDirection;
};
const getMoreStartAndEnd = (board, element, linkLineDirection) => {
    const node = MindElement.getNode(element);
    const isUnderlineShape = getShapeByElement(board, element) === MindElementShape.underline;
    const nodeClient = getRectangleByNode(node);
    let placement = [HorizontalPlacement.right, VerticalPlacement.middle];
    transformPlacement(placement, linkLineDirection);
    // underline shape and horizontal
    const layout = MindQueries.getLayoutByElement(element);
    const isHorizontal = isHorizontalLayout(layout);
    if (isHorizontal && isUnderlineShape && !element.isRoot) {
        placement[1] = VerticalPlacement.bottom;
    }
    let startPoint = getPointByPlacement(nodeClient, placement);
    const endPoint = moveXOfPoint(startPoint, NODE_MORE_LINE_DISTANCE, linkLineDirection);
    return [startPoint, endPoint];
};
const isLastSelectedMindElement = (board, element) => {
    const selectedElements = getSelectedElements(board);
    const selectedMindElements = selectedElements.filter((element) => MindElement.isMindElement(board, element)).reverse();
    return selectedMindElements[selectedMindElements.length - 1] === element;
};
const canHandleNodeMore = (board) => {
    return !isResizing(board) && !isSelectionMoving(board) && !isDragging(board) && !isMovingElements(board);
};

class MindNodeComponent extends CommonElementFlavour {
    get textManage() {
        return this.getRef().getTextManages()[0];
    }
    constructor() {
        super();
        this.shapeG = null;
        this.trackBy = (index, node) => {
            return node.origin.id;
        };
    }
    initializeGenerator() {
        this.nodeShapeGenerator = new NodeShapeGenerator(this.board);
        this.nodeEmojisGenerator = new NodeEmojisGenerator(this.board);
        this.activeGenerator = new NodeActiveGenerator(this.board);
        this.nodeMoreGenerator = new NodeMoreGenerator(this.board);
        this.imageGenerator = new ImageGenerator(this.board, {
            getRectangle: (element) => {
                return getImageForeignRectangle(this.board, element);
            },
            getImageItem: (element) => {
                return element.data.image;
            }
        });
        const plugins = (this.board.getPluginOptions(WithTextPluginKey) || {}).textPlugins;
        const textManage = new TextManage(this.board, {
            getRectangle: () => {
                const rect = getTopicRectangleByNode(this.board, this.node);
                return rect;
            },
            onChange: (data) => {
                const width = data.width;
                const height = data.height;
                if (data.newText) {
                    MindTransforms.setTopic(this.board, this.element, data.newText, width, height);
                }
                else {
                    MindTransforms.setTopicSize(this.board, this.element, width, height);
                }
            },
            getMaxWidth: () => {
                return NodeSpace.getTopicMaxDynamicWidth(this.board, this.element);
            },
            textPlugins: plugins || []
        });
        this.getRef().addGenerator(NodeActiveGenerator.key, this.activeGenerator);
        this.getRef().addGenerator(NodeEmojisGenerator.key, this.nodeEmojisGenerator);
        this.getRef().addGenerator(ImageGenerator.key, this.imageGenerator);
        this.getRef().addGenerator(NodeMoreGenerator.key, this.nodeMoreGenerator);
        this.getRef().initializeTextManage(textManage);
        this.getRef().updateActiveSection = () => {
            this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {
                selected: this.selected
            });
        };
    }
    initialize() {
        super.initialize();
        this.initializeGenerator();
        this.node = MindElement.getNode(this.element);
        this.index = NODE_TO_INDEX.get(this.element) || 0;
        this.roughSVG = PlaitBoard.getRoughSVG(this.board);
        this.nodeShapeGenerator.processDrawing(this.element, this.getElementG(), { node: this.node });
        this.drawLink();
        this.drawTopic();
        this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {
            selected: this.selected
        });
        this.nodeMoreGenerator.processDrawing(this.element, this.getElementG());
        this.drawEmojis();
        this.imageGenerator.processDrawing(this.element, this.getElementG());
        if (PlaitMind.isMind(this.context.parent)) {
            this.getElementG().classList.add('branch');
        }
    }
    onContextChanged(value, previous) {
        const newNode = MindElement.getNode(value.element);
        const isEqualNode = RectangleClient.isEqual(this.node, newNode);
        this.node = newNode;
        if (!isEqualNode || value.element !== previous.element || value.hasThemeChanged) {
            this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {
                selected: this.selected
            });
            this.nodeMoreGenerator.processDrawing(this.element, this.getElementG(), { isSelected: this.selected });
            this.nodeShapeGenerator.processDrawing(this.element, this.getElementG(), { node: this.node });
            this.drawLink();
            this.drawEmojis();
            if (!MindElement.hasImage(previous.element) && MindElement.hasImage(this.element)) {
                this.imageGenerator.processDrawing(this.element, this.getElementG());
            }
            if (MindElement.hasImage(previous.element) && MindElement.hasImage(this.element)) {
                this.imageGenerator.updateImage(this.getElementG(), previous.element, value.element);
            }
            if (MindElement.hasImage(previous.element) && !MindElement.hasImage(this.element)) {
                this.imageGenerator.destroy();
            }
            this.updateTopic();
        }
        else {
            const hasSameSelected = value.selected === previous.selected;
            const hasSameParent = value.parent === previous.parent;
            if (!hasSameSelected || value.selected) {
                this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {
                    selected: this.selected
                });
                this.nodeMoreGenerator.processDrawing(this.element, this.getElementG(), {
                    isSelected: this.selected
                });
            }
            if (!hasSameParent) {
                this.drawLink();
            }
        }
    }
    drawEmojis() {
        const g = this.nodeEmojisGenerator.drawEmojis(this.element);
        if (g) {
            this.getElementG().append(g);
        }
    }
    drawLink() {
        if (PlaitMind.isMind(this.element)) {
            return;
        }
        const parent = MindElement.getParent(this.element);
        const parentNode = MindElement.getNode(parent);
        if (this.linkLineG) {
            this.linkLineG.remove();
        }
        const layout = MindQueries.getLayoutByElement(parent);
        if (AbstractNode.isAbstract(this.node.origin)) {
            this.linkLineG = drawAbstractLink(this.board, this.node, isHorizontalLayout(layout));
        }
        else {
            this.linkLineG = drawLink(this.board, parentNode, this.node, isHorizontalLayout(layout));
        }
        this.getElementG().append(this.linkLineG);
    }
    drawTopic() {
        this.textManage.draw(this.element.data.topic);
        this.getElementG().append(this.textManage.g);
    }
    updateTopic() {
        this.textManage.updateText(this.element.data.topic);
        this.textManage.updateRectangle();
    }
    destroy() {
        super.destroy();
        this.nodeEmojisGenerator.destroy();
        this.imageGenerator.destroy();
        this.activeGenerator.destroy();
        if (ELEMENT_TO_NODE.get(this.element) === this.node) {
            ELEMENT_TO_NODE.delete(this.element);
        }
        this.getRef().destroyTextManage();
    }
}

class PlaitMindComponent extends MindNodeComponent {
    initialize() {
        this.updateMindLayout();
        super.initialize();
        this.getElementG().classList.add('root');
    }
    beforeContextChange(value) {
        if (value.element !== this.element && this.initialized) {
            this.updateMindLayout(value.element);
        }
    }
    updateMindLayout(element = this.element) {
        const mindLayoutType = element.layout || getDefaultLayout();
        this.root = GlobalLayout.layout(element, getLayoutOptions(this.board), mindLayoutType);
        this.updateMindNodeLocation(element);
    }
    updateMindNodeLocation(element) {
        const { x, y, hGap, vGap } = this.root;
        const offsetX = x + hGap;
        const offsetY = y + vGap;
        depthFirstRecursion(this.root, (node) => {
            node.x = node.x - offsetX + element.points[0][0];
            node.y = node.y - offsetY + element.points[0][1];
            ELEMENT_TO_NODE.set(node.origin, node);
        });
    }
}

const DRAG_MOVE_BUFFER = 5;
const withNodeDnd = (board) => {
    const { pointerDown, pointerMove, globalPointerUp } = board;
    let activeElements = [];
    let correspondingElements = [];
    let startPoint;
    let dragFakeNodeG;
    let fakeDropNodeG;
    let dropTarget = null;
    let targetPath;
    board.pointerDown = (event) => {
        if (PlaitBoard.isReadonly(board) ||
            PlaitBoard.hasBeenTextEditing(board) ||
            !PlaitBoard.isPointer(board, PlaitPointerType.selection) ||
            !isMainPointer(event)) {
            pointerDown(event);
            return;
        }
        const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
        const selectedElements = getSelectedElements(board);
        const hitElement = getHitElementByPoint(board, point);
        if (hitElement &&
            MindElement.isMindElement(board, hitElement) &&
            !PlaitMind.isMind(hitElement) &&
            !AbstractNode.isAbstract(hitElement)) {
            const targetElements = selectedElements.filter(element => MindElement.isMindElement(board, element) && !element.isRoot && !AbstractNode.isAbstract(element));
            const isMultipleSelection = selectedElements.length > 0 && selectedElements.includes(hitElement);
            if (isMultipleSelection) {
                activeElements = targetElements;
                startPoint = point;
            }
            else {
                activeElements = [hitElement];
                startPoint = point;
            }
        }
        if (activeElements.length) {
            correspondingElements = getOverallAbstracts(board, activeElements);
        }
        pointerDown(event);
    };
    board.pointerMove = (event) => {
        if (!board.options.readonly && activeElements.length && startPoint) {
            const endPoint = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
            const distance = distanceBetweenPointAndPoint(startPoint[0], startPoint[1], endPoint[0], endPoint[1]);
            if (distance < DRAG_MOVE_BUFFER) {
                return;
            }
            setMindDragging(board, true);
            fakeDropNodeG?.remove();
            const detectPoint = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
            dropTarget = detectDropTarget(board, detectPoint, dropTarget, [...activeElements, ...correspondingElements]);
            if (dropTarget?.target) {
                targetPath = getPathByDropTarget(board, dropTarget);
                fakeDropNodeG = drawFakeDropNode(board, dropTarget, targetPath);
                PlaitBoard.getHost(board).appendChild(fakeDropNodeG);
            }
            const offsetX = endPoint[0] - startPoint[0];
            const offsetY = endPoint[1] - startPoint[1];
            dragFakeNodeG?.remove();
            dragFakeNodeG = createG();
            [...activeElements, ...correspondingElements].forEach(element => {
                addActiveOnDragOrigin(element);
            });
            activeElements.forEach(element => {
                const nodeG = drawFakeDragNode(board, element, offsetX, offsetY);
                dragFakeNodeG?.appendChild(nodeG);
            });
            PlaitBoard.getHost(board).appendChild(dragFakeNodeG);
            return;
        }
        pointerMove(event);
    };
    board.globalPointerUp = (event) => {
        const firstLevelElements = getFirstLevelElement(activeElements);
        if (!board.options.readonly && firstLevelElements.length) {
            firstLevelElements.push(...correspondingElements);
            if (isDragging(board)) {
                firstLevelElements.forEach(element => {
                    removeActiveOnDragOrigin(element);
                });
            }
            if (dropTarget) {
                const targetPathRef = board.pathRef(targetPath);
                const targetPreviousPathRef = Path.hasPrevious(targetPath) && board.pathRef(Path.previous(targetPath));
                const targetElementPathRef = board.pathRef(PlaitBoard.findPath(board, dropTarget.target));
                let abstractRefs = getValidAbstractRefs(board, firstLevelElements);
                const normalElements = firstLevelElements
                    .filter(element => !abstractRefs.some(refs => refs.abstract === element))
                    .map(element => {
                    if (AbstractNode.isAbstract(element)) {
                        return adjustAbstractToNode(element);
                    }
                    return element;
                });
                const hasPreviousNode = targetPath[targetPath.length - 1] !== 0;
                if (hasPreviousNode) {
                    const previousElement = PlaitNode.get(board, Path.previous(targetPath));
                    const correspondingAbstract = getCorrespondingAbstract(previousElement);
                    const targetHasCorrespondAbstract = correspondingAbstract && correspondingAbstract.end !== targetPath[targetPath.length - 1] - 1;
                    if (targetHasCorrespondAbstract) {
                        const adjustedNode = abstractRefs.map(ref => {
                            return adjustAbstractToNode(ref.abstract);
                        });
                        normalElements.push(...adjustedNode);
                        abstractRefs = [];
                    }
                }
                const effectedAbstracts = deleteElementHandleAbstract(board, firstLevelElements);
                insertElementHandleAbstract(board, targetPath, normalElements.length, false, effectedAbstracts);
                MindTransforms.setAbstractsByRefs(board, effectedAbstracts);
                let refs = deleteElementsHandleRightNodeCount(board, firstLevelElements);
                const parent = PlaitNode.get(board, Path.parent(targetPath));
                const shouldChangeRoot = isDropStandardRight(parent, dropTarget);
                if (shouldChangeRoot && targetElementPathRef.current) {
                    refs = insertElementHandleRightNodeCount(board, targetElementPathRef.current.slice(0, 1), normalElements.length, refs);
                }
                MindTransforms.setRightNodeCountByRefs(board, refs);
                CoreTransforms.removeElements(board, firstLevelElements);
                let insertPath = targetPathRef.current;
                const parentPath = Path.parent(targetPathRef.current || targetPath);
                if (!insertPath) {
                    // When the insertion position and the selected node position are the same, the recorded previousPath is used
                    const previousPath = targetPreviousPathRef && targetPreviousPathRef.unref();
                    if (previousPath) {
                        insertPath = Path.next(previousPath);
                    }
                    else {
                        const parent = PlaitNode.get(board, parentPath);
                        const children = getNonAbstractChildren(parent);
                        insertPath = [...parentPath, children.length || 0];
                    }
                }
                MindTransforms.insertNodes(board, normalElements, insertPath);
                if (abstractRefs.length) {
                    MindTransforms.insertAbstractNodes(board, abstractRefs, normalElements, insertPath);
                }
                if (targetElementPathRef.current &&
                    targetPathRef.current &&
                    Path.isAncestor(targetElementPathRef.current, targetPathRef.current) &&
                    dropTarget.target.isCollapsed) {
                    Transforms.setNode(board, { isCollapsed: false }, targetElementPathRef.current);
                }
                targetElementPathRef.unref();
                targetPathRef.unref();
                let setActiveElements = [];
                depthFirstRecursion(board, node => {
                    const isSelected = activeElements.some(element => element.id === node.id);
                    if (isSelected) {
                        setActiveElements.push(node);
                    }
                });
                Transforms.addSelectionWithTemporaryElements(board, setActiveElements);
            }
            setMindDragging(board, false);
            activeElements = [];
            dragFakeNodeG?.remove();
            dragFakeNodeG = undefined;
            fakeDropNodeG?.remove();
            fakeDropNodeG = undefined;
            dropTarget = null;
        }
        globalPointerUp(event);
    };
    return board;
};

const withAbstract = (board) => {
    const newBoard = board;
    const { pointerDown, pointerMove, pointerUp } = board;
    let activeAbstractElement;
    let abstractHandlePosition;
    let touchedAbstract;
    let startPoint;
    let newProperty;
    board.pointerDown = (event) => {
        if (!isMainPointer(event) || PlaitBoard.isReadonly(board)) {
            pointerDown(event);
            return;
        }
        const activeAbstractElements = getSelectedElements(board).filter((element) => AbstractNode.isAbstract(element));
        const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
        activeAbstractElement = activeAbstractElements.find((element) => {
            abstractHandlePosition = getHitAbstractHandle(board, element, point);
            return abstractHandlePosition;
        });
        if (activeAbstractElement) {
            if (newBoard?.onAbstractResize) {
                newBoard.onAbstractResize(AbstractResizeState.start);
            }
            startPoint = point;
            return;
        }
        pointerDown(event);
    };
    board.pointerMove = (event) => {
        getSelectedElements(board);
        const endPoint = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
        touchedAbstract = handleTouchedAbstract(board, touchedAbstract, endPoint);
        if (abstractHandlePosition && activeAbstractElement) {
            const nodeLayout = MindQueries.getCorrectLayoutByElement(board, activeAbstractElement);
            const isHorizontal = isHorizontalLayout(nodeLayout);
            const parentElement = MindElement.getParent(activeAbstractElement);
            let children = parentElement.children;
            const parentLayout = MindQueries.getLayoutByElement(parentElement);
            if (isStandardLayout(parentLayout)) {
                const rightNodeCount = parentElement.rightNodeCount;
                const { leftChildren, rightChildren } = separateChildren(parentElement);
                if (activeAbstractElement.end < rightNodeCount) {
                    children = rightChildren;
                }
                if (activeAbstractElement.start >= rightNodeCount) {
                    children = leftChildren;
                }
            }
            if (newBoard?.onAbstractResize) {
                newBoard.onAbstractResize(AbstractResizeState.resizing);
            }
            const resizingLocation = isHorizontal ? endPoint[1] : endPoint[0];
            const parent = MindElement.getNode(parentElement);
            const scope = getLocationScope(board, abstractHandlePosition, children, activeAbstractElement, parent, isHorizontal);
            const location = Math.min(scope.max, Math.max(scope.min, resizingLocation));
            let locationIndex = findLocationLeftIndex(board, children, location, isHorizontal);
            const isPropertyUnchanged = (abstractHandlePosition === AbstractHandlePosition.start &&
                locationIndex + 1 === activeAbstractElement.start) ||
                (abstractHandlePosition === AbstractHandlePosition.end && locationIndex === activeAbstractElement.end);
            if (isPropertyUnchanged) {
                newProperty = undefined;
            }
            else {
                if (isStandardLayout(parent.layout)) {
                    const rightNodeCount = parent.origin.rightNodeCount;
                    let start = activeAbstractElement.start;
                    if (start >= rightNodeCount) {
                        locationIndex += rightNodeCount;
                    }
                }
                newProperty =
                    abstractHandlePosition === AbstractHandlePosition.start ? { start: locationIndex + 1 } : { end: locationIndex };
            }
            const ref = PlaitElement.getElementRef(activeAbstractElement);
            const activeGenerator = ref.getGenerator(NodeActiveGenerator.key);
            const activeLocation = toActivePointFromViewBoxPoint(board, [location, location]);
            activeGenerator.updateAbstractOutline(activeAbstractElement, abstractHandlePosition, isHorizontal ? activeLocation[1] : activeLocation[0]);
        }
        pointerMove(event);
    };
    board.pointerUp = (event) => {
        startPoint = undefined;
        abstractHandlePosition = undefined;
        if (activeAbstractElement) {
            if (newBoard?.onAbstractResize) {
                newBoard.onAbstractResize(AbstractResizeState.end);
            }
            if (newProperty) {
                const path = PlaitBoard.findPath(board, activeAbstractElement);
                Transforms.setNode(board, newProperty, path);
            }
            else {
                const ref = PlaitElement.getElementRef(activeAbstractElement);
                const activeGenerator = ref.getGenerator(NodeActiveGenerator.key);
                activeGenerator.updateAbstractOutline(activeAbstractElement);
            }
            activeAbstractElement = undefined;
            return;
        }
        pointerUp(event);
    };
    return board;
};

const withMindExtend = (board) => {
    const newBoard = board;
    board.setPluginOptions(WithMindPluginKey, { spaceBetweenEmojis: 4, emojiPadding: 0 });
    return newBoard;
};

const DefaultHotkey = 'm';
const withCreateMind = (board) => {
    const newBoard = board;
    const { keyDown, pointerDown, pointerMove, pointerUp } = board;
    let fakeCreateNodeRef = null;
    let emptyMind = null;
    newBoard.pointerDown = (event) => {
        const isMindPointer = PlaitBoard.isPointer(board, MindPointerType.mind);
        if (!PlaitBoard.isReadonly(board) && isDrawingMode(board) && isMindPointer) {
            const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
            const emptyMind = createEmptyMind(newBoard, point);
            MindTransforms.insertMind(board, emptyMind);
            BoardTransforms.updatePointerType(board, PlaitPointerType.selection);
            return;
        }
        pointerDown(event);
    };
    newBoard.pointerMove = (event) => {
        if (PlaitBoard.isReadonly(board)) {
            pointerMove(event);
            return;
        }
        const isMindPointer = PlaitBoard.isPointer(board, MindPointerType.mind);
        if (isDndMode(board) && isMindPointer) {
            throttleRAF(board, 'with-mind-create', () => {
                let movingPoint = PlaitBoard.getMovingPointInBoard(board);
                if (movingPoint) {
                    movingPoint = toViewBoxPoint(newBoard, toHostPoint(board, movingPoint[0], movingPoint[1]));
                    emptyMind = createEmptyMind(newBoard, movingPoint);
                    const nodeRectangle = getRectangleByElement(newBoard, emptyMind);
                    const nodeG = drawRoundRectangleByElement(board, nodeRectangle, emptyMind);
                    const topicRectangle = getTopicRectangleByElement(newBoard, nodeRectangle, emptyMind);
                    if (!fakeCreateNodeRef) {
                        const textManage = new TextManage(board, {
                            getRectangle: () => {
                                return topicRectangle;
                            }
                        });
                        textManage.draw(emptyMind.data.topic);
                        fakeCreateNodeRef = {
                            g: createG(),
                            nodeG,
                            textManage
                        };
                        fakeCreateNodeRef.g.classList.add('root');
                        fakeCreateNodeRef.g.setAttribute('plait-mind-temporary', 'true');
                        PlaitBoard.getHost(board).append(fakeCreateNodeRef.g);
                        fakeCreateNodeRef.g.append(...[fakeCreateNodeRef.nodeG, textManage.g]);
                    }
                    else {
                        fakeCreateNodeRef.textManage.updateRectangle(topicRectangle);
                        fakeCreateNodeRef.nodeG.remove();
                        fakeCreateNodeRef.nodeG = nodeG;
                        fakeCreateNodeRef.g.append(nodeG);
                        fakeCreateNodeRef.g.append(fakeCreateNodeRef.textManage.g);
                    }
                }
            });
        }
        else {
            destroy();
        }
        pointerMove(event);
    };
    newBoard.pointerUp = (event) => {
        if (emptyMind) {
            MindTransforms.insertMind(board, emptyMind);
            BoardTransforms.updatePointerType(board, PlaitPointerType.selection);
            emptyMind = null;
            destroy();
            return;
        }
        pointerUp(event);
    };
    board.keyDown = (event) => {
        if (PlaitBoard.isReadonly(board) || getSelectedElements(board).length > 0) {
            keyDown(event);
            return;
        }
        if (event.key === DefaultHotkey && !PlaitBoard.isPointer(board, MindPointerType.mind)) {
            BoardTransforms.updatePointerType(board, MindPointerType.mind);
            setCreationMode(board, BoardCreationMode.drawing);
            event.preventDefault();
            return;
        }
        keyDown(event);
    };
    function destroy() {
        if (fakeCreateNodeRef) {
            fakeCreateNodeRef.textManage.destroy();
            fakeCreateNodeRef.g.remove();
            fakeCreateNodeRef = null;
        }
    }
    return newBoard;
};

const withMindHotkey = (baseBoard) => {
    const board = baseBoard;
    const { keyDown, globalKeyDown } = board;
    board.keyDown = (event) => {
        const selectedElements = getSelectedElements(board);
        const isSingleSelection = selectedElements.length === 1;
        const isSingleMindElement = selectedElements.length === 1 && MindElement.isMindElement(board, selectedElements[0]);
        const targetElement = selectedElements[0];
        if (isExpandHotkey(event) && isSingleMindElement && !PlaitMind.isMind(targetElement)) {
            if (targetElement.children && targetElement.children.length > 0) {
                Transforms.setNode(board, { isCollapsed: targetElement.isCollapsed ? false : true }, PlaitBoard.findPath(board, targetElement));
                return;
            }
        }
        if (!PlaitBoard.isReadonly(board)) {
            if (isTabHotkey(event) && isSingleMindElement) {
                event.preventDefault();
                MindTransforms.insertChildNode(board, targetElement);
                return;
            }
            if (isEnterHotkey(event) &&
                isSingleMindElement &&
                !PlaitMind.isMind(targetElement) &&
                !AbstractNode.isAbstract(targetElement)) {
                MindTransforms.insertSiblingNode(board, targetElement);
                return;
            }
            if (!isVirtualKey(event) &&
                !isDelete(event) &&
                !isSpaceHotkey(event) &&
                isSingleSelection &&
                MindElement.isMindElement(board, targetElement)) {
                event.preventDefault();
                editTopic(targetElement);
                return;
            }
        }
        keyDown(event);
    };
    board.globalKeyDown = (event) => {
        if (PlaitBoard.isFocus(board) && PlaitBoard.hasBeenTextEditing(board)) {
            if (isHotkey('mod+z', event)) {
                const { history } = board;
                const { undos } = history;
                const previousOp = undos.length > 0 ? undos[undos.length - 1][0] : undefined;
                if (previousOp && previousOp.type === 'insert_node' && MindElement.isMindElement(board, previousOp.node) && getFirstTextManage(previousOp.node).isEditing) {
                    board.undo();
                }
            }
        }
        globalKeyDown(event);
    };
    return board;
};

const withNodeMore = (board) => {
    const { pointerMove, pointerLeave, pointerUp } = board;
    let nodeMoreRef = null;
    board.pointerMove = (event) => {
        if (canHandleNodeMore(board)) {
            throttleRAF(board, 'with-mind-node-hover-hit-test', () => {
                // target has been deleted
                if (nodeMoreRef && !PlaitElement.hasMounted(nodeMoreRef.target)) {
                    nodeMoreRef = null;
                }
                const newNodeMoreRef = getNodeMoreRef(board, event.x, event.y);
                if (nodeMoreRef && newNodeMoreRef && nodeMoreRef.target === newNodeMoreRef.target) {
                    return;
                }
                if (nodeMoreRef) {
                    toggleHoveredNodeCallback({
                        target: nodeMoreRef.target,
                        isHovered: false,
                        isHoveredCollapseArea: false,
                        isHoveredExpandArea: false,
                        isHoveredAddArea: false
                    });
                }
                if (newNodeMoreRef) {
                    toggleHoveredNodeCallback(newNodeMoreRef);
                    if (nodeMoreRef) {
                        nodeMoreRef.target = newNodeMoreRef.target;
                    }
                    else {
                        nodeMoreRef = newNodeMoreRef;
                    }
                }
                else {
                    nodeMoreRef = null;
                }
            });
        }
        pointerMove(event);
    };
    board.pointerUp = (event) => {
        if (nodeMoreRef && (nodeMoreRef.isHoveredCollapseArea || nodeMoreRef.isHoveredExpandArea)) {
            const isCollapsed = !nodeMoreRef.target.isCollapsed;
            const newElement = { isCollapsed };
            const path = PlaitBoard.findPath(board, nodeMoreRef.target);
            Transforms.setNode(board, newElement, path);
            setTimeout(() => {
                const newNodeMoreRef = getNodeMoreRef(board, event.x, event.y);
                if (newNodeMoreRef) {
                    toggleHoveredNodeCallback(newNodeMoreRef);
                    nodeMoreRef = newNodeMoreRef;
                }
                else {
                    nodeMoreRef = null;
                }
            }, 0);
            return;
        }
        if (nodeMoreRef && nodeMoreRef.isHoveredAddArea && !PlaitBoard.isReadonly(board)) {
            if (nodeMoreRef) {
                const path = findNewChildNodePath(board, nodeMoreRef.target);
                insertMindElement(board, nodeMoreRef.target, path);
            }
            return;
        }
        pointerUp(event);
    };
    const toggleHoveredNodeCallback = (ref) => {
        const elementRef = PlaitElement.getElementRef(ref.target);
        const nodeMoreGenerator = elementRef?.getGenerator(NodeMoreGenerator.key);
        if (nodeMoreGenerator) {
            const g = PlaitElement.getElementG(ref.target);
            nodeMoreGenerator.processDrawing(ref.target, g, {
                isHovered: ref.isHovered,
                isHoveredCollapseArea: ref.isHoveredCollapseArea,
                isHoveredExpandArea: ref.isHoveredExpandArea,
                isSelected: isSelectedElement(board, ref.target),
                isHoveredAddArea: ref.isHoveredAddArea,
                isShowCollapseAnimation: (ref.isHovered || ref.isHoveredCollapseArea) && !isSelectedElement(board, ref.target),
                isShowAddAnimation: (ref.isHovered || ref.isHoveredAddArea) && !isSelectedElement(board, ref.target)
            });
        }
    };
    board.pointerLeave = (event) => {
        if (nodeMoreRef) {
            toggleHoveredNodeCallback({
                target: nodeMoreRef.target,
                isHovered: false,
                isHoveredCollapseArea: false,
                isHoveredExpandArea: false,
                isHoveredAddArea: false
            });
        }
        nodeMoreRef = null;
        pointerLeave(event);
    };
    return board;
};
const getNodeMoreRef = (board, x, y) => {
    let target = null;
    let isHovered = false;
    let isHoveredCollapseArea = false;
    let isHoveredExpandArea = false;
    let isHoveredAddArea = false;
    const point = toViewBoxPoint(board, toHostPoint(board, x, y));
    depthFirstRecursion(board, (element) => {
        if (target) {
            return;
        }
        if (!MindElement.isMindElement(board, element)) {
            return;
        }
        const isMind = PlaitMind.isMind(element);
        const isHitElement = isHitMindElement(board, point, element);
        let isHitCollapseOrExpand = false;
        let isHitAdd = false;
        const { collapseCenter, addCenter } = getCollapseAndAddCenterPoint(board, element);
        const collapseOrExpandIconRectangle = !isMind && RectangleClient.getRectangleByCenterPoint(collapseCenter, NODE_MORE_ICON_DIAMETER, NODE_MORE_ICON_DIAMETER);
        isHitCollapseOrExpand =
            collapseOrExpandIconRectangle &&
                RectangleClient.isHit(RectangleClient.getRectangleByPoints([point, point]), collapseOrExpandIconRectangle);
        const addIconRectangle = RectangleClient.getRectangleByCenterPoint(addCenter, NODE_MORE_ICON_DIAMETER, NODE_MORE_ICON_DIAMETER);
        isHitAdd = RectangleClient.isHit(RectangleClient.getRectangleByPoints([point, point]), addIconRectangle);
        if (isHitElement || isHitCollapseOrExpand || isHitAdd) {
            isHovered = isHitElement;
            if (element.children.length > 0) {
                if (element.isCollapsed) {
                    isHoveredExpandArea = isHitCollapseOrExpand;
                }
                else {
                    isHoveredCollapseArea = isHitCollapseOrExpand;
                }
            }
            isHoveredAddArea = isHitAdd;
            target = element;
        }
    }, getIsRecursionFunc(board), true);
    if (!target) {
        return null;
    }
    return {
        target,
        isHovered,
        isHoveredCollapseArea,
        isHoveredExpandArea,
        isHoveredAddArea
    };
};

const withNodeImage = (board) => {
    const { keyDown, pointerUp, globalPointerUp, buildFragment, insertFragment, deleteFragment, afterChange } = board;
    board.pointerUp = (event) => {
        const elementOfFocusedImage = getElementOfFocusedImage(board);
        if (elementOfFocusedImage &&
            MindElement.isMindElement(board, elementOfFocusedImage) &&
            !isContextmenu(event) &&
            (PlaitBoard.isReadonly(board) || !isMainPointer(event) || !PlaitBoard.isPointer(board, PlaitPointerType.selection))) {
            removeImageFocus(board, elementOfFocusedImage);
            pointerUp(event);
            return;
        }
        if (PlaitBoard.isReadonly(board)) {
            pointerUp(event);
            return;
        }
        const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
        const hitElement = getHitElementByPoint(board, point);
        const isHitImageResult = hitElement &&
            MindElement.isMindElement(board, hitElement) &&
            MindElement.hasImage(hitElement) &&
            isHitImage(board, hitElement, point);
        if (isHitImageResult && elementOfFocusedImage && hitElement === elementOfFocusedImage) {
            temporaryDisableSelection(board);
            pointerUp(event);
            return;
        }
        if (elementOfFocusedImage && MindElement.isMindElement(board, elementOfFocusedImage)) {
            removeImageFocus(board, elementOfFocusedImage);
        }
        if (isHitImageResult && hitElement) {
            temporaryDisableSelection(board);
            addImageFocus(board, hitElement);
        }
        pointerUp(event);
    };
    board.keyDown = (event) => {
        const selectedImageElement = getElementOfFocusedImage(board);
        if (!PlaitBoard.isReadonly(board) && selectedImageElement && (hotkeys.isDeleteBackward(event) || hotkeys.isDeleteForward(event))) {
            addSelectedElement(board, selectedImageElement);
            MindTransforms.removeImage(board, selectedImageElement);
            return;
        }
        keyDown(event);
    };
    board.globalPointerUp = (event) => {
        if (PlaitBoard.isFocus(board)) {
            const isInBoard = event.target instanceof Node && PlaitBoard.getBoardContainer(board).contains(event.target);
            const selectedImageElement = getElementOfFocusedImage(board);
            // Clear image selection when mouse board outside area
            if (selectedImageElement && MindElement.isMindElement(board, selectedImageElement) && !isInBoard) {
                removeImageFocus(board, selectedImageElement);
            }
        }
        globalPointerUp(event);
    };
    board.buildFragment = (clipboardContext, rectangle, operationType, originData) => {
        const selectedImageElement = getElementOfFocusedImage(board);
        if (selectedImageElement) {
            clipboardContext = createClipboardContext(WritableClipboardType.medias, [selectedImageElement.data.image], '');
        }
        return buildFragment(clipboardContext, rectangle, operationType, originData);
    };
    board.deleteFragment = (elements) => {
        const selectedImageElement = getElementOfFocusedImage(board);
        if (selectedImageElement) {
            MindTransforms.removeImage(board, selectedImageElement);
        }
        deleteFragment(elements);
    };
    board.insertFragment = (clipboardData, targetPoint, operationType) => {
        const selectedElements = getSelectedElements(board);
        const isSelectedImage = !!getElementOfFocusedImage(board);
        const isSingleSelection = selectedElements.length === 1 && MindElement.isMindElement(board, selectedElements[0]);
        if (isSelectedImage || isSingleSelection) {
            if (clipboardData?.files?.length) {
                const acceptImageArray = acceptImageTypes.map((type) => 'image/' + type);
                const selectedElement = (selectedElements[0] || getElementOfFocusedImage(board));
                if (acceptImageArray.includes(clipboardData.files[0].type)) {
                    const imageFile = clipboardData.files[0];
                    buildImage(board, imageFile, DEFAULT_MIND_IMAGE_WIDTH, (imageItem) => {
                        MindTransforms.setImage(board, selectedElement, imageItem);
                    });
                    return;
                }
            }
            if (clipboardData?.medias?.length) {
                const selectedElement = (selectedElements[0] || getElementOfFocusedImage(board));
                MindTransforms.setImage(board, selectedElement, clipboardData.medias[0]);
                return;
            }
        }
        insertFragment(clipboardData, targetPoint, operationType);
    };
    board.afterChange = () => {
        afterChange();
        const selectedImageElement = getElementOfFocusedImage(board);
        if (selectedImageElement && MindElement.isMindElement(board, selectedImageElement)) {
            const commonElementRef = PlaitElement.getElementRef(selectedImageElement);
            const imageGenerator = commonElementRef.getGenerator(ImageGenerator.key);
            imageGenerator.setFocus(selectedImageElement, true);
        }
    };
    return board;
};

const withNodeResize = (board) => {
    let targetElementRef = null;
    const options = {
        key: 'mind-node',
        canResize: () => {
            return true;
        },
        hitTest: (point) => {
            const newTargetElement = getSelectedTarget(board, point);
            if (newTargetElement) {
                return {
                    element: newTargetElement,
                    handle: null,
                    cursorClass: ResizeCursorClass.ew
                };
            }
            return null;
        },
        beforeResize: (resizeRef) => {
            targetElementRef = {
                minWidth: NodeSpace.getNodeResizableMinWidth(board, resizeRef.element),
                currentWidth: NodeSpace.getTopicDynamicWidth(board, resizeRef.element),
                path: PlaitBoard.findPath(board, resizeRef.element),
                textManage: getFirstTextManage(resizeRef.element)
            };
        },
        onResize: (resizeRef, resizeState) => {
            let resizedWidth = targetElementRef.currentWidth + Point.getOffsetX(resizeState.startPoint, resizeState.endPoint);
            if (resizedWidth <= targetElementRef.minWidth) {
                resizedWidth = targetElementRef.minWidth;
            }
            const newTarget = PlaitNode.get(board, targetElementRef.path);
            if (newTarget && NodeSpace.getNodeTopicMinWidth(board, newTarget) !== resizedWidth) {
                targetElementRef.textManage.updateRectangleWidth(resizedWidth);
                const { height } = targetElementRef.textManage.getSize(undefined, resizedWidth);
                MindTransforms.setNodeManualWidth(board, newTarget, resizedWidth, height);
            }
        },
        afterResize: (resizeRef) => {
            targetElementRef = null;
        }
    };
    withResize(board, options);
    return board;
};
const getSelectedTarget = (board, point) => {
    const selectedElements = getSelectedElements(board).filter((value) => MindElement.isMindElement(board, value));
    if (selectedElements.length > 0) {
        const target = selectedElements.find((value) => {
            const rectangle = getResizeActiveRectangle(board, value);
            return distanceBetweenPointAndRectangle(point[0], point[1], rectangle) <= 0;
        });
        return target ? target : null;
    }
    return null;
};
const getResizeActiveRectangle = (board, element) => {
    const node = MindElement.getNode(element);
    const rectangle = getRectangleByNode(node);
    return {
        x: rectangle.x + rectangle.width - RESIZE_HANDLE_BUFFER_DISTANCE,
        y: rectangle.y,
        width: RESIZE_HANDLE_BUFFER_DISTANCE * 2,
        height: rectangle.height
    };
};

const withNodeImageResize = (board) => {
    const options = {
        key: 'mind-node-image',
        canResize: () => {
            return true;
        },
        hitTest: (point) => {
            const elementOfFocusedImage = getElementOfFocusedImage(board);
            const selectedMindElement = elementOfFocusedImage && MindElement.isMindElement(board, elementOfFocusedImage) ? elementOfFocusedImage : undefined;
            if (selectedMindElement) {
                const result = getHitImageResizeHandleDirection(board, selectedMindElement, point);
                if (result) {
                    return {
                        element: selectedMindElement,
                        handle: result.handle,
                        cursorClass: result.cursorClass
                    };
                }
            }
            return null;
        },
        onResize: (resizeRef, resizeState) => {
            const offsetX = Point.getOffsetX(resizeState.startPoint, resizeState.endPoint);
            const originWidth = resizeRef.element.data.image.width;
            const originHeight = resizeRef.element.data.image.height;
            const path = resizeRef.path;
            let width = originWidth + offsetX;
            if (width <= 100) {
                width = 100;
            }
            const ratio = originWidth / originHeight;
            const height = width / ratio;
            const imageItem = { ...resizeRef.element.data.image, width, height };
            MindTransforms.setImage(board, PlaitNode.get(board, path), imageItem);
            addElementOfFocusedImage(board, PlaitNode.get(board, path));
        }
    };
    withResize(board, options);
    return board;
};

const buildClipboardData = (board, selectedElements, startPoint) => {
    let result = [];
    // get overall abstract
    const overallAbstracts = getOverallAbstracts(board, selectedElements);
    // get valid abstract refs
    const validAbstractRefs = getValidAbstractRefs(board, [...selectedElements, ...overallAbstracts]);
    // keep correct order
    const newSelectedElements = selectedElements.filter((value) => !validAbstractRefs.find((ref) => ref.abstract === value));
    newSelectedElements.push(...validAbstractRefs.map((value) => value.abstract));
    const selectedMindNodes = newSelectedElements.map((value) => MindElement.getNode(value));
    newSelectedElements.forEach((element, index) => {
        // handle relative location
        const nodeRectangle = getRectangleByNode(selectedMindNodes[index]);
        const points = [[nodeRectangle.x - startPoint[0], nodeRectangle.y - startPoint[1]]];
        // handle invalid abstract
        const abstractRef = validAbstractRefs.find((ref) => ref.abstract === element);
        if (AbstractNode.isAbstract(element) && abstractRef) {
            const { start, end } = getRelativeStartEndByAbstractRef(abstractRef, newSelectedElements);
            result.push({
                ...element,
                points,
                start,
                end
            });
        }
        else {
            if (AbstractNode.isAbstract(element)) {
                let newElement = { ...element, points };
                delete newElement.start;
                delete newElement.end;
                result.push(newElement);
            }
            else {
                result.push({
                    ...element,
                    points: points
                });
            }
        }
    });
    return result;
};
const insertClipboardData = (board, elements, targetPoint, operationType) => {
    let newElement, path;
    const selectedElements = getSelectedElements(board);
    let newELements = [];
    const hasTargetParent = selectedElements.length === 1;
    const targetParent = selectedElements[0];
    const targetParentPath = targetParent && PlaitBoard.findPath(board, targetParent);
    const nonAbstractChildrenLength = targetParent && getNonAbstractChildren(targetParent).length;
    elements.forEach((item, index) => {
        newElement = copyNewNode(item);
        if (hasTargetParent && operationType !== WritableClipboardOperationType.duplicate) {
            if (item.isRoot) {
                newElement = adjustRootToNode(board, newElement);
                const { width, height } = getTopicSizeByElement(board, newElement, targetParent);
                newElement.width = width;
                newElement.height = height;
            }
            // handle abstract start and end
            if (AbstractNode.isAbstract(newElement)) {
                newElement.start = newElement.start + nonAbstractChildrenLength;
                newElement.end = newElement.end + nonAbstractChildrenLength;
            }
            path = [...targetParentPath, nonAbstractChildrenLength + index];
        }
        else {
            const point = [targetPoint[0] + item.points[0][0], targetPoint[1] + item.points[0][1]];
            newElement.points = [point];
            if (AbstractNode.isAbstract(item)) {
                newElement = adjustAbstractToNode(newElement);
            }
            if (!item.isRoot) {
                newElement = adjustNodeToRoot(board, newElement);
                const { width, height } = getTopicSizeByElement(board, newElement);
                newElement.width = width;
                newElement.height = height;
            }
            path = [board.children.length];
        }
        newELements.push(newElement);
        Transforms.insertNode(board, newElement, path);
        return;
    });
    Transforms.addSelectionWithTemporaryElements(board, newELements);
};
const insertClipboardText = (board, targetParent, text) => {
    const { width, height } = getTopicSize(board, false, PlaitMind.isMind(targetParent), buildText(text));
    const newElement = createMindElement(text, Math.max(width, getFontSizeBySlateElement(text)), height, {});
    Transforms.insertNode(board, newElement, findNewChildNodePath(board, targetParent));
    Transforms.addSelectionWithTemporaryElements(board, [newElement]);
};
const getTopicSizeByElement = (board, element, parentElement) => {
    return getTopicSize(board, PlaitMind.isMind(element), (parentElement && PlaitMind.isMind(parentElement)) || false, element.data.topic, element.manualWidth);
};

const withMindFragment = (baseBoard) => {
    const board = baseBoard;
    let firstLevelElements;
    const { getDeletedFragment, insertFragment, buildFragment, deleteFragment } = board;
    board.getDeletedFragment = (data) => {
        const targetMindElements = getSelectedMindElements(board);
        if (targetMindElements.length) {
            firstLevelElements = getFirstLevelElement(targetMindElements).reverse();
            const abstractRefs = deleteElementHandleAbstract(board, firstLevelElements);
            MindTransforms.setAbstractsByRefs(board, abstractRefs);
            const refs = deleteElementsHandleRightNodeCount(board, targetMindElements);
            MindTransforms.setRightNodeCountByRefs(board, refs);
            const deletableElements = getFirstLevelElement(targetMindElements);
            data.push(...deletableElements);
        }
        return getDeletedFragment(data);
    };
    board.deleteFragment = (elements) => {
        deleteFragment(elements);
        if (firstLevelElements) {
            const nextSelected = getNextSelectedElement(board, firstLevelElements);
            if (nextSelected) {
                addSelectedElement(board, nextSelected);
            }
            firstLevelElements = null;
        }
    };
    board.buildFragment = (clipboardContext, rectangle, operationType, originData) => {
        const targetMindElements = getSelectedMindElements(board, originData);
        const firstLevelElements = getFirstLevelElement(targetMindElements);
        if (firstLevelElements.length) {
            const elements = buildClipboardData(board, firstLevelElements, rectangle ? [rectangle.x, rectangle.y] : [0, 0]);
            const text = getElementsText(targetMindElements);
            const addition = {
                text,
                type: WritableClipboardType.elements,
                elements: elements
            };
            clipboardContext = addOrCreateClipboardContext(clipboardContext, addition);
        }
        return buildFragment(clipboardContext, rectangle, operationType, originData);
    };
    board.insertFragment = (clipboardData, targetPoint, operationType) => {
        if (clipboardData?.elements?.length) {
            const mindElements = clipboardData.elements?.filter(value => MindElement.isMindElement(board, value));
            if (mindElements && mindElements.length > 0) {
                insertClipboardData(board, mindElements, targetPoint, operationType);
            }
        }
        if (clipboardData?.text) {
            const mindElements = getSelectedMindElements(board);
            if (mindElements.length === 1) {
                insertClipboardText(board, mindElements[0], buildText(clipboardData.text));
                return;
            }
        }
        insertFragment(clipboardData, targetPoint, operationType);
    };
    return board;
};
const getNextSelectedElement = (board, firstLevelElements) => {
    let activeElement;
    const firstLevelElement = firstLevelElements[0];
    const firstLevelElementPath = PlaitBoard.findPath(board, firstLevelElement);
    let nextSelectedPath = firstLevelElementPath;
    if (Path.hasPrevious(firstLevelElementPath)) {
        nextSelectedPath = Path.previous(firstLevelElementPath);
    }
    if (AbstractNode.isAbstract(firstLevelElement)) {
        const parent = MindElement.getParent(firstLevelElement);
        if (!firstLevelElements.includes(parent.children[firstLevelElement.start])) {
            activeElement = parent.children[firstLevelElement.start];
        }
    }
    try {
        if (!activeElement) {
            activeElement = PlaitNode.get(board, nextSelectedPath);
        }
    }
    catch (error) { }
    const firstElement = firstLevelElements[0];
    const firstElementParent = MindElement.findParent(firstElement);
    const hasSameParent = firstLevelElements.every(element => {
        return MindElement.findParent(element) === firstElementParent;
    });
    if (firstElementParent && hasSameParent && !activeElement) {
        activeElement = firstElementParent;
    }
    return activeElement;
};

const withEmoji = (board) => {
    const newBoard = board;
    newBoard.renderEmoji = (container, props) => {
        throw new Error('No implementation for renderEmoji method.');
    };
    return newBoard;
};

const isNormalizedData = (element) => {
    if (!element.data || !element.data.topic) {
        return false;
    }
    return true;
};
const isNormalizedWidthAndHeight = (element) => {
    if (isNullOrUndefined(element.width) || isNullOrUndefined(element.height)) {
        return false;
    }
    return true;
};
const fixMindElementData = (element) => {
    const emptyTopic = {
        children: [
            {
                text: ''
            }
        ]
    };
    if (!element.data) {
        const data = {
            topic: emptyTopic
        };
        element.data = data;
    }
    else if (!element.data.topic) {
        element.data.topic = emptyTopic;
    }
};
const fixMindElementWidthAndHeight = (element) => {
    if (isNullOrUndefined(element.width)) {
        element.width = 56;
    }
    if (isNullOrUndefined(element.height)) {
        element.width = 20;
    }
};

const withMind = (baseBoard) => {
    const board = baseBoard;
    const { drawElement, dblClick, isRectangleHit, isHit, getRectangle, isMovable, isRecursion, isAlign, isImageBindingAllowed, canAddToGroup, canSetZIndex, isExpanded, getOneHitElement, normalizeElement } = board;
    board.normalizeElement = (context) => {
        if (PlaitMind.isMind(context.element)) {
            depthFirstRecursion(context.element, (node) => {
                if (!isNormalizedData(node)) {
                    fixMindElementData(node);
                }
                if (!isNormalizedWidthAndHeight(node)) {
                    fixMindElementWidthAndHeight(node);
                }
            });
        }
        normalizeElement(context);
    };
    board.drawElement = (context) => {
        if (PlaitMind.isMind(context.element)) {
            return PlaitMindComponent;
        }
        else if (MindElement.isMindElement(board, context.element)) {
            return MindNodeComponent;
        }
        return drawElement(context);
    };
    board.applyTheme = (element) => {
        const mindElement = element;
        const shouldClearProperty = !PlaitBoard.isBoard(element) && (mindElement?.branchColor || mindElement?.fill || mindElement?.strokeColor);
        if (PlaitMind.isMind(element) && shouldClearProperty) {
            const path = PlaitBoard.findPath(board, element);
            Transforms.setNode(board, { fill: null, strokeColor: null, branchColor: null }, path);
        }
    };
    board.getRectangle = (element) => {
        if (MindElement.isMindElement(board, element)) {
            if (!PlaitElement.hasMounted(element)) {
                console.error('mind element has not been mounted');
            }
            return getRectangleByNode(MindElement.getNode(element));
        }
        return getRectangle(element);
    };
    board.canAddToGroup = (element) => {
        if (MindElement.isMindElement(board, element) && !element.isRoot) {
            return false;
        }
        return canAddToGroup(element);
    };
    board.canSetZIndex = (element) => {
        if (MindElement.isMindElement(board, element) && !element.isRoot) {
            return false;
        }
        return canSetZIndex(element);
    };
    board.isRecursion = (element) => {
        if (MindElement.isMindElement(board, element) && element.isCollapsed) {
            return false;
        }
        return isRecursion(element);
    };
    board.isRectangleHit = (element, selection) => {
        if (MindElement.isMindElement(board, element)) {
            const client = getRectangleByNode(MindElement.getNode(element));
            const isHit = RectangleClient.isHit(RectangleClient.getRectangleByPoints([selection.anchor, selection.focus]), client);
            return isHit;
        }
        return isRectangleHit(element, selection);
    };
    board.isHit = (element, point, isStrict) => {
        if (MindElement.isMindElement(board, element)) {
            const client = getRectangleByNode(MindElement.getNode(element));
            const isHit = RectangleClient.isHit(RectangleClient.getRectangleByPoints([point, point]), client);
            return isHit;
        }
        return isHit(element, point, isStrict);
    };
    board.getOneHitElement = (elements) => {
        const isAllMindElements = elements.every((item) => MindElement.isMindElement(board, item));
        if (isAllMindElements) {
            return elements[0];
        }
        return getOneHitElement(elements);
    };
    board.isMovable = (element) => {
        if (PlaitMind.isMind(element) && element.isRoot) {
            return true;
        }
        return isMovable(element);
    };
    board.isImageBindingAllowed = (element) => {
        if (MindElement.isMindElement(board, element)) {
            return true;
        }
        return isImageBindingAllowed(element);
    };
    board.isAlign = (element) => {
        if (PlaitMind.isMind(element) && element.isRoot) {
            return true;
        }
        return isAlign(element);
    };
    board.isExpanded = (element) => {
        if (MindElement.isMindElement(board, element) && !PlaitMind.isMind(element)) {
            return !element.isCollapsed;
        }
        return isExpanded(element);
    };
    board.dblClick = (event) => {
        if (PlaitBoard.isReadonly(board)) {
            dblClick(event);
            return;
        }
        const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
        board.children
            .filter((value) => PlaitMind.isMind(value))
            .forEach((mindMap) => {
            depthFirstRecursion(mindMap, (node) => {
                if (!PlaitBoard.hasBeenTextEditing(board) && isHitMindElement(board, point, node)) {
                    editTopic(node);
                }
            }, getIsRecursionFunc(board));
        });
        if (PlaitBoard.hasBeenTextEditing(board)) {
            return;
        }
        dblClick(event);
    };
    return withEmoji(withNodeResize(withNodeImageResize(withNodeImage(withNodeMore(withMindFragment(withMindHotkey(withMindExtend(withCreateMind(withAbstract(withNodeDnd(board)))))))))));
};

class MindEmojiBaseComponent {
    constructor() {
        this.fontSize = 14;
    }
}

/*
 * Public API Surface of mind
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ABSTRACT_HANDLE_COLOR, ABSTRACT_HANDLE_LENGTH, ABSTRACT_HANDLE_MASK_WIDTH, ABSTRACT_INCLUDED_OUTLINE_OFFSET, ABSTRACT_NODE_TEXT, AbstractHandlePosition, AbstractResizeState, BASE, BranchShape, DEFAULT_MIND_IMAGE_WIDTH, DefaultAbstractNodeStyle, DefaultNodeStyle, ELEMENT_TO_NODE, GRAY_COLOR, INHERIT_ATTRIBUTE_KEYS, LayoutDirection, LayoutDirectionsMap, MIND_CENTRAL_TEXT, MindColorfulThemeColor, MindDarkThemeColor, MindDefaultThemeColor, MindElement, MindElementShape, MindEmojiBaseComponent, MindI18nKey, MindNode, MindNodeComponent, MindPointerType, MindQueries, MindRetroThemeColor, MindSoftThemeColor, MindStarryThemeColor, MindThemeColor, MindThemeColors, MindTransforms, NODE_ADD_CIRCLE_COLOR, NODE_ADD_HOVER_COLOR, NODE_ADD_INNER_CROSS_COLOR, NODE_MORE_BRIDGE_DISTANCE, NODE_MORE_ICON_DIAMETER, NODE_MORE_LINE_DISTANCE, NODE_MORE_STROKE_WIDTH, NodeSpace, NodeTopicThreshold, PRIMARY_COLOR, PlaitMind, PlaitMindComponent, RESIZE_HANDLE_BUFFER_DISTANCE, ROOT_TOPIC_FONT_SIZE, STROKE_WIDTH, TOPIC_DEFAULT_MAX_WORD_COUNT, TOPIC_FONT_SIZE, WithMindPluginKey, addActiveOnDragOrigin, addImageFocus, adjustAbstractToNode, adjustNodeToRoot, adjustRootToNode, canSetAbstract, copyNewNode, correctLayoutByDirection, createEmptyMind, createMindElement, deleteElementHandleAbstract, deleteElementsHandleRightNodeCount, detectDropTarget, directionCorrector, directionDetector, divideElementByParent, drawFakeDragNode, drawFakeDropNode, editTopic, findLastChild, findLocationLeftIndex, findNewChildNodePath, findNewSiblingNodePath, getAbstractBranchColor, getAbstractBranchWidth, getAbstractHandleRectangle, getAbstractNodeText, getAllowedDirection, getAvailableSubLayoutsByLayoutDirections, getBehindAbstracts, getBranchColorByMindElement, getBranchDirectionsByLayouts, getBranchShapeByMindElement, getBranchWidthByMindElement, getChildrenCount, getCorrespondingAbstract, getDefaultBranchColor, getDefaultBranchColorByIndex, getDefaultLayout, getDefaultMindElementFontSize, getDefaultMindNameText, getEmojiFontSize, getEmojiForeignRectangle, getEmojiRectangle, getEmojisWidthHeight, getFillByElement, getFirstLevelElement, getFontSizeBySlateElement, getHitAbstractHandle, getHitImageResizeHandleDirection, getImageForeignRectangle, getInCorrectLayoutDirection, getLayoutDirection$1 as getLayoutDirection, getLayoutOptions, getLayoutReverseDirection, getLocationScope, getMindThemeColor, getNewNodeHeight, getNextBranchColor, getOverallAbstracts, getPathByDropTarget, getRectangleByElement, getRectangleByNode, getRectangleByResizingLocation, getRelativeStartEndByAbstractRef, getRootLayout, getSelectedMindElements, getShapeByElement, getStrokeColorByElement, getStrokeStyleByElement, getStrokeWidthByElement, getTopicRectangleByElement, getTopicRectangleByNode, getTopicSize, getValidAbstractRefs, handleTouchedAbstract, hasPreviousOrNextOfDropPath, insertElementHandleAbstract, insertElementHandleRightNodeCount, insertMindElement, isChildElement, isChildOfAbstract, isChildRight, isChildUp, isCorrectLayout, isDropStandardRight, isHitEmojis, isHitImage, isHitMindElement, isInRightBranchOfStandardLayout, isMixedLayout, isSetAbstract, isValidTarget, normalizeWidthAndHeight, removeActiveOnDragOrigin, removeImageFocus, separateChildren, setMindDragging, withEmoji, withMind, withMindExtend };
//# sourceMappingURL=plait-mind.mjs.map
