{
  "version": 3,
  "sources": ["../../../../packages/common/src/constants/default.ts", "../../../../packages/common/src/constants/media.ts", "../../../../packages/common/src/constants/resize.ts", "../../../../packages/common/src/constants/property.ts", "../../../../packages/common/src/generators/generator.ts", "../../../../packages/common/src/utils/drawing/resize-handle.ts", "../../../../packages/common/src/utils/drawing/rotate-handle.ts", "../../../../packages/common/src/generators/active.generator.ts", "../../../../packages/common/src/utils/resize.ts", "../../../../packages/common/src/utils/vector.ts", "../../../../packages/common/src/utils/math.ts", "../../../../packages/common/src/utils/line-path.ts", "../../../../packages/common/src/utils/direction.ts", "../../../../packages/common/src/utils/default-orthogonal-routing.ts", "../../../../packages/common/src/utils/hot-key.ts", "../../../../packages/common/src/utils/creation-mode.ts", "../../../../packages/common/src/utils/text.ts", "../../../../packages/common/src/utils/image.ts", "../../../../packages/common/src/algorithms/data-structures/priority-queue.ts", "../../../../packages/common/src/algorithms/a-star.ts", "../../../../packages/common/src/algorithms/data-structures/graph.ts", "../../../../packages/common/src/utils/elbow-line-route.ts", "../../../../packages/common/src/utils/memorize.ts", "../../../../packages/common/src/utils/rotate.ts", "../../../../packages/common/src/utils/elements.ts", "../../../../packages/common/src/utils/animate.ts", "../../../../packages/common/src/utils/stroke.ts", "../../../../packages/common/src/utils/clipboard.ts", "../../../../packages/common/src/utils/point-placement.ts", "../../../../packages/common/src/image/image.generator.ts", "../../../../packages/common/src/transforms/property.ts", "../../../../packages/common/src/transforms/align.ts", "../../../../packages/common/src/shapes/common.ts", "../../../../packages/common/src/plugins/with-resize.ts", "../../../../packages/common/src/generators/group.generator.ts", "../../../../packages/common/src/core/element-ref.ts", "../../../../packages/common/src/core/element-flavour.ts", "../../../../packages/common/src/core/group.component.ts", "../../../../packages/common/src/plugins/with-group.ts", "../../../../packages/common/src/image/image-base.component.ts", "../../../../packages/common/src/text/text-measure.ts", "../../../../packages/common/src/text/text-manage.ts", "../../../../packages/common/src/text/with-text.ts", "../../../../packages/common/src/text/types.ts", "../../../../packages/common/src/image/with-image.ts", "../../../../packages/common/src/public-api.ts", "../../../../packages/common/src/plait-common.ts"],
  "sourcesContent": ["export const BASE = 4;\nexport const PRIMARY_COLOR = '#6698FF';\nexport const RESIZE_HANDLE_DIAMETER = 9;\nexport const WithTextPluginKey = 'plait-text-plugin-key';\nexport const DEFAULT_ROUTE_MARGIN = 30;\nexport const TRANSPARENT = 'transparent';\nexport const ROTATE_HANDLE_DISTANCE_TO_ELEMENT = 20;\nexport const ROTATE_HANDLE_SIZE = 18;\nexport const DEFAULT_FONT_FAMILY = `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'PingFang SC', 'Noto Sans', 'Noto Sans CJK SC', 'Microsoft Yahei', 'Hiragino Sans GB', Arial, sans-serif`;\nexport const DEFAULT_FILL = 'none';\n", "export enum MediaKeys {\n    image = 'image'\n}\n\nexport const PICTURE_ACCEPTED_UPLOAD_SIZE = 20;\n\nexport const acceptImageTypes = ['png', 'jpeg', 'gif', 'bmp'];\n\nexport const WithCommonPluginKey = 'plait-common-plugin-key';\n", "export enum ResizeHandle {\n    nw = '0',\n    n = '4',\n    ne = '1',\n    e = '5',\n    se = '2',\n    s = '6',\n    sw = '3',\n    w = '7'\n}\n", "export enum StrokeStyle {\n    solid = 'solid',\n    dashed = 'dashed',\n    dotted = 'dotted'\n}\n", "import {\n    PlaitBoard,\n    PlaitElement,\n    PlaitGroupElement,\n    RectangleClient,\n    getElementsInGroup,\n    getSelectionAngle,\n    setAngleForG,\n    toActiveRectangleFromViewBoxRectangle\n} from '@plait/core';\n\nexport interface GeneratorExtraData {}\n\nexport interface GeneratorOptions {\n    prepend?: boolean;\n    active?: boolean;\n}\n\nexport abstract class Generator<\n    T extends PlaitElement = PlaitElement,\n    K extends GeneratorExtraData = GeneratorExtraData,\n    V extends GeneratorOptions = GeneratorOptions,\n    P extends PlaitBoard = PlaitBoard\n> {\n    g?: SVGGElement;\n\n    protected options?: V;\n\n    constructor(protected board: P, options?: V) {\n        this.options = options;\n    }\n\n    processDrawing(element: T, parentG: SVGGElement, data?: K) {\n        if (this.canDraw && this.canDraw(element, data)) {\n            const g = this.draw(element, data);\n            if (g) {\n                if (this.g && parentG.contains(this.g)) {\n                    this.g.replaceWith(g);\n                } else {\n                    if (this.g) {\n                        this.g.remove();\n                    }\n                    if (this.options?.prepend) {\n                        parentG.prepend(g);\n                    } else {\n                        parentG.appendChild(g);\n                    }\n                }\n                this.g = g;\n                const rectangle = this.board.getRectangle(element);\n                if (!rectangle) {\n                    return;\n                }\n                let centerPoint = RectangleClient.getCenterPoint(rectangle);\n                if (this.options?.active) {\n                    const activeRectangle = toActiveRectangleFromViewBoxRectangle(this.board, rectangle);\n                    centerPoint = RectangleClient.getCenterPoint(activeRectangle);\n                }\n                let angle;\n                if (PlaitGroupElement.isGroup(element)) {\n                    angle = getSelectionAngle(getElementsInGroup(this.board, element, true));\n                } else {\n                    angle = element.angle;\n                }\n                if (angle) {\n                    setAngleForG(g, centerPoint, angle);\n                }\n            } else {\n                this.destroy();\n            }\n            if (hasAfterDraw(this)) {\n                this.afterDraw(element);\n            }\n        } else {\n            this.destroy();\n        }\n    }\n\n    /**\n     * abstract function\n     */\n    protected abstract canDraw(element: T, data?: K): boolean;\n\n    /**\n     * abstract function\n     */\n    protected abstract draw(element: T, data?: K): SVGGElement | undefined;\n\n    destroy() {\n        if (this.g) {\n            this.g.remove();\n            this.g = undefined;\n        }\n    }\n}\n\nexport interface AfterDraw<T extends PlaitElement = PlaitElement> {\n    afterDraw(element: T): void;\n}\n\nexport function hasAfterDraw(value: any): value is AfterDraw {\n    if (value.afterDraw) {\n        return true;\n    }\n    return false;\n}\n", "import { RESIZE_HANDLE_CLASS_NAME, PlaitBoard, Point, drawCircle } from '@plait/core';\nimport { Options } from 'roughjs/bin/core';\nimport { PRIMARY_COLOR, RESIZE_HANDLE_DIAMETER } from '../../constants/default';\n\nexport const drawHandle = (board: PlaitBoard, centerPoint: Point) => {\n    const options: Options = { stroke: '#99999995', strokeWidth: 2, fill: '#FFF', fillStyle: 'solid' };\n    const handleG = drawCircle(PlaitBoard.getRoughSVG(board), centerPoint, RESIZE_HANDLE_DIAMETER, options);\n    handleG.classList.add(RESIZE_HANDLE_CLASS_NAME);\n    return handleG;\n};\n\nexport function drawFillPrimaryHandle(board: PlaitBoard, point: Point) {\n    return drawCircle(PlaitBoard.getRoughSVG(board), point, RESIZE_HANDLE_DIAMETER, {\n        stroke: '#FFFFFF',\n        strokeWidth: 1,\n        fill: `${PRIMARY_COLOR}`,\n        fillStyle: 'solid'\n    });\n}\n\nexport function drawPrimaryHandle(board: PlaitBoard, point: Point) {\n    return drawCircle(PlaitBoard.getRoughSVG(board), point, RESIZE_HANDLE_DIAMETER, {\n        stroke: `${PRIMARY_COLOR}`,\n        strokeWidth: 2,\n        fill: `#FFFFFF`,\n        fillStyle: 'solid'\n    });\n}\n", "import { DEFAULT_COLOR, PlaitBoard, RectangleClient, createG, setStrokeLinecap } from '@plait/core';\nimport { Options } from 'roughjs/bin/core';\nimport { ROTATE_HANDLE_DISTANCE_TO_ELEMENT, ROTATE_HANDLE_SIZE } from '../../constants';\n\nconst rotateHandleRadius = 6;\n\nexport const drawRotateHandle = (board: PlaitBoard, rectangle: RectangleClient) => {\n    const options: Options = { stroke: DEFAULT_COLOR, strokeWidth: 1, fillStyle: 'solid' };\n    const handleCenterPoint = [\n        rectangle.x - ROTATE_HANDLE_DISTANCE_TO_ELEMENT - ROTATE_HANDLE_SIZE / 2,\n        rectangle.y + rectangle.height + ROTATE_HANDLE_DISTANCE_TO_ELEMENT + ROTATE_HANDLE_SIZE / 2\n    ];\n    const rs = PlaitBoard.getRoughSVG(board);\n    const handleG = createG();\n    const line = rs.path(\n        `M ${handleCenterPoint[0] + rotateHandleRadius} ${handleCenterPoint[1]} A ${rotateHandleRadius} ${rotateHandleRadius}, 0, 1, 0, ${\n            handleCenterPoint[0]\n        } ${handleCenterPoint[1] + rotateHandleRadius}`,\n        options\n    );\n    const arrow = rs.polygon(\n        [\n            [handleCenterPoint[0], handleCenterPoint[1] + rotateHandleRadius - 2],\n            [handleCenterPoint[0], handleCenterPoint[1] + rotateHandleRadius + 2],\n            [handleCenterPoint[0] + 4.5, handleCenterPoint[1] + rotateHandleRadius]\n        ],\n        { ...options, fill: DEFAULT_COLOR }\n    );\n    setStrokeLinecap(arrow, 'round');\n    handleG.append(line, arrow);\n    return handleG;\n};\n", "import {\n    ACTIVE_STROKE_WIDTH,\n    PlaitBoard,\n    PlaitElement,\n    RectangleClient,\n    SELECTION_RECTANGLE_CLASS_NAME,\n    createG,\n    drawRectangle,\n    toActiveRectangleFromViewBoxRectangle\n} from '@plait/core';\nimport { Generator, GeneratorOptions } from './generator';\nimport { PRIMARY_COLOR } from '../constants/default';\nimport { drawHandle } from '../utils/drawing';\n\nexport interface ActiveGeneratorExtraData {\n    selected: boolean;\n}\n\nexport interface ActiveGeneratorOptions<T> extends GeneratorOptions {\n    getRectangle: (element: T) => RectangleClient;\n    getStrokeWidth: () => number;\n    getStrokeOpacity: () => number;\n    hasResizeHandle: () => boolean;\n}\n\nexport const createActiveGenerator = <T extends PlaitElement = PlaitElement>(board: PlaitBoard, options: ActiveGeneratorOptions<T>) => {\n    return new ActiveGenerator<T>(board, { ...options, active: true });\n};\n\nexport class ActiveGenerator<T extends PlaitElement = PlaitElement> extends Generator<\n    T,\n    ActiveGeneratorExtraData,\n    ActiveGeneratorOptions<T>\n> {\n    static key = 'active-generator';\n\n    hasResizeHandle = false;\n\n    constructor(public board: PlaitBoard, public options: ActiveGeneratorOptions<T>) {\n        super(board, { ...options, active: true });\n    }\n\n    canDraw(element: T, data: ActiveGeneratorExtraData): boolean {\n        if (data.selected) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    draw(element: T, data: ActiveGeneratorExtraData): SVGGElement {\n        const activeG = createG();\n        const activeRectangle = toActiveRectangleFromViewBoxRectangle(this.board, this.options.getRectangle(element));\n\n        const delta = this.options.getStrokeWidth() * this.board.viewport.zoom;\n        const activeRectangleWithDelta = RectangleClient.inflate(activeRectangle, delta);\n\n        const strokeG = drawRectangle(this.board, activeRectangleWithDelta, {\n            stroke: PRIMARY_COLOR,\n            strokeWidth: ACTIVE_STROKE_WIDTH\n        });\n\n        activeG.append(strokeG);\n        strokeG.classList.add(SELECTION_RECTANGLE_CLASS_NAME);\n        strokeG.style.opacity = `${this.options.getStrokeOpacity()}`;\n        if (this.options.hasResizeHandle()) {\n            this.hasResizeHandle = true;\n            // draw resize handle\n            RectangleClient.getCornerPoints(activeRectangleWithDelta).forEach((corner) => {\n                const cornerHandleG = drawHandle(this.board, corner);\n                activeG.append(cornerHandleG);\n            });\n        } else {\n            this.hasResizeHandle = false;\n        }\n        return activeG;\n    }\n}\n", "import {\n    PlaitBoard,\n    Point,\n    RectangleClient,\n    ResizeCursorClass,\n    setDragging,\n    RESIZE_CURSORS,\n    rotatePoints,\n    PlaitElement,\n    getSelectedElements,\n    isSelectionMoving\n} from '@plait/core';\nimport { ResizeHandle } from '../constants/resize';\nimport { PlaitElementOrArray, ResizeRef } from '../types/resize';\n\nexport const getResizeHandleByIndex = (index: number) => {\n    return `${index}` as ResizeHandle;\n};\n\nexport const getIndexByResizeHandle = (resizeHandle: ResizeHandle) => {\n    return Number(resizeHandle);\n};\n\nexport const getSymmetricHandleIndex = (board: PlaitBoard, index: number) => {\n    const originIndex = isEdgeHandle(board, getResizeHandleByIndex(index)) ? index - 4 : index;\n    let originSymmetricHandleIndex = originIndex + 2;\n    if (originSymmetricHandleIndex >= 4) {\n        originSymmetricHandleIndex = originSymmetricHandleIndex - 4;\n    }\n    return isEdgeHandle(board, getResizeHandleByIndex(index)) ? originSymmetricHandleIndex + 4 : originSymmetricHandleIndex;\n};\n\nconst getResizeCursorClassByIndex = (index: number) => {\n    switch (index) {\n        case 0:\n        case 2:\n            return ResizeCursorClass.nwse;\n        case 1:\n        case 3:\n            return ResizeCursorClass.nesw;\n        case 4:\n        case 6:\n            return ResizeCursorClass.ns;\n        case 5:\n        case 7:\n            return ResizeCursorClass.ew;\n        default:\n            return null;\n    }\n};\n\nexport const getRotatedResizeCursorClassByAngle = (cursor: ResizeCursorClass, angle: number) => {\n    const index = RESIZE_CURSORS.indexOf(cursor);\n    if (index >= 0) {\n        const temp = Math.round(angle / (Math.PI / 4));\n        cursor = RESIZE_CURSORS[(index + temp) % RESIZE_CURSORS.length] as ResizeCursorClass;\n    }\n    return cursor;\n};\n\nexport const getRectangleResizeHandleRefs = (rectangle: RectangleClient, diameter: number) => {\n    const corners = RectangleClient.getCornerPoints(rectangle);\n    const refs = corners.map((corner, index: number) => {\n        return {\n            rectangle: {\n                x: corner[0] - diameter / 2,\n                y: corner[1] - diameter / 2,\n                width: diameter,\n                height: diameter\n            },\n            handle: getResizeHandleByIndex(index) as ResizeHandle,\n            cursorClass: getResizeCursorClassByIndex(index) as ResizeCursorClass\n        };\n    });\n    const rectangles = getResizeSideRectangles(corners, diameter / 2);\n    refs.push(\n        ...rectangles.map((rectangle, index) => {\n            return {\n                rectangle,\n                handle: getResizeHandleByIndex(index + 4) as ResizeHandle,\n                cursorClass: getResizeCursorClassByIndex(index + 4) as ResizeCursorClass\n            };\n        })\n    );\n    return refs;\n};\n\nexport const getResizeHandlePointByIndex = (rectangle: RectangleClient, index: number) => {\n    if (index <= 3) {\n        const corners = RectangleClient.getCornerPoints(rectangle);\n        return corners[index];\n    } else {\n        const edgeCenterPoints = RectangleClient.getEdgeCenterPoints(rectangle);\n        return edgeCenterPoints[index - 4];\n    }\n};\n\nconst getResizeSideRectangles = (cornerPoints: Point[], offset: number): RectangleClient[] => {\n    const result = [];\n    for (let i = 0; i < cornerPoints.length; i++) {\n        let rectangle = RectangleClient.getRectangleByPoints([cornerPoints[i], cornerPoints[(i + 1) % 4]]);\n        const arr = new Array(2).fill(0);\n        arr[(i + 1) % 2] = offset / 2;\n        rectangle = RectangleClient.expand(rectangle, arr[0], arr[1]);\n        result.push(rectangle);\n    }\n    return result;\n};\n\nexport const IS_RESIZING = new WeakMap<PlaitBoard, ResizeRef<any, any, any>>();\n\nexport const isResizing = (board: PlaitBoard) => {\n    return !!IS_RESIZING.get(board);\n};\n\nexport const isResizingByCondition = <T extends PlaitElementOrArray, K>(\n    board: PlaitBoard,\n    match: (resizeRef: ResizeRef<T, K>) => boolean\n) => {\n    return isResizing(board) && match(IS_RESIZING.get(board)!);\n};\n\nexport const addResizing = <T extends PlaitElementOrArray, K, P>(board: PlaitBoard, resizeRef: ResizeRef<T, K, P>, key: string) => {\n    PlaitBoard.getBoardContainer(board).classList.add(`${key}-resizing`);\n    IS_RESIZING.set(board, resizeRef);\n    setDragging(board, true);\n};\n\nexport const removeResizing = (board: PlaitBoard, key: string) => {\n    PlaitBoard.getBoardContainer(board).classList.remove(`${key}-resizing`);\n    IS_RESIZING.delete(board);\n    setDragging(board, false);\n};\n\nexport const isEdgeHandle = (board: PlaitBoard, handle: ResizeHandle) => {\n    const index = getIndexByResizeHandle(handle);\n    if (index >= 4) {\n        return true;\n    } else {\n        return false;\n    }\n};\n\nexport const isCornerHandle = (board: PlaitBoard, handle: ResizeHandle) => {\n    return !isEdgeHandle(board, handle);\n};\n\n// 处理元素先旋转后resize导致的位置偏移\nexport const resetPointsAfterResize = (\n    originRectangle: RectangleClient,\n    currentRectangle: RectangleClient,\n    originSelectionCenterPoint: Point,\n    currentSelectionCenterPoint: Point,\n    angle: number\n): [Point, Point] => {\n    const correctSelectionCenterPoint = rotatePoints([currentSelectionCenterPoint], originSelectionCenterPoint, angle)[0];\n    const rotatedElementCenterPoint = rotatePoints(\n        [RectangleClient.getCenterPoint(currentRectangle) as Point],\n        originSelectionCenterPoint,\n        angle\n    )[0];\n\n    const currentPoints = RectangleClient.getPoints(currentRectangle);\n    const originRectangleCenterPoint = RectangleClient.getCenterPoint(originRectangle);\n\n    const correctElementCenterPoint = rotatePoints([rotatedElementCenterPoint], correctSelectionCenterPoint, -angle)[0];\n\n    const rotatedPoints = rotatePoints(currentPoints, originRectangleCenterPoint, angle);\n    return rotatePoints(rotatedPoints, correctElementCenterPoint, -angle) as [Point, Point];\n};\n\nexport const hasMoreThanOnePoint = (element: PlaitElement) => {\n    const points = element.points as Point[];\n    return points && points.length > 1;\n};\n\nexport const hasResizeHandle = (board: PlaitBoard, element: PlaitElement) => {\n    if (PlaitBoard.hasBeenTextEditing(board) || isSelectionMoving(board)) {\n        return false;\n    }\n    const selectedElements = getSelectedElements(board);\n    return selectedElements.length === 1 && selectedElements[0] === element && hasMoreThanOnePoint(element);\n};\n", "import { Point, Vector } from '@plait/core';\n\nexport function getUnitVectorByPointAndPoint(point1: Point, point2: Point): Point {\n    const deltaX = point2[0] - point1[0];\n    const deltaY = point2[1] - point1[1];\n    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n    // Avoid division by zero if the points are the same\n    if (distance === 0) {\n        throw new Error('Points must not be the same for a unit vector calculation.');\n    }\n    // Calculate the unit vector components\n    const unitX = deltaX / distance;\n    const unitY = deltaY / distance;\n\n    return [unitX, unitY];\n}\n\nexport function getPointByVectorComponent(point: Point, vector: Vector, component: number): Point {\n    const distance = Math.hypot(vector[0], vector[1]);\n    return [point[0] + (vector[0] / distance) * component, point[1] + (vector[1] / distance) * component];\n}\n\nexport function getPointByVectorDirectionComponent(point: Point, unitVector: Vector, directionComponent: number, isHorizontal: boolean) {\n    if (isHorizontal) {\n        return [point[0] + directionComponent, point[1] + (directionComponent / unitVector[0]) * unitVector[1]] as Point;\n    } else {\n        return [point[0] + (directionComponent / unitVector[1]) * unitVector[0], point[1] + directionComponent] as Point;\n    }\n}\n\nexport function rotateVectorAnti90(vector: Vector): Vector {\n    const x = vector[0];\n    const y = vector[1];\n    const rotatedX = y;\n    const rotatedY = -x;\n    return [rotatedX, rotatedY];\n}\n\nexport function rotateVector(vector: Vector, angle: number): Vector {\n    if (!angle) {\n        return vector;\n    }\n    const x = vector[0];\n    const y = vector[1];\n    const rotatedX = x * Math.cos(angle) - y * Math.sin(angle);\n    const rotatedY = x * Math.sin(angle) + y * Math.cos(angle);\n    return [rotatedX, rotatedY];\n}\n", "import { Point, distanceBetweenPointAndPoint } from '@plait/core';\nimport { getPointByVectorDirectionComponent, getUnitVectorByPointAndPoint } from './vector';\n\nexport function isPointOnSegment(point: Point, startPoint: Point, endPoint: Point) {\n    const distanceToStart = distanceBetweenPointAndPoint(point[0], point[1], startPoint[0], startPoint[1]);\n    const distanceToEnd = distanceBetweenPointAndPoint(point[0], point[1], endPoint[0], endPoint[1]);\n    const segmentLength = distanceBetweenPointAndPoint(startPoint[0], startPoint[1], endPoint[0], endPoint[1]);\n    return Math.abs(distanceToStart + distanceToEnd - segmentLength) < 0.1;\n}\n\nexport const getCrossingPointsBetweenPointAndSegment = (point: Point, startPoint: Point, endPoint: Point) => {\n    const result: Point[] = [];\n    const xRange = [Math.min(startPoint[0], endPoint[0]), Math.max(startPoint[0], endPoint[0])];\n    const yRange = [Math.min(startPoint[1], endPoint[1]), Math.max(startPoint[1], endPoint[1])];\n    const unitVector = getUnitVectorByPointAndPoint(startPoint, endPoint);\n    if (point[0] >= xRange[0] && point[0] <= xRange[1]) {\n        const crossingPoint = getPointByVectorDirectionComponent(startPoint, unitVector, point[0] - startPoint[0], true) as Point;\n        result.push(crossingPoint);\n    } else if (point[1] >= yRange[0] && point[1] <= yRange[1]) {\n        const crossingPoint = getPointByVectorDirectionComponent(startPoint, unitVector, point[1] - startPoint[1], false) as Point;\n        result.push(crossingPoint);\n    }\n    return result;\n};\n", "import { Point, distanceBetweenPointAndPoint } from '@plait/core';\nimport { isPointOnSegment } from './math';\n\nexport function getPointOnPolyline(points: Point[], ratio: number) {\n    const totalLength = calculatePolylineLength(points);\n    const targetDistance = totalLength * ratio;\n\n    let accumulatedDistance = 0;\n    for (let i = 0; i < points.length - 1; i++) {\n        const [x1, y1] = points[i];\n        const [x2, y2] = points[i + 1];\n        const segmentLength = distanceBetweenPointAndPoint(x1, y1, x2, y2);\n\n        if (accumulatedDistance + segmentLength >= targetDistance) {\n            const remainingDistance = targetDistance - accumulatedDistance;\n            const ratioInSegment = remainingDistance / segmentLength;\n\n            const targetX = x1 + (x2 - x1) * ratioInSegment;\n            const targetY = y1 + (y2 - y1) * ratioInSegment;\n            return [targetX, targetY];\n        }\n\n        accumulatedDistance += segmentLength;\n    }\n\n    return points[points.length - 1];\n}\n\nexport function calculatePolylineLength(points: Point[]) {\n    let length = 0;\n    for (let i = 0; i < points.length - 1; i++) {\n        const [x1, y1] = points[i];\n        const [x2, y2] = points[i + 1];\n        length += distanceBetweenPointAndPoint(x1, y1, x2, y2);\n    }\n    return length;\n}\n\nexport function getRatioByPoint(points: Point[], point: Point) {\n    const totalLength = calculatePolylineLength(points);\n    let distance = 0;\n    for (let i = 0; i < points.length - 1; i++) {\n        const isOverlap = isPointOnSegment(point, points[i], points[i + 1]);\n        if (isOverlap) {\n            distance += distanceBetweenPointAndPoint(point[0], point[1], points[i][0], points[i][1]);\n            return distance / totalLength;\n        } else {\n            distance += distanceBetweenPointAndPoint(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1]);\n        }\n    }\n    throw new Error('Cannot get ratio by point');\n}\n\nexport const removeDuplicatePoints = (points: Point[]) => {\n    const newArray: Point[] = [];\n    points.forEach(point => {\n        const index = newArray.findIndex(otherPoint => {\n            return Point.isEquals(point, otherPoint);\n        });\n        if (index === -1) newArray.push(point);\n    });\n    return newArray;\n};\n\nexport function simplifyOrthogonalPoints(points: Point[]) {\n    if (points.length <= 2) return points;\n    let simplifiedPoints: Point[] = [points[0]];\n    for (let i = 1; i < points.length - 1; i++) {\n        const previous = points[i - 1];\n        const current = points[i];\n        const next = points[i + 1];\n        const isTurn = !(Point.isOverHorizontal([previous, current, next]) || Point.isOverVertical([previous, current, next]));\n        if (isTurn) {\n            simplifiedPoints.push(current);\n        }\n    }\n    simplifiedPoints.push(points[points.length - 1]);\n    return simplifiedPoints;\n}\n\nexport const getExtendPoint = (source: Point, target: Point, extendDistance: number): Point => {\n    const distance = distanceBetweenPointAndPoint(...source, ...target);\n    const isEqual = Point.isEquals(source, target);\n    const sin = isEqual ? 1 : (target[1] - source[1]) / distance;\n    const cos = isEqual ? 1 : (target[0] - source[0]) / distance;\n    return [source[0] + extendDistance * cos, source[1] + extendDistance * sin];\n};\n", "import { Direction, DirectionFactor, Point, PointOfRectangle, Vector } from '@plait/core';\n\nconst handleDirectionFactors = {\n    [Direction.left]: { x: -1, y: 0 },\n    [Direction.right]: { x: 1, y: 0 },\n    [Direction.top]: { x: 0, y: -1 },\n    [Direction.bottom]: { x: 0, y: 1 }\n};\n\nexport function getOppositeDirection(direction: Direction) {\n    switch (direction) {\n        case Direction.left:\n            return Direction.right;\n        case Direction.right:\n            return Direction.left;\n        case Direction.top:\n            return Direction.bottom;\n        case Direction.bottom:\n            return Direction.top;\n    }\n}\n\nexport function getDirectionByPointOfRectangle(point: PointOfRectangle): Direction | undefined {\n    if (point[0] === 0) {\n        return Direction.left;\n    }\n    if (point[0] === 1) {\n        return Direction.right;\n    }\n    if (point[1] === 0) {\n        return Direction.top;\n    }\n    if (point[1] === 1) {\n        return Direction.bottom;\n    }\n    return undefined;\n}\n\n/**\n * this function accepts vector parameter, the vector parameter vector is based on the screen coordinate system\n * vector[0] and vector[1] are the x and y components of the vector respectively.\n * if the vector has only one direction, the function returns a string in that direction, such as 'right', 'top', 'bottom' or 'left'.\n * if the vector has two directions, the function will return the string in which direction it is closer.\n */\nexport function getDirectionByVector(vector: Vector): Direction | null {\n    const x = vector[0];\n    const y = vector[1];\n    if (x === 0 && y === 0) {\n        return null;\n    }\n    if (x === 0) {\n        return y > 0 ? Direction.bottom : Direction.top;\n    }\n    if (y === 0) {\n        return x > 0 ? Direction.right : Direction.left;\n    }\n    const angle = Math.atan2(y, x);\n    if (angle > -Math.PI / 4 && angle <= Math.PI / 4) {\n        return Direction.right;\n    } else if (angle > Math.PI / 4 && angle <= (3 * Math.PI) / 4) {\n        return Direction.bottom;\n    } else if (angle > (-3 * Math.PI) / 4 && angle <= -Math.PI / 4) {\n        return Direction.top;\n    } else {\n        return Direction.left;\n    }\n}\n\nexport function getDirectionBetweenPointAndPoint(source: Point, target: Point) {\n    if (source[0] === target[0]) {\n        if (source[1] >= target[1]) {\n            return Direction.top;\n        } else {\n            return Direction.bottom;\n        }\n    }\n    if (source[1] === target[1]) {\n        if (source[0] >= target[0]) {\n            return Direction.left;\n        } else {\n            return Direction.right;\n        }\n    }\n    throw new Error('can not match direction');\n}\n\nexport function getDirectionFactor(direction: Direction) {\n    return handleDirectionFactors[direction];\n}\n\nexport function getDirectionFactorByDirectionComponent(directionComponent: number): DirectionFactor {\n    const directionFactor = directionComponent === 0 ? directionComponent : directionComponent / Math.abs(directionComponent);\n    return directionFactor as DirectionFactor;\n}\n", "// Credits to xyflow\n// https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/edges/smoothstep-edge.ts\n\nimport { Direction, Point } from \"@plait/core\";\nimport { getDirectionFactor } from \"./direction\";\n\nexport const getPoints = (source: Point, sourcePosition: Direction, target: Point, targetPosition: Direction, offset: number) => {\n    const sourceDirectionFactors = getDirectionFactor(sourcePosition);\n    const targetDFs = getDirectionFactor(targetPosition);\n    const sourceGapped: Point = [source[0] + sourceDirectionFactors.x * offset, source[1] + sourceDirectionFactors.y * offset];\n    const targetGapped: Point = [target[0] + targetDFs.x * offset, target[1] + targetDFs.y * offset];\n    const dir = getDirection(sourceGapped, sourcePosition, targetGapped);\n    const dirAccessor = dir.x !== 0 ? 'x' : 'y';\n    const currDir = dir[dirAccessor];\n\n    let points: Point[] = [];\n    let centerX, centerY;\n    const [defaultCenterX, defaultCenterY] = getEdgeCenter({\n        sourceX: source[0],\n        sourceY: source[1],\n        targetX: target[0],\n        targetY: target[1]\n    });\n    // opposite handle positions, default case\n    if (sourceDirectionFactors[dirAccessor] * targetDFs[dirAccessor] === -1) {\n        centerX = defaultCenterX;\n        centerY = defaultCenterY;\n        //    --->\n        //    |\n        // >---\n        const verticalSplit: Point[] = [\n            [centerX, sourceGapped[1]],\n            [centerX, targetGapped[1]]\n        ];\n        //    |\n        //  ---\n        //  |\n        const horizontalSplit: Point[] = [\n            [sourceGapped[0], centerY],\n            [targetGapped[0], centerY]\n        ];\n        if (sourceDirectionFactors[dirAccessor] === currDir) {\n            points = dirAccessor === 'x' ? verticalSplit : horizontalSplit;\n        } else {\n            points = dirAccessor === 'x' ? horizontalSplit : verticalSplit;\n        }\n    } else {\n        // sourceTarget means we take x from source and y from target, targetSource is the opposite\n        const sourceTarget: Point[] = [[sourceGapped[0], targetGapped[1]]];\n        const targetSource: Point[] = [[targetGapped[0], sourceGapped[1]]];\n        // this handles edges with same handle positions\n        if (dirAccessor === 'x') {\n            points = sourceDirectionFactors.x === currDir ? targetSource : sourceTarget;\n        } else {\n            points = sourceDirectionFactors.y === currDir ? sourceTarget : targetSource;\n        }\n\n        // these are conditions for handling mixed handle positions like right -> bottom for example\n        let flipSourceTarget;\n        if (sourcePosition !== targetPosition) {\n            const dirAccessorOpposite = dirAccessor === 'x' ? 1 : 0;\n            const isSameDir = sourceDirectionFactors[dirAccessor] === targetDFs[dirAccessor === 'x' ? 'y' : 'x'];\n            const sourceGtTarget = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite];\n            const sourceLtTarget = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];\n            flipSourceTarget =\n                (sourceDirectionFactors[dirAccessor] === 1 && ((!isSameDir && sourceGtTarget) || (isSameDir && sourceLtTarget))) ||\n                (sourceDirectionFactors[dirAccessor] !== 1 && ((!isSameDir && sourceLtTarget) || (isSameDir && sourceGtTarget)));\n\n            if (flipSourceTarget) {\n                points = dirAccessor === 'x' ? sourceTarget : targetSource;\n            }\n        }\n    }\n    return [source, sourceGapped, ...points, targetGapped, target];\n};\n\nconst getDirection = (source: Point, sourcePosition = Direction.bottom, target: Point) => {\n    if (sourcePosition === Direction.left || sourcePosition === Direction.right) {\n        return source[0] < target[0] ? { x: 1, y: 0 } : { x: -1, y: 0 };\n    }\n    return source[1] < target[1] ? { x: 0, y: 1 } : { x: 0, y: -1 };\n};\n\nfunction getEdgeCenter({\n    sourceX,\n    sourceY,\n    targetX,\n    targetY\n}: {\n    sourceX: number;\n    sourceY: number;\n    targetX: number;\n    targetY: number;\n}): [number, number, number, number] {\n    const xOffset = Math.abs(targetX - sourceX) / 2;\n    const centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;\n\n    const yOffset = Math.abs(targetY - sourceY) / 2;\n    const centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;\n\n    return [centerX, centerY, xOffset, yOffset];\n}", "import { hotkeys } from '@plait/core';\nimport { isKeyHotkey } from 'is-hotkey';\n\nexport function isVirtualKey(e: KeyboardEvent) {\n    const isMod = e.ctrlKey || e.metaKey;\n    const isAlt = isKeyHotkey('alt', e);\n    const isShift = isKeyHotkey('shift', e);\n    const isCapsLock = e.key.includes('CapsLock');\n    const isTab = e.key.includes('Tab');\n    const isEsc = e.key.includes('Escape');\n    const isF = e.key.startsWith('F');\n    const isArrow = e.key.includes('Arrow') ? true : false;\n    return isCapsLock || isMod || isAlt || isArrow || isShift || isTab || isEsc || isF;\n}\n\nexport const isExpandHotkey = (event: KeyboardEvent) => {\n    return isKeyHotkey('mod+/', event);\n};\n\nexport const isTabHotkey = (event: KeyboardEvent) => {\n    return event.key === 'Tab';\n};\n\nexport const isEnterHotkey = (event: KeyboardEvent) => {\n    return event.key === 'Enter';\n};\n\nexport const isSpaceHotkey = (event: KeyboardEvent) => {\n    return event.code === 'Space';\n};\n\nexport const isDelete = (event: KeyboardEvent) => {\n    return hotkeys.isDeleteBackward(event) || hotkeys.isDeleteForward(event);\n};\n", "import { PlaitBoard } from '@plait/core';\n\nexport enum BoardCreationMode {\n    'dnd' = 'dnd',\n    'drawing' = 'drawing'\n}\n\nconst BOARD_TO_CREATION_MODE: WeakMap<PlaitBoard, BoardCreationMode> = new WeakMap();\n\nexport const getCreationMode = (board: PlaitBoard) => {\n    return BOARD_TO_CREATION_MODE.get(board);\n};\n\nexport const setCreationMode = (board: PlaitBoard, mode: BoardCreationMode) => {\n    BOARD_TO_CREATION_MODE.set(board, mode);\n};\n\nexport const isDndMode = (board: PlaitBoard) => {\n    return getCreationMode(board) === BoardCreationMode.dnd;\n};\n\nexport const isDrawingMode = (board: PlaitBoard) => {\n    return getCreationMode(board) === BoardCreationMode.drawing;\n};\n", "import { PlaitBoard, PlaitElement, getSelectedElements } from '@plait/core';\nimport { Editor, Node, Element } from 'slate';\nimport { TextManage } from '../text/text-manage';\nimport { Alignment, CustomText, ParagraphElement } from '../text/types';\nimport { PlaitCommonElementRef } from '../core';\n\nexport interface TextInterface {\n    getTextEditors: (board: PlaitBoard, elements?: PlaitElement[]) => Editor[] | undefined;\n    findFirstTextEditor: (board: PlaitBoard) => null;\n    getFirstTextEditor: (element: PlaitElement) => Editor;\n    getTextEditorsByElement: (element: PlaitElement) => Editor[];\n    getEditingTextEditor: (board: PlaitBoard, elements?: PlaitElement[]) => Editor | undefined;\n}\n\nexport const getTextManages = (element: PlaitElement) => {\n    const ref = PlaitElement.getElementRef<PlaitCommonElementRef>(element);\n    return ref?.getTextManages() || [];\n};\n\nexport const getFirstTextManage = (element: PlaitElement) => {\n    const textManage = getTextManages(element)[0];\n    if (!textManage) {\n        console.warn('can not find textManage');\n    }\n    return textManage;\n};\n\nexport const getTextEditorsByElement: TextInterface['getTextEditorsByElement'] = (element: PlaitElement) => {\n    return getTextManages(element).map(manage => {\n        return manage.editor;\n    });\n};\n\nexport const getFirstTextEditor: TextInterface['getFirstTextEditor'] = (element: PlaitElement) => {\n    const textEditor = getTextEditorsByElement(element)[0];\n    if (!textEditor) {\n        console.warn('can not find textManage');\n    }\n    return textEditor;\n};\n\nexport const findFirstTextEditor: TextInterface['findFirstTextEditor'] = (board: PlaitBoard) => {\n    const selectedElements = getSelectedElements(board);\n    let firstEditor: Editor | null = null;\n    selectedElements.forEach(element => {\n        const editors = getTextEditorsByElement(element);\n        if (!firstEditor && editors && editors.length > 0) {\n            firstEditor = editors[0];\n        }\n    });\n    return firstEditor;\n};\n\nexport const getElementsText = (elements: PlaitElement[]) => {\n    return elements\n        .map(item => {\n            try {\n                const editors = getTextEditorsByElement(item);\n                if (editors.length) {\n                    return editors\n                        .map(editor => {\n                            const textsEntry = Node.texts(editor);\n                            return Array.from(textsEntry).reduce((total, text) => (total += text[0].text), '');\n                        })\n                        .join(' ');\n                }\n                return '';\n            } catch (error) {\n                return '';\n            }\n        })\n        .filter(item => item)\n        .join(' ');\n};\n\nexport const getTextEditors: TextInterface['getTextEditors'] = (board: PlaitBoard, elements?: PlaitElement[]) => {\n    const selectedElements = elements || getSelectedElements(board);\n    if (selectedElements.length) {\n        const textManages: TextManage[] = [];\n        selectedElements.forEach(item => {\n            textManages.push(...getTextManages(item));\n        });\n        const editingTextManage = textManages.find(textManage => textManage.isEditing);\n        if (editingTextManage) {\n            return [editingTextManage.editor];\n        }\n        return textManages.map(item => {\n            return item.editor;\n        });\n    }\n    return undefined;\n};\n\nexport const getEditingTextEditor: TextInterface['getEditingTextEditor'] = (board: PlaitBoard, elements?: PlaitElement[]) => {\n    const selectedElements = elements || getSelectedElements(board);\n    const textManages: TextManage[] = [];\n    selectedElements.forEach(item => {\n        textManages.push(...getTextManages(item));\n    });\n    const editingTextManage = textManages.find(textManage => textManage.isEditing);\n    if (editingTextManage) {\n        return editingTextManage.editor;\n    }\n    return undefined;\n};\n\nexport const buildText = (text: string | Element, align?: Alignment, properties?: Partial<CustomText>) => {\n    properties = properties || {};\n    const plaitText = typeof text === 'string' ? { children: [{ text, ...properties }], type: 'paragraph' } : text;\n    if (align) {\n        (plaitText as ParagraphElement).align = align;\n    }\n    return plaitText;\n};\n\nexport const getLineHeightByFontSize = (fontSize: number) => {\n    if (fontSize === 14) {\n        return 20;\n    }\n    if (fontSize === 18) {\n        return 25;\n    }\n    return fontSize * 1.5;\n};\n", "import { PlaitBoard, PlaitElement } from '@plait/core';\n\nexport interface CommonImageItem {\n    url: string;\n    width: number;\n    height: number;\n}\n\nexport const selectImage = (\n    board: PlaitBoard,\n    defaultImageWidth: number,\n    handle: (commonImage: CommonImageItem) => void,\n    acceptImageTypes: string[] = ['png', 'jpeg', 'gif', 'bmp']\n) => {\n    const inputFile = document.createElement('input');\n    inputFile.setAttribute('type', 'file');\n    const acceptImageTypesString = '.' + acceptImageTypes.join(',.');\n    inputFile.setAttribute('accept', acceptImageTypesString);\n    inputFile.onchange = (event: Event) => {\n        buildImage(board, (event.target as any).files[0], defaultImageWidth, handle);\n    };\n    inputFile.click();\n};\n\nexport const buildImage = async (\n    board: PlaitBoard,\n    imageFile: File,\n    defaultImageWidth: number,\n    handle: (commonImage: CommonImageItem) => void\n) => {\n    let width = 0,\n        height = 0;\n    await getImageSize(imageFile, defaultImageWidth).then((value: { width: number; height: number }) => {\n        width = value.width;\n        height = value.height;\n    });\n\n    let imageItem = null;\n    const url = URL.createObjectURL(imageFile);\n    const context = PlaitBoard.getBoardContext(board);\n    context.setUploadingFile({ url, file: imageFile });\n\n    imageItem = {\n        url,\n        width,\n        height\n    };\n    handle(imageItem);\n};\n\nfunction getImageSize(file: File, defaultImageWidth: number): Promise<{ width: number; height: number }> {\n    return new Promise((resolve, reject) => {\n        const image = new Image();\n        image.src = URL.createObjectURL(file);\n\n        image.onload = function() {\n            const width = defaultImageWidth;\n            const height = (defaultImageWidth * image.naturalHeight) / image.naturalWidth;\n            resolve(\n                image.naturalWidth > defaultImageWidth ? { width, height } : { width: image.naturalWidth, height: image.naturalHeight }\n            );\n        };\n    });\n}\n\nconst BOARD_TO_ELEMENT_OF_FOCUSED_IMAGE = new WeakMap<PlaitBoard, PlaitElement>();\n\nexport const getElementOfFocusedImage = (board: PlaitBoard) => {\n    return BOARD_TO_ELEMENT_OF_FOCUSED_IMAGE.get(board);\n};\n\nexport const addElementOfFocusedImage = (board: PlaitBoard, element: PlaitElement) => {\n    BOARD_TO_ELEMENT_OF_FOCUSED_IMAGE.set(board, element);\n};\n\nexport const removeElementOfFocusedImage = (board: PlaitBoard) => {\n    BOARD_TO_ELEMENT_OF_FOCUSED_IMAGE.delete(board);\n};\n", "import { PointNode } from './graph';\n\nexport class PriorityQueue {\n    list: { node: PointNode; priority: number }[];\n\n    constructor() {\n        this.list = [];\n    }\n\n    enqueue(item: { node: PointNode; priority: number }) {\n        this.list.push(item);\n        this.list = this.list.sort((item1, item2) => item1.priority - item2.priority);\n    }\n\n    dequeue() {\n        return this.list.shift();\n    }\n}\n", "import { Point } from '@plait/core';\nimport { PointGraph, PointNode } from './data-structures/graph';\nimport { PriorityQueue } from './data-structures/priority-queue';\n\nexport class AStar {\n    cameFrom: Map<PointNode, PointNode>;\n\n    constructor(private graph: PointGraph) {\n        this.cameFrom = new Map<PointNode, PointNode>();\n    }\n\n    heuristic(a: Point, b: Point) {\n        return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]);\n    }\n\n    search(start: Point, end: Point, previousStart: Point) {\n        const frontier = new PriorityQueue();\n        const startNode = this.graph.get(start);\n        this.cameFrom = new Map<PointNode, PointNode>();\n        const costSoFar = new Map<PointNode, number>();\n        costSoFar.set(startNode!, 0);\n        frontier.enqueue({ node: startNode!, priority: 0 });\n        while (frontier.list.length > 0) {\n            var current = frontier.dequeue();\n\n            if (!current) {\n                throw new Error(`can't find current`);\n            }\n            const currentPoint = current!.node.data;\n            if (currentPoint[0] === end[0] && currentPoint[1] === end[1]) {\n                break;\n            }\n            current.node.adjacentNodes.forEach(next => {\n                let newCost = costSoFar.get(current!.node)! + this.heuristic(next.data, current!.node.data);\n                const previousNode = this.cameFrom.get(current!.node);\n                // Inflection point weight, if an inflection point occurs, cost + 1 to avoid the inflection point path\n                // Three points on a line to determine whether there is an inflection point\n                const previousPoint = previousNode ? previousNode.data : previousStart;\n                const x = previousPoint[0] === current?.node.data[0] && previousPoint[0] === next.data[0];\n                const y = previousPoint[1] === current?.node.data[1] && previousPoint[1] === next.data[1];\n                if (!x && !y) {\n                    newCost = newCost + 1;\n                }\n                if (!costSoFar.has(next) || (costSoFar.get(next) && newCost < costSoFar.get(next)!)) {\n                    costSoFar.set(next, newCost);\n                    const priority = newCost + this.heuristic(next.data, end);\n                    frontier.enqueue({ node: next, priority });\n                    this.cameFrom.set(next, current!.node);\n                }\n            });\n        }\n    }\n\n    getRoute(start: Point, end: Point) {\n        const result = [];\n        let temp = end;\n        while (temp[0] !== start[0] || temp[1] !== start[1]) {\n            const node = this.graph.get(temp);\n            const preNode = this.cameFrom.get(node!);\n            result.unshift(preNode!.data);\n            temp = preNode!.data;\n        }\n        return result;\n    }\n}\n", "import { Point, distanceBetweenPointAndPoint } from '@plait/core';\n\nexport class PointNode {\n    public distance = Number.MAX_SAFE_INTEGER;\n    public adjacentNodes: PointNode[] = [];\n    constructor(public data: Point) {}\n}\n\nexport class PointGraph {\n    private index: { [x: string]: { [y: string]: PointNode } } = {};\n\n    add(p: Point) {\n        const x = p[0];\n        const y = p[1];\n        const xs = x.toString(),\n            ys = y.toString();\n\n        if (!(xs in this.index)) {\n            this.index[xs] = {};\n        }\n        if (!(ys in this.index[xs])) {\n            this.index[xs][ys] = new PointNode(p);\n        }\n    }\n    connect(a: Point, b: Point) {\n        const nodeA = this.get(a);\n        const nodeB = this.get(b);\n\n        if (!nodeA || !nodeB) {\n            throw new Error(`A point was not found`);\n        }\n\n        nodeA.adjacentNodes.push(nodeB);\n    }\n\n    has(p: Point): boolean {\n        const x = p[0];\n        const y = p[1];\n        const xs = x.toString(),\n            ys = y.toString();\n        return xs in this.index && ys in this.index[xs];\n    }\n\n    get(p: Point): PointNode | null {\n        const x = p[0];\n        const y = p[1];\n        const xs = x.toString(),\n            ys = y.toString();\n\n        if (xs in this.index && ys in this.index[xs]) {\n            return this.index[xs][ys];\n        }\n\n        return null;\n    }\n}\n", "import { Direction, PlaitBoard, Point, RectangleClient, createDebugGenerator, DebugGenerator } from '@plait/core';\nimport { removeDuplicatePoints, simplifyOrthogonalPoints } from '../utils';\nimport { DEFAULT_ROUTE_MARGIN } from '../constants';\nimport { AStar, PointGraph } from '../algorithms';\n\nconst debugGenerator = createDebugGenerator('debug:plait:elbow-line-routing');\n\nexport interface ElbowLineRouteOptions {\n    sourcePoint: Point;\n    nextSourcePoint: Point;\n    sourceRectangle: RectangleClient;\n    sourceOuterRectangle: RectangleClient;\n    targetPoint: Point;\n    nextTargetPoint: Point;\n    targetOuterRectangle: RectangleClient;\n    targetRectangle: RectangleClient;\n}\n\nexport interface RouteAdjustOptions {\n    centerX?: number;\n    centerY?: number;\n    sourceRectangle: RectangleClient;\n    targetRectangle: RectangleClient;\n}\n\nexport interface AdjustOptions {\n    parallelPaths: [Point, Point][];\n    pointOfHit: Point;\n    sourceRectangle: RectangleClient;\n    targetRectangle: RectangleClient;\n}\n\nexport const generateElbowLineRoute = (options: ElbowLineRouteOptions, board?: PlaitBoard) => {\n    const { nextSourcePoint, nextTargetPoint } = options;\n    const points = getGraphPoints(options);\n    const graph = createGraph(points);\n    const aStar = new AStar(graph);\n    aStar.search(nextSourcePoint, nextTargetPoint, options.sourcePoint);\n    let route = aStar.getRoute(nextSourcePoint, nextTargetPoint);\n    route = [options.sourcePoint, ...route, nextTargetPoint, options.targetPoint];\n    // Centerline correction: Correct the shortest path route based on the horizontal centerline/vertical centerline\n    // 1. Find the horizontal center line (centerX)/vertical center line (centerY)\n    // 2. Find the point that intersects centerX/centerY in route, and find the line segment parallel to centerX/centerY in route\n    // 3. Construct a rectangle based on the intersection points and parallel lines found in the previous step.\n    // 4. Determine whether the rectangle intersects with the element. If it does not intersect, the center line can be mapped based on the rectangle constructed in the previous step.\n    // 5. Determine whether the path after mapping the center line meets the constraints (inflection point cannot be increased)\n    const isHitX = RectangleClient.isHitX(options.sourceOuterRectangle, options.targetOuterRectangle);\n    const isHitY = RectangleClient.isHitY(options.sourceOuterRectangle, options.targetOuterRectangle);\n    const centerX = isHitX ? undefined : RectangleClient.getGapCenter(options.sourceOuterRectangle, options.targetOuterRectangle, true);\n    const centerY = isHitY ? undefined : RectangleClient.getGapCenter(options.sourceOuterRectangle, options.targetOuterRectangle, false);\n    route = routeAdjust(route, { centerX, centerY, sourceRectangle: options.sourceRectangle, targetRectangle: options.targetRectangle }, board);\n    return route;\n};\n\nexport const routeAdjust = (path: Point[], options: RouteAdjustOptions, board?: PlaitBoard) => {\n    const { sourceRectangle, targetRectangle, centerX, centerY } = options;\n    if (board) {\n        debugGenerator.clear();\n    }\n    if (centerX !== undefined) {\n        const optionsX = getAdjustOptions(path, centerX, true);\n        const resultX =\n            optionsX.pointOfHit &&\n            adjust(path, { parallelPaths: optionsX.parallelPaths, pointOfHit: optionsX.pointOfHit, sourceRectangle, targetRectangle }, board);\n        if (resultX) {\n            path = resultX;\n        }\n    }\n    if (centerY !== undefined) {\n        const optionsY = getAdjustOptions(path, centerY, false);\n        const resultY =\n            optionsY.pointOfHit &&\n            adjust(path, { parallelPaths: optionsY.parallelPaths, pointOfHit: optionsY.pointOfHit, sourceRectangle, targetRectangle },  board);\n        if (resultY) {\n            path = resultY;\n        }\n    }\n    return path;\n};\n\nconst adjust = (route: Point[], options: AdjustOptions, board?: PlaitBoard): null | Point[] => {\n    const { parallelPaths, pointOfHit, sourceRectangle, targetRectangle } = options;\n    let result = null;\n    parallelPaths.forEach(parallelPath => {\n        // Construct a rectangle\n        const tempRectPoints = [pointOfHit, parallelPath[0], parallelPath[1]];\n        // directly use getCornerPoints will bring the precision issue (eg: 263.6923375175286 - 57.130859375)\n        const tempRect = RectangleClient.getRectangleByPoints(tempRectPoints);\n        if (!RectangleClient.isHit(tempRect, sourceRectangle) && !RectangleClient.isHit(tempRect, targetRectangle)) {\n            const tempCorners = RectangleClient.getCornerPointsByPoints(tempRectPoints);\n            if (board) {\n                debugGenerator.drawRectangle(board, tempRect);\n            }\n            const indexRangeInPath: number[] = [];\n            const indexRangeInCorner: number[] = [];\n            route.forEach((point, index) => {\n                const cornerResult = tempCorners.findIndex(corner => Point.isEquals(point, corner));\n                if (cornerResult !== -1) {\n                    indexRangeInPath.push(index);\n                    indexRangeInCorner.push(cornerResult);\n                }\n            });\n            const newPath = [...route];\n            const missCorner = tempCorners.find((c, index) => !indexRangeInCorner.includes(index)) as Point;\n            const removeLength = Math.abs(indexRangeInPath[0] - indexRangeInPath[indexRangeInPath.length - 1]) + 1;\n            newPath.splice(indexRangeInPath[0] + 1, removeLength - 2, missCorner);\n            const turnCount = simplifyOrthogonalPoints([...route]).length - 1;\n            const simplifyPoints = simplifyOrthogonalPoints([...newPath]);\n            // if (board) {\n            //     debugGenerator.drawLine(board, simplifyPoints);\n            // }\n            const newTurnCount = simplifyPoints.length - 1;\n            if (newTurnCount <= turnCount) {\n                result = newPath;\n            }\n        }\n        return null;\n    });\n    return result;\n};\n\nconst getAdjustOptions = (path: Point[], centerOfAxis: number, isHorizontal: boolean) => {\n    const parallelPaths: [Point, Point][] = [];\n    let start: null | Point = null;\n    let pointOfHit: null | Point = null;\n    const axis = isHorizontal ? 0 : 1;\n\n    for (let index = 0; index < path.length; index++) {\n        const previous = path[index - 1];\n        const current = path[index];\n        if (start === null && previous && previous[axis] === current[axis]) {\n            start = previous;\n        }\n        if (start !== null) {\n            if (previous[axis] !== current[axis]) {\n                parallelPaths.push([start, previous]);\n                start = null;\n            }\n        }\n        if (current[axis] === centerOfAxis) {\n            pointOfHit = current;\n        }\n    }\n    if (start) {\n        parallelPaths.push([start, path[path.length - 1]]);\n    }\n    return { pointOfHit, parallelPaths };\n};\n\nexport const getGraphPoints = (options: ElbowLineRouteOptions) => {\n    const { nextSourcePoint, nextTargetPoint, sourceOuterRectangle, targetOuterRectangle } = options;\n    const x: number[] = [];\n    const y: number[] = [];\n    let result: Point[] = [];\n\n    [sourceOuterRectangle, targetOuterRectangle].forEach(rectangle => {\n        x.push(rectangle.x, rectangle.x + rectangle.width / 2, rectangle.x + rectangle.width);\n        y.push(rectangle.y, rectangle.y + rectangle.height / 2, rectangle.y + rectangle.height);\n    });\n    const rectanglesX = [\n        sourceOuterRectangle.x,\n        sourceOuterRectangle.x + sourceOuterRectangle.width,\n        targetOuterRectangle.x,\n        targetOuterRectangle.x + targetOuterRectangle.width\n    ].sort((a, b) => a - b);\n    x.push((rectanglesX[1] + rectanglesX[2]) / 2, nextSourcePoint[0], nextTargetPoint[0]);\n    const rectanglesY = [\n        sourceOuterRectangle.y,\n        sourceOuterRectangle.y + sourceOuterRectangle.height,\n        targetOuterRectangle.y,\n        targetOuterRectangle.y + targetOuterRectangle.height\n    ].sort((a, b) => a - b);\n    y.push((rectanglesY[1] + rectanglesY[2]) / 2, nextSourcePoint[1], nextTargetPoint[1]);\n    for (let i = 0; i < x.length; i++) {\n        for (let j = 0; j < y.length; j++) {\n            const point: Point = [x[i], y[j]];\n            const isInSource = RectangleClient.isPointInRectangle(sourceOuterRectangle, point);\n            const isInTarget = RectangleClient.isPointInRectangle(targetOuterRectangle, point);\n            if (!isInSource && !isInTarget) {\n                result.push(point);\n            }\n        }\n    }\n    result = removeDuplicatePoints(result).filter(point => {\n        const isInSource = RectangleClient.isPointInRectangle(sourceOuterRectangle, point);\n        const isInTarget = RectangleClient.isPointInRectangle(targetOuterRectangle, point);\n        return !isInSource && !isInTarget;\n    });\n    return result;\n};\n\nexport const createGraph = (points: Point[]) => {\n    const graph = new PointGraph();\n    const Xs: number[] = [];\n    const Ys: number[] = [];\n    points.forEach(p => {\n        const x = p[0],\n            y = p[1];\n        if (Xs.indexOf(x) < 0) Xs.push(x);\n        if (Ys.indexOf(y) < 0) Ys.push(y);\n        graph.add(p);\n    });\n    Xs.sort((a, b) => a - b);\n    Ys.sort((a, b) => a - b);\n    const inHotIndex = (p: Point): boolean => graph.has(p);\n    for (let i = 0; i < Xs.length; i++) {\n        for (let j = 0; j < Ys.length; j++) {\n            const point: Point = [Xs[i], Ys[j]];\n            if (!inHotIndex(point)) continue;\n            if (i > 0) {\n                const otherPoint: Point = [Xs[i - 1], Ys[j]];\n                if (inHotIndex(otherPoint)) {\n                    graph.connect(otherPoint, point);\n                    graph.connect(point, otherPoint);\n                }\n            }\n            if (j > 0) {\n                const otherPoint: Point = [Xs[i], Ys[j - 1]];\n                if (inHotIndex(otherPoint)) {\n                    graph.connect(otherPoint, point);\n                    graph.connect(point, otherPoint);\n                }\n            }\n        }\n    }\n    return graph;\n};\n\nexport const reduceRouteMargin = (sourceRectangle: RectangleClient, targetRectangle: RectangleClient) => {\n    const defaultOffset = DEFAULT_ROUTE_MARGIN;\n    let sourceOffset: number[] = new Array(4).fill(defaultOffset);\n    let targetOffset: number[] = new Array(4).fill(defaultOffset);\n    const leftToRight = sourceRectangle.x - (targetRectangle.x + targetRectangle.width);\n    const rightToLeft = targetRectangle.x - (sourceRectangle.x + sourceRectangle.width);\n    if (leftToRight > 0 && leftToRight < defaultOffset * 2) {\n        const offset = leftToRight / 2;\n        sourceOffset[3] = offset;\n        targetOffset[1] = offset;\n    }\n\n    if (rightToLeft > 0 && rightToLeft < defaultOffset * 2) {\n        const offset = rightToLeft / 2;\n        targetOffset[3] = offset;\n        sourceOffset[1] = offset;\n    }\n\n    const topToBottom = sourceRectangle.y - (targetRectangle.y + targetRectangle.height);\n    const bottomToTop = targetRectangle.y - (sourceRectangle.y + sourceRectangle.height);\n    if (topToBottom > 0 && topToBottom < defaultOffset * 2) {\n        const offset = topToBottom / 2;\n        sourceOffset[0] = offset;\n        targetOffset[2] = offset;\n    }\n    if (bottomToTop > 0 && bottomToTop < defaultOffset * 2) {\n        const offset = bottomToTop / 2;\n        sourceOffset[2] = offset;\n        targetOffset[0] = offset;\n    }\n    return { sourceOffset, targetOffset };\n};\n\nexport const getNextPoint = (point: Point, outerRectangle: RectangleClient, direction: Direction): Point => {\n    switch (direction) {\n        case Direction.top: {\n            return [point[0], outerRectangle.y];\n        }\n        case Direction.bottom: {\n            return [point[0], outerRectangle.y + outerRectangle.height];\n        }\n        case Direction.right: {\n            return [outerRectangle.x + outerRectangle.width, point[1]];\n        }\n        default: {\n            return [outerRectangle.x, point[1]];\n        }\n    }\n};\n\nexport const getSourceAndTargetOuterRectangle = (sourceRectangle: RectangleClient, targetRectangle: RectangleClient) => {\n    const { sourceOffset, targetOffset } = reduceRouteMargin(sourceRectangle, targetRectangle);\n    const sourceOuterRectangle = RectangleClient.expand(\n        sourceRectangle,\n        sourceOffset[3],\n        sourceOffset[0],\n        sourceOffset[1],\n        sourceOffset[2]\n    );\n    const targetOuterRectangle = RectangleClient.expand(\n        targetRectangle,\n        targetOffset[3],\n        targetOffset[0],\n        targetOffset[1],\n        targetOffset[2]\n    );\n    return {\n        sourceOuterRectangle,\n        targetOuterRectangle\n    };\n};\n\nexport const isSourceAndTargetIntersect = (options: ElbowLineRouteOptions) => {\n    const {\n        sourcePoint,\n        nextSourcePoint,\n        sourceRectangle,\n        sourceOuterRectangle,\n        targetPoint,\n        nextTargetPoint,\n        targetRectangle,\n        targetOuterRectangle\n    } = options;\n\n    return (\n        RectangleClient.isPointInRectangle(targetRectangle, sourcePoint) ||\n        RectangleClient.isPointInRectangle(targetOuterRectangle, nextSourcePoint) ||\n        RectangleClient.isPointInRectangle(sourceOuterRectangle, nextTargetPoint) ||\n        RectangleClient.isPointInRectangle(sourceRectangle, targetPoint)\n    );\n};\n", "import { PlaitElement } from '@plait/core';\n\nconst map = new Map<string, any>();\n\nexport const memorizeLatest = <T extends PlaitElement = PlaitElement>(\n    memorizedKey: string,\n    propertyKey: keyof T,\n    propertyValue: T[keyof T]\n) => {\n    let obj = map.has(memorizedKey) ? map.get(memorizedKey) : {};\n    obj[propertyKey] = propertyValue;\n    map.set(memorizedKey, obj);\n};\n\nexport const getMemorizedLatest = <T extends PlaitElement = PlaitElement>(memorizedKey: string): T => {\n    return map.get(memorizedKey);\n};\n", "import { PlaitBoard, setDragging } from '@plait/core';\nimport { RotateRef } from '../types';\n\nexport const IS_ROTATING = new WeakMap<PlaitBoard, RotateRef>();\n\nexport const isRotating = (board: PlaitBoard) => {\n    return !!IS_ROTATING.get(board);\n};\n\nexport const addRotating = (board: PlaitBoard, rotateRef: RotateRef) => {\n    PlaitBoard.getBoardContainer(board).classList.add(`draw-elements-rotating`);\n    IS_ROTATING.set(board, rotateRef);\n    setDragging(board, true);\n};\n\nexport const removeRotating = (board: PlaitBoard) => {\n    PlaitBoard.getBoardContainer(board).classList.remove(`draw-elements-rotating`);\n    IS_ROTATING.delete(board);\n    setDragging(board, false);\n};\n", "import { PlaitBoard, PlaitElement } from '@plait/core';\nimport { DEFAULT_FILL, TRANSPARENT } from '../constants';\n\nexport const getElementArea = (board: PlaitBoard, element: PlaitElement) => {\n    const rectangle = board.getRectangle(element);\n    if (rectangle) {\n        return rectangle.width * rectangle.height;\n    }\n    return 0;\n};\n\nexport const sortElementsByArea = (board: PlaitBoard, elements: PlaitElement[], direction: 'desc' | 'asc' = 'asc') => {\n    return elements.sort((a, b) => {\n        const areaA = getElementArea(board, a);\n        const areaB = getElementArea(board, b);\n        return direction === 'asc' ? areaA - areaB : areaB - areaA;\n    });\n};\n\nexport const isFilled = (fill: string) => {\n    return fill && fill !== DEFAULT_FILL && fill !== TRANSPARENT;\n};\n", "export type AnimateOption = { stop: () => void; start: () => void };\n\nexport function animate(tween: (t: number) => void, duration: number, ease: Function, callback: Function): AnimateOption {\n    const start = getTimestamp();\n    let stopAnimation = false;\n\n    function tick(now: number) {\n        if (stopAnimation) {\n            return;\n        }\n        const elapsed = now - start;\n        const t = Math.min(elapsed / duration, 1);\n        tween(ease(t));\n        if (t < 1) {\n            requestAnimationFrame(tick);\n        } else if (callback) {\n            callback();\n        }\n    }\n\n    requestAnimationFrame(tick);\n    return {\n        stop: () => (stopAnimation = true),\n        start: () => {\n            stopAnimation = false;\n            requestAnimationFrame(tick);\n        }\n    };\n}\n\nexport function getTimestamp() {\n    if (window.performance && window.performance.now) {\n        return window.performance.now();\n    } else {\n        return Date.now();\n    }\n}\n\nexport function linear(t: number) {\n    return t;\n}\n", "import { StrokeStyle } from '../constants';\n\nexport const getStrokeLineDash = (strokeStyle: StrokeStyle, strokeWidth: number) => {\n    switch (strokeStyle) {\n        case StrokeStyle.dashed:\n            return [8, 8 + strokeWidth];\n        case StrokeStyle.dotted:\n            return [2, 4 + strokeWidth];\n        default:\n            return undefined;\n    }\n};\n", "import { idCreator, PlaitBoard, PlaitElement, Point, Transforms } from '@plait/core';\n\nexport const buildClipboardData = (\n    board: PlaitBoard,\n    elements: PlaitElement[],\n    startPoint: Point,\n    elementBuilder?: (element: PlaitElement) => PlaitElement | undefined\n) => {\n    return elements.map(element => {\n        const newElement = elementBuilder && elementBuilder(element);\n        if (newElement) {\n            return newElement;\n        }\n        if (element.points) {\n            const points = element.points.map(point => [point[0] - startPoint[0], point[1] - startPoint[1]]);\n            return { ...element, points };\n        }\n        return element;\n    });\n};\n\nexport const insertClipboardData = (\n    board: PlaitBoard,\n    elements: PlaitElement[],\n    startPoint: Point,\n    elementHandler?: (element: PlaitElement, idsMap: Record<string, string>) => void\n) => {\n    const idsMap: Record<string, string> = {};\n    elements.forEach(element => {\n        idsMap[element.id] = idCreator();\n    });\n    elements.forEach(element => {\n        element.id = idsMap[element.id];\n        elementHandler && elementHandler(element, idsMap);\n        if (element.points) {\n            element.points = element.points.map(point => [startPoint[0] + point[0], startPoint[1] + point[1]]) as [Point, Point];\n        }\n        Transforms.insertNode(board, element, [board.children.length]);\n    });\n    Transforms.addSelectionWithTemporaryElements(board, elements);\n};\n", "import { Direction, Point } from '@plait/core';\n\n// Based on right\n// Right -> Left:\n// 1. End point -> starting point/start point -> end point\n// 2. Add -> Subtract\n\n// Horizontal -> Vertical:\n// 1. Starting point/end point -> vertical axis\n// 2. Addition and subtraction -> vertical axis\n\n// Bottom -> Top:\n// 1. End point -> starting point/end point -> starting point\n// 2. Add -> Subtract\nexport const moveXOfPoint = (point: Point, distance: number, direction: Direction = Direction.right): Point => {\n    if (direction === Direction.left) {\n        return [point[0] - distance, point[1]];\n    }\n    if (direction === Direction.bottom) {\n        return [point[0], point[1] + distance];\n    }\n    if (direction === Direction.top) {\n        return [point[0], point[1] - distance];\n    }\n    return [point[0] + distance, point[1]];\n};\n\nexport const moveYOfPoint = (point: Point, distance: number, direction: Direction = Direction.right): Point => {\n    if (direction === Direction.bottom) {\n        return [point[0] + distance, point[1]];\n    }\n    if (direction === Direction.top) {\n        return [point[0] + distance, point[1]];\n    }\n    return [point[0], point[1] + distance];\n};\n\nexport const getDirectionByIndex = (index: number) => {\n    if (index === 0) {\n        return Direction.top;\n    }\n    if (index === 1) {\n        return Direction.right;\n    }\n    if (index === 2) {\n        return Direction.bottom;\n    }\n    if (index === 3) {\n        return Direction.left;\n    }\n    return Direction.right;\n};\n\nexport const getXDistanceBetweenPoint = (point1: Point, point2: Point, isHorizontal: boolean) => {\n    if (isHorizontal) {\n        return Math.abs(point1[0] - point2[0]);\n    } else {\n        return Math.abs(point1[1] - point2[1]);\n    }\n};\n", "import {\n    ACTIVE_STROKE_WIDTH,\n    PlaitBoard,\n    PlaitElement,\n    RectangleClient,\n    createForeignObject,\n    createG,\n    getSelectedElements,\n    isSelectionMoving,\n    setAngleForG,\n    updateForeignObject\n} from '@plait/core';\nimport { Generator, GeneratorExtraData, GeneratorOptions } from '../generators/generator';\nimport { CommonImageItem, hasResizeHandle, getElementOfFocusedImage } from '../utils';\nimport { ActiveGenerator, createActiveGenerator } from '../generators/active.generator';\nimport { PlaitImageBoard, ImageComponentRef, ImageProps } from './with-image';\n\nexport const FOREIGN_OBJECT_IMAGE_CLASS_NAME = 'foreign-object-image';\n\nexport interface ImageGeneratorOptions<T> {\n    getRectangle: (element: T) => RectangleClient;\n    getImageItem: (element: T) => CommonImageItem;\n}\n\nexport class ImageGenerator<T extends PlaitElement = PlaitElement> extends Generator<\n    T,\n    GeneratorExtraData,\n    ImageGeneratorOptions<T> & GeneratorOptions\n> {\n    static key = 'image-generator';\n\n    foreignObject!: SVGForeignObjectElement;\n\n    imageComponentRef!: ImageComponentRef;\n\n    activeGenerator!: ActiveGenerator;\n\n    isFocus = false;\n\n    element!: T;\n\n    constructor(public board: PlaitBoard, public options: ImageGeneratorOptions<T>) {\n        super(board, options);\n    }\n\n    canDraw(element: T): boolean {\n        return !!this.options.getImageItem(element);\n    }\n\n    draw(element: T): SVGGElement {\n        this.element = element;\n        const g = createG();\n        const foreignRectangle = this.options.getRectangle(element);\n        this.foreignObject = createForeignObject(foreignRectangle.x, foreignRectangle.y, foreignRectangle.width, foreignRectangle.height);\n        this.foreignObject.classList.add(FOREIGN_OBJECT_IMAGE_CLASS_NAME);\n        g.append(this.foreignObject);\n        const props: ImageProps = {\n            board: this.board,\n            imageItem: this.options.getImageItem(element),\n            element,\n            getRectangle: () => {\n                return this.options.getRectangle(element);\n            }\n        };\n        this.imageComponentRef = (this.board as unknown as PlaitImageBoard).renderImage(this.foreignObject, props);\n\n        this.activeGenerator = createActiveGenerator(this.board, {\n            getStrokeWidth: () => {\n                const selectedElements = getSelectedElements(this.board);\n                if (!(selectedElements.length === 1 && !isSelectionMoving(this.board))) {\n                    return ACTIVE_STROKE_WIDTH;\n                } else {\n                    return ACTIVE_STROKE_WIDTH;\n                }\n            },\n            getStrokeOpacity: () => {\n                const selectedElements = getSelectedElements(this.board);\n                if ((selectedElements.length === 1 && !isSelectionMoving(this.board)) || !selectedElements.length) {\n                    return 1;\n                } else {\n                    return 0.5;\n                }\n            },\n            getRectangle: () => {\n                return this.options.getRectangle(this.element);\n            },\n            hasResizeHandle: () => {\n                const isSelectedImageElement = hasResizeHandle(this.board, this.element);\n                const isSelectedImage = !!getElementOfFocusedImage(this.board);\n                return isSelectedImage || isSelectedImageElement;\n            }\n        });\n        return g;\n    }\n\n    updateImage(nodeG: SVGGElement, previous: T, current: T) {\n        this.element = current;\n        if (previous !== current && this.imageComponentRef) {\n            const props = {\n                imageItem: this.options.getImageItem(current),\n                element: current,\n                getRectangle: () => {\n                    return this.options.getRectangle(current);\n                }\n            };\n            this.imageComponentRef.update(props);\n        }\n        const currentForeignObject = this.options.getRectangle(current);\n        updateForeignObject(\n            this.g!,\n            currentForeignObject.width,\n            currentForeignObject.height,\n            currentForeignObject.x,\n            currentForeignObject.y\n        );\n        if (currentForeignObject && current.angle !== undefined) {\n            setAngleForG(this.g!, RectangleClient.getCenterPoint(currentForeignObject), current.angle);\n        }\n        const activeG = PlaitBoard.getActiveHost(this.board);\n        this.activeGenerator.processDrawing(current, activeG, { selected: this.isFocus });\n    }\n\n    setFocus(element: PlaitElement, isFocus: boolean) {\n        this.isFocus = isFocus;\n        const activeG = PlaitBoard.getActiveHost(this.board);\n        this.activeGenerator.processDrawing(element, activeG, { selected: isFocus });\n        const props: Partial<ImageProps> = {\n            isFocus\n        };\n        this.imageComponentRef.update(props);\n    }\n\n    destroy(): void {\n        super.destroy();\n        this.imageComponentRef?.destroy();\n        this.activeGenerator?.destroy();\n    }\n}\n", "import { Path, PlaitBoard, PlaitElement, Transforms, getSelectedElements } from '@plait/core';\nimport { memorizeLatest } from '../utils';\n\nexport interface SetOptions<T extends PlaitElement = PlaitElement> {\n    callback?: (element: T, path: Path) => void;\n    getMemorizeKey?: (element: T) => string;\n    match?: (element: T) => boolean;\n}\n\nexport const setProperty = <T extends PlaitElement = PlaitElement>(board: PlaitBoard, properties: Partial<T>, options?: SetOptions<T>) => {\n    const selectedElements = getSelectedElements(board) as T[];\n    selectedElements.forEach(element => {\n        if (options?.match && !options?.match(element)) return;\n        const path = PlaitBoard.findPath(board, element);\n        const memorizeKey = options?.getMemorizeKey ? options?.getMemorizeKey(element) : '';\n        for (let key in properties) {\n            memorizeKey && memorizeLatest(memorizeKey, key, properties[key]);\n        }\n        if (options?.callback) {\n            options.callback(element, path);\n        } else {\n            Transforms.setNode(board, properties, path);\n        }\n    });\n};\n\nconst setStrokeStyle = (board: PlaitBoard, strokeStyle: string, options: SetOptions) => {\n    setProperty(board, { strokeStyle }, options);\n};\n\nconst setFillColor = (board: PlaitBoard, fill: string | null, options: SetOptions) => {\n    setProperty(board, { fill }, options);\n};\n\nconst setStrokeColor = (board: PlaitBoard, strokeColor: string | null, options: SetOptions) => {\n    setProperty(board, { strokeColor }, options);\n};\n\nconst setStrokeWidth = (board: PlaitBoard, strokeWidth: number, options: SetOptions) => {\n    setProperty(board, { strokeWidth }, options);\n};\n\nexport const PropertyTransforms = {\n    setFillColor,\n    setStrokeStyle,\n    setProperty,\n    setStrokeWidth,\n    setStrokeColor\n};\n", "import {\n    MERGING,\n    PlaitBoard,\n    PlaitElement,\n    PlaitGroupElement,\n    Point,\n    RectangleClient,\n    Transforms,\n    getElementsInGroup,\n    getHighestSelectedElements,\n    getRectangleByElements\n} from '@plait/core';\n\nexport const alignTop = (board: PlaitBoard) => {\n    function getOffset(outerRectangle: RectangleClient, rectangle: RectangleClient) {\n        return [0, outerRectangle.y - rectangle.y] as Point;\n    }\n    setOffset(board, getOffset);\n};\n\nexport const alignBottom = (board: PlaitBoard) => {\n    function getOffset(outerRectangle: RectangleClient, rectangle: RectangleClient) {\n        return [0, outerRectangle.y + outerRectangle.height - (rectangle.y + rectangle.height)] as Point;\n    }\n    setOffset(board, getOffset);\n};\n\nexport const alignLeft = (board: PlaitBoard) => {\n    function getOffset(outerRectangle: RectangleClient, rectangle: RectangleClient) {\n        return [outerRectangle.x - rectangle.x, 0] as Point;\n    }\n    setOffset(board, getOffset);\n};\n\nexport const alignHorizontalCenter = (board: PlaitBoard) => {\n    function getOffset(outerRectangle: RectangleClient, rectangle: RectangleClient) {\n        const outerCenter = outerRectangle.x + outerRectangle.width / 2;\n        const elementCenter = rectangle.x + rectangle.width / 2;\n        return [outerCenter - elementCenter, 0] as Point;\n    }\n    setOffset(board, getOffset);\n};\n\nexport const alignVerticalCenter = (board: PlaitBoard) => {\n    function getOffset(outerRectangle: RectangleClient, rectangle: RectangleClient) {\n        const outerCenter = outerRectangle.y + outerRectangle.height / 2;\n        const elementCenter = rectangle.y + rectangle.height / 2;\n        return [0, outerCenter - elementCenter] as Point;\n    }\n    setOffset(board, getOffset);\n};\n\nexport const alignRight = (board: PlaitBoard) => {\n    function getOffset(outerRectangle: RectangleClient, rectangle: RectangleClient) {\n        return [outerRectangle.x + outerRectangle.width - (rectangle.x + rectangle.width), 0] as Point;\n    }\n    setOffset(board, getOffset);\n};\n\nfunction setOffset(board: PlaitBoard, getOffset: (outerRectangle: RectangleClient, rectangle: RectangleClient) => Point) {\n    const elements = getHighestSelectedElements(board);\n    const outerRectangle = getRectangleByElements(board, elements, false);\n    elements.forEach(element => {\n        if (!element.points && !PlaitGroupElement.isGroup(element)) return;\n        const rectangle = board.getRectangle(element)!;\n        const offset = getOffset(outerRectangle, rectangle);\n        let updateElements: PlaitElement[] = [];\n        if (PlaitGroupElement.isGroup(element)) {\n            updateElements = getElementsInGroup(board, element, true, false);\n        } else if (element.points) {\n            updateElements = [element];\n        }\n        updateElements.forEach(item => {\n            const newPoints = item.points!.map(p => [p[0] + offset[0], p[1] + offset[1]]) as Point[];\n            const path = PlaitBoard.findPath(board, item);\n            Transforms.setNode(\n                board,\n                {\n                    points: newPoints\n                },\n                path\n            );\n        });\n        MERGING.set(board, true);\n    });\n    MERGING.set(board, false);\n}\n\nexport const distributeHorizontal = (board: PlaitBoard) => {\n    distribute(board, true);\n};\n\nexport const distributeVertical = (board: PlaitBoard) => {\n    distribute(board, false);\n};\n\nconst distribute = (board: PlaitBoard, isHorizontal: boolean) => {\n    const axis = isHorizontal ? 'x' : 'y';\n    const side = isHorizontal ? 'width' : 'height';\n    const highestSelectedElements = getHighestSelectedElements(board);\n    const refs = highestSelectedElements.map(element => {\n        return { element, rectangle: board.getRectangle(element)! };\n    });\n    const outerRectangle = getRectangleByElements(board, highestSelectedElements, false);\n    const minRectangleRef = refs.sort((a, b) => a.rectangle[axis] - b.rectangle[axis])[0];\n    const maxRectangleRef = refs.sort((a, b) => b.rectangle[axis] + b.rectangle[side] - (a.rectangle[axis] + a.rectangle[side]))[0];\n    const minIndex = refs.findIndex(ref => ref === minRectangleRef);\n    const maxIndex = refs.findIndex(ref => ref === maxRectangleRef);\n    let distributeRefs = refs.filter((element, index) => index !== minIndex && index !== maxIndex);\n    const sum = distributeRefs.reduce((accumulator, current) => current.rectangle[side] + accumulator, 0);\n    const offset =\n        (outerRectangle[side] - minRectangleRef.rectangle[side] - maxRectangleRef.rectangle[side] - sum) / (distributeRefs.length + 1);\n    distributeRefs = distributeRefs.sort((a, b) => a.rectangle[axis] - b.rectangle[axis]);\n    let position = minRectangleRef.rectangle[axis] + minRectangleRef.rectangle[side] + offset;\n    for (let i = 0; i < distributeRefs.length; i++) {\n        const rectangle = distributeRefs[i].rectangle;\n        const moveOffset = [0, 0];\n        const moveAxis = isHorizontal ? 0 : 1;\n        moveOffset[moveAxis] = position - rectangle[axis];\n        const path = PlaitBoard.findPath(board, distributeRefs[i].element);\n        const newPoints = distributeRefs[i].element.points!.map(p => [p[0] + moveOffset[0], p[1] + moveOffset[1]]) as Point[];\n        Transforms.setNode(\n            board,\n            {\n                points: newPoints\n            },\n            path\n        );\n        MERGING.set(board, true);\n        position = position + rectangle[side] + offset;\n    }\n    MERGING.set(board, false);\n};\n\nexport interface AlignTransform {\n    alignTop: (board: PlaitBoard) => void;\n    alignHorizontalCenter: (board: PlaitBoard) => void;\n    alignBottom: (board: PlaitBoard) => void;\n    alignLeft: (board: PlaitBoard) => void;\n    alignVerticalCenter: (board: PlaitBoard) => void;\n    alignRight: (board: PlaitBoard) => void;\n    distributeHorizontal: (board: PlaitBoard) => void;\n    distributeVertical: (board: PlaitBoard) => void;\n}\n\nexport const AlignTransform: AlignTransform = {\n    alignTop,\n    alignHorizontalCenter,\n    alignBottom,\n    alignLeft,\n    alignVerticalCenter,\n    alignRight,\n    distributeHorizontal,\n    distributeVertical\n};\n", "import { Point } from '@plait/core';\n\nexport const normalizeShapePoints = (points: [Point, Point], shift: boolean = false): [Point, Point] => {\n    let start = points[0];\n    let end = points[1];\n    if (shift) {\n        const width = Math.abs(start[0] - end[0]);\n        const height = Math.abs(start[1] - end[1]);\n        const edge = Math.max(height, width);\n        end = [start[0] + (end[0] > start[0] ? edge : -edge), start[1] + (end[1] > start[1] ? edge : -edge)];\n    }\n\n    const leftTopPoint: Point = [Math.min(start[0], end[0]), Math.min(start[1], end[1])];\n    let rightBottomPoint: Point = [Math.max(start[0], end[0]), Math.max(start[1], end[1])];\n\n    return [leftTopPoint, rightBottomPoint];\n};\n", "import {\n    MERGING,\n    PRESS_AND_MOVE_BUFFER,\n    PlaitBoard,\n    PlaitPointerType,\n    Point,\n    distanceBetweenPointAndPoint,\n    isMainPointer,\n    throttleRAF,\n    toViewBoxPoint,\n    toHostPoint,\n    isDragging\n} from '@plait/core';\nimport { ResizeHandle } from '../constants/resize';\nimport { addResizing, isResizing, removeResizing } from '../utils/resize';\nimport { PlaitElementOrArray, ResizeOptions, ResizeHitTestRef, ResizeRef, WithResizeOptions } from '../types/resize';\n\nconst generalCanResize = (board: PlaitBoard, event: PointerEvent) => {\n    return (\n        !PlaitBoard.isReadonly(board) && !PlaitBoard.hasBeenTextEditing(board) && PlaitBoard.isPointer(board, PlaitPointerType.selection)\n    );\n};\n\nexport const withResize = <T extends PlaitElementOrArray = PlaitElementOrArray, K = ResizeHandle, P = ResizeOptions>(\n    board: PlaitBoard,\n    options: WithResizeOptions<T, K, P>\n) => {\n    const { pointerDown, pointerMove, globalPointerUp } = board;\n    let resizeHitTestRef: ResizeHitTestRef<T, K, P> | null = null;\n    let resizeRef: ResizeRef<T, K, P> | null = null;\n    let startPoint: Point | null = null;\n    let hoverHitTestRef: ResizeHitTestRef<T, K, P> | null = null;\n\n    board.pointerDown = (event: PointerEvent) => {\n        if (!options.canResize() || !generalCanResize(board, event) || !isMainPointer(event)) {\n            pointerDown(event);\n            return;\n        }\n        const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n        resizeHitTestRef = options.hitTest(point);\n        if (resizeHitTestRef) {\n            if (resizeHitTestRef.cursorClass) {\n                PlaitBoard.getBoardContainer(board).classList.add(`${resizeHitTestRef.cursorClass}`);\n            }\n            startPoint = [event.x, event.y];\n            const path = Array.isArray(resizeHitTestRef.element)\n                ? resizeHitTestRef.element.map(el => PlaitBoard.findPath(board, el))\n                : PlaitBoard.findPath(board, resizeHitTestRef.element);\n            resizeRef = {\n                path,\n                element: resizeHitTestRef.element,\n                handle: resizeHitTestRef.handle,\n                handleIndex: resizeHitTestRef.handleIndex,\n                rectangle: resizeHitTestRef.rectangle,\n                options: resizeHitTestRef.options\n            };\n            return;\n        }\n        pointerDown(event);\n    };\n\n    board.pointerMove = (event: PointerEvent) => {\n        if (!options.canResize() || !generalCanResize(board, event)) {\n            clearHoverHitTestRef();\n            pointerMove(event);\n            return;\n        }\n        if (startPoint && resizeHitTestRef && !isResizing(board)) {\n            const endPoint = [event.x, event.y];\n            const distance = distanceBetweenPointAndPoint(startPoint[0], startPoint[1], endPoint[0], endPoint[1]);\n            if (distance > PRESS_AND_MOVE_BUFFER) {\n                addResizing(board, resizeRef!, options.key);\n                MERGING.set(board, true);\n                options.beforeResize && options.beforeResize(resizeRef!);\n            }\n        }\n        if (!isResizing(board) && !isDragging(board)) {\n            const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n            throttleRAF(board, options.key + '-common-resize-hit-test', () => {\n                const hitTestRef = options.hitTest(point);\n                if (hitTestRef) {\n                    if (hoverHitTestRef && hitTestRef.cursorClass !== hoverHitTestRef.cursorClass) {\n                        PlaitBoard.getBoardContainer(board).classList.remove(`${hoverHitTestRef.cursorClass}`);\n                    }\n                    hoverHitTestRef = hitTestRef;\n                    if (hoverHitTestRef.cursorClass) {\n                        PlaitBoard.getBoardContainer(board).classList.add(`${hoverHitTestRef.cursorClass}`);\n                    }\n                } else {\n                    clearHoverHitTestRef();\n                }\n            });\n        } else {\n            if (startPoint && isResizing(board)) {\n                event.preventDefault();\n                const endPoint = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n                throttleRAF(board, 'with-common-resize', () => {\n                    if (startPoint && resizeRef) {\n                        options.onResize(resizeRef, {\n                            startPoint: toViewBoxPoint(board, toHostPoint(board, startPoint[0], startPoint[1])),\n                            endPoint,\n                            isShift: !!event.shiftKey\n                        });\n                    }\n                });\n                return;\n            }\n        }\n        pointerMove(event);\n    };\n\n    board.globalPointerUp = (event: PointerEvent) => {\n        globalPointerUp(event);\n        if (isResizing(board) || resizeHitTestRef) {\n            options.afterResize && options.afterResize(resizeRef!);\n            removeResizing(board, options.key);\n            startPoint = null;\n            resizeHitTestRef = null;\n            resizeRef = null;\n            MERGING.set(board, false);\n        }\n    };\n\n    const clearHoverHitTestRef = () => {\n        if (hoverHitTestRef) {\n            if (hoverHitTestRef.cursorClass) {\n                PlaitBoard.getBoardContainer(board).classList.remove(`${hoverHitTestRef.cursorClass}`);\n            }\n            hoverHitTestRef = null;\n        }\n    };\n\n    return board;\n};\n", "import { ACTIVE_STROKE_WIDTH, PlaitGroup, RectangleClient, drawRectangle, getRectangleByGroup } from '@plait/core';\nimport { Options } from 'roughjs/bin/core';\nimport { Generator } from './generator';\n\nexport class GroupGenerator extends Generator<PlaitGroup> {\n    canDraw(element: PlaitGroup): boolean {\n        return true;\n    }\n\n    draw(element: PlaitGroup, partialSelected: boolean) {\n        const options: Options = {\n            stroke: '',\n            strokeWidth: ACTIVE_STROKE_WIDTH,\n            strokeLineDash: [5]\n        };\n        let rectangle: RectangleClient = { x: 0, y: 0, width: 0, height: 0 };\n        if (partialSelected) {\n            options.stroke = '#999';\n            rectangle = getRectangleByGroup(this.board, element, true);\n        }\n        return drawRectangle(this.board, rectangle, options);\n    }\n}\n", "import { PlaitElementRef } from '@plait/core';\nimport { Generator } from '../generators';\nimport { TextManage } from '../text';\n\nexport class PlaitCommonElementRef implements PlaitElementRef {\n    private textManages: TextManage[] = [];\n\n    private generatorMap = new Map<string, Generator | Object>();\n\n    addGenerator<T extends Object = Generator>(key: string, generator: T) {\n        this.generatorMap.set(key, generator);\n    }\n\n    getGenerator<T extends Object = Generator>(key: string) {\n        return this.generatorMap.get(key) as T;\n    }\n\n    initializeTextManage(textManage: TextManage | TextManage[]) {\n        this.textManages = [];\n        if (Array.isArray(textManage)) {\n            this.textManages.push(...textManage);\n        } else {\n            this.textManages.push(textManage);\n        }\n    }\n\n    getTextManages() {\n        return this.textManages;\n    }\n\n    updateActiveSection = () => {};\n\n    destroyTextManage() {\n        this.textManages.forEach((textManage) => {\n            textManage.destroy();\n        });\n        this.textManages = [];\n    }\n}\n", "import { ElementFlavour, PlaitBoard, PlaitElement } from '@plait/core';\nimport { PlaitCommonElementRef } from './element-ref';\n\nexport class CommonElementFlavour<\n    T extends PlaitElement = PlaitElement,\n    K extends PlaitBoard = PlaitBoard,\n    R extends PlaitCommonElementRef = PlaitCommonElementRef\n> extends ElementFlavour<T, K, R> {\n    constructor(elementRef = new PlaitCommonElementRef()) {\n        super(elementRef as R);\n    }\n}\n", "import {\n    OnContextChanged,\n    PlaitBoard,\n    PlaitGroup,\n    PlaitPluginElementContext,\n    getElementsInGroup,\n    getRectangleByGroup,\n    isSelectedElementOrGroup,\n    isSelectionMoving\n} from '@plait/core';\nimport { GroupGenerator } from '../generators/group.generator';\nimport { ActiveGenerator, createActiveGenerator } from '../generators';\nimport { CommonElementFlavour } from './element-flavour';\nimport { Subscription } from 'rxjs';\n\nexport class GroupComponent extends CommonElementFlavour<PlaitGroup, PlaitBoard> implements OnContextChanged<PlaitGroup, PlaitBoard> {\n    onStableSubscription?: Subscription;\n\n    constructor() {\n        super();\n    }\n\n    activeGenerator!: ActiveGenerator<PlaitGroup>;\n\n    groupGenerator!: GroupGenerator;\n\n    initializeGenerator() {\n        this.activeGenerator = createActiveGenerator<PlaitGroup>(this.board, {\n            getRectangle: (element: PlaitGroup) => {\n                return getRectangleByGroup(this.board, element);\n            },\n            getStrokeWidth: () => 0,\n            getStrokeOpacity: () => 0,\n            hasResizeHandle: () => {\n                return !isSelectionMoving(this.board);\n            }\n        });\n        this.groupGenerator = new GroupGenerator(this.board);\n    }\n\n    initialize(): void {\n        super.initialize();\n        this.initializeGenerator();\n        const contextService = PlaitBoard.getBoardContext(this.board);\n        this.onStableSubscription = contextService.onStable().subscribe(() => {\n            const elementsInGroup = getElementsInGroup(this.board, this.element, false, true);\n            const isPartialSelectGroup =\n                elementsInGroup.some(item => isSelectedElementOrGroup(this.board, item)) &&\n                !elementsInGroup.every(item => isSelectedElementOrGroup(this.board, item));\n            this.groupGenerator.processDrawing(this.element, this.getElementG(), isPartialSelectGroup);\n        });\n    }\n\n    onContextChanged(\n        value: PlaitPluginElementContext<PlaitGroup, PlaitBoard>,\n        previous: PlaitPluginElementContext<PlaitGroup, PlaitBoard>\n    ) {}\n\n    destroy(): void {\n        super.destroy();\n        this.onStableSubscription?.unsubscribe();\n    }\n}\n", "import {\n    PlaitBoard,\n    PlaitPluginElementContext,\n    PlaitGroupElement,\n    toViewBoxPoint,\n    toHostPoint,\n    getHitElementsBySelection,\n    createGroupRectangleG,\n    ClipboardData,\n    getHighestSelectedGroups,\n    getSelectedIsolatedElements,\n    PlaitElement,\n    PlaitGroup,\n    getSelectedGroups,\n    Selection,\n    Point,\n    Transforms,\n    idCreator,\n    getGroupByElement,\n    getSelectedIsolatedElementsCanAddToGroup,\n    getElementsInGroup,\n    getRectangleByGroup,\n    PlaitPointerType,\n    WritableClipboardOperationType,\n    throttleRAF,\n    isMovingElements\n} from '@plait/core';\nimport { GroupComponent } from '../core/group.component';\nimport { isKeyHotkey } from 'is-hotkey';\nimport { isResizing } from '../utils';\n\nexport function withGroup(board: PlaitBoard) {\n    let groupRectangleG: SVGGElement | null;\n    let removeGroups: PlaitGroup[] | null;\n\n    const {\n        drawElement,\n        pointerMove,\n        globalPointerUp,\n        insertFragment,\n        getDeletedFragment,\n        deleteFragment,\n        getRelatedFragment,\n        getRectangle,\n        keyDown\n    } = board;\n\n    board.drawElement = (context: PlaitPluginElementContext) => {\n        if (PlaitGroupElement.isGroup(context.element)) {\n            return GroupComponent;\n        }\n        return drawElement(context);\n    };\n\n    board.pointerMove = (event: PointerEvent) => {\n        throttleRAF(board, 'with-group', () => {\n            groupRectangleG?.remove();\n            const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n            let selection: Selection = { anchor: point, focus: point };\n            if (board.selection && !Selection.isCollapsed(board.selection)) {\n                selection = board.selection;\n            }\n            const pointer = PlaitBoard.getPointer(board);\n            if (!isResizing(board) && !isMovingElements(board) && pointer === PlaitPointerType.selection) {\n                const hitElements = getHitElementsBySelection(board, selection);\n                if (hitElements.length) {\n                    groupRectangleG = createGroupRectangleG(board, hitElements);\n                    groupRectangleG && PlaitBoard.getElementTopHost(board).append(groupRectangleG);\n                }\n            }\n        });\n        pointerMove(event);\n    };\n\n    board.globalPointerUp = (event: PointerEvent) => {\n        groupRectangleG?.remove();\n        groupRectangleG = null;\n        globalPointerUp(event);\n    };\n\n    board.getRelatedFragment = (elements: PlaitElement[], originData?: PlaitElement[]) => {\n        const groups = getSelectedGroups(board, elements, originData);\n        return getRelatedFragment([...elements, ...groups], originData);\n    };\n\n    board.insertFragment = (clipboardData: ClipboardData | null, targetPoint: Point, operationType?: WritableClipboardOperationType) => {\n        let elements: PlaitElement[] = [];\n        if (clipboardData?.elements?.length) {\n            elements = new Array(clipboardData?.elements?.length);\n            const groups = getHighestSelectedGroups(board, clipboardData?.elements);\n            const selectedIsolatedElements = getSelectedIsolatedElements(board, clipboardData?.elements);\n            selectedIsolatedElements.forEach((item) => {\n                const index = clipboardData.elements!.map((element) => element.id).indexOf(item.id);\n                elements.splice(index, 1, !item.groupId ? item : updateGroupId(item, undefined));\n            });\n            if (groups.length) {\n                groups.forEach((item) => {\n                    const index = clipboardData.elements!.map((element) => element.id).indexOf(item.id);\n                    const newGroup = { ...updateGroupId(item, undefined), id: idCreator() };\n                    elements.splice(index, 1, newGroup);\n                    updateElementsGroupId(item, clipboardData.elements!, newGroup.id, elements);\n                });\n            }\n            clipboardData.elements = elements;\n        }\n        insertFragment(clipboardData, targetPoint, operationType);\n        const groupElements = elements?.filter((value) => PlaitGroupElement.isGroup(value)) as PlaitElement[];\n        groupElements.forEach((element) => {\n            Transforms.insertNode(board, element, [board.children.length]);\n        });\n    };\n\n    board.getDeletedFragment = (data: PlaitElement[]) => {\n        removeGroups = getRemoveGroups(board);\n        if (removeGroups && removeGroups.length) {\n            data.push(...removeGroups);\n        }\n        return getDeletedFragment(data);\n    };\n\n    board.deleteFragment = (elements: PlaitElement[]) => {\n        if (removeGroups?.length) {\n            updateSiblingElementGroupId(board, removeGroups);\n        }\n        deleteFragment(elements);\n        removeGroups = null;\n    };\n\n    board.getRectangle = (element: PlaitElement) => {\n        if (PlaitGroupElement.isGroup(element)) {\n            return getRectangleByGroup(board, element, true);\n        }\n        return getRectangle(element);\n    };\n\n    board.keyDown = (event: KeyboardEvent) => {\n        if (!PlaitBoard.isReadonly(board)) {\n            if (isKeyHotkey('mod+g', event)) {\n                event.preventDefault();\n                Transforms.addGroup(board);\n                return;\n            }\n            if (isKeyHotkey('mod+shift+g', event)) {\n                event.preventDefault();\n                Transforms.removeGroup(board);\n                return;\n            }\n        }\n        keyDown(event);\n    };\n\n    return board;\n}\n\nconst updateGroupId = (element: PlaitElement, groupId?: string) => {\n    return {\n        ...element,\n        groupId: groupId\n    };\n};\n\nconst updateElementsGroupId = (group: PlaitGroup, clipboardDataElements: PlaitElement[], newGroupId: string, elements: PlaitElement[]) => {\n    const elementsInGroup = clipboardDataElements.filter((item) => item.groupId === group.id);\n    if (elementsInGroup.length) {\n        elementsInGroup.forEach((item) => {\n            const index = clipboardDataElements.map((item) => item.id).indexOf(item.id);\n            if (PlaitGroupElement.isGroup(item)) {\n                const newGroup = { ...updateGroupId(item, newGroupId), id: idCreator() };\n                elements.splice(index, 1, newGroup);\n                updateElementsGroupId(item, clipboardDataElements, newGroup.id, elements);\n            } else {\n                elements.splice(index, 1, updateGroupId(item, newGroupId));\n            }\n        });\n    }\n    return elements;\n};\n\nconst getRemoveGroups = (board: PlaitBoard) => {\n    const selectedGroups = board.getRelatedFragment([]) as PlaitGroup[];\n    const removeGroups = [...selectedGroups];\n    const highestSelectedGroups = getHighestSelectedGroups(board);\n    const selectedIsolatedElements = getSelectedIsolatedElementsCanAddToGroup(board);\n    const removeNodes = [...highestSelectedGroups, ...selectedIsolatedElements];\n    removeNodes.forEach((item) => {\n        const hitElementGroups = getGroupByElement(board, item, true) as PlaitGroup[];\n        if (hitElementGroups.length) {\n            const elementsInGroup = getElementsInGroup(board, hitElementGroups[0], false, true);\n            const siblingElements = elementsInGroup.filter(\n                (element) => ![...removeNodes, ...removeGroups].map((item) => item.id).includes(element.id)\n            );\n            if (siblingElements.length === 1 || siblingElements.length === 0) {\n                if (!removeGroups.includes(hitElementGroups[0])) {\n                    removeGroups.push(hitElementGroups[0]);\n                }\n                if (siblingElements.length === 1) {\n                    if (hitElementGroups.length > 1) {\n                        const aboveGroup = findAboveGroupWithAnotherElement(board, hitElementGroups.slice(1, hitElementGroups.length), [\n                            ...removeNodes,\n                            ...removeGroups\n                        ]);\n                        let index = hitElementGroups.length;\n                        if (aboveGroup) {\n                            index = hitElementGroups.findIndex((item) => item.id === aboveGroup.id);\n                        }\n                        [...hitElementGroups.slice(1, index)].forEach((item) => {\n                            if (!removeGroups.includes(item)) {\n                                removeGroups.push(item);\n                            }\n                        });\n                    }\n                }\n            }\n        }\n    });\n    return removeGroups;\n};\n\nconst findAboveGroupWithAnotherElement = (board: PlaitBoard, groups: PlaitGroup[], excludeNodes: PlaitElement[]) => {\n    let group: PlaitGroup | null = null;\n    for (let i = 0; i < groups.length; i++) {\n        const elementsInGroup = getElementsInGroup(board, groups[i], false, true);\n        const siblingElements = elementsInGroup.filter((element) => !excludeNodes.map((item) => item.id).includes(element.id));\n        if (siblingElements.length > 0) {\n            group = groups[i];\n            break;\n        }\n    }\n    return group;\n};\n\nconst updateSiblingElementGroupId = (board: PlaitBoard, removeGroups: PlaitGroup[]) => {\n    const selectedIsolatedElements = getSelectedIsolatedElementsCanAddToGroup(board);\n    const highestSelectedGroups = getHighestSelectedGroups(board);\n    const isolatedElementsInGroup = selectedIsolatedElements.filter((item) => item.groupId);\n    [...highestSelectedGroups, ...isolatedElementsInGroup].forEach((item) => {\n        const hitElementGroups = getGroupByElement(board, item, true) as PlaitGroup[];\n        if (hitElementGroups.length) {\n            const elementsInGroup = getElementsInGroup(board, hitElementGroups[0], false, true);\n            const siblingElements = elementsInGroup.filter((element) => element.id !== item.id);\n            if (siblingElements.length === 1) {\n                const removeGroupIds = removeGroups.map((item) => item.id);\n                if (hitElementGroups.some((group) => removeGroupIds.includes(group.id))) {\n                    const group = hitElementGroups.find((group) => !removeGroupIds.includes(group.id));\n                    const path = PlaitBoard.findPath(board, siblingElements[0]);\n                    Transforms.setNode(board, { groupId: group?.id || undefined }, path);\n                }\n            }\n        }\n    });\n};\n", "import { PlaitBoard, PlaitElement } from '@plait/core';\n\nexport abstract class ImageBaseComponent {\n    _isFocus!: boolean;\n\n    element!: PlaitElement;\n\n    board!: PlaitBoard;\n\n    set isFocus(value: boolean) {\n        this._isFocus = value;\n    }\n\n    get isFocus() {\n        return this._isFocus;\n    }\n\n    abstract nativeElement(): HTMLElement;\n}\n", "import { Node } from 'slate';\nimport { CustomText, ElementSize, ParagraphElement } from './types';\nimport { getLineHeightByFontSize } from '../utils/text';\nimport { PlaitBoard } from '@plait/core';\n\nconst BOARD_TO_CANVAS_MAP = new WeakMap<PlaitBoard, HTMLCanvasElement>();\n\nconst ELEMENT_TO_SIZE_MAP = new WeakMap<ParagraphElement, ElementSize>();\n\nconst getCanvasForBoard = (board: PlaitBoard | null): HTMLCanvasElement => {\n    if (board) {\n        if (!BOARD_TO_CANVAS_MAP.get(board)) {\n            const canvas = document.createElement('canvas');\n            BOARD_TO_CANVAS_MAP.set(board, canvas);\n            return canvas;\n        }\n        return BOARD_TO_CANVAS_MAP.get(board) as HTMLCanvasElement;\n    }\n    return document.createElement('canvas');\n};\n\nexport const getElementSize = (\n    board: PlaitBoard | null,\n    element: ParagraphElement,\n    options: {\n        fontSize: number;\n        fontFamily: string;\n    },\n    containerMaxWidth: number = 10000\n) => {\n    let size = ELEMENT_TO_SIZE_MAP.get(element);\n    if (size) {\n        return size;\n    }\n    size = measureElement(board, element, options, containerMaxWidth);\n    ELEMENT_TO_SIZE_MAP.set(element, size);\n    return size;\n};\n\nexport const updateElementSizeCache = (board: PlaitBoard | null, element: ParagraphElement, size: ElementSize) => {\n    ELEMENT_TO_SIZE_MAP.set(element, size);\n};\n\nexport const clearElementSizeCache = (board: PlaitBoard | null, element: ParagraphElement) => {\n    ELEMENT_TO_SIZE_MAP.delete(element);\n};\n\nexport function measureElement(\n    board: PlaitBoard | null,\n    element: ParagraphElement,\n    options: {\n        fontSize: number;\n        fontFamily: string;\n    },\n    containerMaxWidth: number = 10000\n) {\n    const canvas = getCanvasForBoard(board);\n    const ctx = canvas.getContext('2d') as CanvasRenderingContext2D;\n    const textEntries = Node.texts(element);\n    const lines: CustomText[][] = [[]];\n    for (const textEntry of textEntries) {\n        const [text] = textEntry;\n        const textString = Node.string(text);\n        const textArray = textString.split('\\n');\n        textArray.forEach((segmentTextString: string, index: number) => {\n            const segmentText = { ...text, text: segmentTextString };\n            if (index === 0) {\n                const currentLine = lines[lines.length - 1];\n                currentLine.push(segmentText);\n            } else {\n                const newLine: CustomText[] = [];\n                newLine.push(segmentText);\n                lines.push(newLine);\n            }\n        });\n    }\n    let width = 0;\n    let height = 0;\n    lines.forEach((lineTexts: CustomText[], index: number) => {\n        let lineWidth = 0;\n        let maxLineHeight = getLineHeightByFontSize(options.fontSize);\n        lineTexts.forEach((text: CustomText, index: number) => {\n            const font = getFont(text, { fontFamily: options.fontFamily, fontSize: options.fontSize });\n            ctx.font = font;\n            lineWidth += ctx.measureText(text.text).width;\n            const isLast = index === lineTexts.length - 1;\n            if (text['font-size'] && (isLast || text.text !== '')) {\n                const lineHeight = getLineHeightByFontSize(parseFloat(text['font-size']));\n                if (lineHeight > maxLineHeight) {\n                    maxLineHeight = lineHeight;\n                }\n            }\n        });\n        if (lineWidth <= containerMaxWidth) {\n            if (lineWidth > width) {\n                width = lineWidth;\n            }\n            height += maxLineHeight;\n        } else {\n            width = containerMaxWidth;\n            const lineWrapNumber = Math.ceil(lineWidth / containerMaxWidth);\n            height += maxLineHeight * lineWrapNumber;\n        }\n    });\n    return { width, height };\n}\n\nconst getFont = (\n    text: CustomText,\n    options: {\n        fontSize: number;\n        fontFamily: string;\n    }\n) => {\n    return `${text.italic ? 'italic ' : ''} ${text.bold ? 'bold ' : ''} ${text['font-size'] || options.fontSize}px ${options.fontFamily} `;\n};\n", "import {\n    IS_TEXT_EDITABLE,\n    MERGING,\n    PlaitBoard,\n    Point,\n    RectangleClient,\n    createForeignObject,\n    createG,\n    setAngleForG,\n    toHostPoint,\n    toViewBoxPoint,\n    updateForeignObject,\n    updateForeignObjectWidth\n} from '@plait/core';\nimport { fromEvent, timer } from 'rxjs';\nimport { Editor, Element, NodeEntry, Range, Text, Node, Transforms, Operation } from 'slate';\nimport { PlaitTextBoard, TextPlugin } from './with-text';\nimport { clearElementSizeCache, measureElement, updateElementSizeCache } from './text-measure';\nimport { TextChangeData, TextComponentRef, TextProps } from './with-text';\nimport { ParagraphElement } from './types';\n\nexport interface TextManageChangeData {\n    newText?: Element;\n    operations?: Operation[];\n    width: number;\n    height: number;\n}\n\nexport class TextManage {\n    isEditing = false;\n\n    editor!: Editor;\n\n    g!: SVGGElement;\n\n    foreignObject!: SVGForeignObjectElement;\n\n    textComponentRef!: TextComponentRef;\n\n    exitCallback?: () => void;\n\n    constructor(\n        private board: PlaitBoard,\n        private options: {\n            getRectangle: () => RectangleClient;\n            onChange?: (data: TextManageChangeData) => void;\n            getRenderRectangle?: () => RectangleClient;\n            getMaxWidth?: () => number;\n            textPlugins?: TextPlugin[];\n        }\n    ) {\n        if (!this.options.getMaxWidth) {\n            this.options.getMaxWidth = () => 999;\n        }\n    }\n\n    draw(text: Element) {\n        const _rectangle = this.options.getRectangle();\n        this.g = createG();\n        this.foreignObject = createForeignObject(_rectangle.x, _rectangle.y, _rectangle.width, _rectangle.height);\n        this.g.append(this.foreignObject);\n        this.g.classList.add('text');\n        const props: TextProps = {\n            board: this.board,\n            text,\n            textPlugins: this.options.textPlugins,\n            onChange: (data: TextChangeData) => {\n                if (data.operations.some(op => !Operation.isSelectionOperation(op))) {\n                    const { width: newWidth, height: newHeight } = this.getSize();\n                    this.options.onChange && this.options.onChange({ ...data, width: newWidth, height: newHeight });\n                    MERGING.set(this.board, true);\n                }\n            },\n            afterInit: (editor: Editor) => {\n                this.editor = editor;\n            },\n            onComposition: (event: CompositionEvent) => {\n                if (event.type === 'compositionend') {\n                    clearElementSizeCache(this.board, this.editor.children[0] as ParagraphElement);\n                    return;\n                }\n                const fakeRoot = buildCompositionData(this.editor, event.data);\n                if (fakeRoot) {\n                    const sizeData = this.getSize(fakeRoot.children[0]);\n                    updateElementSizeCache(this.board, this.editor.children[0] as ParagraphElement, sizeData);\n                    // invoking onChange asap to avoid blinking on typing chinese\n                    this.options.onChange && this.options.onChange({ ...sizeData });\n                    MERGING.set(this.board, true);\n                }\n            }\n        };\n        this.textComponentRef = ((this.board as unknown) as PlaitTextBoard).renderText(this.foreignObject, props);\n    }\n\n    updateRectangleWidth(width: number) {\n        updateForeignObjectWidth(this.g, width);\n    }\n\n    updateAngle(centerPoint: Point, angle: number = 0) {\n        setAngleForG(this.g, centerPoint, angle);\n    }\n\n    updateRectangle(rectangle?: RectangleClient) {\n        const { x, y, width, height } = rectangle || this.options.getRectangle();\n        updateForeignObject(this.g, width, height, x, y);\n    }\n\n    updateText(newText: Element) {\n        const props = {\n            text: newText\n        };\n        this.textComponentRef.update(props);\n    }\n\n    edit(callback?: () => void, exitEdit?: (event: Event) => boolean) {\n        this.isEditing = true;\n        IS_TEXT_EDITABLE.set(this.board, true);\n        const props: Partial<TextProps> = {\n            readonly: false\n        };\n        this.textComponentRef.update(props);\n        Transforms.select(this.editor, [0]);\n        const mousedown$ = fromEvent<MouseEvent>(document, 'mousedown').subscribe((event: MouseEvent) => {\n            const point = toViewBoxPoint(this.board, toHostPoint(this.board, event.x, event.y));\n            const textRec = this.options.getRenderRectangle ? this.options.getRenderRectangle() : this.options.getRectangle();\n            const clickInText = RectangleClient.isHit(RectangleClient.getRectangleByPoints([point, point]), textRec);\n            const isAttached = (event.target as HTMLElement).closest('.plait-board-attached');\n            if (!clickInText && !isAttached) {\n                // handle composition input state, like: Chinese IME Composition Input\n                timer(0).subscribe(() => {\n                    exitCallback();\n                });\n            }\n        });\n        const keydown$ = fromEvent<KeyboardEvent>(document, 'keydown').subscribe((event: KeyboardEvent) => {\n            if (event.isComposing) {\n                return;\n            }\n            if (event.key === 'Escape' || event.key === 'Tab' || (exitEdit ? exitEdit(event) : false)) {\n                event.preventDefault();\n                event.stopPropagation();\n                exitCallback();\n                return;\n            }\n        });\n        const exitCallback = () => {\n            if (this.isEditing) {\n                this.updateRectangle();\n                mousedown$.unsubscribe();\n                keydown$.unsubscribe();\n                IS_TEXT_EDITABLE.set(this.board, false);\n                MERGING.set(this.board, false);\n                callback && callback();\n                const props = {\n                    readonly: true\n                };\n                this.textComponentRef.update(props);\n                this.isEditing = false;\n                this.exitCallback = undefined;\n            }\n        };\n        this.exitCallback = exitCallback;\n        return exitCallback;\n    }\n\n    getSize = (element?: Element, maxWidth?: number) => {\n        const computedStyle = window.getComputedStyle(this.foreignObject.children[0]);\n        const fontFamily = computedStyle.fontFamily;\n        const fontSize = parseFloat(computedStyle.fontSize);\n        const target = element || (this.editor.children[0] as Element);\n        return measureElement(\n            this.board,\n            target,\n            {\n                fontSize: fontSize,\n                fontFamily\n            },\n            maxWidth || this.options.getMaxWidth!()\n        );\n    };\n\n    getText = () => {\n        return this.editor.children[0];\n    };\n\n    destroy() {\n        this.g?.remove();\n        this.textComponentRef?.destroy();\n        this.exitCallback && this.exitCallback();\n    }\n}\n\nexport const buildCompositionData = (editor: Editor, data: string) => {\n    if (editor.selection && Range.isCollapsed(editor.selection)) {\n        const [textNode, textPath] = Editor.node(editor, editor.selection) as NodeEntry<Text>;\n        const offset = editor.selection.anchor.offset;\n        const clonedElement = JSON.parse(JSON.stringify(editor.children[0]));\n        const root = { children: [clonedElement] };\n        const newTextString = textNode.text.slice(0, offset + 1) + data + textNode.text.slice(offset + 1);\n        const clonedTextNode = Node.get(root, textPath) as Text;\n        clonedTextNode.text = newTextString;\n        return root;\n    }\n    return null;\n};\n", "import { PlaitBoard, WithPluginOptions } from '@plait/core';\nimport { Editor, Operation, Element as SlateElement } from 'slate';\nimport { RenderComponentRef } from '../core/render-component';\n\nexport interface PlaitTextBoard {\n    renderText: (container: Element | DocumentFragment, props: TextProps) => TextComponentRef;\n}\n\nexport const withText = <T extends PlaitBoard = PlaitBoard>(board: T) => {\n    const newBoard = board as T & PlaitTextBoard;\n\n    newBoard.renderText = (container: Element | DocumentFragment, props: TextProps) => {\n        throw new Error('No implementation for renderText method.');\n    };\n    return newBoard;\n};\n\nexport type TextComponentRef = RenderComponentRef<TextProps>;\n\nexport interface TextProps {\n    board: PlaitBoard;\n    text: SlateElement;\n    textPlugins?: TextPlugin[];\n    readonly?: boolean;\n    onChange?: (data: TextChangeData) => void;\n    afterInit?: (data: Editor) => void;\n    onComposition?: (data: CompositionEvent) => void;\n}\n\nexport type TextChangeData = { newText: SlateElement; operations: Operation[] };\n\nexport interface WithTextPluginOptions extends WithPluginOptions {\n    textPlugins?: TextPlugin[];\n}\n\nexport type TextPlugin = (editor: Editor) => Editor;\n", "import { BaseElement } from 'slate';\n\nexport type ElementSize =  {\n    width: number;\n    height: number;\n}\n\nexport enum Alignment {\n    left = 'left',\n    center = 'center',\n    right = 'right'\n}\n\nexport type CustomText = {\n    bold?: boolean;\n    italic?: boolean;\n    strike?: boolean;\n    code?: boolean;\n    text: string;\n    underlined?: boolean;\n    color?: string;\n    [`font-size`]?: string;\n};\n\nexport interface LinkElement extends BaseElement {\n    type: 'link';\n    url: string;\n}\n\nexport interface ParagraphElement extends BaseElement {\n    align?: Alignment;\n}\n\nexport type CustomElement = ParagraphElement | LinkElement;\n", "import { PlaitBoard, PlaitElement, RectangleClient } from '@plait/core';\nimport { RenderComponentRef } from '../core/render-component';\nimport { CommonImageItem } from '../utils/image';\n\nexport interface PlaitImageBoard {\n    renderImage: (container: Element | DocumentFragment, props: ImageProps) => ImageComponentRef;\n}\n\nexport const withImage = <T extends PlaitBoard = PlaitBoard>(board: T) => {\n    const newBoard = board as T & PlaitImageBoard;\n\n    newBoard.renderImage = (container: Element | DocumentFragment, props: ImageProps) => {\n        throw new Error('No implementation for renderImage method.');\n    };\n    return newBoard;\n};\n\nexport type ImageComponentRef = RenderComponentRef<ImageProps>;\n\nexport interface ImageProps {\n    board: PlaitBoard;\n    imageItem: CommonImageItem;\n    element: PlaitElement;\n    isFocus?: boolean;\n    getRectangle: () => RectangleClient;\n}\n", "/*\n * Public API Surface of utils\n */\n\nexport * from './constants';\nexport * from './generators';\nexport * from './transforms';\nexport * from './shapes';\nexport * from './plugins';\nexport * from './utils';\nexport * from './image/image-base.component';\nexport * from './core';\nexport * from './algorithms';\nexport * from './text';\nexport * from './image';\nexport * from './types';\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],
  "mappings": "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",
  "names": ["MediaKeys", "ResizeHandle", "StrokeStyle", "rectangle", "BoardCreationMode", "acceptImageTypes", "item", "group", "index", "Transforms", "props", "Alignment"]
}
