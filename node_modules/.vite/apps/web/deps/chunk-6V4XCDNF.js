import {
  createDraft,
  finishDraft,
  isDraft
} from "./chunk-LYPQCHSP.js";
import {
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __extends,
  __generator,
  __read,
  __spreadArray,
  __values
} from "./chunk-YHVPT5BK.js";
import {
  require_lib
} from "./chunk-R23N5LB2.js";
import {
  __toESM
} from "./chunk-2TUXWMP5.js";

// ../../node_modules/@plait/core/fesm2022/plait-core.mjs
var import_is_hotkey = __toESM(require_lib(), 1);

// ../../node_modules/rxjs/dist/esm5/internal/util/isFunction.js
function isFunction(value) {
  return typeof value === "function";
}

// ../../node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// ../../node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});

// ../../node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}

// ../../node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// ../../node_modules/rxjs/dist/esm5/internal/config.js
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// ../../node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// ../../node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// ../../node_modules/rxjs/dist/esm5/internal/util/noop.js
function noop() {
}

// ../../node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
var COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}

// ../../node_modules/rxjs/dist/esm5/internal/util/errorContext.js
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a = context, errorThrown = _a.errorThrown, error = _a.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// ../../node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};

// ../../node_modules/rxjs/dist/esm5/internal/symbol/observable.js
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();

// ../../node_modules/rxjs/dist/esm5/internal/util/identity.js
function identity(x) {
  return x;
}

// ../../node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}

// ../../node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}

// ../../node_modules/rxjs/dist/esm5/internal/util/lift.js
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}

// ../../node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);

// ../../node_modules/rxjs/dist/esm5/internal/operators/refCount.js
function refCount() {
  return operate(function(source, subscriber) {
    var connection = null;
    source._refCount++;
    var refCounter = createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      var sharedConnection = source._connection;
      var conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}

// ../../node_modules/rxjs/dist/esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable = function(_super) {
  __extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._subject = null;
    _this._refCount = 0;
    _this._connection = null;
    if (hasLift(source)) {
      _this.lift = source.lift;
    }
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype._teardown = function() {
    this._refCount = 0;
    var _connection = this._connection;
    this._subject = this._connection = null;
    _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
  };
  ConnectableObservable2.prototype.connect = function() {
    var _this = this;
    var connection = this._connection;
    if (!connection) {
      connection = this._connection = new Subscription();
      var subject_1 = this.getSubject();
      connection.add(this.source.subscribe(createOperatorSubscriber(subject_1, void 0, function() {
        _this._teardown();
        subject_1.complete();
      }, function(err) {
        _this._teardown();
        subject_1.error(err);
      }, function() {
        return _this._teardown();
      })));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  };
  return ConnectableObservable2;
}(Observable);

// ../../node_modules/rxjs/dist/esm5/internal/scheduler/performanceTimestampProvider.js
var performanceTimestampProvider = {
  now: function() {
    return (performanceTimestampProvider.delegate || performance).now();
  },
  delegate: void 0
};

// ../../node_modules/rxjs/dist/esm5/internal/scheduler/animationFrameProvider.js
var animationFrameProvider = {
  schedule: function(callback) {
    var request = requestAnimationFrame;
    var cancel = cancelAnimationFrame;
    var delegate = animationFrameProvider.delegate;
    if (delegate) {
      request = delegate.requestAnimationFrame;
      cancel = delegate.cancelAnimationFrame;
    }
    var handle = request(function(timestamp2) {
      cancel = void 0;
      callback(timestamp2);
    });
    return new Subscription(function() {
      return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
    });
  },
  requestAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  cancelAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  delegate: void 0
};

// ../../node_modules/rxjs/dist/esm5/internal/observable/dom/animationFrames.js
function animationFramesFactory(timestampProvider) {
  return new Observable(function(subscriber) {
    var provider = timestampProvider || performanceTimestampProvider;
    var start = provider.now();
    var id = 0;
    var run = function() {
      if (!subscriber.closed) {
        id = animationFrameProvider.requestAnimationFrame(function(timestamp2) {
          id = 0;
          var now = provider.now();
          subscriber.next({
            timestamp: timestampProvider ? now : timestamp2,
            elapsed: now - start
          });
          run();
        });
      }
    };
    run();
    return function() {
      if (id) {
        animationFrameProvider.cancelAnimationFrame(id);
      }
    };
  });
}
var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();

// ../../node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});

// ../../node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);

// ../../node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
var BehaviorSubject = function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);

// ../../node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};

// ../../node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
var ReplaySubject = function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
    var copy = _buffer.slice();
    for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy[i]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now = _timestampProvider.now();
      var last3 = 0;
      for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
        last3 = i;
      }
      last3 && _buffer.splice(0, last3 + 1);
    }
  };
  return ReplaySubject2;
}(Subject);

// ../../node_modules/rxjs/dist/esm5/internal/AsyncSubject.js
var AsyncSubject = function(_super) {
  __extends(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._value = null;
    _this._hasValue = false;
    _this._isComplete = false;
    return _this;
  }
  AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped || _isComplete) {
      _hasValue && subscriber.next(_value);
      subscriber.complete();
    }
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._value = value;
      this._hasValue = true;
    }
  };
  AsyncSubject2.prototype.complete = function() {
    var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
    if (!_isComplete) {
      this._isComplete = true;
      _hasValue && _super.prototype.next.call(this, _value);
      _super.prototype.complete.call(this);
    }
  };
  return AsyncSubject2;
}(Subject);

// ../../node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
var Action = function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return this;
  };
  return Action2;
}(Subscription);

// ../../node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
var intervalProvider = {
  setInterval: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearInterval: function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};

// ../../node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
var AsyncAction = function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay2);
    }
    this.pending = true;
    this.delay = delay2;
    this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay2);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && this.delay === delay2 && this.pending === false) {
      return id;
    }
    if (id != null) {
      intervalProvider.clearInterval(id);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay2) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay2);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = e ? e : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a = this, id = _a.id, scheduler = _a.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action);

// ../../node_modules/rxjs/dist/esm5/internal/util/Immediate.js
var nextHandle = 1;
var resolved;
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var Immediate = {
  setImmediate: function(cb) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    if (!resolved) {
      resolved = Promise.resolve();
    }
    resolved.then(function() {
      return findAndClearHandle(handle) && cb();
    });
    return handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
};

// ../../node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js
var setImmediate = Immediate.setImmediate;
var clearImmediate = Immediate.clearImmediate;
var immediateProvider = {
  setImmediate: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray([], __read(args)));
  },
  clearImmediate: function(handle) {
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
  },
  delegate: void 0
};

// ../../node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js
var AsapAction = function(_super) {
  __extends(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    }
    var actions = scheduler.actions;
    if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
      immediateProvider.clearImmediate(id);
      if (scheduler._scheduled === id) {
        scheduler._scheduled = void 0;
      }
    }
    return void 0;
  };
  return AsapAction2;
}(AsyncAction);

// ../../node_modules/rxjs/dist/esm5/internal/Scheduler.js
var Scheduler = function() {
  function Scheduler2(schedulerActionCtor, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now;
  }
  Scheduler2.prototype.schedule = function(work, delay2, state) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay2);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
}();

// ../../node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler = function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);

// ../../node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js
var AsapScheduler = function(_super) {
  __extends(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsapScheduler2;
}(AsyncScheduler);

// ../../node_modules/rxjs/dist/esm5/internal/scheduler/asap.js
var asapScheduler = new AsapScheduler(AsapAction);

// ../../node_modules/rxjs/dist/esm5/internal/scheduler/async.js
var asyncScheduler = new AsyncScheduler(AsyncAction);
var async = asyncScheduler;

// ../../node_modules/rxjs/dist/esm5/internal/scheduler/QueueAction.js
var QueueAction = function(_super) {
  __extends(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 > 0) {
      return _super.prototype.schedule.call(this, state, delay2);
    }
    this.delay = delay2;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state, delay2) {
    return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay2) : this._execute(state, delay2);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.flush(this);
    return 0;
  };
  return QueueAction2;
}(AsyncAction);

// ../../node_modules/rxjs/dist/esm5/internal/scheduler/QueueScheduler.js
var QueueScheduler = function(_super) {
  __extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler);

// ../../node_modules/rxjs/dist/esm5/internal/scheduler/queue.js
var queueScheduler = new QueueScheduler(QueueAction);

// ../../node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction = function(_super) {
  __extends(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(function() {
      return scheduler.flush(void 0);
    }));
  };
  AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    }
    var actions = scheduler.actions;
    if (id != null && id === scheduler._scheduled && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
      animationFrameProvider.cancelAnimationFrame(id);
      scheduler._scheduled = void 0;
    }
    return void 0;
  };
  return AnimationFrameAction2;
}(AsyncAction);

// ../../node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler = function(_super) {
  __extends(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationFrameScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId;
    if (action) {
      flushId = action.id;
    } else {
      flushId = this._scheduled;
      this._scheduled = void 0;
    }
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AnimationFrameScheduler2;
}(AsyncScheduler);

// ../../node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js
var animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);

// ../../node_modules/rxjs/dist/esm5/internal/scheduler/VirtualTimeScheduler.js
var VirtualTimeScheduler = function(_super) {
  __extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
    if (schedulerActionCtor === void 0) {
      schedulerActionCtor = VirtualAction;
    }
    if (maxFrames === void 0) {
      maxFrames = Infinity;
    }
    var _this = _super.call(this, schedulerActionCtor, function() {
      return _this.frame;
    }) || this;
    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }
  VirtualTimeScheduler2.prototype.flush = function() {
    var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
    var error;
    var action;
    while ((action = actions[0]) && action.delay <= maxFrames) {
      actions.shift();
      this.frame = action.delay;
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    }
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  VirtualTimeScheduler2.frameTimeFactor = 10;
  return VirtualTimeScheduler2;
}(AsyncScheduler);
var VirtualAction = function(_super) {
  __extends(VirtualAction2, _super);
  function VirtualAction2(scheduler, work, index) {
    if (index === void 0) {
      index = scheduler.index += 1;
    }
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.index = index;
    _this.active = true;
    _this.index = scheduler.index = index;
    return _this;
  }
  VirtualAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (Number.isFinite(delay2)) {
      if (!this.id) {
        return _super.prototype.schedule.call(this, state, delay2);
      }
      this.active = false;
      var action = new VirtualAction2(this.scheduler, this.work);
      this.add(action);
      return action.schedule(state, delay2);
    } else {
      return Subscription.EMPTY;
    }
  };
  VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    this.delay = scheduler.frame + delay2;
    var actions = scheduler.actions;
    actions.push(this);
    actions.sort(VirtualAction2.sortActions);
    return 1;
  };
  VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return void 0;
  };
  VirtualAction2.prototype._execute = function(state, delay2) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state, delay2);
    }
  };
  VirtualAction2.sortActions = function(a, b) {
    if (a.delay === b.delay) {
      if (a.index === b.index) {
        return 0;
      } else if (a.index > b.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a.delay > b.delay) {
      return 1;
    } else {
      return -1;
    }
  };
  return VirtualAction2;
}(AsyncAction);

// ../../node_modules/rxjs/dist/esm5/internal/observable/empty.js
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});

// ../../node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
function isScheduler(value) {
  return value && isFunction(value.schedule);
}

// ../../node_modules/rxjs/dist/esm5/internal/util/args.js
function last(arr) {
  return arr[arr.length - 1];
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}

// ../../node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
var isArrayLike = function(x) {
  return x && typeof x.length === "number" && typeof x !== "function";
};

// ../../node_modules/rxjs/dist/esm5/internal/util/isPromise.js
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}

// ../../node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return isFunction(input[observable]);
}

// ../../node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

// ../../node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

// ../../node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// ../../node_modules/rxjs/dist/esm5/internal/util/isIterable.js
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}

// ../../node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false) return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done) return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

// ../../node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2) throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}

// ../../node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
function executeSchedule(parentSubscription, scheduler, work, delay2, repeat2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  if (repeat2 === void 0) {
    repeat2 = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat2) {
      parentSubscription.add(this.schedule(null, delay2));
    } else {
      this.unsubscribe();
    }
  }, delay2);
  parentSubscription.add(scheduleSubscription);
  if (!repeat2) {
    return scheduleSubscription;
  }
}

// ../../node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay2);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay2);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay2);
    }));
  });
}

// ../../node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay2));
  });
}

// ../../node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// ../../node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// ../../node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i = 0;
    return scheduler.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}

// ../../node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a;
        var value;
        var done;
        try {
          _a = iterator2.next(), value = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}

// ../../node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}

// ../../node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}

// ../../node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}

// ../../node_modules/rxjs/dist/esm5/internal/observable/from.js
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}

// ../../node_modules/rxjs/dist/esm5/internal/observable/of.js
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  return from(args, scheduler);
}

// ../../node_modules/rxjs/dist/esm5/internal/observable/throwError.js
function throwError(errorOrErrorFactory, scheduler) {
  var errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
    return errorOrErrorFactory;
  };
  var init = function(subscriber) {
    return subscriber.error(errorFactory());
  };
  return new Observable(scheduler ? function(subscriber) {
    return scheduler.schedule(init, 0, subscriber);
  } : init);
}

// ../../node_modules/rxjs/dist/esm5/internal/Notification.js
var NotificationKind;
(function(NotificationKind2) {
  NotificationKind2["NEXT"] = "N";
  NotificationKind2["ERROR"] = "E";
  NotificationKind2["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = function() {
  function Notification2(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === "N";
  }
  Notification2.prototype.observe = function(observer) {
    return observeNotification(this, observer);
  };
  Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
    var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
    return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
  };
  Notification2.prototype.accept = function(nextOrObserver, error, complete) {
    var _a;
    return isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
  };
  Notification2.prototype.toObservable = function() {
    var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
    var result = kind === "N" ? of(value) : kind === "E" ? throwError(function() {
      return error;
    }) : kind === "C" ? EMPTY : 0;
    if (!result) {
      throw new TypeError("Unexpected notification kind " + kind);
    }
    return result;
  };
  Notification2.createNext = function(value) {
    return new Notification2("N", value);
  };
  Notification2.createError = function(err) {
    return new Notification2("E", void 0, err);
  };
  Notification2.createComplete = function() {
    return Notification2.completeNotification;
  };
  Notification2.completeNotification = new Notification2("C");
  return Notification2;
}();
function observeNotification(notification, observer) {
  var _a, _b, _c;
  var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
  if (typeof kind !== "string") {
    throw new TypeError('Invalid notification, missing "kind"');
  }
  kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
}

// ../../node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});

// ../../node_modules/rxjs/dist/esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeError = createErrorClass(function(_super) {
  return function ArgumentOutOfRangeErrorImpl() {
    _super(this);
    this.name = "ArgumentOutOfRangeError";
    this.message = "argument out of range";
  };
});

// ../../node_modules/rxjs/dist/esm5/internal/util/NotFoundError.js
var NotFoundError = createErrorClass(function(_super) {
  return function NotFoundErrorImpl(message) {
    _super(this);
    this.name = "NotFoundError";
    this.message = message;
  };
});

// ../../node_modules/rxjs/dist/esm5/internal/util/SequenceError.js
var SequenceError = createErrorClass(function(_super) {
  return function SequenceErrorImpl(message) {
    _super(this);
    this.name = "SequenceError";
    this.message = message;
  };
});

// ../../node_modules/rxjs/dist/esm5/internal/util/isDate.js
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}

// ../../node_modules/rxjs/dist/esm5/internal/operators/timeout.js
var TimeoutError = createErrorClass(function(_super) {
  return function TimeoutErrorImpl(info) {
    if (info === void 0) {
      info = null;
    }
    _super(this);
    this.message = "Timeout has occurred";
    this.name = "TimeoutError";
    this.info = info;
  };
});

// ../../node_modules/rxjs/dist/esm5/internal/operators/map.js
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}

// ../../node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
var isArray = Array.isArray;
function callOrApply(fn, args) {
  return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
}
function mapOneOrManyArgs(fn) {
  return map(function(args) {
    return callOrApply(fn, args);
  });
}

// ../../node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
var isArray2 = Array.isArray;
var objectProto = Object.prototype;

// ../../node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand2, innerSubScheduler, additionalFinalizer) {
  var buffer2 = [];
  var active = 0;
  var index = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer2.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer2.push(value);
  };
  var doInnerSub = function(value) {
    expand2 && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand2) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer2.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer2.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}

// ../../node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function(a, i) {
      return map(function(b, ii) {
        return resultSelector(a, b, i, ii);
      })(innerFrom(project(a, i)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}

// ../../node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js
var nodeEventEmitterMethods = ["addListener", "removeListener"];
var eventTargetMethods = ["addEventListener", "removeEventListener"];
var jqueryMethods = ["on", "off"];
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
  }
  var _a = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler, options);
    };
  }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove = _a[1];
  if (!add) {
    if (isArrayLike(target)) {
      return mergeMap(function(subTarget) {
        return fromEvent(subTarget, eventName, options);
      })(innerFrom(target));
    }
  }
  if (!add) {
    throw new TypeError("Invalid event target");
  }
  return new Observable(function(subscriber) {
    var handler = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return subscriber.next(1 < args.length ? args : args[0]);
    };
    add(handler);
    return function() {
      return remove(handler);
    };
  });
}
function toCommonHandlerRegistry(target, eventName) {
  return function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler);
    };
  };
}
function isNodeStyleEventEmitter(target) {
  return isFunction(target.addListener) && isFunction(target.removeListener);
}
function isJQueryStyleEventEmitter(target) {
  return isFunction(target.on) && isFunction(target.off);
}
function isEventTarget(target) {
  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
}

// ../../node_modules/rxjs/dist/esm5/internal/observable/timer.js
function timer(dueTime, intervalOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  var intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler(intervalOrScheduler)) {
      scheduler = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable(function(subscriber) {
    var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    var n = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}

// ../../node_modules/rxjs/dist/esm5/internal/observable/never.js
var NEVER = new Observable(noop);

// ../../node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js
var isArray3 = Array.isArray;

// ../../node_modules/@plait/core/fesm2022/plait-core.mjs
var MAC_ENTER = 3;
var BACKSPACE = 8;
var TAB = 9;
var NUM_CENTER = 12;
var ENTER = 13;
var SHIFT = 16;
var CONTROL = 17;
var ALT = 18;
var PAUSE = 19;
var CAPS_LOCK = 20;
var ESCAPE = 27;
var SPACE = 32;
var PAGE_UP = 33;
var PAGE_DOWN = 34;
var END = 35;
var HOME = 36;
var LEFT_ARROW = 37;
var UP_ARROW = 38;
var RIGHT_ARROW = 39;
var DOWN_ARROW = 40;
var PLUS_SIGN = 43;
var PRINT_SCREEN = 44;
var INSERT = 45;
var DELETE = 46;
var ZERO = 48;
var ONE = 49;
var TWO = 50;
var THREE = 51;
var FOUR = 52;
var FIVE = 53;
var SIX = 54;
var SEVEN = 55;
var EIGHT = 56;
var NINE = 57;
var FF_SEMICOLON = 59;
var FF_EQUALS = 61;
var QUESTION_MARK = 63;
var AT_SIGN = 64;
var A = 65;
var B = 66;
var C = 67;
var D = 68;
var E = 69;
var F = 70;
var G = 71;
var H = 72;
var I = 73;
var J = 74;
var K = 75;
var L = 76;
var M = 77;
var N = 78;
var O = 79;
var P = 80;
var Q = 81;
var R = 82;
var S = 83;
var T = 84;
var U = 85;
var V = 86;
var W = 87;
var X = 88;
var Y = 89;
var Z = 90;
var META = 91;
var MAC_WK_CMD_LEFT = 91;
var MAC_WK_CMD_RIGHT = 93;
var CONTEXT_MENU = 93;
var NUMPAD_ZERO = 96;
var NUMPAD_ONE = 97;
var NUMPAD_TWO = 98;
var NUMPAD_THREE = 99;
var NUMPAD_FOUR = 100;
var NUMPAD_FIVE = 101;
var NUMPAD_SIX = 102;
var NUMPAD_SEVEN = 103;
var NUMPAD_EIGHT = 104;
var NUMPAD_NINE = 105;
var NUMPAD_MULTIPLY = 106;
var NUMPAD_PLUS = 107;
var NUMPAD_MINUS = 109;
var NUMPAD_PERIOD = 110;
var NUMPAD_DIVIDE = 111;
var F1 = 112;
var F2 = 113;
var F3 = 114;
var F4 = 115;
var F5 = 116;
var F6 = 117;
var F7 = 118;
var F8 = 119;
var F9 = 120;
var F10 = 121;
var F11 = 122;
var F12 = 123;
var NUM_LOCK = 144;
var SCROLL_LOCK = 145;
var FIRST_MEDIA = 166;
var FF_MINUS = 173;
var MUTE = 173;
var VOLUME_DOWN = 174;
var VOLUME_UP = 175;
var FF_MUTE = 181;
var FF_VOLUME_DOWN = 182;
var LAST_MEDIA = 183;
var FF_VOLUME_UP = 183;
var SEMICOLON = 186;
var EQUALS = 187;
var COMMA = 188;
var DASH = 189;
var PERIOD = 190;
var SLASH = 191;
var APOSTROPHE = 192;
var TILDE = 192;
var OPEN_SQUARE_BRACKET = 219;
var BACKSLASH = 220;
var CLOSE_SQUARE_BRACKET = 221;
var SINGLE_QUOTE = 222;
var MAC_META = 224;
var ResizeCursorClass;
(function(ResizeCursorClass2) {
  ResizeCursorClass2["ew"] = "ew-resize";
  ResizeCursorClass2["ns"] = "ns-resize";
  ResizeCursorClass2["nesw"] = "nesw-resize";
  ResizeCursorClass2["nwse"] = "nwse-resize";
})(ResizeCursorClass || (ResizeCursorClass = {}));
var CursorClass;
(function(CursorClass2) {
  CursorClass2["crosshair"] = "crosshair";
})(CursorClass || (CursorClass = {}));
var RESIZE_CURSORS = [ResizeCursorClass.ns, ResizeCursorClass.nesw, ResizeCursorClass.ew, ResizeCursorClass.nwse];
var ATTACHED_ELEMENT_CLASS_NAME = "plait-board-attached";
var ACTIVE_STROKE_WIDTH = 1;
var SNAPPING_STROKE_WIDTH = 2;
var SELECTION_RECTANGLE_CLASS_NAME = "selection-rectangle";
var SELECTION_RECTANGLE_BOUNDING_CLASS_NAME = "selection-rectangle-bounding";
var ZOOM_STEP = 0.1;
var MIN_ZOOM = 0.1;
var MAX_ZOOM = 4;
var HOST_CLASS_NAME = "plait-board-container";
var ACTIVE_MOVING_CLASS_NAME = "active-with-moving";
var ROTATE_HANDLE_CLASS_NAME = "rotate-handle";
var RESIZE_HANDLE_CLASS_NAME = "resize-handle";
var SCROLL_BAR_WIDTH = 20;
var MAX_RADIUS = 16;
var POINTER_BUTTON = {
  MAIN: 0,
  WHEEL: 1,
  SECONDARY: 2,
  TOUCH: -1
};
var PRESS_AND_MOVE_BUFFER = 3;
var DRAG_SELECTION_PRESS_AND_MOVE_BUFFER = 10;
var HIT_DISTANCE_BUFFER = 5;
function hasBeforeContextChange(value) {
  if (value.beforeContextChange) {
    return true;
  }
  return false;
}
function hasOnContextChanged(value) {
  if (value.onContextChanged) {
    return true;
  }
  return false;
}
var IS_BOARD_CACHE = /* @__PURE__ */ new WeakMap();
var FLUSHING = /* @__PURE__ */ new WeakMap();
var NODE_TO_INDEX = /* @__PURE__ */ new WeakMap();
var NODE_TO_PARENT = /* @__PURE__ */ new WeakMap();
var KEY_TO_ELEMENT_MAP = /* @__PURE__ */ new WeakMap();
var NODE_TO_G = /* @__PURE__ */ new WeakMap();
var NODE_TO_CONTAINER_G = /* @__PURE__ */ new WeakMap();
var IS_TEXT_EDITABLE = /* @__PURE__ */ new WeakMap();
var BOARD_TO_ON_CHANGE = /* @__PURE__ */ new WeakMap();
var BOARD_TO_AFTER_CHANGE = /* @__PURE__ */ new WeakMap();
var BOARD_TO_ROUGH_SVG = /* @__PURE__ */ new WeakMap();
var BOARD_TO_HOST = /* @__PURE__ */ new WeakMap();
var BOARD_TO_CONTEXT = /* @__PURE__ */ new WeakMap();
var IS_BOARD_ALIVE = /* @__PURE__ */ new WeakMap();
var BOARD_TO_ELEMENT_HOST = /* @__PURE__ */ new WeakMap();
var BOARD_TO_SELECTED_ELEMENT = /* @__PURE__ */ new WeakMap();
var BOARD_TO_MOVING_POINT_IN_BOARD = /* @__PURE__ */ new WeakMap();
var BOARD_TO_MOVING_POINT = /* @__PURE__ */ new WeakMap();
var BOARD_TO_VIEWPORT_ORIGINATION = /* @__PURE__ */ new WeakMap();
var BOARD_TO_IS_SELECTION_MOVING = /* @__PURE__ */ new WeakMap();
var BOARD_TO_TEMPORARY_ELEMENTS = /* @__PURE__ */ new WeakMap();
var BOARD_TO_MOVING_ELEMENT = /* @__PURE__ */ new WeakMap();
var PATH_REFS = /* @__PURE__ */ new WeakMap();
var ELEMENT_TO_REF = /* @__PURE__ */ new WeakMap();
function isNullOrUndefined(value) {
  return value === null || value === void 0;
}
function normalizePoint(point) {
  return Array.isArray(point) ? {
    x: point[0],
    y: point[1]
  } : point;
}
var rgbaToHEX = (rgb, opacity) => {
  return rgb + Math.floor(opacity * 255).toString(16);
};
function isContextmenu(event) {
  return event.button === 2;
}
function uniqueById(elements) {
  const uniqueMap = /* @__PURE__ */ new Map();
  elements.forEach((item) => {
    if (!uniqueMap.has(item.id)) {
      uniqueMap.set(item.id, item);
    }
  });
  return Array.from(uniqueMap.values());
}
var findLastIndex = (array, cb, fromIndex = array.length - 1) => {
  if (fromIndex < 0) {
    fromIndex = array.length + fromIndex;
  }
  fromIndex = Math.min(array.length - 1, Math.max(fromIndex, 0));
  let index = fromIndex + 1;
  while (--index > -1) {
    if (cb(array[index], index, array)) {
      return index;
    }
  }
  return -1;
};
var findIndex2 = (array, cb, fromIndex = 0) => {
  if (fromIndex < 0) {
    fromIndex = array.length + fromIndex;
  }
  fromIndex = Math.min(array.length, Math.max(fromIndex, 0));
  let index = fromIndex - 1;
  while (++index < array.length) {
    if (cb(array[index], index, array)) {
      return index;
    }
  }
  return -1;
};
var isIndicesContinuous = (indexes) => {
  indexes.sort((a, b) => a - b);
  for (let i = 1; i < indexes.length; i++) {
    if (indexes[i] !== indexes[i - 1] + 1) {
      return false;
    }
  }
  return true;
};
var Viewport = {
  isViewport: (value) => {
    return !isNullOrUndefined(value.zoom) && !isNullOrUndefined(value.viewBackgroundColor);
  }
};
var Path = {
  /**
   * Get a list of ancestor paths for a given path.
   *
   * The paths are sorted from shallowest to deepest ancestor. However, if the
   * `reverse: true` option is passed, they are reversed.
   */
  ancestors(path, options = {}) {
    const { reverse = false } = options;
    let paths = Path.levels(path, options);
    if (reverse) {
      paths = paths.slice(1);
    } else {
      paths = paths.slice(0, -1);
    }
    return paths;
  },
  /**
   * Get a list of paths at every level down to a path. Note: this is the same
   * as `Path.ancestors`, but including the path itself.
   *
   * The paths are sorted from shallowest to deepest. However, if the `reverse:
   * true` option is passed, they are reversed.
   */
  levels(path, options = {}) {
    const { reverse = false } = options;
    const list = [];
    for (let i = 0; i <= path.length; i++) {
      list.push(path.slice(0, i));
    }
    if (reverse) {
      list.reverse();
    }
    return list;
  },
  parent(path) {
    if (path.length === 0) {
      throw new Error(`Cannot get the parent path of the root path [${path}].`);
    }
    return path.slice(0, -1);
  },
  next(path) {
    if (path.length === 0) {
      throw new Error(`Cannot get the next path of a root path [${path}], because it has no next index.`);
    }
    const last3 = path[path.length - 1];
    return path.slice(0, -1).concat(last3 + 1);
  },
  hasPrevious(path) {
    return path[path.length - 1] > 0;
  },
  previous(path) {
    if (path.length === 0) {
      throw new Error(`Cannot get the previous path of a root path [${path}], because it has no previous index.`);
    }
    const last3 = path[path.length - 1];
    if (last3 <= 0) {
      throw new Error(`Cannot get the previous path of a first child path [${path}] because it would result in a negative index.`);
    }
    return path.slice(0, -1).concat(last3 - 1);
  },
  /**
   * Check if a path is an ancestor of another.
   */
  isAncestor(path, another) {
    return path.length < another.length && Path.compare(path, another) === 0;
  },
  /**
   * Compare a path to another, returning an integer indicating whether the path
   * was before, at, or after the other.
   *
   * Note: Two paths of unequal length can still receive a `0` result if one is
   * directly above or below the other. If you want exact matching, use
   * [[Path.equals]] instead.
   */
  compare(path, another) {
    const min2 = Math.min(path.length, another.length);
    for (let i = 0; i < min2; i++) {
      if (path[i] < another[i])
        return -1;
      if (path[i] > another[i])
        return 1;
    }
    return 0;
  },
  /**
   * Check if a path is exactly equal to another.
   */
  equals(path, another) {
    return path.length === another.length && path.every((n, i) => n === another[i]);
  },
  /**
   * Check if a path ends before one of the indexes in another.
   */
  endsBefore(path, another) {
    const i = path.length - 1;
    const as = path.slice(0, i);
    const bs = another.slice(0, i);
    const av = path[i];
    const bv = another[i];
    return Path.equals(as, bs) && av < bv;
  },
  /**
   * Check if a path is a sibling of another.
   */
  isSibling(path, another) {
    if (path.length !== another.length) {
      return false;
    }
    const as = path.slice(0, -1);
    const bs = another.slice(0, -1);
    const al = path[path.length - 1];
    const bl = another[another.length - 1];
    return al !== bl && Path.equals(as, bs);
  },
  transform(path, operation) {
    if (!path)
      return null;
    const p = [...path];
    if (path.length === 0) {
      return p;
    }
    switch (operation.type) {
      case "insert_node": {
        const { path: op } = operation;
        if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {
          p[op.length - 1] += 1;
        }
        break;
      }
      case "remove_node": {
        const { path: op } = operation;
        if (Path.equals(op, p) || Path.isAncestor(op, p)) {
          return null;
        } else if (Path.endsBefore(op, p)) {
          p[op.length - 1] -= 1;
        }
        break;
      }
      case "move_node": {
        const { path: op, newPath: onp } = operation;
        if (Path.equals(op, onp)) {
          return p;
        }
        if (Path.isAncestor(op, p) || Path.equals(op, p)) {
          const copy = onp.slice();
          if (Path.endsBefore(op, onp) && op.length < onp.length) {
            copy[op.length - 1] -= 1;
          }
          return copy.concat(p.slice(op.length));
        } else if (Path.isSibling(op, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {
          if (Path.endsBefore(op, p)) {
            p[op.length - 1] -= 1;
          } else {
            p[op.length - 1] += 1;
          }
        } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {
          if (Path.endsBefore(op, p)) {
            p[op.length - 1] -= 1;
          }
          p[onp.length - 1] += 1;
        } else if (Path.endsBefore(op, p)) {
          if (Path.equals(onp, p)) {
            p[onp.length - 1] += 1;
          }
          p[op.length - 1] -= 1;
        }
        break;
      }
    }
    return p;
  }
};
var PlaitNode = {
  parent: (board, path) => {
    const parentPath = Path.parent(path);
    const p = PlaitNode.get(board, parentPath);
    return p;
  },
  /**
   * Return a generator of all the ancestor nodes above a specific path.
   *
   * By default the order is top-down, from highest to lowest ancestor in
   * the tree, but you can pass the `reverse: true` option to go bottom-up.
   */
  *parents(root, path, options = {}) {
    for (const p of Path.ancestors(path, options)) {
      const n = PlaitNode.get(root, p);
      yield n;
    }
  },
  get(root, path) {
    let node = root;
    for (let i = 0; i < path.length; i++) {
      const p = path[i];
      if (!node || !node.children || !node.children[p]) {
        throw new Error(`Cannot find a descendant at path [${path}]`);
      }
      node = node.children[p];
    }
    return node;
  },
  last(board, path) {
    let n = PlaitNode.get(board, path);
    while (n && n.children && n.children.length > 0) {
      const i = n.children.length - 1;
      n = n.children[i];
    }
    return n;
  },
  first(board, path) {
    const p = path.slice();
    let n = PlaitNode.get(board, p);
    if (!n.children || !board.isExpanded(n)) {
      return n;
    }
    while (n && n.children && n.children.length > 0 && board.isExpanded(n)) {
      if (n.children.length === 0) {
        break;
      } else {
        n = n.children[0];
        p.push(0);
      }
    }
    return n;
  }
};
var applyToDraft = (board, selection, viewport, theme, op) => {
  var _a, _b;
  switch (op.type) {
    case "insert_node": {
      const { path, node } = op;
      const parent = PlaitNode.parent(board, path);
      const index = path[path.length - 1];
      if (!parent.children || index > parent.children.length) {
        throw new Error(`Cannot apply an "insert_node" operation at path [${path}] because the destination is past the end of the node.`);
      }
      parent.children.splice(index, 0, node);
      break;
    }
    case "remove_node": {
      const { path } = op;
      const parent = PlaitNode.parent(board, path);
      const index = path[path.length - 1];
      if (!parent.children || index > parent.children.length) {
        throw new Error(`Cannot apply an "insert_node" operation at path [${path}] because the destination is past the end of the node.`);
      }
      parent.children.splice(index, 1);
      break;
    }
    case "move_node": {
      const { path, newPath } = op;
      if (Path.isAncestor(path, newPath)) {
        throw new Error(`Cannot move a path [${path}] to new path [${newPath}] because the destination is inside itself.`);
      }
      const node = PlaitNode.get(board, path);
      const parent = PlaitNode.parent(board, path);
      const index = path[path.length - 1];
      (_a = parent.children) == null ? void 0 : _a.splice(index, 1);
      const truePath = Path.transform(path, op);
      const newParent = PlaitNode.get(board, Path.parent(truePath));
      const newIndex = truePath[truePath.length - 1];
      (_b = newParent.children) == null ? void 0 : _b.splice(newIndex, 0, node);
      break;
    }
    case "set_node": {
      const { path, properties, newProperties } = op;
      if (path.length === 0) {
        throw new Error(`Cannot set properties on the root node!`);
      }
      const node = PlaitNode.get(board, path);
      for (const key in newProperties) {
        const value = newProperties[key];
        if (value == null) {
          delete node[key];
        } else {
          node[key] = value;
        }
      }
      for (const key in properties) {
        if (!newProperties.hasOwnProperty(key)) {
          delete node[key];
        }
      }
      break;
    }
    case "set_viewport": {
      const { newProperties } = op;
      if (newProperties == null) {
        viewport = newProperties;
      } else {
        if (viewport == null) {
          if (!Viewport.isViewport(newProperties)) {
            throw new Error(`Cannot apply an incomplete "set_viewport" operation properties ${JSON.stringify(newProperties)} when there is no current viewport.`);
          }
          viewport = { ...newProperties };
        }
        for (const key in newProperties) {
          const value = newProperties[key];
          if (value == null) {
            delete viewport[key];
          } else {
            viewport[key] = value;
          }
        }
      }
      break;
    }
    case "set_selection": {
      const { newProperties } = op;
      if (newProperties == null) {
        selection = newProperties;
      } else {
        if (selection === null) {
          selection = op.newProperties;
        } else {
          selection = newProperties;
        }
      }
      break;
    }
    case "set_theme": {
      const { newProperties } = op;
      theme = newProperties;
      break;
    }
  }
  return { selection, viewport, theme };
};
var GeneralTransforms = {
  /**
   * Transform the board by an operation.
   */
  transform(board, op) {
    board.children = createDraft(board.children);
    let viewport = board.viewport && createDraft(board.viewport);
    let selection = board.selection && createDraft(board.selection);
    let theme = board.theme && createDraft(board.theme);
    try {
      const state = applyToDraft(board, selection, viewport, theme, op);
      viewport = state.viewport;
      selection = state.selection;
      theme = state.theme;
    } finally {
      board.children = finishDraft(board.children);
      if (selection) {
        board.selection = isDraft(selection) ? finishDraft(selection) : selection;
      } else {
        board.selection = null;
      }
      board.viewport = isDraft(viewport) ? finishDraft(viewport) : viewport;
      board.theme = isDraft(theme) ? finishDraft(theme) : theme;
    }
  }
};
var RectangleClient = {
  isHit: (origin, target) => {
    return RectangleClient.isHitX(origin, target) && RectangleClient.isHitY(origin, target);
  },
  isHitX: (origin, target) => {
    const minX = origin.x < target.x ? origin.x : target.x;
    const maxX = origin.x + origin.width > target.x + target.width ? origin.x + origin.width : target.x + target.width;
    if (Math.floor(maxX - minX - origin.width - target.width) <= 0) {
      return true;
    } else {
      return false;
    }
  },
  isHitY: (origin, target) => {
    const minY = origin.y < target.y ? origin.y : target.y;
    const maxY = origin.y + origin.height > target.y + target.height ? origin.y + origin.height : target.y + target.height;
    if (Math.floor(maxY - minY - origin.height - target.height) <= 0) {
      return true;
    } else {
      return false;
    }
  },
  getPoints(rectangle) {
    return [
      [rectangle.x, rectangle.y],
      [rectangle.x + rectangle.width, rectangle.y + rectangle.height]
    ];
  },
  getRectangleByCenterPoint(point, width, height) {
    return RectangleClient.getRectangleByPoint([point[0] - width / 2, point[1] - height / 2], width, height);
  },
  getRectangleByPoint(point, width, height) {
    return {
      x: point[0],
      y: point[1],
      width,
      height
    };
  },
  getRectangleByPoints(points) {
    if (isPointArray(points)) {
      points = [points];
    }
    let xMin = Infinity;
    let yMin = Infinity;
    let xMax = -Infinity;
    let yMax = -Infinity;
    for (const point of points) {
      const xArray = point.map((ele) => ele[0]);
      const yArray = point.map((ele) => ele[1]);
      xMin = Math.min(xMin, ...xArray);
      yMin = Math.min(yMin, ...yArray);
      xMax = Math.max(xMax, ...xArray);
      yMin = Math.min(yMin, ...yArray);
      yMax = Math.max(yMax, ...yArray);
    }
    const rect = { x: xMin, y: yMin, width: xMax - xMin, height: yMax - yMin };
    return rect;
  },
  getCornerPointsByPoints(points) {
    const xArray = points.map((ele) => ele[0]);
    const yArray = points.map((ele) => ele[1]);
    const xMin = Math.min(...xArray);
    const xMax = Math.max(...xArray);
    const yMin = Math.min(...yArray);
    const yMax = Math.max(...yArray);
    return [
      [xMin, yMin],
      [xMax, yMin],
      [xMax, yMax],
      [xMin, yMax]
    ];
  },
  getOutlineRectangle: (rectangle, offset) => {
    return {
      x: rectangle.x + offset,
      y: rectangle.y + offset,
      width: rectangle.width - offset * 2,
      height: rectangle.height - offset * 2
    };
  },
  inflate: (rectangle, delta) => {
    const half = delta / 2;
    return {
      x: rectangle.x - half,
      y: rectangle.y - half,
      width: rectangle.width + half * 2,
      height: rectangle.height + half * 2
    };
  },
  isEqual: (rectangle, otherRectangle) => {
    return rectangle.x === otherRectangle.x && rectangle.y === otherRectangle.y && rectangle.width === otherRectangle.width && rectangle.height === otherRectangle.height;
  },
  getCornerPoints: (rectangle) => {
    return [
      [rectangle.x, rectangle.y],
      [rectangle.x + rectangle.width, rectangle.y],
      [rectangle.x + rectangle.width, rectangle.y + rectangle.height],
      [rectangle.x, rectangle.y + rectangle.height]
    ];
  },
  getCenterPoint: (rectangle) => {
    return [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height / 2];
  },
  getCenterPointByPoints: (points) => {
    return RectangleClient.getCenterPoint(RectangleClient.getRectangleByPoints(points));
  },
  getEdgeCenterPoints: (rectangle) => {
    return [
      [rectangle.x + rectangle.width / 2, rectangle.y],
      [rectangle.x + rectangle.width, rectangle.y + rectangle.height / 2],
      [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height],
      [rectangle.x, rectangle.y + rectangle.height / 2]
    ];
  },
  getConnectionPoint: (rectangle, point) => {
    return [rectangle.x + rectangle.width * point[0], rectangle.y + rectangle.height * point[1]];
  },
  expand(rectangle, left, top = left, right = left, bottom = top) {
    return {
      x: rectangle.x - left,
      y: rectangle.y - top,
      width: rectangle.width + left + right,
      height: rectangle.height + top + bottom
    };
  },
  getGapCenter(rectangle1, rectangle2, isHorizontal) {
    const axis = isHorizontal ? "x" : "y";
    const side = isHorizontal ? "width" : "height";
    const align = [rectangle1[axis], rectangle1[axis] + rectangle1[side], rectangle2[axis], rectangle2[axis] + rectangle2[side]];
    const sortArr = align.sort((a, b) => a - b);
    return (sortArr[1] + sortArr[2]) / 2;
  },
  isPointInRectangle(rectangle, point) {
    const x = point[0], y = point[1];
    return x > rectangle.x && x < rectangle.x + rectangle.width && y > rectangle.y && y < rectangle.y + rectangle.height;
  },
  getBoundingRectangle(rectangles) {
    if (rectangles.length === 0) {
      throw new Error("rectangles can not be empty array");
    }
    let minX = Number.MAX_VALUE;
    let minY = Number.MAX_VALUE;
    let maxX = Number.NEGATIVE_INFINITY;
    let maxY = Number.NEGATIVE_INFINITY;
    rectangles.forEach((rect) => {
      minX = Math.min(minX, rect.x);
      minY = Math.min(minY, rect.y);
      maxX = Math.max(maxX, rect.x + rect.width);
      maxY = Math.max(maxY, rect.y + rect.height);
    });
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
};
function isPointArray(data) {
  return Array.isArray(data) && data.every((item) => Array.isArray(item) && item.length === 2 && typeof item[0] === "number" && typeof item[1] === "number");
}
function distanceBetweenPointAndSegment(x, y, x1, y1, x2, y2) {
  const A2 = x - x1;
  const B2 = y - y1;
  const C2 = x2 - x1;
  const D2 = y2 - y1;
  const dot = A2 * C2 + B2 * D2;
  const lenSquare = C2 * C2 + D2 * D2;
  let param = -1;
  if (lenSquare !== 0) {
    param = dot / lenSquare;
  }
  let xx, yy;
  if (param < 0) {
    xx = x1;
    yy = y1;
  } else if (param > 1) {
    xx = x2;
    yy = y2;
  } else {
    xx = x1 + param * C2;
    yy = y1 + param * D2;
  }
  const dx = x - xx;
  const dy = y - yy;
  return Math.hypot(dx, dy);
}
function getNearestPointBetweenPointAndSegment(point, linePoints) {
  const x = point[0], y = point[1], x1 = linePoints[0][0], y1 = linePoints[0][1], x2 = linePoints[1][0], y2 = linePoints[1][1];
  const A2 = x - x1;
  const B2 = y - y1;
  const C2 = x2 - x1;
  const D2 = y2 - y1;
  const dot = A2 * C2 + B2 * D2;
  const lenSquare = C2 * C2 + D2 * D2;
  let param = -1;
  if (lenSquare !== 0) {
    param = dot / lenSquare;
  }
  let xx, yy;
  if (param < 0) {
    xx = x1;
    yy = y1;
  } else if (param > 1) {
    xx = x2;
    yy = y2;
  } else {
    xx = x1 + param * C2;
    yy = y1 + param * D2;
  }
  return [xx, yy];
}
function distanceBetweenPointAndSegments(point, points) {
  const len = points.length;
  let distance = Infinity;
  if (points.length === 1) {
    return distanceBetweenPointAndPoint(...points[0], ...point);
  }
  for (let i = 0; i < len - 1; i++) {
    const p = points[i];
    const p2 = points[i + 1];
    const currentDistance = distanceBetweenPointAndSegment(point[0], point[1], p[0], p[1], p2[0], p2[1]);
    if (currentDistance < distance) {
      distance = currentDistance;
    }
  }
  return distance;
}
function getNearestPointBetweenPointAndSegments(point, points, isClose = true) {
  const len = points.length;
  let distance = Infinity;
  let result = point;
  for (let i = 0; i < len; i++) {
    const p = points[i];
    if (i === len - 1 && !isClose)
      continue;
    const p2 = i === len - 1 ? points[0] : points[i + 1];
    const currentDistance = distanceBetweenPointAndSegment(point[0], point[1], p[0], p[1], p2[0], p2[1]);
    if (currentDistance < distance) {
      distance = currentDistance;
      result = getNearestPointBetweenPointAndSegment(point, [p, p2]);
    }
  }
  return result;
}
function getNearestPointBetweenPointAndDiscreteSegments(point, segments) {
  let minDistance = Infinity;
  let nearestPoint = point;
  for (const segment of segments) {
    const currentNearestPoint = getNearestPointBetweenPointAndSegment(point, segment);
    const currentDistance = distanceBetweenPointAndPoint(point[0], point[1], currentNearestPoint[0], currentNearestPoint[1]);
    if (currentDistance < minDistance) {
      minDistance = currentDistance;
      nearestPoint = currentNearestPoint;
    }
  }
  return nearestPoint;
}
function getNearestPointBetweenPointAndEllipse(point, center, rx, ry) {
  const rectangleClient = {
    x: center[0] - rx,
    y: center[1] - ry,
    height: ry * 2,
    width: rx * 2
  };
  const px = Math.abs(point[0] - rectangleClient.x - rectangleClient.width / 2);
  const py = Math.abs(point[1] - rectangleClient.y - rectangleClient.height / 2);
  let tx = 0.707;
  let ty = 0.707;
  const a = Math.abs(rectangleClient.width) / 2;
  const b = Math.abs(rectangleClient.height) / 2;
  [0, 1, 2, 3].forEach((x) => {
    const xx = a * tx;
    const yy = b * ty;
    const ex = (a * a - b * b) * tx ** 3 / a;
    const ey = (b * b - a * a) * ty ** 3 / b;
    const rx2 = xx - ex;
    const ry2 = yy - ey;
    const qx = px - ex;
    const qy = py - ey;
    const r = Math.hypot(ry2, rx2);
    const q = Math.hypot(qy, qx);
    tx = Math.min(1, Math.max(0, (qx * r / q + ex) / a));
    ty = Math.min(1, Math.max(0, (qy * r / q + ey) / b));
    const t = Math.hypot(ty, tx);
    tx /= t;
    ty /= t;
  });
  const signX = point[0] > center[0] ? 1 : -1;
  const signY = point[1] > center[1] ? 1 : -1;
  return [center[0] + a * tx * signX, center[1] + b * ty * signY];
}
function rotate(x1, y1, x2, y2, angle) {
  return [(x1 - x2) * Math.cos(angle) - (y1 - y2) * Math.sin(angle) + x2, (x1 - x2) * Math.sin(angle) + (y1 - y2) * Math.cos(angle) + y2];
}
function distanceBetweenPointAndPoint(x1, y1, x2, y2) {
  const dx = x1 - x2;
  const dy = y1 - y2;
  return Math.hypot(dx, dy);
}
function distanceBetweenPointAndRectangle(x, y, rect) {
  var dx = Math.max(rect.x - x, 0, x - (rect.x + rect.width));
  var dy = Math.max(rect.y - y, 0, y - (rect.y + rect.height));
  return Math.sqrt(dx * dx + dy * dy);
}
var isLineHitLine = (a, b, c, d) => {
  if (Point.isEquals(a, b) && Point.isEquals(c, d) && !Point.isEquals(a, c)) {
    return false;
  }
  const crossProduct = (v1, v2) => v1[0] * v2[1] - v1[1] * v2[0];
  const ab = [b[0] - a[0], b[1] - a[1]];
  const ac = [c[0] - a[0], c[1] - a[1]];
  const ad = [d[0] - a[0], d[1] - a[1]];
  const ca = [a[0] - c[0], a[1] - c[1]];
  const cb = [b[0] - c[0], b[1] - c[1]];
  const cd = [d[0] - c[0], d[1] - c[1]];
  return crossProduct(ab, ac) * crossProduct(ab, ad) <= 0 && crossProduct(cd, ca) * crossProduct(cd, cb) <= 0;
};
var isLineHitRectangle = (points, rectangle) => {
  if (points.length === 1) {
    return RectangleClient.isPointInRectangle(rectangle, points[0]);
  }
  const rectanglePoints = RectangleClient.getCornerPoints(rectangle);
  const len = points.length;
  for (let i = 0; i < len; i++) {
    const p1 = points[i];
    const p2 = points[(i + 1) % len];
    if (i === len - 1 && Point.isEquals(p1, p2))
      continue;
    const isHit = isSingleLineHitRectangleEdge(p1, p2, rectangle);
    if (isHit || isPointInPolygon(p1, rectanglePoints) || isPointInPolygon(p2, rectanglePoints)) {
      return true;
    }
  }
  return false;
};
var isLineHitRectangleEdge = (points, rectangle, isClose = true) => {
  const len = points.length;
  for (let i = 0; i < len; i++) {
    if (i === len - 1 && !isClose)
      continue;
    const p1 = points[i];
    const p2 = points[(i + 1) % len];
    const isHit = isSingleLineHitRectangleEdge(p1, p2, rectangle);
    if (isHit) {
      return true;
    }
  }
  return false;
};
var isSingleLineHitRectangleEdge = (p1, p2, rectangle) => {
  const rectanglePoints = RectangleClient.getCornerPoints(rectangle);
  return isLineHitLine(p1, p2, rectanglePoints[0], rectanglePoints[1]) || isLineHitLine(p1, p2, rectanglePoints[1], rectanglePoints[2]) || isLineHitLine(p1, p2, rectanglePoints[2], rectanglePoints[3]) || isLineHitLine(p1, p2, rectanglePoints[3], rectanglePoints[0]);
};
var isPointInPolygon = (point, points) => {
  const x = point[0], y = point[1];
  let inside = false;
  for (var i = 0, j = points.length - 1; i < points.length; j = i++) {
    let xi = points[i][0], yi = points[i][1];
    let xj = points[j][0], yj = points[j][1];
    let intersect = yi > y != yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
};
var isPointInEllipse = (point, center, rx, ry, angle = 0) => {
  const cosAngle = Math.cos(angle);
  const sinAngle = Math.sin(angle);
  const x1 = (point[0] - center[0]) * cosAngle + (point[1] - center[1]) * sinAngle;
  const y1 = (point[1] - center[1]) * cosAngle - (point[0] - center[0]) * sinAngle;
  return x1 * x1 / (rx * rx) + y1 * y1 / (ry * ry) <= 1;
};
var isPointInRoundRectangle = (point, rectangle, radius, angle = 0) => {
  const { x: rectX, y: rectY, width, height } = rectangle;
  const isInRectangle = point[0] >= rectX && point[0] <= rectX + width && point[1] >= rectY && point[1] <= rectY + height;
  const handleLeftTop = point[0] >= rectX && point[0] <= rectX + radius && point[1] >= rectY && point[1] <= rectY + radius && Math.hypot(point[0] - (rectX + radius), point[1] - (rectY + radius)) > radius;
  const handleLeftBottom = point[0] >= rectX && point[0] <= rectX + radius && point[1] >= rectY + height && point[1] <= rectY + height - radius && Math.hypot(point[0] - (rectX + radius), point[1] - (rectY + height - radius)) > radius;
  const handleRightTop = point[0] >= rectX + width - radius && point[0] <= rectX + width && point[1] >= rectY && point[1] <= rectY + radius && Math.hypot(point[0] - (rectX + width - radius), point[1] - (rectY + radius)) > radius;
  const handleRightBottom = point[0] >= rectX + width - radius && point[0] <= rectX + width && point[1] >= rectY + height - radius && point[1] <= rectY + height && Math.hypot(point[0] - (rectX + width - radius), point[1] - (rectY + height - radius)) > radius;
  const isInCorner = handleLeftTop || handleLeftBottom || handleRightTop || handleRightBottom;
  return isInRectangle && !isInCorner;
};
var catmullRomFitting = function(points) {
  const alpha = 0.5;
  let p0, p1, p2, p3, bp1, bp2, d1, d2, d3, A2, B2, N2, M2;
  var d3powA, d2powA, d3pow2A, d2pow2A, d1pow2A, d1powA;
  const result = [];
  result.push([Math.round(points[0][0]), Math.round(points[0][1])]);
  var length = points.length;
  for (var i = 0; i < length - 1; i++) {
    p0 = i == 0 ? points[0] : points[i - 1];
    p1 = points[i];
    p2 = points[i + 1];
    p3 = i + 2 < length ? points[i + 2] : p2;
    d1 = Math.sqrt(Math.pow(p0[0] - p1[0], 2) + Math.pow(p0[1] - p1[1], 2));
    d2 = Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));
    d3 = Math.sqrt(Math.pow(p2[0] - p3[0], 2) + Math.pow(p2[1] - p3[1], 2));
    d3powA = Math.pow(d3, alpha);
    d3pow2A = Math.pow(d3, 2 * alpha);
    d2powA = Math.pow(d2, alpha);
    d2pow2A = Math.pow(d2, 2 * alpha);
    d1powA = Math.pow(d1, alpha);
    d1pow2A = Math.pow(d1, 2 * alpha);
    A2 = 2 * d1pow2A + 3 * d1powA * d2powA + d2pow2A;
    B2 = 2 * d3pow2A + 3 * d3powA * d2powA + d2pow2A;
    N2 = 3 * d1powA * (d1powA + d2powA);
    if (N2 > 0) {
      N2 = 1 / N2;
    }
    M2 = 3 * d3powA * (d3powA + d2powA);
    if (M2 > 0) {
      M2 = 1 / M2;
    }
    bp1 = [(-d2pow2A * p0[0] + A2 * p1[0] + d1pow2A * p2[0]) * N2, (-d2pow2A * p0[1] + A2 * p1[1] + d1pow2A * p2[1]) * N2];
    bp2 = [(d3pow2A * p1[0] + B2 * p2[0] - d2pow2A * p3[0]) * M2, (d3pow2A * p1[1] + B2 * p2[1] - d2pow2A * p3[1]) * M2];
    if (bp1[0] == 0 && bp1[1] == 0) {
      bp1 = p1;
    }
    if (bp2[0] == 0 && bp2[1] == 0) {
      bp2 = p2;
    }
    result.push(bp1, bp2, p2);
  }
  return result;
};
function getEllipseTangentSlope(x, y, a, b) {
  if (Math.abs(y) === 0) {
    return x > 0 ? -Infinity : Infinity;
  }
  const k = -b * b * x / (a * a * y);
  return k;
}
function getVectorFromPointAndSlope(x, y, slope) {
  if (slope === Infinity) {
    return [0, -1];
  } else if (slope === -Infinity) {
    return [0, 1];
  }
  let vector = [1, -slope];
  if (y < 0) {
    vector = [-vector[0], -vector[1]];
  }
  return vector;
}
function toDomPrecision(v) {
  return +v.toFixed(4);
}
function toFixed(v) {
  return +v.toFixed(2);
}
function ceilToDecimal(value, decimalPlaces) {
  const factor = Math.pow(10, decimalPlaces);
  return Math.ceil(value * factor) / factor;
}
function approximately(a, b, precision = 1e-6) {
  return Math.abs(a - b) <= precision;
}
function getCrossingPointsBetweenEllipseAndSegment(startPoint, endPoint, cx, cy, rx, ry, segment_only = true) {
  if (rx === 0 || ry === 0 || startPoint[0] === endPoint[0] && startPoint[1] === endPoint[1]) {
    return [];
  }
  rx = rx < 0 ? rx : -rx;
  ry = ry < 0 ? ry : -ry;
  startPoint[0] -= cx;
  startPoint[1] -= cy;
  endPoint[0] -= cx;
  endPoint[1] -= cy;
  var A2 = (endPoint[0] - startPoint[0]) * (endPoint[0] - startPoint[0]) / rx / rx + (endPoint[1] - startPoint[1]) * (endPoint[1] - startPoint[1]) / ry / ry;
  var B2 = 2 * startPoint[0] * (endPoint[0] - startPoint[0]) / rx / rx + 2 * startPoint[1] * (endPoint[1] - startPoint[1]) / ry / ry;
  var C2 = startPoint[0] * startPoint[0] / rx / rx + startPoint[1] * startPoint[1] / ry / ry - 1;
  var tValues = [];
  var discriminant = B2 * B2 - 4 * A2 * C2;
  if (discriminant === 0) {
    tValues.push(-B2 / 2 / A2);
  } else if (discriminant > 0) {
    tValues.push((-B2 + Math.sqrt(discriminant)) / 2 / A2);
    tValues.push((-B2 - Math.sqrt(discriminant)) / 2 / A2);
  }
  return tValues.filter((t) => !segment_only || t >= 0 && t <= 1).map((t) => [startPoint[0] + (endPoint[0] - startPoint[0]) * t + cx, startPoint[1] + (endPoint[1] - startPoint[1]) * t + cy]);
}
function getPointBetween(x0, y0, x1, y1, d = 0.5) {
  return [x0 + (x1 - x0) * d, y0 + (y1 - y0) * d];
}
function getEllipseArcCenter(startPoint, arcCommand) {
  const dx = (arcCommand.endX - startPoint[0]) / 2;
  const dy = (arcCommand.endY - startPoint[1]) / 2;
  const cosAngle = Math.cos(arcCommand.xAxisRotation);
  const sinAngle = Math.sin(arcCommand.xAxisRotation);
  const x1 = cosAngle * dx + sinAngle * dy;
  const y1 = -sinAngle * dx + cosAngle * dy;
  const rx = Math.abs(arcCommand.rx);
  const ry = Math.abs(arcCommand.ry);
  const lambda = x1 * x1 / (rx * rx) + y1 * y1 / (ry * ry);
  const factor = lambda > 1 ? Math.sqrt(lambda) : 1;
  const adjustedRx = rx * factor;
  const adjustedRy = ry * factor;
  const sign = arcCommand.largeArcFlag === arcCommand.sweepFlag ? -1 : 1;
  const sq = (adjustedRx * adjustedRx * adjustedRy * adjustedRy - adjustedRx * adjustedRx * y1 * y1 - adjustedRy * adjustedRy * x1 * x1) / (adjustedRx * adjustedRx * y1 * y1 + adjustedRy * adjustedRy * x1 * x1);
  const coef = sign * Math.sqrt(Math.max(0, sq));
  const centerX = coef * (adjustedRx * y1 / adjustedRy);
  const centerY = coef * (-(adjustedRy * x1) / adjustedRx);
  const cx = cosAngle * centerX - sinAngle * centerY + (startPoint[0] + arcCommand.endX) / 2;
  const cy = sinAngle * centerX + cosAngle * centerY + (startPoint[1] + arcCommand.endY) / 2;
  return {
    center: [cx, cy],
    rx: adjustedRx,
    ry: adjustedRy
  };
}
function getNearestPointBetweenPointAndArc(point, startPoint, arcCommand) {
  const { center, rx, ry } = getEllipseArcCenter(startPoint, arcCommand);
  const nearestPoint = getNearestPointBetweenPointAndEllipse(point, center, rx, ry);
  const startAngle = Math.atan2(startPoint[1] - center[1], startPoint[0] - center[0]);
  const endAngle = Math.atan2(arcCommand.endY - center[1], arcCommand.endX - center[0]);
  const pointAngle = Math.atan2(nearestPoint[1] - center[1], nearestPoint[0] - center[0]);
  const isInArc = isAngleBetween(pointAngle, startAngle, endAngle, arcCommand.sweepFlag === 1);
  if (isInArc) {
    return nearestPoint;
  }
  const distanceToStart = distanceBetweenPointAndPoint(point[0], point[1], startPoint[0], startPoint[1]);
  const distanceToEnd = distanceBetweenPointAndPoint(point[0], point[1], arcCommand.endX, arcCommand.endY);
  return distanceToStart < distanceToEnd ? startPoint : [arcCommand.endX, arcCommand.endY];
}
function isAngleBetween(angle, start, end, clockwise) {
  const normalize = (a2) => (a2 % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);
  const a = normalize(angle);
  const s = normalize(start);
  const e = normalize(end);
  if (clockwise) {
    return s <= e ? a >= s && a <= e : a >= s || a <= e;
  } else {
    return s >= e ? a <= s && a >= e : a <= s || a >= e;
  }
}
function isInPlaitBoard(board, x, y) {
  const plaitBoardElement = PlaitBoard.getBoardContainer(board);
  const plaitBoardRect = plaitBoardElement.getBoundingClientRect();
  const distances = distanceBetweenPointAndRectangle(x, y, plaitBoardRect);
  return distances === 0;
}
function getRealScrollBarWidth(board) {
  const { hideScrollbar } = board.options;
  let scrollBarWidth = 0;
  if (!hideScrollbar) {
    const viewportContainer = PlaitBoard.getViewportContainer(board);
    scrollBarWidth = viewportContainer.offsetWidth - viewportContainer.clientWidth;
  }
  return scrollBarWidth;
}
var NS = "http://www.w3.org/2000/svg";
function createG() {
  const newG = document.createElementNS(NS, "g");
  return newG;
}
function createPath() {
  const newG = document.createElementNS(NS, "path");
  return newG;
}
function createRect(rectangle, options) {
  const rect = document.createElementNS(NS, "rect");
  rect.setAttribute("x", `${rectangle.x}`);
  rect.setAttribute("y", `${rectangle.y}`);
  rect.setAttribute("width", `${rectangle.width}`);
  rect.setAttribute("height", `${rectangle.height}`);
  for (let key in options) {
    const optionKey = key;
    rect.setAttribute(key, `${options[optionKey]}`);
  }
  return rect;
}
var setStrokeLinecap = (g, value) => {
  g.setAttribute("stroke-linecap", value);
};
var setPathStrokeLinecap = (g, value) => {
  g.querySelectorAll("path").forEach((path) => {
    path.setAttribute("stroke-linecap", value);
  });
};
function createMask() {
  return document.createElementNS(NS, "mask");
}
function createSVG() {
  const svg = document.createElementNS(NS, "svg");
  return svg;
}
function createText(x, y, fill, textContent) {
  var text = document.createElementNS(NS, "text");
  text.setAttribute("x", `${x}`);
  text.setAttribute("y", `${y}`);
  text.setAttribute("fill", fill);
  text.textContent = textContent;
  return text;
}
var isDOMElement = (value) => {
  return isDOMNode(value) && value.nodeType === 1;
};
var isDOMNode = (value) => {
  return value instanceof window.Node;
};
var hasInputOrTextareaTarget = (target) => {
  if (isDOMElement(target)) {
    if (target.tagName === "INPUT" || target.tagName === "TEXTAREA") {
      return true;
    }
  }
  return false;
};
var isSecondaryPointer = (event) => {
  return event.button === POINTER_BUTTON.SECONDARY;
};
var isMainPointer = (event) => {
  return event.button === POINTER_BUTTON.MAIN;
};
var isWheelPointer = (event) => {
  return event.button === POINTER_BUTTON.WHEEL;
};
function createForeignObject(x, y, width, height) {
  var newForeignObject = document.createElementNS(NS, "foreignObject");
  newForeignObject.setAttribute("x", `${x}`);
  newForeignObject.setAttribute("y", `${y}`);
  newForeignObject.setAttribute("width", `${ceilToDecimal(width, 0)}`);
  newForeignObject.setAttribute("height", `${height}`);
  return newForeignObject;
}
function updateForeignObject(target, width, height, x, y) {
  const foreignObject = target instanceof SVGForeignObjectElement ? target : target.querySelector("foreignObject");
  if (foreignObject) {
    foreignObject.setAttribute("width", `${ceilToDecimal(width, 0)}`);
    foreignObject.setAttribute("height", `${height}`);
    foreignObject.setAttribute("x", `${x}`);
    foreignObject.setAttribute("y", `${y}`);
  }
}
function updateForeignObjectWidth(target, width) {
  const foreignObject = target instanceof SVGForeignObjectElement ? target : target.querySelector("foreignObject");
  if (foreignObject) {
    foreignObject.setAttribute("width", `${ceilToDecimal(width, 0)}`);
  }
}
var IS_MAC = typeof window != "undefined" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
var IS_IOS = typeof navigator !== "undefined" && typeof window !== "undefined" && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
var IS_APPLE = typeof navigator !== "undefined" && /Mac OS X/.test(navigator.userAgent);
var IS_FIREFOX = typeof navigator !== "undefined" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
var IS_SAFARI = typeof navigator !== "undefined" && /Version\/[\d\.]+.*Safari/.test(navigator.userAgent);
var IS_EDGE_LEGACY = typeof navigator !== "undefined" && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])/i.test(navigator.userAgent);
var IS_CHROME = typeof navigator !== "undefined" && /Chrome/i.test(navigator.userAgent);
var IS_CHROME_LEGACY = typeof navigator !== "undefined" && /Chrome?\/(?:[0-7][0-5]|[0-6][0-9])/i.test(navigator.userAgent);
var IS_WINDOWS = typeof navigator !== "undefined" && /Windows/.test(navigator.userAgent);
var shouldMerge = (op, prev) => {
  if (op.type === "set_viewport" && op.type === (prev == null ? void 0 : prev.type)) {
    return true;
  }
  return false;
};
var shouldSave = (op, prev) => {
  if (op.type === "set_selection" || op.type === "set_viewport") {
    return false;
  }
  return true;
};
var shouldClear = (op) => {
  if (op.type === "set_selection") {
    return false;
  }
  return true;
};
var PlaitHistoryBoard = {
  /**
   * Get the saving flag's current value.
   */
  isSaving(board) {
    return SAVING.get(board);
  },
  /**
   * Get the merge flag's current value.
   */
  isMerging(board) {
    return MERGING.get(board);
  },
  /**
   * Get the splitting once flag's current value.
   */
  isSplittingOnce(board) {
    return SPLITTING_ONCE.get(board);
  },
  setSplittingOnce(board, value) {
    SPLITTING_ONCE.set(board, value);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, These operations will
   * be merged into the previous history.
   */
  withMerging(board, fn) {
    const prev = PlaitHistoryBoard.isMerging(board);
    MERGING.set(board, true);
    fn();
    MERGING.set(board, prev);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, ensuring that the first
   * operation starts a new batch in the history. Subsequent operations will be
   * merged as usual.
   */
  withNewBatch(board, fn) {
    const prev = PlaitHistoryBoard.isMerging(board);
    MERGING.set(board, true);
    SPLITTING_ONCE.set(board, true);
    fn();
    MERGING.set(board, prev);
    SPLITTING_ONCE.delete(board);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without merging any of
   * the new operations into previous save point in the history.
   */
  withoutMerging(board, fn) {
    const prev = PlaitHistoryBoard.isMerging(board);
    MERGING.set(board, false);
    fn();
    MERGING.set(board, prev);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without saving any of
   * their operations into the history.
   */
  withoutSaving(board, fn) {
    const prev = PlaitHistoryBoard.isSaving(board);
    SAVING.set(board, false);
    fn();
    SAVING.set(board, prev);
  }
};
var HOTKEYS = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  arrow: ["down", "left", "right", "up"],
  extendArrow: ["shift+down", "shift+left", "shift+right", "shift+up"],
  moveBackward: "left",
  moveForward: "right",
  moveUp: "up",
  moveDown: "down",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  extendUp: "shift+up",
  extendDown: "shift+down",
  italic: "mod+i",
  splitBlock: "shift?+enter",
  undo: "mod+z",
  shift: "shift"
};
var APPLE_HOTKEYS = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
};
var WINDOWS_HOTKEYS = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
};
var create = (key) => {
  const generic = HOTKEYS[key];
  const apple = APPLE_HOTKEYS[key];
  const windows = WINDOWS_HOTKEYS[key];
  const isGeneric = generic && (0, import_is_hotkey.isKeyHotkey)(generic);
  const isApple = apple && (0, import_is_hotkey.isKeyHotkey)(apple);
  const isWindows = windows && (0, import_is_hotkey.isKeyHotkey)(windows);
  return (event) => {
    if (isGeneric && isGeneric(event)) {
      return true;
    }
    if (IS_APPLE && isApple && isApple(event)) {
      return true;
    }
    if (!IS_APPLE && isWindows && isWindows(event)) {
      return true;
    }
    return false;
  };
};
var hotkeys = {
  isBold: create("bold"),
  isCompose: create("compose"),
  isArrow: create("arrow"),
  isMoveBackward: create("moveBackward"),
  isMoveForward: create("moveForward"),
  isMoveUp: create("moveUp"),
  isMoveDown: create("moveDown"),
  isDeleteBackward: create("deleteBackward"),
  isDeleteForward: create("deleteForward"),
  isDeleteLineBackward: create("deleteLineBackward"),
  isDeleteLineForward: create("deleteLineForward"),
  isDeleteWordBackward: create("deleteWordBackward"),
  isDeleteWordForward: create("deleteWordForward"),
  isExtendBackward: create("extendBackward"),
  isExtendForward: create("extendForward"),
  isExtendUp: create("extendUp"),
  isExtendDown: create("extendDown"),
  isExtendArrow: create("extendArrow"),
  isExtendLineBackward: create("extendLineBackward"),
  isExtendLineForward: create("extendLineForward"),
  isItalic: create("italic"),
  isMoveLineBackward: create("moveLineBackward"),
  isMoveLineForward: create("moveLineForward"),
  isMoveWordBackward: create("moveWordBackward"),
  isMoveWordForward: create("moveWordForward"),
  isRedo: create("redo"),
  isSplitBlock: create("splitBlock"),
  isTransposeCharacter: create("transposeCharacter"),
  isUndo: create("undo"),
  isShift: create("shift")
};
function idCreator(length = 5) {
  const $chars = "ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz";
  const maxPosition = $chars.length;
  let key = "";
  for (let i = 0; i < length; i++) {
    key += $chars.charAt(Math.floor(Math.random() * maxPosition));
  }
  return key;
}
function depthFirstRecursion(node, callback, recursion, isReverse) {
  if (node.children && (!recursion || recursion(node))) {
    let children = [...node.children];
    children = isReverse ? children.reverse() : children;
    children.forEach((child) => {
      depthFirstRecursion(child, callback, recursion);
    });
  }
  callback(node);
}
var getIsRecursionFunc = (board) => {
  return (element) => {
    if (PlaitBoard.isBoard(element) || board.isRecursion(element)) {
      return true;
    } else {
      return false;
    }
  };
};
var SELECTION_BORDER_COLOR = "#6698FF";
var SELECTION_FILL_COLOR = "#6698FF25";
var Selection = {
  isCollapsed(selection) {
    if (selection.anchor[0] == selection.focus[0] && selection.anchor[1] === selection.focus[1]) {
      return true;
    } else {
      return false;
    }
  }
};
var PlaitElement = {
  isRootElement(value) {
    const parent = NODE_TO_PARENT.get(value);
    if (parent && PlaitBoard.isBoard(parent)) {
      return true;
    } else {
      return false;
    }
  },
  getElementRef(value) {
    return ELEMENT_TO_REF.get(value);
  },
  getElementG(value) {
    const g = NODE_TO_G.get(value);
    if (!g) {
      throw new Error(`can not resolve element g: ${JSON.stringify(value)}`);
    }
    return g;
  },
  hasMounted(element) {
    const containerG = PlaitElement.getContainerG(element, { suppressThrow: true });
    if (containerG) {
      return true;
    } else {
      return false;
    }
  },
  getContainerG(value, options) {
    const containerG = NODE_TO_CONTAINER_G.get(value) || null;
    if (!containerG) {
      if (options.suppressThrow) {
        return null;
      }
      throw new Error("can not resolve container g");
    }
    return containerG;
  }
};
var sortElements = (board, elements, ascendingOrder = true) => {
  return [...elements].sort((a, b) => {
    const pathA = PlaitBoard.findPath(board, a);
    const pathB = PlaitBoard.findPath(board, b);
    return ascendingOrder ? pathA[0] - pathB[0] : pathB[0] - pathA[0];
  });
};
var TEMPORARY_G = /* @__PURE__ */ new Map();
var getTemporaryGArray = (debugKey) => {
  return TEMPORARY_G.get(debugKey) || [];
};
var setTemporaryGArray = (debugKey, gArray) => {
  TEMPORARY_G.set(debugKey, gArray);
};
var DebugGenerator = class {
  constructor(debugKey) {
    this.debugKey = debugKey;
  }
  isDebug() {
    return isDebug(this.debugKey);
  }
  clear() {
    if (!this.isDebug()) {
      return;
    }
    const gArray = getTemporaryGArray(this.debugKey);
    setTemporaryGArray(this.debugKey, []);
    gArray.forEach((g) => g.remove());
  }
  drawPolygon(board, points, options) {
    if (!isDebug(this.debugKey)) {
      return;
    }
    const polygonG = PlaitBoard.getRoughSVG(board).polygon(points, options || { stroke: "red" });
    polygonG.classList.add(this.debugKey);
    PlaitBoard.getElementTopHost(board).append(polygonG);
    const gArray = getTemporaryGArray(this.debugKey);
    gArray.push(polygonG);
    setTemporaryGArray(this.debugKey, gArray);
    return polygonG;
  }
  drawLine(board, points, options) {
    if (!isDebug(this.debugKey)) {
      return;
    }
    const lineG = PlaitBoard.getRoughSVG(board).linearPath(points, options || { stroke: "red" });
    lineG.classList.add(this.debugKey);
    PlaitBoard.getElementTopHost(board).append(lineG);
    const gArray = getTemporaryGArray(this.debugKey);
    gArray.push(lineG);
    setTemporaryGArray(this.debugKey, gArray);
    return lineG;
  }
  drawRectangle(board, data, options) {
    if (!isDebug(this.debugKey)) {
      return;
    }
    let rectangle;
    if (data instanceof Array) {
      rectangle = RectangleClient.getRectangleByPoints(data);
    } else {
      rectangle = data;
    }
    const rectangleG = PlaitBoard.getRoughSVG(board).rectangle(rectangle.x, rectangle.y, rectangle.width, rectangle.height, options || { stroke: "red" });
    rectangleG.classList.add(this.debugKey);
    PlaitBoard.getElementTopHost(board).append(rectangleG);
    const gArray = getTemporaryGArray(this.debugKey);
    gArray.push(rectangleG);
    setTemporaryGArray(this.debugKey, gArray);
    return rectangleG;
  }
  drawCircles(board, points, diameter = 0, isCumulativeDiameter = false, options) {
    if (!isDebug(this.debugKey)) {
      return;
    }
    const result = [];
    points.forEach((p, i) => {
      const circle = PlaitBoard.getRoughSVG(board).circle(p[0], p[1], isCumulativeDiameter ? diameter * (i + 1) : diameter, Object.assign({}, { stroke: "red", fill: "red", fillStyle: "solid" }, options || {}));
      circle.classList.add(this.debugKey);
      PlaitBoard.getElementTopHost(board).append(circle);
      const gArray = getTemporaryGArray(this.debugKey);
      gArray.push(circle);
      result.push(circle);
      setTemporaryGArray(this.debugKey, gArray);
    });
    return result;
  }
};
var createDebugGenerator = (debugKey) => {
  return new DebugGenerator(debugKey);
};
var isDebug = (key) => {
  const defaultKey = "debug:plait";
  return localStorage.getItem(key || defaultKey) === "true";
};
var PlaitPluginKey;
(function(PlaitPluginKey2) {
  PlaitPluginKey2["withSelection"] = "withSelection";
  PlaitPluginKey2["withHand"] = "withHand";
})(PlaitPluginKey || (PlaitPluginKey = {}));
var getHitElementsBySelection = (board, selection, match = () => true) => {
  const newSelection = selection || board.selection;
  const rectangleHitElements = [];
  if (!newSelection) {
    return [];
  }
  const isCollapsed = Selection.isCollapsed(newSelection);
  if (isCollapsed) {
    const hitElements = getHitElementsByPoint(board, newSelection.anchor, match);
    if (hitElements == null ? void 0 : hitElements.length) {
      return hitElements;
    } else {
      return [];
    }
  }
  depthFirstRecursion(board, (node) => {
    if (!PlaitBoard.isBoard(node) && match(node)) {
      let isRectangleHit = false;
      try {
        isRectangleHit = board.isRectangleHit(node, newSelection);
      } catch (error) {
        if (isDebug()) {
          console.error("isRectangleHit", error, "node", node);
        }
      }
      if (isRectangleHit) {
        rectangleHitElements.push(node);
      }
    }
  }, getIsRecursionFunc(board), true);
  return rectangleHitElements;
};
var getHitElementsByPoint = (board, point, match = () => true, isStrict = true) => {
  let hitElements = [];
  depthFirstRecursion(board, (node) => {
    if (PlaitBoard.isBoard(node) || !match(node) || !PlaitElement.hasMounted(node)) {
      return;
    }
    let isHit = false;
    try {
      isHit = board.isHit(node, point, isStrict);
    } catch (error) {
      if (isDebug()) {
        console.error("isHit", error, "node", node);
      }
    }
    if (isHit) {
      hitElements.push(node);
      return;
    }
  }, getIsRecursionFunc(board), true);
  return hitElements;
};
var getHitElementByPoint = (board, point, match = () => true, isStrict = true) => {
  const pointHitElements = getHitElementsByPoint(board, point, match, isStrict);
  const hitElement = board.getOneHitElement(pointHitElements);
  return hitElement;
};
var getHitSelectedElements = (board, point) => {
  const selectedElements = getSelectedElements(board);
  const targetRectangle = selectedElements.length > 0 && getRectangleByElements(board, selectedElements, false);
  const isInTargetRectangle = targetRectangle && RectangleClient.isPointInRectangle(targetRectangle, point);
  if (isInTargetRectangle) {
    return selectedElements;
  } else {
    return [];
  }
};
var cacheSelectedElements = (board, selectedElements) => {
  const sortedElements = sortElements(board, selectedElements);
  BOARD_TO_SELECTED_ELEMENT.set(board, sortedElements);
};
var getSelectedElements = (board) => {
  return BOARD_TO_SELECTED_ELEMENT.get(board) || [];
};
var addSelectedElement = (board, element) => {
  let elements = [];
  if (Array.isArray(element)) {
    elements.push(...element);
  } else {
    elements.push(element);
  }
  const selectedElements = getSelectedElements(board);
  cacheSelectedElements(board, [...selectedElements, ...elements]);
};
var removeSelectedElement = (board, element, isRemoveChildren = false) => {
  const selectedElements = getSelectedElements(board);
  if (selectedElements.includes(element)) {
    const targetElements = [];
    if (board.isRecursion(element) && isRemoveChildren) {
      depthFirstRecursion(element, (node) => {
        targetElements.push(node);
      }, (node) => board.isRecursion(node));
    } else {
      targetElements.push(element);
    }
    const newSelectedElements = selectedElements.filter((value) => !targetElements.includes(value));
    cacheSelectedElements(board, newSelectedElements);
  }
};
var replaceSelectedElement = (board, element, newElement) => {
  const selectedElements = getSelectedElements(board);
  selectedElements.splice(selectedElements.indexOf(element), 1, newElement);
};
var clearSelectedElement = (board) => {
  cacheSelectedElements(board, []);
};
var isSelectedElement = (board, element) => {
  const selectedElements = getSelectedElements(board);
  return !!selectedElements.find((value) => value === element);
};
var temporaryDisableSelection = (board) => {
  const currentOptions = board.getPluginOptions(PlaitPluginKey.withSelection);
  board.setPluginOptions(PlaitPluginKey.withSelection, {
    isDisabledSelection: true
  });
  setTimeout(() => {
    board.setPluginOptions(PlaitPluginKey.withSelection, { ...currentOptions });
  }, 0);
};
var isHitSelectedRectangle = (board, point) => {
  const hitSelectedElements = getHitSelectedElements(board, point);
  return hitSelectedElements.length > 0;
};
var isHitElement = (board, point) => {
  const hitElement = getHitElementByPoint(board, point);
  return !!hitElement || isHitSelectedRectangle(board, point);
};
function drawRoundRectangle(rs, x1, y1, x2, y2, options, outline = false, borderRadius) {
  const width = Math.abs(x1 - x2);
  const height = Math.abs(y1 - y2);
  let radius = borderRadius || 0;
  if (radius === 0) {
    const defaultRadius = Math.min(width, height) / 8;
    let radius2 = defaultRadius;
    if (defaultRadius > MAX_RADIUS) {
      radius2 = outline ? MAX_RADIUS + 2 : MAX_RADIUS;
    }
  }
  const point1 = [x1 + radius, y1];
  const point2 = [x2 - radius, y1];
  const point3 = [x2, y1 + radius];
  const point4 = [x2, y2 - radius];
  const point5 = [x2 - radius, y2];
  const point6 = [x1 + radius, y2];
  const point7 = [x1, y2 - radius];
  const point8 = [x1, y1 + radius];
  const rectangleG = rs.path(`M${point2[0]} ${point2[1]} A ${radius} ${radius}, 0, 0, 1, ${point3[0]} ${point3[1]} L ${point4[0]} ${point4[1]} A ${radius} ${radius}, 0, 0, 1, ${point5[0]} ${point5[1]} L ${point6[0]} ${point6[1]} A ${radius} ${radius}, 0, 0, 1, ${point7[0]} ${point7[1]} L ${point8[0]} ${point8[1]} A ${radius} ${radius}, 0, 0, 1, ${point1[0]} ${point1[1]} Z`, options);
  setStrokeLinecap(rectangleG, "round");
  return rectangleG;
}
var drawRectangle = (board, rectangle, options) => {
  const roughSVG = PlaitBoard.getRoughSVG(board);
  const rectangleG = roughSVG.rectangle(rectangle.x, rectangle.y, rectangle.width, rectangle.height, options);
  setStrokeLinecap(rectangleG, "round");
  return rectangleG;
};
function arrowPoints(start, end, degree = 40) {
  const width = Math.abs(start[0] - end[0]);
  const height = Math.abs(start[1] - end[1]);
  let hypotenuse = Math.hypot(width, height);
  const realRotateLine = hypotenuse / 2;
  const rotateWidth = realRotateLine / hypotenuse * width;
  const rotateHeight = realRotateLine / hypotenuse * height;
  const rotatePoint = [
    end[0] > start[0] ? end[0] - rotateWidth : end[0] + rotateWidth,
    end[1] > start[1] ? end[1] - rotateHeight : end[1] + rotateHeight
  ];
  const pointRight = rotate(rotatePoint[0], rotatePoint[1], end[0], end[1], degree * Math.PI / 180);
  const pointLeft = rotate(rotatePoint[0], rotatePoint[1], end[0], end[1], -degree * Math.PI / 180);
  return { pointLeft, pointRight };
}
function drawArrow(rs, start, end, options, maxHypotenuseLength = 10, degree = 40) {
  const { pointLeft, pointRight } = arrowPoints(start, end, degree);
  const arrowLineLeft = rs.linearPath([pointLeft, end], options);
  const arrowLineRight = rs.linearPath([pointRight, end], options);
  return [arrowLineLeft, arrowLineRight];
}
function drawCircle(roughSVG, point, diameter, options) {
  return roughSVG.circle(point[0], point[1], diameter, options);
}
function drawLine(rs, start, end, options) {
  return rs.linearPath([start, end], options);
}
function drawLinearPath(points, options, closePath) {
  const g = createG();
  const path = createPath();
  let polylinePath = "";
  points.forEach((point, index) => {
    if (index === 0) {
      polylinePath += `M ${point[0]} ${point[1]} `;
    } else {
      polylinePath += `L ${point[0]} ${point[1]} `;
    }
  });
  if (closePath) {
    polylinePath += "Z";
  }
  path.setAttribute("d", polylinePath);
  path.setAttribute("stroke", `${options == null ? void 0 : options.stroke}`);
  path.setAttribute("stroke-width", `${options == null ? void 0 : options.strokeWidth}`);
  path.setAttribute("fill", `${(options == null ? void 0 : options.fill) || "none"}`);
  (options == null ? void 0 : options.strokeLineDash) && path.setAttribute("stroke-dasharray", `${options.strokeLineDash}`);
  g.appendChild(path);
  return g;
}
function drawBezierPath(points, options) {
  const g = createG();
  const path = createPath();
  let polylinePath = "";
  for (let i = 0; i < points.length - 3; i += 3) {
    if (i === 0) {
      polylinePath += `M ${points[0][0]} ${points[0][1]} `;
    } else {
      polylinePath += `C ${points[i + 1][0]} ${points[i + 1][1]}, ${points[i + 2][0]} ${points[i + 2][1]}, ${points[i + 3][0]} ${points[i + 3][1]}`;
    }
  }
  path.setAttribute("d", polylinePath);
  path.setAttribute("stroke", `${options == null ? void 0 : options.stroke}`);
  path.setAttribute("stroke-width", `${options == null ? void 0 : options.strokeWidth}`);
  path.setAttribute("fill", `none`);
  g.appendChild(path);
  return g;
}
function setViewport(board, viewport) {
  const operation = { type: "set_viewport", properties: board.viewport, newProperties: viewport };
  board.apply(operation);
}
var ViewportTransforms$1 = {
  setViewport
};
function setTheme(board, themeColorMode) {
  const operation = { type: "set_theme", properties: board.theme, newProperties: themeColorMode };
  board.apply(operation);
}
function updateViewport(board, origination, zoom) {
  zoom = zoom ?? board.viewport.zoom;
  setViewport(board, {
    ...board.viewport,
    zoom,
    origination
  });
  clearViewportOrigination(board);
}
function updateZoom(board, newZoom, center) {
  newZoom = clampZoomLevel(newZoom);
  const nativeElement = PlaitBoard.getBoardContainer(board);
  const nativeElementRect = nativeElement.getBoundingClientRect();
  const boardContainerRect = PlaitBoard.getBoardContainer(board).getBoundingClientRect();
  let focusPoint = [boardContainerRect.width / 2, boardContainerRect.height / 2];
  if (center && distanceBetweenPointAndRectangle(center[0], center[1], nativeElementRect) === 0) {
    focusPoint = [center[0] - nativeElementRect.x, center[1] - nativeElementRect.y];
  }
  const zoom = board.viewport.zoom;
  const origination = getViewportOrigination(board);
  const centerX = origination[0] + focusPoint[0] / zoom;
  const centerY = origination[1] + focusPoint[1] / zoom;
  const newOrigination = [centerX - focusPoint[0] / newZoom, centerY - focusPoint[1] / newZoom];
  updateViewport(board, newOrigination, newZoom);
}
function fitViewport(board) {
  let scrollBarWidth = getRealScrollBarWidth(board);
  const boardContainerRect = PlaitBoard.getBoardContainer(board).getBoundingClientRect();
  const elementHostBox = getRectangleByElements(board, board.children, true);
  const zoom = board.viewport.zoom;
  const autoFitPadding = 16;
  const viewportWidth = boardContainerRect.width - 2 * autoFitPadding;
  const viewportHeight = boardContainerRect.height - 2 * autoFitPadding;
  let newZoom = zoom;
  if (viewportWidth < elementHostBox.width || viewportHeight < elementHostBox.height) {
    newZoom = Math.min(viewportWidth / elementHostBox.width, viewportHeight / elementHostBox.height);
  } else {
    newZoom = 1;
  }
  const centerPoint = getViewBoxCenterPoint(board);
  const newOrigination = [
    centerPoint[0] - boardContainerRect.width / 2 / newZoom + scrollBarWidth / 2 / zoom,
    centerPoint[1] - boardContainerRect.height / 2 / newZoom + scrollBarWidth / 2 / zoom
  ];
  updateViewport(board, newOrigination, newZoom);
}
function fitViewportWidth(board, options) {
  let scrollBarWidth = getRealScrollBarWidth(board);
  const boardContainer = PlaitBoard.getBoardContainer(board);
  const boardContainerRectangle = boardContainer.getBoundingClientRect();
  let finalWidth = 0;
  if (options.maxWidth) {
    finalWidth = options.maxWidth;
  } else {
    finalWidth = boardContainerRectangle.width;
  }
  const elementHostBox = getRectangleByElements(board, board.children, true);
  const contentWidth = finalWidth - 2 * options.autoFitPadding;
  let newZoom = 0;
  if (contentWidth < elementHostBox.width) {
    newZoom = Math.min(contentWidth / elementHostBox.width);
  } else {
    newZoom = 1;
  }
  let finalHeight = elementHostBox.height * newZoom + 2 * options.autoFitPadding;
  if (finalHeight > options.limitHeight) {
    const containerEl = boardContainer.closest(`.${options.containerClass}`);
    containerEl.style.height = `${finalHeight}px`;
    initializeViewportContainer(board);
  } else {
    finalHeight = options.limitHeight;
  }
  const centerX = elementHostBox.x + elementHostBox.width / 2;
  const centerY = elementHostBox.y + elementHostBox.height / 2;
  const newOrigination = [
    centerX - finalWidth / 2 / newZoom + scrollBarWidth / 2 / newZoom,
    centerY - finalHeight / 2 / newZoom + scrollBarWidth / 2 / newZoom
  ];
  updateViewport(board, newOrigination, newZoom);
}
function updateThemeColor(board, mode) {
  mode = mode ?? board.theme.themeColorMode;
  setTheme(board, { themeColorMode: mode });
  depthFirstRecursion(board, (element) => {
    board.applyTheme(element);
  });
}
var updatePointerType = (board, pointer) => {
  if (board.pointer === pointer)
    return;
  board.pointer = pointer;
};
function moveToCenter(board, centerPoint) {
  var _a;
  const plaitElement = (_a = getSelectedElements(board)) == null ? void 0 : _a[0];
  if (plaitElement) {
    const boardContainerRect = PlaitBoard.getBoardContainer(board).getBoundingClientRect();
    const scrollBarWidth = getRealScrollBarWidth(board);
    const oldCenterPoint = getViewBoxCenterPoint(board);
    const left = centerPoint[0] - oldCenterPoint[0];
    const top = centerPoint[1] - oldCenterPoint[1];
    const zoom = board.viewport.zoom;
    const origination = [
      left - boardContainerRect.width / 2 / zoom + scrollBarWidth / 2 / zoom,
      top - boardContainerRect.height / 2 / zoom + scrollBarWidth / 2 / zoom
    ];
    setViewport(board, {
      ...board.viewport,
      origination
    });
    clearViewportOrigination(board);
  }
}
var BoardTransforms = {
  updatePointerType,
  updateViewport,
  fitViewport,
  updateZoom,
  updateThemeColor,
  fitViewportWidth,
  moveToCenter
};
var getViewBox = (board) => {
  return PlaitBoard.getHost(board).viewBox.baseVal;
};
function toHostPoint(board, x, y) {
  const host = PlaitBoard.getHost(board);
  const rect = host.getBoundingClientRect();
  return [x - rect.x, y - rect.y];
}
function toActiveRectangleFromViewBoxRectangle(board, rectangle) {
  const leftTop = [rectangle.x, rectangle.y];
  const rightBottom = [rectangle.x + rectangle.width, rectangle.y + rectangle.height];
  const leftTopOfActive = toActivePointFromViewBoxPoint(board, leftTop);
  const rightBottomOfActive = toActivePointFromViewBoxPoint(board, rightBottom);
  return RectangleClient.getRectangleByPoints([leftTopOfActive, rightBottomOfActive]);
}
function toActivePointFromViewBoxPoint(board, point) {
  const screenPoint = toScreenPointFromHostPoint(board, toHostPointFromViewBoxPoint(board, point));
  return toActivePoint(board, screenPoint[0], screenPoint[1]);
}
function toActivePoint(board, x, y) {
  const boardContainer = PlaitBoard.getBoardContainer(board);
  const rect = boardContainer.getBoundingClientRect();
  return [x - rect.x, y - rect.y];
}
function toScreenPointFromActivePoint(board, activePoint) {
  const boardContainer = PlaitBoard.getBoardContainer(board);
  const rect = boardContainer.getBoundingClientRect();
  return [rect.x + activePoint[0], rect.y + activePoint[1]];
}
function toViewBoxPoint(board, hostPoint) {
  const viewBox = getViewBox(board);
  const { zoom } = board.viewport;
  const x = hostPoint[0] / zoom + viewBox.x;
  const y = hostPoint[1] / zoom + viewBox.y;
  const newPoint = [x, y];
  return newPoint;
}
function toViewBoxPoints(board, hostPoints) {
  const newPoints = hostPoints.map((point) => {
    return toViewBoxPoint(board, point);
  });
  return newPoints;
}
function toScreenPointFromHostPoint(board, hostPoint) {
  const host = PlaitBoard.getHost(board);
  const rect = host.getBoundingClientRect();
  return [hostPoint[0] + rect.x, hostPoint[1] + rect.y];
}
function toHostPointFromViewBoxPoint(board, viewBoxPoint) {
  const { zoom } = board.viewport;
  const viewBox = getViewBox(board);
  const x = (viewBoxPoint[0] - viewBox.x) * zoom;
  const y = (viewBoxPoint[1] - viewBox.y) * zoom;
  return [x, y];
}
var VIEWPORT_PADDING_RATIO = 0.75;
var IS_FROM_SCROLLING = /* @__PURE__ */ new WeakMap();
var IS_FROM_VIEWPORT_CHANGE = /* @__PURE__ */ new WeakMap();
function getViewportContainerRect(board) {
  const { hideScrollbar } = board.options;
  const scrollBarWidth = hideScrollbar ? SCROLL_BAR_WIDTH : 0;
  const viewportRect = PlaitBoard.getBoardContainer(board).getBoundingClientRect();
  return {
    width: viewportRect.width + scrollBarWidth,
    height: viewportRect.height + scrollBarWidth
  };
}
function getElementHostBBox(board, zoom) {
  const childrenRect = getRectangleByElements(board, board.children, true);
  let left;
  let right;
  let top;
  let bottom;
  left = childrenRect.x;
  right = childrenRect.x + childrenRect.width;
  top = childrenRect.y;
  bottom = childrenRect.y + childrenRect.height;
  return {
    left,
    right,
    top,
    bottom
  };
}
function clampZoomLevel(zoom, minZoom = MIN_ZOOM, maxZoom = MAX_ZOOM) {
  return zoom < minZoom ? minZoom : zoom > maxZoom ? maxZoom : zoom;
}
function prepareElementBBox(board, zoom) {
  const boardContainerRectangle = PlaitBoard.getBoardContainer(board).getBoundingClientRect();
  const elementHostBBox = getElementHostBBox(board, zoom);
  const containerWidth = boardContainerRectangle.width;
  const containerHeight = boardContainerRectangle.height;
  let width = elementHostBBox.right - elementHostBBox.left;
  let height = elementHostBBox.bottom - elementHostBBox.top;
  const minWidth = containerWidth / 2;
  const minHeight = containerHeight / 2;
  if (width < minWidth / zoom) {
    const center = elementHostBBox.left + width / 2;
    elementHostBBox.left = center - minWidth / 2 / zoom;
    elementHostBBox.right = center + minWidth / 2 / zoom;
    width = minWidth / zoom;
  }
  if (height < minHeight / zoom) {
    const center = elementHostBBox.top + height / 2;
    elementHostBBox.top = center - minHeight / 2 / zoom;
    elementHostBBox.bottom = center + minHeight / 2 / zoom;
    height = minHeight / zoom;
  }
  return {
    elementHostBBox,
    containerWidth,
    containerHeight,
    width,
    height
  };
}
function calculateViewBox(elementHostBBox, containerWidth, containerHeight, width, height, zoom, paddingRatio = VIEWPORT_PADDING_RATIO) {
  const horizontalPaddingInViewBox = containerWidth * paddingRatio / zoom;
  const verticalPaddingInViewBox = containerHeight * paddingRatio / zoom;
  return [
    elementHostBBox.left - horizontalPaddingInViewBox,
    elementHostBBox.top - verticalPaddingInViewBox,
    width + horizontalPaddingInViewBox * 2,
    height + verticalPaddingInViewBox * 2
  ];
}
function calcNewViewBox(board, zoom) {
  const { elementHostBBox, containerWidth, containerHeight, width, height } = prepareElementBBox(board, zoom);
  return calculateViewBox(elementHostBBox, containerWidth, containerHeight, width, height, zoom);
}
function getViewBoxCenterPoint(board) {
  const childrenRectangle = getRectangleByElements(board, board.children, true);
  return [childrenRectangle.x + childrenRectangle.width / 2, childrenRectangle.y + childrenRectangle.height / 2];
}
function setSVGViewBox(board, viewBox) {
  const zoom = board.viewport.zoom;
  const hostElement = PlaitBoard.getHost(board);
  hostElement.style.display = "block";
  hostElement.style.width = `${viewBox[2] * zoom}px`;
  hostElement.style.height = `${viewBox[3] * zoom}px`;
  if (viewBox && viewBox[2] > 0 && viewBox[3] > 0) {
    hostElement.setAttribute("viewBox", viewBox.join(" "));
  }
}
function updateViewportOffset(board) {
  const origination = getViewportOrigination(board);
  if (!origination) {
    return;
  }
  const [scrollLeft, scrollTop] = toHostPointFromViewBoxPoint(board, origination);
  updateViewportContainerScroll(board, scrollLeft, scrollTop);
}
function updateViewportContainerScroll(board, left, top, isFromViewportChange2 = true) {
  const viewportContainer = PlaitBoard.getViewportContainer(board);
  const previousScrollLeft = viewportContainer.scrollLeft;
  const previousScrollTop = viewportContainer.scrollTop;
  if (!approximately(viewportContainer.scrollLeft, left, 1) || !approximately(viewportContainer.scrollTop, top, 1)) {
    viewportContainer.scrollLeft = left;
    viewportContainer.scrollTop = top;
    const offsetWidth = viewportContainer.offsetWidth;
    const offsetHeight = viewportContainer.offsetHeight;
    if (previousScrollLeft === viewportContainer.scrollLeft && previousScrollTop === viewportContainer.scrollTop) {
      updateViewportByScrolling(board, previousScrollLeft, previousScrollTop);
    } else {
      const isValidLeftOrTop = left > 0 && top > 0 && left < viewportContainer.scrollWidth - offsetWidth && top < viewportContainer.scrollHeight - offsetHeight;
      if (isFromViewportChange2 && isValidLeftOrTop) {
        setIsFromViewportChange(board, true);
      }
    }
  }
}
function updateViewportByScrolling(board, scrollLeft, scrollTop) {
  const origination = toViewBoxPoint(board, [scrollLeft, scrollTop]);
  if (Point.isEquals(origination, getViewportOrigination(board))) {
    return;
  }
  BoardTransforms.updateViewport(board, origination);
  setIsFromScrolling(board, true);
}
function initializeViewportContainer(board) {
  const { width, height } = getViewportContainerRect(board);
  const viewportContainer = PlaitBoard.getViewportContainer(board);
  viewportContainer.style.width = `${width}px`;
  viewportContainer.style.height = `${height}px`;
}
function initializeViewBox(board) {
  const zoom = board.viewport.zoom;
  const viewBox = calcNewViewBox(board, zoom);
  setSVGViewBox(board, viewBox);
}
function updateViewBox(board) {
  const zoom = board.viewport.zoom;
  const { elementHostBBox, containerWidth, containerHeight, width, height } = prepareElementBBox(board, zoom);
  const checkViewBox = calculateViewBox(
    elementHostBBox,
    containerWidth,
    containerHeight,
    width,
    height,
    zoom,
    0.5
    // Use smaller padding ratio for checking
  );
  const currentViewBox = getViewBox(board);
  if (checkViewBox[0] < currentViewBox.x || checkViewBox[1] < currentViewBox.y || checkViewBox[0] + checkViewBox[2] > currentViewBox.x + currentViewBox.width || checkViewBox[1] + checkViewBox[3] > currentViewBox.y + currentViewBox.height) {
    const newViewBox = calculateViewBox(elementHostBBox, containerWidth, containerHeight, width, height, zoom, VIEWPORT_PADDING_RATIO);
    setSVGViewBox(board, newViewBox);
  }
}
function initializeViewportOffset(board) {
  var _a;
  if (!((_a = board.viewport) == null ? void 0 : _a.origination)) {
    const zoom = board.viewport.zoom;
    const viewportContainerRect = PlaitBoard.getBoardContainer(board).getBoundingClientRect();
    const viewBox = calcNewViewBox(board, zoom);
    const centerX = viewBox[0] + viewBox[2] / 2;
    const centerY = viewBox[1] + viewBox[3] / 2;
    const origination = [centerX - viewportContainerRect.width / 2 / zoom, centerY - viewportContainerRect.height / 2 / zoom];
    updateViewportOrigination(board, origination);
    updateViewportOffset(board);
    return;
  }
  updateViewportOffset(board);
}
var updateViewportOrigination = (board, origination) => {
  BOARD_TO_VIEWPORT_ORIGINATION.set(board, origination);
};
var clearViewportOrigination = (board) => {
  BOARD_TO_VIEWPORT_ORIGINATION.delete(board);
};
var getViewportOrigination = (board) => {
  const origination = BOARD_TO_VIEWPORT_ORIGINATION.get(board);
  if (origination) {
    return origination;
  } else {
    return board.viewport.origination;
  }
};
var isFromScrolling = (board) => {
  return !!IS_FROM_SCROLLING.get(board);
};
var setIsFromScrolling = (board, state) => {
  IS_FROM_SCROLLING.set(board, state);
};
var isFromViewportChange = (board) => {
  return !!IS_FROM_VIEWPORT_CHANGE.get(board);
};
var setIsFromViewportChange = (board, state) => {
  IS_FROM_VIEWPORT_CHANGE.set(board, state);
};
function scrollToRectangle(board, client) {
}
function insertNode(board, node, path) {
  const operation = { type: "insert_node", node, path };
  board.apply(operation);
}
function setNode(board, props, path) {
  const properties = {};
  const newProperties = {};
  const node = PlaitNode.get(board, path);
  for (const k in props) {
    if (node[k] !== props[k]) {
      if (node.hasOwnProperty(k)) {
        properties[k] = node[k];
      }
      if (props[k] != null)
        newProperties[k] = props[k];
    }
  }
  const operation = { type: "set_node", properties, newProperties, path };
  board.apply(operation);
}
function removeNode(board, path) {
  const node = PlaitNode.get(board, path);
  const operation = { type: "remove_node", path, node };
  board.apply(operation);
}
function moveNode(board, path, newPath) {
  const operation = { type: "move_node", path, newPath };
  board.apply(operation);
}
var NodeTransforms = {
  insertNode,
  setNode,
  removeNode,
  moveNode
};
var BOARD_TO_RAF = /* @__PURE__ */ new WeakMap();
var getTimerId = (board, key) => {
  const state = getRAFState(board);
  return state[key] || null;
};
var getRAFState = (board) => {
  return BOARD_TO_RAF.get(board) || {};
};
var throttleRAF = (board, key, fn) => {
  const scheduleFunc = () => {
    let timerId2 = requestAnimationFrame(() => {
      const value = BOARD_TO_RAF.get(board) || {};
      value[key] = null;
      BOARD_TO_RAF.set(board, value);
      PlaitBoard.isAlive(board) && fn();
    });
    const state = getRAFState(board);
    state[key] = timerId2;
    BOARD_TO_RAF.set(board, state);
  };
  let timerId = getTimerId(board, key);
  if (timerId !== null) {
    cancelAnimationFrame(timerId);
  }
  scheduleFunc();
};
var debounce2 = (func, wait, options) => {
  let timeoutId = null;
  return (args) => {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => {
        func(args);
        timeoutId = null;
      }, wait);
    } else {
      if (options == null ? void 0 : options.leading) {
        func(args);
      }
      timeoutId = setTimeout(() => {
        timeoutId = null;
        if (!(options == null ? void 0 : options.leading)) {
          func(args);
        }
      }, wait);
    }
  };
};
var getElementsIndices = (board, elements) => {
  sortElements(board, elements);
  return elements.map((item) => {
    return board.children.map((item2) => item2.id).indexOf(item.id);
  }).filter((item) => item >= 0);
};
var getHighestIndexOfElement = (board, elements) => {
  const indices = getElementsIndices(board, elements);
  return indices[indices.length - 1];
};
var moveElementsToNewPath = (board, moveOptions) => {
  moveOptions.map((item) => {
    const path = PlaitBoard.findPath(board, item.element);
    const ref = board.pathRef(path);
    return () => {
      ref.current && NodeTransforms.moveNode(board, ref.current, item.newPath);
      ref.unref();
    };
  }).forEach((action) => {
    action();
  });
};
var IS_DRAGGING = /* @__PURE__ */ new WeakMap();
var isDragging = (board) => {
  return !!IS_DRAGGING.get(board);
};
var setDragging = (board, state) => {
  IS_DRAGGING.set(board, state);
};
var getMovingElements = (board) => {
  return BOARD_TO_MOVING_ELEMENT.get(board) || [];
};
var isMovingElements = (board) => {
  return (BOARD_TO_MOVING_ELEMENT.get(board) || []).length > 0;
};
var removeMovingElements = (board) => {
  BOARD_TO_MOVING_ELEMENT.delete(board);
  setDragging(board, false);
};
var cacheMovingElements = (board, elements) => {
  BOARD_TO_MOVING_ELEMENT.set(board, elements);
  setDragging(board, true);
};
var FOREIGN_OBJECT_EXPRESSION = `foreignObject[class^='foreign-object']`;
function isElementNode(node) {
  return node.nodeType === Node.ELEMENT_NODE;
}
function loadImage(src) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = "Anonymous";
    img.onload = () => resolve(img);
    img.onerror = () => reject(new Error("Failed to load image"));
    img.src = src;
  });
}
function createCanvas(width, height, fillStyle = "transparent") {
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  canvas.width = width;
  canvas.height = height;
  canvas.style.width = `${width}px`;
  canvas.style.height = `${height}px`;
  ctx.strokeStyle = "#ffffff";
  ctx.fillStyle = fillStyle;
  ctx.fillRect(0, 0, width, height);
  return {
    canvas,
    ctx
  };
}
async function convertImageToBase64(url) {
  const response = await fetch(url);
  const blob = await response.blob();
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}
function cloneCSSStyle(nativeNode, clonedNode) {
  const targetStyle = clonedNode == null ? void 0 : clonedNode.style;
  if (!targetStyle) {
    return;
  }
  const sourceStyle = window.getComputedStyle(nativeNode);
  if (sourceStyle.cssText) {
    targetStyle.cssText = sourceStyle.cssText;
    targetStyle.transformOrigin = sourceStyle.transformOrigin;
  } else {
    Array.from(sourceStyle).forEach((name) => {
      let value = sourceStyle.getPropertyValue(name);
      targetStyle.setProperty(name, value, sourceStyle.getPropertyPriority(name));
    });
  }
}
function batchCloneCSSStyle(sourceNode, cloneNode, inlineStyleClassNames) {
  if (inlineStyleClassNames) {
    const classNames = inlineStyleClassNames + `, ${FOREIGN_OBJECT_EXPRESSION}`;
    const sourceNodes = Array.from(sourceNode.querySelectorAll(classNames));
    const cloneNodes = Array.from(cloneNode.querySelectorAll(classNames));
    sourceNodes.forEach((node, index) => {
      const childElements = Array.from(node.querySelectorAll("*")).filter(isElementNode);
      const cloneChildElements = Array.from(cloneNodes[index].querySelectorAll("*")).filter(isElementNode);
      sourceNodes.push(...childElements);
      cloneNodes.push(...cloneChildElements);
    });
    sourceNodes.map((node, index) => {
      cloneCSSStyle(node, cloneNodes[index]);
    });
  }
}
async function batchConvertImage(sourceNode, cloneNode) {
  const sourceImageNodes = Array.from(sourceNode.querySelectorAll(`${FOREIGN_OBJECT_EXPRESSION}`));
  const cloneImageNodes = Array.from(cloneNode.querySelectorAll(`${FOREIGN_OBJECT_EXPRESSION}`));
  await Promise.all(sourceImageNodes.map((_, index) => {
    return new Promise((resolve) => {
      const cloneImageNode = cloneImageNodes[index];
      const image = cloneImageNode.querySelector("img");
      const url = image == null ? void 0 : image.getAttribute("src");
      if (!url) {
        return resolve(true);
      }
      convertImageToBase64(url).then((base64Image) => {
        image == null ? void 0 : image.setAttribute("src", base64Image);
        resolve(true);
      });
    });
  }));
}
async function cloneSvg(board, elements, rectangle, options) {
  const { width, height, x, y } = rectangle;
  const { padding = 4, inlineStyleClassNames } = options;
  const sourceSvg = PlaitBoard.getHost(board);
  const selectedGElements = elements.map((value) => PlaitElement.getElementG(value));
  const cloneSvgElement = sourceSvg.cloneNode();
  const newHostElement = PlaitBoard.getElementHost(board).cloneNode();
  cloneSvgElement.style.width = `${width}px`;
  cloneSvgElement.style.height = `${height}px`;
  cloneSvgElement.style.backgroundColor = "";
  cloneSvgElement.setAttribute("width", `${width}`);
  cloneSvgElement.setAttribute("height", `${height}`);
  cloneSvgElement.setAttribute("viewBox", [x - padding, y - padding, width + 2 * padding, height + 2 * padding].join(","));
  const promiseArray = new Array(selectedGElements.length);
  await Promise.all(selectedGElements.map(async (child, i) => {
    const cloneChild = child.cloneNode(true);
    batchCloneCSSStyle(child, cloneChild, inlineStyleClassNames);
    await batchConvertImage(child, cloneChild);
    promiseArray[i] = cloneChild;
  }));
  newHostElement.append(...promiseArray);
  cloneSvgElement.appendChild(newHostElement);
  return cloneSvgElement;
}
async function toImage(board, options) {
  if (!board) {
    return void 0;
  }
  const elements = options.elements || findElements(board, { match: () => true, recursion: () => true, isReverse: false });
  const targetRectangle = getRectangleByElements(board, elements, false);
  const { ratio = 2, fillStyle = "transparent" } = options;
  const { width, height } = targetRectangle;
  const ratioWidth = width * ratio;
  const ratioHeight = height * ratio;
  const cloneSvgElement = await cloneSvg(board, elements, targetRectangle, options);
  const { canvas, ctx } = createCanvas(ratioWidth, ratioHeight, fillStyle);
  const svgStr = new XMLSerializer().serializeToString(cloneSvgElement);
  const imgSrc = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svgStr)}`;
  try {
    const img = await loadImage(imgSrc);
    ctx.drawImage(img, 0, 0, ratioWidth, ratioHeight);
    return canvas.toDataURL("image/png");
  } catch (error) {
    console.error("Error converting SVG to image:", error);
    return void 0;
  }
}
function downloadImage(url, name) {
  const a = document.createElement("a");
  a.href = url;
  a.download = name;
  a.click();
  a.remove();
}
var WritableClipboardType;
(function(WritableClipboardType2) {
  WritableClipboardType2["medias"] = "medias";
  WritableClipboardType2["elements"] = "elements";
})(WritableClipboardType || (WritableClipboardType = {}));
var WritableClipboardOperationType;
(function(WritableClipboardOperationType2) {
  WritableClipboardOperationType2["copy"] = "copy";
  WritableClipboardOperationType2["cut"] = "cut";
  WritableClipboardOperationType2["duplicate"] = "duplicate";
  WritableClipboardOperationType2["paste"] = "paste";
})(WritableClipboardOperationType || (WritableClipboardOperationType = {}));
var buildPlaitHtml = (type, data) => {
  const stringifiedClipboard = replaceAngleBrackets(JSON.stringify({
    type,
    data
  }));
  return `<plait>${stringifiedClipboard}</plait>`;
};
var getClipboardFromHtml = (html) => {
  var _a;
  let plaitString = (_a = html == null ? void 0 : html.match(/<plait[^>]*>(.*)<\/plait>/)) == null ? void 0 : _a[1];
  if (plaitString) {
    plaitString = reverseReplaceAngleBrackets(plaitString);
    try {
      const plaitJson = JSON.parse(plaitString);
      if (plaitJson) {
        if (plaitJson.type === WritableClipboardType.elements) {
          return {
            elements: plaitJson.data
          };
        } else if (plaitJson.type === WritableClipboardType.medias) {
          return {
            medias: plaitJson.data
          };
        }
      }
    } catch (error) {
      console.error(error);
      return null;
    }
  }
  return null;
};
var stripHtml = (html) => {
  const doc = document.implementation.createHTMLDocument("");
  doc.documentElement.innerHTML = html.trim();
  return doc.body.textContent || doc.body.innerText || "";
};
var getProbablySupportsClipboardWrite = () => {
  return "clipboard" in navigator && "write" in navigator.clipboard;
};
var getProbablySupportsClipboardWriteText = () => {
  return "clipboard" in navigator && "writeText" in navigator.clipboard;
};
var getProbablySupportsClipboardRead = () => {
  return "clipboard" in navigator && "read" in navigator.clipboard;
};
var createClipboardContext = (type, elements, text) => {
  return {
    type,
    elements,
    text
  };
};
var addClipboardContext = (clipboardContext, addition) => {
  const { type, elements, text } = clipboardContext;
  if (type === addition.type) {
    return {
      type,
      elements: elements.concat(addition.elements),
      text: text + " " + addition.text
    };
  }
  return clipboardContext;
};
var addOrCreateClipboardContext = (clipboardContext, addition) => {
  if (!clipboardContext) {
    return addition;
  } else {
    return addClipboardContext(clipboardContext, addition);
  }
};
var replaceAngleBrackets = (str) => {
  return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
};
var reverseReplaceAngleBrackets = (str) => {
  return str.replace(/&lt;/g, "<").replace(/&gt;/g, ">");
};
var setDataTransferClipboard = (dataTransfer, type, data) => {
  dataTransfer == null ? void 0 : dataTransfer.setData(`text/html`, buildPlaitHtml(type, data));
};
var setDataTransferClipboardText = (data, text) => {
  data == null ? void 0 : data.setData(`text/plain`, text);
};
var getDataTransferClipboard = (data) => {
  const html = data == null ? void 0 : data.getData(`text/html`);
  if (html) {
    const htmlClipboardData = getClipboardFromHtml(html);
    if (htmlClipboardData) {
      return htmlClipboardData;
    }
  }
  return {};
};
var getDataTransferClipboardText = (data) => {
  if (!data) {
    return {};
  }
  const text = data == null ? void 0 : data.getData(`text/plain`);
  if (text) {
    const htmlClipboardData = getClipboardFromHtml(text);
    if (htmlClipboardData) {
      return htmlClipboardData;
    }
  }
  return {
    text
  };
};
var setNavigatorClipboard = async (type, data, text = "") => {
  let textClipboard = text;
  if (getProbablySupportsClipboardWrite()) {
    await navigator.clipboard.write([
      new ClipboardItem({
        "text/html": new Blob([buildPlaitHtml(type, data)], {
          type: "text/html"
        }),
        "text/plain": new Blob([textClipboard ?? JSON.stringify(data)], { type: "text/plain" })
      })
    ]);
  }
};
var getNavigatorClipboard = async () => {
  if (!getProbablySupportsClipboardRead()) {
    return {};
  }
  const clipboardItems = await navigator.clipboard.read();
  let clipboardData = {};
  if (Array.isArray(clipboardItems) && clipboardItems[0] instanceof ClipboardItem) {
    for (const item of clipboardItems) {
      if (isFile(item)) {
        const clipboardFiles = item.types.filter((type) => type.match(/^image\//));
        const fileBlobs = await Promise.all(clipboardFiles.map((type) => item.getType(type)));
        const urls = fileBlobs.filter(Boolean).map((blob) => URL.createObjectURL(blob));
        const files = await Promise.all(urls.map(async (url) => {
          const blob = await (await fetch(url)).blob();
          return new File([blob], "plait-file", { type: blob.type });
        }));
        return {
          files
        };
      }
      if (item.types.includes("text/html")) {
        const htmlContent = await blobAsString(await item.getType("text/html"));
        const htmlClipboardData = getClipboardFromHtml(htmlContent);
        if (htmlClipboardData) {
          return htmlClipboardData;
        }
        if (htmlContent && htmlContent.trim()) {
          clipboardData = { text: stripHtml(htmlContent) };
        }
      }
      if (item.types.includes("text/plain")) {
        const textContent = await blobAsString(await item.getType("text/plain"));
        clipboardData = {
          text: stripHtml(textContent)
        };
      }
    }
  }
  return clipboardData;
};
var isFile = (item) => {
  return item.types.find((i) => i.match(/^image\//));
};
var blobAsString = (blob) => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.addEventListener("loadend", () => {
      const text = reader.result;
      resolve(text);
    });
    reader.addEventListener("error", () => {
      reject(reader.error);
    });
    reader.readAsText(blob);
  });
};
var getClipboardData = async (dataTransfer) => {
  let clipboardData = {};
  if (dataTransfer) {
    if (dataTransfer.files.length) {
      return { files: Array.from(dataTransfer.files) };
    }
    clipboardData = getDataTransferClipboard(dataTransfer);
    if (Object.keys(clipboardData).length === 0) {
      clipboardData = getDataTransferClipboardText(dataTransfer);
    }
    return clipboardData;
  }
  if (getProbablySupportsClipboardRead()) {
    return await getNavigatorClipboard();
  }
  return clipboardData;
};
var setClipboardData = async (dataTransfer, clipboardContext) => {
  if (!clipboardContext) {
    return;
  }
  const { type, elements, text } = clipboardContext;
  if (getProbablySupportsClipboardWrite()) {
    return await setNavigatorClipboard(type, elements, text);
  }
  if (dataTransfer) {
    setDataTransferClipboard(dataTransfer, type, elements);
    setDataTransferClipboardText(dataTransfer, text);
    return;
  }
  if (getProbablySupportsClipboardWriteText()) {
    return await navigator.clipboard.writeText(buildPlaitHtml(type, elements));
  }
};
function isSelectionMoving(board) {
  return !!BOARD_TO_IS_SELECTION_MOVING.get(board);
}
function setSelectionMoving(board) {
  PlaitBoard.getBoardContainer(board).classList.add("selection-moving");
  BOARD_TO_IS_SELECTION_MOVING.set(board, true);
  setDragging(board, true);
}
function clearSelectionMoving(board) {
  PlaitBoard.getBoardContainer(board).classList.remove("selection-moving");
  BOARD_TO_IS_SELECTION_MOVING.delete(board);
  setDragging(board, false);
}
function isHandleSelection(board) {
  const options = getSelectionOptions(board);
  return board.pointer !== PlaitPointerType.hand && !options.isDisabledSelection && !PlaitBoard.isReadonly(board);
}
function hasSetSelectionOperation(board) {
  return !!board.operations.find((op) => PlaitOperation.isSetSelectionOperation(op));
}
function getTemporaryElements(board) {
  const ref = BOARD_TO_TEMPORARY_ELEMENTS.get(board);
  if (ref) {
    return ref.elements;
  } else {
    return void 0;
  }
}
function getTemporaryRef(board) {
  return BOARD_TO_TEMPORARY_ELEMENTS.get(board);
}
function deleteTemporaryElements(board) {
  BOARD_TO_TEMPORARY_ELEMENTS.delete(board);
}
function drawSelectionRectangleG(board) {
  const elements = getSelectedElements(board);
  const rectangle = getRectangleByElements(board, elements, false);
  const activeRectangle = toActiveRectangleFromViewBoxRectangle(board, rectangle);
  if (activeRectangle.width > 0 && activeRectangle.height > 0 && elements.length > 1) {
    const selectionRectangleG = drawRectangle(board, RectangleClient.inflate(activeRectangle, ACTIVE_STROKE_WIDTH), {
      stroke: SELECTION_BORDER_COLOR,
      strokeWidth: ACTIVE_STROKE_WIDTH,
      fillStyle: "solid"
    });
    selectionRectangleG.classList.add(SELECTION_RECTANGLE_CLASS_NAME, SELECTION_RECTANGLE_BOUNDING_CLASS_NAME);
    const angle = getSelectionAngle(elements);
    if (angle) {
      setAngleForG(selectionRectangleG, RectangleClient.getCenterPoint(activeRectangle), angle);
    }
    return selectionRectangleG;
  }
  return null;
}
function setSelectedElementsWithGroup(board, elements, isShift) {
  if (!board.selection) {
    return;
  }
  const selectedElements = getSelectedElements(board);
  if (!Selection.isCollapsed(board.selection)) {
    let newElements = [...selectedElements];
    elements.forEach((item) => {
      if (!item.groupId) {
        newElements.push(item);
      } else {
        newElements.push(...getElementsInGroupByElement(board, item));
      }
    });
    cacheSelectedElements(board, uniqueById(newElements));
    return;
  }
  if (Selection.isCollapsed(board.selection)) {
    const hitElement = elements[0];
    const hitElementGroups = getGroupByElement(board, hitElement, true);
    if (hitElementGroups.length > 0) {
      const elementsInHighestGroup = getElementsInGroup(board, hitElementGroups[hitElementGroups.length - 1], true) || [];
      const isSelectGroupElement = selectedElements.some((element) => elementsInHighestGroup.map((item) => item.id).includes(element.id));
      if (isShift) {
        cacheSelectedElementsWithGroupOnShift(board, elements, isSelectGroupElement, elementsInHighestGroup);
      } else {
        cacheSelectedElementsWithGroup(board, elements, isSelectGroupElement, hitElementGroups);
      }
    }
  }
}
function cacheSelectedElementsWithGroupOnShift(board, elements, isSelectGroupElement, elementsInHighestGroup) {
  const selectedElements = getSelectedElements(board);
  let newElements = [...selectedElements];
  const hitElement = elements[0];
  let pendingElements = [];
  if (!isSelectGroupElement) {
    pendingElements = elementsInHighestGroup;
  } else {
    const isHitSelectedElement = selectedElements.some((item) => item.id === hitElement.id);
    const selectedElementsInGroup = elementsInHighestGroup.filter((item) => selectedElements.includes(item));
    if (isHitSelectedElement) {
      pendingElements = selectedElementsInGroup.filter((item) => item.id !== hitElement.id);
    } else {
      pendingElements.push(...selectedElementsInGroup, ...elements);
    }
  }
  elementsInHighestGroup.forEach((element) => {
    if (newElements.includes(element)) {
      newElements.splice(newElements.indexOf(element), 1);
    }
  });
  if (pendingElements.length) {
    newElements.push(...pendingElements);
  }
  cacheSelectedElements(board, uniqueById(newElements));
}
function cacheSelectedElementsWithGroup(board, elements, isSelectGroupElement, hitElementGroups) {
  let newElements = [...elements];
  const selectedGroups = filterSelectedGroups(board, hitElementGroups);
  if (selectedGroups.length > 0) {
    if (selectedGroups.length > 1) {
      newElements = getAllElementsInGroup(board, selectedGroups[selectedGroups.length - 2], true);
    } else {
      const element = board.getOneHitElement(elements);
      if (element) {
        newElements = [element];
      }
    }
  } else {
    const elementsInGroup = getAllElementsInGroup(board, hitElementGroups[hitElementGroups.length - 1], true);
    if (!isSelectGroupElement) {
      newElements = elementsInGroup;
    } else {
      const element = board.getOneHitElement(elements);
      if (element) {
        newElements = [element];
      }
    }
  }
  cacheSelectedElements(board, uniqueById(newElements));
}
var getSelectionOptions = (board) => {
  const options = board.getPluginOptions(PlaitPluginKey.withSelection);
  return options;
};
var setSelectionOptions = (board, options) => {
  board.setPluginOptions(PlaitPluginKey.withSelection, options);
};
var getElementsInGroup = (board, group, recursion, includeGroup) => {
  let result = [];
  const elements = board.children.filter((value) => value.groupId === group.id);
  if (recursion) {
    elements.forEach((item) => {
      if (PlaitGroupElement.isGroup(item)) {
        if (includeGroup) {
          result.push(item);
        }
        result.push(...getElementsInGroup(board, item, recursion, includeGroup));
      } else {
        result.push(item);
      }
    });
  } else {
    result = includeGroup ? elements : elements.filter((item) => !PlaitGroupElement.isGroup(item));
  }
  return result;
};
var getAllElementsInGroup = (board, group, recursion, includeGroup) => {
  const elementsInGroup = getElementsInGroup(board, group, recursion, includeGroup);
  const result = [];
  elementsInGroup.forEach((element) => {
    depthFirstRecursion(element, (node) => {
      result.push(node);
    }, () => true);
  });
  return result;
};
var getRectangleByGroup = (board, group, recursion) => {
  const elementsInGroup = getAllElementsInGroup(board, group, recursion);
  return getRectangleByElements(board, elementsInGroup, false);
};
var getGroupByElement = (board, element, recursion, originElements) => {
  const group = (originElements || board.children).find((item) => item.id === (element == null ? void 0 : element.groupId));
  if (!group) {
    return recursion ? [] : null;
  }
  if (recursion) {
    const groups = [group];
    const grandGroups = getGroupByElement(board, group, recursion, originElements);
    if (grandGroups.length) {
      groups.push(...grandGroups);
    }
    return groups;
  } else {
    return group;
  }
};
var getHighestGroup = (board, element) => {
  const hitElementGroups = getGroupByElement(board, element, true);
  if (hitElementGroups.length) {
    return hitElementGroups[hitElementGroups.length - 1];
  }
  return null;
};
var getElementsInGroupByElement = (board, element) => {
  const highestGroup = getHighestGroup(board, element);
  if (highestGroup) {
    return getAllElementsInGroup(board, highestGroup, true);
  } else {
    return [element];
  }
};
var isSelectedElementOrGroup = (board, element, elements) => {
  const selectedElements = (elements == null ? void 0 : elements.length) ? elements : getSelectedElements(board);
  if (PlaitGroupElement.isGroup(element)) {
    return isSelectedAllElementsInGroup(board, element, elements);
  }
  return selectedElements.map((item) => item.id).includes(element.id);
};
var isSelectedAllElementsInGroup = (board, group, elements) => {
  const selectedElements = (elements == null ? void 0 : elements.length) ? elements : getSelectedElements(board);
  const elementsInGroup = getElementsInGroup(board, group, true);
  return elementsInGroup.every((item) => selectedElements.map((element) => element.id).includes(item.id));
};
var filterSelectedGroups = (board, groups, elements) => {
  const selectedGroups = [];
  groups.forEach((item) => {
    if (isSelectedElementOrGroup(board, item, elements)) {
      selectedGroups.push(item);
    }
  });
  return selectedGroups;
};
var getSelectedGroups = (board, elements, originElements) => {
  const highestSelectedGroups = getHighestSelectedGroups(board, elements, originElements);
  const groups = [];
  highestSelectedGroups.forEach((item) => {
    groups.push(item);
    const elementsInGroup = getElementsInGroup(board, item, true, true);
    groups.push(...elementsInGroup.filter((item2) => PlaitGroupElement.isGroup(item2)));
  });
  return groups;
};
var getHighestSelectedGroup = (board, element, elements, originElements) => {
  const hitElementGroups = getGroupByElement(board, element, true, originElements);
  const selectedGroups = filterSelectedGroups(board, hitElementGroups, elements);
  if (selectedGroups.length) {
    return selectedGroups[selectedGroups.length - 1];
  }
  return null;
};
var getHighestSelectedGroups = (board, elements, originElements) => {
  let result = [];
  const selectedElements = (elements == null ? void 0 : elements.length) ? elements : getSelectedElements(board);
  selectedElements.forEach((item) => {
    if (item.groupId) {
      const group = getHighestSelectedGroup(board, item, elements, originElements);
      if (group && !result.includes(group)) {
        result.push(group);
      }
    }
  });
  return result;
};
var getSelectedIsolatedElements = (board, elements) => {
  let result = [];
  const selectedElements = (elements == null ? void 0 : elements.length) ? elements : getSelectedElements(board);
  selectedElements.filter((item) => !PlaitGroupElement.isGroup(item)).forEach((item) => {
    if (!item.groupId) {
      result.push(item);
    } else {
      const group = getHighestSelectedGroup(board, item, elements);
      if (!group) {
        result.push(item);
      }
    }
  });
  return result;
};
var getSelectedIsolatedElementsCanAddToGroup = (board, elements) => {
  const selectedIsolatedElements = getSelectedIsolatedElements(board, elements);
  return selectedIsolatedElements.filter((item) => board.canAddToGroup(item));
};
var getHighestSelectedElements = (board, elements) => {
  return [...getHighestSelectedGroups(board, elements), ...getSelectedIsolatedElements(board, elements)];
};
var createGroupRectangleG = (board, elements) => {
  const selectedElementIds = getSelectedElements(board).map((item) => item.id);
  let groupRectangleG = null;
  const isMoving = isSelectionMoving(board);
  elements.forEach((item) => {
    const isRender = !selectedElementIds.includes(item.id) && !isMoving || isMoving;
    if (item.groupId && isRender) {
      if (!groupRectangleG) {
        groupRectangleG = createG();
      }
      const elements2 = getElementsInGroupByElement(board, item);
      const rectangle = getRectangleByElements(board, elements2, false);
      const rectangleG = drawRectangle(board, rectangle, {
        stroke: SELECTION_BORDER_COLOR,
        strokeWidth: ACTIVE_STROKE_WIDTH,
        strokeLineDash: [5]
      });
      const angle = getSelectionAngle(elements2);
      if (angle) {
        setAngleForG(rectangleG, RectangleClient.getCenterPoint(rectangle), angle);
      }
      groupRectangleG.append(rectangleG);
    }
  });
  return groupRectangleG;
};
var createGroup = (groupId) => {
  return groupId ? {
    id: idCreator(),
    type: "group",
    groupId
  } : {
    id: idCreator(),
    type: "group"
  };
};
var nonGroupInHighestSelectedElements = (elements) => {
  return elements.every((item) => !item.groupId);
};
var hasSelectedElementsInSameGroup = (elements) => {
  return elements.every((item) => item.groupId && item.groupId === elements[0].groupId);
};
var canAddGroup = (board, elements) => {
  const highestSelectedElements = getHighestSelectedElements(board, elements);
  const rootElements = highestSelectedElements.filter((item) => board.canAddToGroup(item));
  if (rootElements.length > 1) {
    return nonGroupInHighestSelectedElements(rootElements) || hasSelectedElementsInSameGroup(rootElements);
  }
  return false;
};
var canRemoveGroup = (board, elements, originElements) => {
  const selectedGroups = getHighestSelectedGroups(board, elements, originElements);
  const selectedElements = (elements == null ? void 0 : elements.length) ? elements : getSelectedElements(board);
  return selectedElements.length > 0 && selectedGroups.length > 0;
};
var getEditingGroup = (board, element) => {
  const groups = getGroupByElement(board, element, true);
  let editingGroup = null;
  if (groups == null ? void 0 : groups.length) {
    for (let i = 0; i < (groups == null ? void 0 : groups.length); i++) {
      if (!isSelectedAllElementsInGroup(board, groups[i])) {
        editingGroup = groups[i];
        break;
      }
    }
  }
  return editingGroup;
};
var moveElementsToNewPathAfterAddGroup = (board, selectedElements, newPath) => {
  const moveElements = [...selectedElements];
  sortElements(board, moveElements);
  moveElements.pop();
  moveElementsToNewPath(board, moveElements.map((element) => {
    return {
      element,
      newPath
    };
  }));
};
var deleteFragment = (board) => {
  const elements = board.getDeletedFragment([]);
  board.deleteFragment(elements);
};
var setFragment = (board, operationType, clipboardData) => {
  const selectedElements = getSelectedElements(board);
  const rectangle = getRectangleByElements(board, selectedElements, false);
  const clipboardContext = board.buildFragment(null, rectangle, operationType);
  clipboardContext && setClipboardData(clipboardData, clipboardContext);
};
var duplicateElements = (board, elements, point) => {
  const targetElements = (elements == null ? void 0 : elements.length) ? elements : getSelectedElements(board);
  const targetRectangle = getRectangleByElements(board, targetElements, false);
  const clipboardContext = board.buildFragment(null, targetRectangle, WritableClipboardOperationType.duplicate, targetElements);
  const stringifiedContext = clipboardContext && JSON.stringify(clipboardContext);
  const clonedContext = stringifiedContext && JSON.parse(stringifiedContext);
  clonedContext && board.insertFragment({
    ...clonedContext,
    text: void 0
  }, point || [targetRectangle.x + targetRectangle.width / 2, targetRectangle.y + targetRectangle.height / 2], WritableClipboardOperationType.duplicate);
};
var SNAP_TOLERANCE = 2;
var SNAP_SPACING = 24;
function getSnapRectangles(board, activeElements) {
  const elements = findElements(board, {
    match: (element) => board.isAlign(element) && !activeElements.some((item) => item.id === element.id),
    recursion: () => true,
    isReverse: false
  });
  return elements.map((item) => {
    const rectangle = board.getRectangle(item);
    return getRectangleByAngle(rectangle, item.angle || 0);
  });
}
function getBarPoint(point, isHorizontal) {
  return isHorizontal ? [
    [point[0], point[1] - 4],
    [point[0], point[1] + 4]
  ] : [
    [point[0] - 4, point[1]],
    [point[0] + 4, point[1]]
  ];
}
function getMinPointDelta(pointRectangles, axis, isHorizontal) {
  let delta = SNAP_TOLERANCE;
  pointRectangles.forEach((item) => {
    const distance = getNearestDelta(axis, item, isHorizontal);
    if (Math.abs(distance) < Math.abs(delta)) {
      delta = distance;
    }
  });
  return delta;
}
var getNearestDelta = (axis, rectangle, isHorizontal) => {
  const pointAxis = getTripleAxis(rectangle, isHorizontal);
  const deltas = pointAxis.map((item) => item - axis);
  const absDeltas = deltas.map((item) => Math.abs(item));
  const index = absDeltas.indexOf(Math.min(...absDeltas));
  return deltas[index];
};
var getTripleAxis = (rectangle, isHorizontal) => {
  const axis = isHorizontal ? "x" : "y";
  const side = isHorizontal ? "width" : "height";
  return [rectangle[axis], rectangle[axis] + rectangle[side] / 2, rectangle[axis] + rectangle[side]];
};
function getNearestPointRectangle(snapRectangles, activeRectangle) {
  let minDistance = Infinity;
  let nearestRectangle = snapRectangles[0];
  snapRectangles.forEach((item) => {
    const distance = Math.sqrt(Math.pow(activeRectangle.x - item.x, 2) + Math.pow(activeRectangle.y - item.y, 2));
    if (distance < minDistance) {
      minDistance = distance;
      nearestRectangle = item;
    }
  });
  return nearestRectangle;
}
var isSnapPoint = (axis, rectangle, isHorizontal) => {
  const pointAxis = getTripleAxis(rectangle, isHorizontal);
  return pointAxis.includes(axis);
};
function drawPointSnapLines(board, activeRectangle, snapRectangles, drawHorizontal = true, drawVertical = true, snapMiddle = false) {
  let pointLinePoints = [];
  const pointAxisX = getTripleAxis(activeRectangle, true);
  const pointAxisY = getTripleAxis(activeRectangle, false);
  const pointLineRefs = [
    {
      axis: pointAxisX[0],
      isHorizontal: true,
      pointRectangles: []
    },
    {
      axis: pointAxisX[1],
      isHorizontal: true,
      pointRectangles: []
    },
    {
      axis: pointAxisX[2],
      isHorizontal: true,
      pointRectangles: []
    },
    {
      axis: pointAxisY[0],
      isHorizontal: false,
      pointRectangles: []
    },
    {
      axis: pointAxisY[1],
      isHorizontal: false,
      pointRectangles: []
    },
    {
      axis: pointAxisY[2],
      isHorizontal: false,
      pointRectangles: []
    }
  ];
  for (let index = 0; index < snapRectangles.length; index++) {
    const element = snapRectangles[index];
    if (isSnapPoint(pointLineRefs[0].axis, element, pointLineRefs[0].isHorizontal)) {
      pointLineRefs[0].pointRectangles.push(element);
    }
    if (isSnapPoint(pointLineRefs[1].axis, element, pointLineRefs[1].isHorizontal)) {
      pointLineRefs[1].pointRectangles.push(element);
    }
    if (isSnapPoint(pointLineRefs[2].axis, element, pointLineRefs[2].isHorizontal)) {
      pointLineRefs[2].pointRectangles.push(element);
    }
    if (isSnapPoint(pointLineRefs[3].axis, element, pointLineRefs[3].isHorizontal)) {
      pointLineRefs[3].pointRectangles.push(element);
    }
    if (isSnapPoint(pointLineRefs[4].axis, element, pointLineRefs[4].isHorizontal)) {
      pointLineRefs[4].pointRectangles.push(element);
    }
    if (isSnapPoint(pointLineRefs[5].axis, element, pointLineRefs[5].isHorizontal)) {
      pointLineRefs[5].pointRectangles.push(element);
    }
  }
  const setResizePointSnapLine = (axis, pointRectangle, isHorizontal) => {
    const boundingRectangle = RectangleClient.inflate(RectangleClient.getBoundingRectangle([activeRectangle, pointRectangle]), SNAP_SPACING);
    if (isHorizontal) {
      const pointStart = [axis, boundingRectangle.y];
      const pointEnd = [axis, boundingRectangle.y + boundingRectangle.height];
      pointLinePoints.push([pointStart, pointEnd]);
    } else {
      const pointStart = [boundingRectangle.x, axis];
      const pointEnd = [boundingRectangle.x + boundingRectangle.width, axis];
      pointLinePoints.push([pointStart, pointEnd]);
    }
  };
  if (drawHorizontal && pointLineRefs[0].pointRectangles.length) {
    const leftRectangle = pointLineRefs[0].pointRectangles.length === 1 ? pointLineRefs[0].pointRectangles[0] : getNearestPointRectangle(pointLineRefs[0].pointRectangles, activeRectangle);
    setResizePointSnapLine(pointLineRefs[0].axis, leftRectangle, pointLineRefs[0].isHorizontal);
  }
  if (drawHorizontal && snapMiddle && pointLineRefs[1].pointRectangles.length) {
    const middleRectangle = pointLineRefs[1].pointRectangles.length === 1 ? pointLineRefs[1].pointRectangles[0] : getNearestPointRectangle(pointLineRefs[1].pointRectangles, activeRectangle);
    setResizePointSnapLine(pointLineRefs[1].axis, middleRectangle, pointLineRefs[1].isHorizontal);
  }
  if (drawHorizontal && pointLineRefs[2].pointRectangles.length) {
    const rightRectangle = pointLineRefs[2].pointRectangles.length === 1 ? pointLineRefs[2].pointRectangles[0] : getNearestPointRectangle(pointLineRefs[2].pointRectangles, activeRectangle);
    setResizePointSnapLine(pointLineRefs[2].axis, rightRectangle, pointLineRefs[2].isHorizontal);
  }
  if (drawVertical && pointLineRefs[3].pointRectangles.length) {
    const topRectangle = pointLineRefs[3].pointRectangles.length === 1 ? pointLineRefs[3].pointRectangles[0] : getNearestPointRectangle(pointLineRefs[3].pointRectangles, activeRectangle);
    setResizePointSnapLine(pointLineRefs[3].axis, topRectangle, pointLineRefs[3].isHorizontal);
  }
  if (drawVertical && snapMiddle && pointLineRefs[4].pointRectangles.length) {
    const middleRectangle = pointLineRefs[4].pointRectangles.length === 1 ? pointLineRefs[4].pointRectangles[0] : getNearestPointRectangle(pointLineRefs[4].pointRectangles, activeRectangle);
    setResizePointSnapLine(pointLineRefs[4].axis, middleRectangle, pointLineRefs[4].isHorizontal);
  }
  if (drawVertical && pointLineRefs[5].pointRectangles.length) {
    const rightRectangle = pointLineRefs[5].pointRectangles.length === 1 ? pointLineRefs[5].pointRectangles[0] : getNearestPointRectangle(pointLineRefs[5].pointRectangles, activeRectangle);
    setResizePointSnapLine(pointLineRefs[5].axis, rightRectangle, pointLineRefs[5].isHorizontal);
  }
  return drawDashedLines(board, pointLinePoints);
}
function drawDashedLines(board, lines) {
  const g = createG();
  lines.forEach((points) => {
    if (!points.length)
      return;
    const line = PlaitBoard.getRoughSVG(board).line(points[0][0], points[0][1], points[1][0], points[1][1], {
      stroke: SELECTION_BORDER_COLOR,
      strokeWidth: 1,
      strokeLineDash: [4, 4]
    });
    g.appendChild(line);
  });
  return g;
}
function drawSolidLines(board, lines) {
  const g = createG();
  lines.forEach((points) => {
    if (!points.length)
      return;
    let isHorizontal = points[0][1] === points[1][1];
    const line = PlaitBoard.getRoughSVG(board).line(points[0][0], points[0][1], points[1][0], points[1][1], {
      stroke: SELECTION_BORDER_COLOR,
      strokeWidth: 1
    });
    g.appendChild(line);
    points.forEach((point) => {
      const barPoint = getBarPoint(point, isHorizontal);
      const bar = PlaitBoard.getRoughSVG(board).line(barPoint[0][0], barPoint[0][1], barPoint[1][0], barPoint[1][1], {
        stroke: SELECTION_BORDER_COLOR,
        strokeWidth: 1
      });
      g.appendChild(bar);
    });
  });
  return g;
}
var getOneMoveOptions = (board, direction) => {
  const indicesToMove = getElementsIndices(board, getSelectedElements(board));
  let groupedIndices = toContiguousGroups(board, indicesToMove);
  if (direction === "up") {
    groupedIndices = groupedIndices.reverse();
  }
  let moveContents = [];
  groupedIndices.forEach((indices, i) => {
    const leadingIndex = indices[0];
    const trailingIndex = indices[indices.length - 1];
    const boundaryIndex = direction === "down" ? leadingIndex : trailingIndex;
    const targetIndex = getTargetIndex(board, boundaryIndex, direction);
    if (targetIndex === -1 || boundaryIndex === targetIndex) {
      return;
    }
    if (direction === "down") {
      indices = indices.reverse();
    }
    moveContents.push(...indices.map((path) => {
      return {
        element: board.children[path],
        newPath: [targetIndex]
      };
    }));
  });
  return moveContents;
};
var getAllMoveOptions = (board, direction) => {
  const indicesToMove = getElementsIndices(board, getSelectedElements(board));
  let groupedIndices = toContiguousGroups(board, indicesToMove);
  let moveContents = [];
  if (direction === "down") {
    groupedIndices = groupedIndices.reverse();
  }
  groupedIndices.forEach((indices) => {
    const leadingIndex = indices[0];
    const trailingIndex = indices[indices.length - 1];
    const boundaryIndex = direction === "down" ? leadingIndex : trailingIndex;
    const sourceElement = board.children[boundaryIndex];
    const editingGroup = getEditingGroup(board, sourceElement);
    let targetIndex = direction === "down" ? 0 : board.children.length - 1;
    if (editingGroup) {
      const elementsInGroup = sortElements(board, getElementsInGroup(board, editingGroup, true, true));
      targetIndex = direction === "down" ? board.children.indexOf(elementsInGroup[0]) : board.children.indexOf(elementsInGroup[elementsInGroup.length - 1]);
    }
    if (direction === "down") {
      indices = indices.reverse();
    }
    moveContents.push(...indices.map((path) => {
      return {
        element: board.children[path],
        newPath: [targetIndex]
      };
    }));
  });
  return moveContents;
};
var canSetZIndex = (board) => {
  const selectedElements = getSelectedElements(board).filter((item) => board.canSetZIndex(item));
  return selectedElements.length > 0;
};
var toContiguousGroups = (board, array) => {
  let cursor = 0;
  return array.reduce((acc, value, index) => {
    if (index > 0) {
      const currentElement = board.children[value];
      const previousElement = board.children[array[index - 1]];
      const isContiguous = value - 1 === array[index - 1] ? true : board.children.every((item, childIndex) => {
        if (childIndex > array[index - 1] && childIndex <= value - 1) {
          return PlaitGroupElement.isGroup(item);
        }
        return true;
      });
      let isPartialSelectGroupElement = false;
      if ((previousElement == null ? void 0 : previousElement.groupId) || (currentElement == null ? void 0 : currentElement.groupId) && (previousElement == null ? void 0 : previousElement.groupId) !== (currentElement == null ? void 0 : currentElement.groupId)) {
        let isPartialSelectPreviousGroup = false;
        let isPartialSelectCurrentElement = false;
        if (previousElement.groupId) {
          const highestGroup = getHighestGroup(board, previousElement);
          isPartialSelectPreviousGroup = !isSelectedAllElementsInGroup(board, highestGroup);
        }
        if (currentElement.groupId) {
          const highestGroup = getHighestGroup(board, currentElement);
          isPartialSelectCurrentElement = !isSelectedAllElementsInGroup(board, highestGroup);
        }
        isPartialSelectGroupElement = isPartialSelectPreviousGroup || isPartialSelectCurrentElement;
      }
      if (!isContiguous || isPartialSelectGroupElement) {
        cursor = ++cursor;
      }
    }
    (acc[cursor] || (acc[cursor] = [])).push(value);
    return acc;
  }, []);
};
var getTargetIndex = (board, boundaryIndex, direction) => {
  if (boundaryIndex === 0 && direction === "down" || boundaryIndex === board.children.length - 1 && direction === "up") {
    return -1;
  }
  const indexFilter = (element) => {
    if (element.isDeleted || PlaitGroupElement.isGroup(element)) {
      return false;
    }
    return true;
  };
  const candidateIndex = direction === "down" ? findLastIndex(board.children, (el) => indexFilter(el), Math.max(0, boundaryIndex - 1)) : findIndex2(board.children, (el) => indexFilter(el), boundaryIndex + 1);
  const nextElement = board.children[candidateIndex];
  if (!nextElement) {
    return -1;
  }
  const elements = [...board.children];
  const sourceElement = elements[boundaryIndex];
  const editingGroup = getEditingGroup(board, sourceElement);
  const nextElementGroups = getGroupByElement(board, nextElement, true) || [];
  if (editingGroup && (sourceElement == null ? void 0 : sourceElement.groupId) !== (nextElement == null ? void 0 : nextElement.groupId)) {
    if (!nextElementGroups.find((item) => item.id === editingGroup.id)) {
      return -1;
    }
  }
  if (!nextElement.groupId) {
    return candidateIndex;
  }
  let siblingGroup;
  if (editingGroup) {
    siblingGroup = nextElementGroups[nextElementGroups.indexOf(editingGroup) - 1];
  } else {
    siblingGroup = nextElementGroups[nextElementGroups.length - 1];
  }
  if (siblingGroup) {
    let elementsInSiblingGroup = getElementsInGroup(board, siblingGroup, true, false);
    if (elementsInSiblingGroup.length) {
      elementsInSiblingGroup.sort((a, b) => {
        const indexA = board.children.findIndex((child) => child.id === a.id);
        const indexB = board.children.findIndex((child) => child.id === b.id);
        return indexA - indexB;
      });
      return direction === "down" ? elements.indexOf(elementsInSiblingGroup[0]) : elements.indexOf(elementsInSiblingGroup[elementsInSiblingGroup.length - 1]);
    }
  }
  return candidateIndex;
};
var isMobileDeviceEvent = (event) => {
  return isPencilEvent(event) || isTouchEvent(event);
};
var isPencilEvent = (event) => {
  return event.pointerType === "pen";
};
var isTouchEvent = (event) => {
  return event.pointerType === "touch";
};
var isMouseEvent = (event) => {
  return event.pointerType === "mouse";
};
var addGroup = (board, elements) => {
  const selectedGroups = getHighestSelectedGroups(board, elements);
  const selectedIsolatedElements = getSelectedIsolatedElementsCanAddToGroup(board);
  const highestSelectedElements = [...selectedGroups, ...selectedIsolatedElements];
  const group = createGroup();
  if (canAddGroup(board)) {
    highestSelectedElements.forEach((item) => {
      const path = PlaitBoard.findPath(board, item);
      NodeTransforms.setNode(board, { groupId: group.id }, path);
    });
    const selectedElements = getSelectedElements(board);
    const highestIndexOfSelectedElement = getHighestIndexOfElement(board, selectedElements);
    const indices = getElementsIndices(board, highestSelectedElements);
    const isContinuous = isIndicesContinuous(indices);
    if (!isContinuous) {
      moveElementsToNewPathAfterAddGroup(board, selectedElements, [highestIndexOfSelectedElement - 1]);
    }
    if (hasSelectedElementsInSameGroup(highestSelectedElements)) {
      const newGroupId = selectedIsolatedElements[0].groupId;
      NodeTransforms.insertNode(board, {
        ...group,
        groupId: newGroupId
      }, [board.children.length]);
    } else {
      NodeTransforms.insertNode(board, group, [board.children.length]);
    }
  }
};
var removeGroup = (board, elements) => {
  const selectedGroups = getHighestSelectedGroups(board, elements);
  if (canRemoveGroup(board)) {
    selectedGroups.forEach((group) => {
      const elementsInGroup = findElements(board, {
        match: (item) => item.groupId === group.id,
        recursion: () => false
      });
      elementsInGroup.forEach((element) => {
        const path = PlaitBoard.findPath(board, element);
        NodeTransforms.setNode(board, { groupId: group.groupId || void 0 }, path);
      });
    });
    selectedGroups.map((group) => {
      const groupPath = PlaitBoard.findPath(board, group);
      const groupRef = board.pathRef(groupPath);
      return () => {
        groupRef.current && NodeTransforms.removeNode(board, groupRef.current);
        groupRef.unref();
      };
    }).forEach((action) => {
      action();
    });
  }
};
var GroupTransforms = {
  addGroup,
  removeGroup
};
function setSelection(board, selection) {
  const operation = { type: "set_selection", properties: board.selection, newProperties: selection };
  board.apply(operation);
}
var SelectionTransforms = {
  setSelection,
  addSelectionWithTemporaryElements
};
function addSelectionWithTemporaryElements(board, elements) {
  const timeoutId = setTimeout(() => {
    setSelection(board, { anchor: [0, 0], focus: [0, 0] });
  }, 0);
  let ref = getTemporaryRef(board);
  if (ref) {
    clearTimeout(ref.timeoutId);
    const currentElements = ref.elements;
    ref.elements.push(...elements.filter((element) => !currentElements.includes(element)));
    ref.timeoutId = timeoutId;
  } else {
    BOARD_TO_TEMPORARY_ELEMENTS.set(board, { timeoutId, elements });
  }
}
var moveToTop = (board) => {
  const moveOptions = getAllMoveOptions(board, "up");
  moveElementsToNewPath(board, moveOptions);
};
var moveToBottom = (board) => {
  const moveOptions = getAllMoveOptions(board, "down");
  moveElementsToNewPath(board, moveOptions);
};
var moveUp = (board) => {
  const moveOptions = getOneMoveOptions(board, "up");
  moveElementsToNewPath(board, moveOptions);
};
var moveDown = (board) => {
  const moveOptions = getOneMoveOptions(board, "down");
  moveElementsToNewPath(board, moveOptions);
};
var ZIndexTransforms = { moveUp, moveDown, moveToTop, moveToBottom };
var removeElements = (board, elements) => {
  elements.map((element) => {
    const path = PlaitBoard.findPath(board, element);
    const ref = board.pathRef(path);
    return () => {
      ref.current && removeNode(board, ref.current);
      ref.unref();
      removeSelectedElement(board, element, true);
    };
  }).forEach((action) => {
    action();
  });
};
var CoreTransforms = {
  removeElements
};
var Transforms = {
  ...GeneralTransforms,
  ...ViewportTransforms$1,
  ...SelectionTransforms,
  ...NodeTransforms,
  ...GroupTransforms,
  ...ZIndexTransforms
};
var rotatePoints = (points, centerPoint, angle) => {
  if (!angle) {
    angle = 0;
  }
  if (Array.isArray(points) && typeof points[0] === "number") {
    return rotate(points[0], points[1], centerPoint[0], centerPoint[1], angle);
  } else {
    return points.map((point) => {
      return rotate(point[0], point[1], centerPoint[0], centerPoint[1], angle || 0);
    });
  }
};
var getSelectionAngle = (elements) => {
  var _a;
  let angle = ((_a = elements[0]) == null ? void 0 : _a.angle) || 0;
  elements.forEach((item) => {
    if (item.angle !== angle && !approximately((item.angle || 0) % (Math.PI / 2) - angle % (Math.PI / 2), 0)) {
      angle = 0;
    }
  });
  return angle;
};
var hasSameAngle = (elements) => {
  if (!elements.length) {
    return false;
  }
  const angle = elements[0].angle;
  if (angle === void 0) {
    return false;
  }
  return !elements.some((item) => item.angle !== angle);
};
var getRotatedBoundingRectangle = (rectanglesCornerPoints, angle) => {
  let rectanglesFromOrigin = [];
  for (let i = 0; i < rectanglesCornerPoints.length; i++) {
    const cornerPoints = rectanglesCornerPoints[i];
    const invertCornerPointsFromOrigin = rotatePoints(cornerPoints, [0, 0], -angle);
    rectanglesFromOrigin.push(RectangleClient.getRectangleByPoints(invertCornerPointsFromOrigin));
  }
  const selectionRectangleFromOrigin = RectangleClient.getBoundingRectangle(rectanglesFromOrigin);
  const selectionCornerPoints = RectangleClient.getCornerPoints(selectionRectangleFromOrigin);
  const cornerPointsFromOrigin = rotatePoints(selectionCornerPoints, [0, 0], angle);
  const centerPoint = RectangleClient.getCenterPoint(RectangleClient.getRectangleByPoints(cornerPointsFromOrigin));
  return RectangleClient.getRectangleByPoints(rotatePoints(cornerPointsFromOrigin, centerPoint, -angle));
};
var getOffsetAfterRotate = (rectangle, rotateCenterPoint, angle) => {
  const targetCenterPoint = RectangleClient.getCenterPoint(rectangle);
  const [rotatedCenterPoint] = rotatePoints([targetCenterPoint], rotateCenterPoint, angle);
  const offsetX = rotatedCenterPoint[0] - targetCenterPoint[0];
  const offsetY = rotatedCenterPoint[1] - targetCenterPoint[1];
  return { offsetX, offsetY };
};
var rotatedDataPoints = (points, rotateCenterPoint, angle) => {
  const { offsetX, offsetY } = getOffsetAfterRotate(RectangleClient.getRectangleByPoints(points), rotateCenterPoint, angle);
  return points.map((p) => [p[0] + offsetX, p[1] + offsetY]);
};
var hasValidAngle = (node) => {
  return isValidAngle(node.angle);
};
var isValidAngle = (angle) => {
  return angle && angle !== 0;
};
var rotatePointsByElement = (points, element) => {
  if (hasValidAngle(element)) {
    let rectangle = RectangleClient.getRectangleByPoints(element.points);
    const centerPoint = RectangleClient.getCenterPoint(rectangle);
    return rotatePoints(points, centerPoint, element.angle);
  } else {
    return null;
  }
};
var rotatePointsByAngle = (points, angle) => {
  if (isValidAngle(angle)) {
    let rectangle = RectangleClient.getRectangleByPoints(points);
    const centerPoint = RectangleClient.getCenterPoint(rectangle);
    return rotatePoints(points, centerPoint, angle);
  } else {
    return null;
  }
};
var rotateAntiPointsByElement = (board, points, element, isToActive = false) => {
  if (hasValidAngle(element)) {
    let rectangle = RectangleClient.getRectangleByPoints(element.points);
    const activeRectangle = isToActive ? toActiveRectangleFromViewBoxRectangle(board, rectangle) : rectangle;
    const centerPoint = RectangleClient.getCenterPoint(activeRectangle);
    return rotatePoints(points, centerPoint, element.angle ? -element.angle : 0);
  } else {
    return null;
  }
};
var getRectangleByAngle = (rectangle, angle) => {
  if (angle) {
    const cornerPoints = RectangleClient.getCornerPoints(rectangle);
    const centerPoint = RectangleClient.getCenterPoint(rectangle);
    return RectangleClient.getRectangleByPoints(rotatePoints(cornerPoints, centerPoint, angle));
  }
  return rectangle;
};
var isAxisChangedByAngle = (angle) => {
  const unitAngle = Math.abs(angle) % Math.PI;
  return unitAngle >= 1 / 4 * Math.PI && unitAngle <= 3 / 4 * Math.PI;
};
function degreesToRadians(d) {
  return d / 180 * Math.PI;
}
function radiansToDegrees(r) {
  return r / Math.PI * 180;
}
function rotateElements(board, elements, angle) {
  const selectionRectangle = getRectangleByElements(board, elements, false);
  const selectionCenterPoint = RectangleClient.getCenterPoint(selectionRectangle);
  elements.forEach((item) => {
    const originAngle = item.angle;
    const points = rotatedDataPoints(item.points, selectionCenterPoint, normalizeAngle(angle));
    const path = PlaitBoard.findPath(board, item);
    Transforms.setNode(board, { points, angle: normalizeAngle((originAngle || 0) + angle) }, path);
  });
}
var normalizeAngle = (angle) => {
  if (angle < 0) {
    return angle + 2 * Math.PI;
  }
  if (angle >= 2 * Math.PI) {
    return angle - 2 * Math.PI;
  }
  return angle;
};
var getAngleBetweenPoints = (startPoint, endPoint, centerPoint) => {
  const startAngle = 5 * Math.PI / 2 + Math.atan2(startPoint[1] - centerPoint[1], startPoint[0] - centerPoint[0]);
  const endAngle = 5 * Math.PI / 2 + Math.atan2(endPoint[1] - centerPoint[1], endPoint[0] - centerPoint[0]);
  return normalizeAngle(endAngle - startAngle);
};
var getAngleByElement = (element) => {
  return element == null ? void 0 : element.angle;
};
var setAngleForG = (g, centerPoint, angle) => {
  if (angle === 0) {
    g.removeAttribute("transform");
    return;
  }
  var centerX = centerPoint[0];
  var centerY = centerPoint[1];
  let cosTheta = Math.cos(angle);
  let sinTheta = Math.sin(angle);
  let transformMatrix = [
    cosTheta,
    sinTheta,
    -sinTheta,
    cosTheta,
    centerX * (1 - cosTheta) + centerY * sinTheta,
    centerY * (1 - cosTheta) - centerX * sinTheta
  ];
  let matrix = "matrix(" + transformMatrix.join(",") + ")";
  g.setAttribute("transform", `${matrix}`);
};
function getRectangleByElements(board, elements, recursion) {
  const rectanglesCornerPoints = [];
  const callback = (node) => {
    const nodeRectangle = board.getRectangle(node);
    if (nodeRectangle) {
      const cornerPoints = RectangleClient.getCornerPoints(nodeRectangle);
      const rotatedCornerPoints = rotatePointsByElement(cornerPoints, node) || cornerPoints;
      rectanglesCornerPoints.push(rotatedCornerPoints);
    } else {
      console.error(`can not get rectangle of element:`, node);
    }
  };
  elements.forEach((element) => {
    if (recursion) {
      depthFirstRecursion(element, (node) => callback(node), (node) => board.isRecursion(node));
    } else {
      callback(element);
    }
  });
  if (rectanglesCornerPoints.length > 0) {
    if (hasSameAngle(elements)) {
      const angle = getSelectionAngle(elements);
      return getRotatedBoundingRectangle(rectanglesCornerPoints, angle);
    } else {
      const flatCornerPoints = rectanglesCornerPoints.reduce((acc, val) => {
        return acc.concat(val);
      }, []);
      return RectangleClient.getRectangleByPoints(flatCornerPoints);
    }
  } else {
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }
}
function getBoundingRectangleByElements(board, elements, recursion) {
  const rectangle = getRectangleByElements(board, elements, recursion);
  const angle = getSelectionAngle(elements);
  return getRectangleByAngle(rectangle, angle);
}
function getBoardRectangle(board) {
  return getRectangleByElements(board, board.children, true);
}
function getElementById(board, id, dataSource) {
  const cachedElement = !dataSource && getElementMap(board).get(id);
  if (cachedElement) {
    return cachedElement;
  }
  if (!dataSource) {
    dataSource = findElements(board, { match: (element2) => true, recursion: (element2) => true });
  }
  let element = dataSource.find((element2) => element2.id === id);
  return element;
}
function getElementMap(board) {
  const elementMap = KEY_TO_ELEMENT_MAP.get(board);
  if (!elementMap) {
    throw new Error("can not resolve element map");
  }
  return elementMap;
}
function findElements(board, options) {
  let elements = [];
  const isReverse = options.isReverse ?? true;
  depthFirstRecursion(board, (node) => {
    if (!PlaitBoard.isBoard(node) && options.match(node)) {
      elements.push(node);
    }
  }, (value) => {
    if (PlaitBoard.isBoard(value)) {
      return true;
    } else {
      return getIsRecursionFunc(board)(value) && options.recursion(value);
    }
  }, isReverse);
  return elements;
}
var ThemeColorMode;
(function(ThemeColorMode2) {
  ThemeColorMode2["default"] = "default";
  ThemeColorMode2["colorful"] = "colorful";
  ThemeColorMode2["soft"] = "soft";
  ThemeColorMode2["retro"] = "retro";
  ThemeColorMode2["dark"] = "dark";
  ThemeColorMode2["starry"] = "starry";
})(ThemeColorMode || (ThemeColorMode = {}));
var DEFAULT_COLOR = "#333333";
var DefaultThemeColor = {
  mode: ThemeColorMode.default,
  boardBackground: "#ffffff",
  textColor: DEFAULT_COLOR
};
var ColorfulThemeColor = {
  mode: ThemeColorMode.colorful,
  boardBackground: "#ffffff",
  textColor: DEFAULT_COLOR
};
var SoftThemeColor = {
  mode: ThemeColorMode.soft,
  boardBackground: "#f5f5f5",
  textColor: DEFAULT_COLOR
};
var RetroThemeColor = {
  mode: ThemeColorMode.retro,
  boardBackground: "#f9f8ed",
  textColor: DEFAULT_COLOR
};
var DarkThemeColor = {
  mode: ThemeColorMode.dark,
  boardBackground: "#141414",
  textColor: "#FFFFFF"
};
var StarryThemeColor = {
  mode: ThemeColorMode.starry,
  boardBackground: "#0d2537",
  textColor: "#FFFFFF"
};
var ThemeColors = [
  DefaultThemeColor,
  ColorfulThemeColor,
  SoftThemeColor,
  RetroThemeColor,
  DarkThemeColor,
  StarryThemeColor
];
var PlaitBoard = {
  isBoard(value) {
    const cachedIsBoard = IS_BOARD_CACHE.get(value);
    if (cachedIsBoard !== void 0) {
      return cachedIsBoard;
    }
    const isBoard = typeof value.onChange === "function" && typeof value.apply === "function";
    IS_BOARD_CACHE.set(value, isBoard);
    return isBoard;
  },
  isAlive(board) {
    const isAlive = IS_BOARD_ALIVE.get(board);
    return !!isAlive;
  },
  findPath(board, node) {
    const path = [];
    let child = node;
    while (true) {
      const parent = NODE_TO_PARENT.get(child);
      if (parent == null) {
        if (PlaitBoard.isBoard(child)) {
          return path;
        } else {
          break;
        }
      }
      const i = NODE_TO_INDEX.get(child);
      if (i == null) {
        break;
      }
      path.unshift(i);
      child = parent;
    }
    throw new Error(`Unable to find the path for Plait node: ${JSON.stringify(node)}`);
  },
  getHost(board) {
    return BOARD_TO_HOST.get(board);
  },
  getElementLowerHost(board) {
    var _a;
    return (_a = BOARD_TO_ELEMENT_HOST.get(board)) == null ? void 0 : _a.lowerHost;
  },
  getElementHost(board) {
    var _a;
    return (_a = BOARD_TO_ELEMENT_HOST.get(board)) == null ? void 0 : _a.host;
  },
  getElementUpperHost(board) {
    var _a;
    return (_a = BOARD_TO_ELEMENT_HOST.get(board)) == null ? void 0 : _a.upperHost;
  },
  getElementTopHost(board) {
    var _a;
    return (_a = BOARD_TO_ELEMENT_HOST.get(board)) == null ? void 0 : _a.topHost;
  },
  getActiveHost(board) {
    var _a;
    return (_a = BOARD_TO_ELEMENT_HOST.get(board)) == null ? void 0 : _a.activeHost;
  },
  getRoughSVG(board) {
    return BOARD_TO_ROUGH_SVG.get(board);
  },
  getBoardContainer(board) {
    var _a;
    return (_a = BOARD_TO_ELEMENT_HOST.get(board)) == null ? void 0 : _a.container;
  },
  getBoardContext(board) {
    return BOARD_TO_CONTEXT.get(board);
  },
  getRectangle(board) {
    return getRectangleByElements(board, board.children, true);
  },
  getViewportContainer(board) {
    var _a;
    return (_a = BOARD_TO_ELEMENT_HOST.get(board)) == null ? void 0 : _a.viewportContainer;
  },
  isFocus(board) {
    return !!board.selection;
  },
  isReadonly(board) {
    return board.options.readonly;
  },
  hasBeenTextEditing(board) {
    return !!IS_TEXT_EDITABLE.get(board);
  },
  getPointer(board) {
    return board.pointer;
  },
  isPointer(board, pointer) {
    return board.pointer === pointer;
  },
  isInPointer(board, pointers) {
    const point = board.pointer;
    return pointers.includes(point);
  },
  getMovingPointInBoard(board) {
    return BOARD_TO_MOVING_POINT_IN_BOARD.get(board);
  },
  isMovingPointInBoard(board) {
    const point = BOARD_TO_MOVING_POINT.get(board);
    const rect = PlaitBoard.getBoardContainer(board).getBoundingClientRect();
    if (point && distanceBetweenPointAndRectangle(point[0], point[1], rect) === 0) {
      return true;
    }
    return false;
  },
  getThemeColors(board) {
    return board.options.themeColors || ThemeColors;
  }
};
var PlaitPointerType;
(function(PlaitPointerType2) {
  PlaitPointerType2["hand"] = "hand";
  PlaitPointerType2["selection"] = "selection";
})(PlaitPointerType || (PlaitPointerType = {}));
var isSetViewportOperation = (value) => {
  return value.type === "set_viewport";
};
var isSetSelectionOperation = (value) => {
  return value.type === "set_selection";
};
var isSetThemeOperation = (value) => {
  return value.type === "set_theme";
};
var inverse = (op) => {
  switch (op.type) {
    case "insert_node": {
      return { ...op, type: "remove_node" };
    }
    case "remove_node": {
      return { ...op, type: "insert_node" };
    }
    case "move_node": {
      const { newPath, path } = op;
      if (Path.equals(newPath, path)) {
        return op;
      }
      const inversePath = Path.transform(path, op);
      const inverseNewPath = Path.transform(Path.next(path), op);
      return { ...op, path: inversePath, newPath: inverseNewPath };
    }
    case "set_node": {
      const { properties, newProperties } = op;
      return { ...op, properties: newProperties, newProperties: properties };
    }
    case "set_selection": {
      const { properties, newProperties } = op;
      if (properties == null) {
        return {
          ...op,
          properties: newProperties,
          newProperties: null
        };
      } else if (newProperties == null) {
        return {
          ...op,
          properties: null,
          newProperties: properties
        };
      } else {
        return { ...op, properties: newProperties, newProperties: properties };
      }
    }
    case "set_viewport": {
      const { properties, newProperties } = op;
      if (properties == null) {
        return {
          ...op,
          properties: newProperties,
          newProperties
        };
      } else if (newProperties == null) {
        return {
          ...op,
          properties,
          newProperties: properties
        };
      } else {
        return { ...op, properties: newProperties, newProperties: properties };
      }
    }
    case "set_theme": {
      const { properties, newProperties } = op;
      return { ...op, properties: newProperties, newProperties: properties };
    }
  }
};
var PlaitOperation = {
  isSetViewportOperation,
  isSetSelectionOperation,
  isSetThemeOperation,
  inverse
};
var Point = {
  isEquals(point, otherPoint) {
    return point && otherPoint && point[0] === otherPoint[0] && point[1] === otherPoint[1];
  },
  isHorizontal(point, otherPoint, tolerance = 0) {
    return point && otherPoint && Point.isOverHorizontal([point, otherPoint], tolerance);
  },
  isOverHorizontal(points, tolerance = 0) {
    return points.every((point) => Math.abs(point[1] - points[0][1]) <= tolerance);
  },
  isVertical(point, otherPoint, tolerance = 0) {
    return point && otherPoint && Point.isOverVertical([point, otherPoint], tolerance);
  },
  isOverVertical(points, tolerance = 0) {
    return points.every((point) => Math.abs(point[0] - points[0][0]) <= tolerance);
  },
  isAlign(points, tolerance = 0) {
    return Point.isOverHorizontal(points, tolerance) || Point.isOverVertical(points, tolerance);
  },
  getOffsetX(point1, point2) {
    return point2[0] - point1[0];
  },
  getOffsetY(point1, point2) {
    return point2[1] - point1[1];
  }
};
var SAVING = /* @__PURE__ */ new WeakMap();
var MERGING = /* @__PURE__ */ new WeakMap();
var HISTORY = /* @__PURE__ */ new WeakMap();
var SPLITTING_ONCE = /* @__PURE__ */ new WeakMap();
var Direction;
(function(Direction2) {
  Direction2["left"] = "left";
  Direction2["top"] = "top";
  Direction2["right"] = "right";
  Direction2["bottom"] = "bottom";
})(Direction || (Direction = {}));
var isHorizontalDirection = (direction) => {
  return direction === Direction.left || direction === Direction.right;
};
var isVerticalDirection = (direction) => {
  return !isHorizontalDirection(direction);
};
var PlaitGroupElement = {
  isGroup: (value) => {
    return value.type === "group";
  }
};
function isListLikeIterable(obj) {
  if (!isJsObject(obj))
    return false;
  return Array.isArray(obj) || !(obj instanceof Map) && // JS Map are iterables but return entries as [k, v]
  Symbol.iterator in obj;
}
function isJsObject(o) {
  return o !== null && (typeof o === "function" || typeof o === "object");
}
function iterateListLike(obj, fn) {
  if (Array.isArray(obj)) {
    for (let i = 0; i < obj.length; i++) {
      fn(obj[i]);
    }
  } else {
    const iterator2 = obj[Symbol.iterator]();
    let item;
    while (!(item = iterator2.next()).done) {
      fn(item.value);
    }
  }
}
var trackByIdentity = (index, item) => item;
var DefaultIterableDiffer = class {
  constructor(trackByFn) {
    this.length = 0;
    this._linkedRecords = null;
    this._unlinkedRecords = null;
    this._previousItHead = null;
    this._itHead = null;
    this._itTail = null;
    this._additionsHead = null;
    this._additionsTail = null;
    this._movesHead = null;
    this._movesTail = null;
    this._removalsHead = null;
    this._removalsTail = null;
    this._identityChangesHead = null;
    this._identityChangesTail = null;
    this._trackByFn = trackByFn || trackByIdentity;
  }
  forEachItem(fn) {
    let record;
    for (record = this._itHead; record !== null; record = record._next) {
      fn(record);
    }
  }
  forEachOperation(fn) {
    let nextIt = this._itHead;
    let nextRemove = this._removalsHead;
    let addRemoveOffset = 0;
    let moveOffsets = null;
    while (nextIt || nextRemove) {
      const record = !nextRemove || nextIt && nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ? nextIt : nextRemove;
      const adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
      const currentIndex = record.currentIndex;
      if (record === nextRemove) {
        addRemoveOffset--;
        nextRemove = nextRemove._nextRemoved;
      } else {
        nextIt = nextIt._next;
        if (record.previousIndex == null) {
          addRemoveOffset++;
        } else {
          if (!moveOffsets)
            moveOffsets = [];
          const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
          const localCurrentIndex = currentIndex - addRemoveOffset;
          if (localMovePreviousIndex != localCurrentIndex) {
            for (let i = 0; i < localMovePreviousIndex; i++) {
              const offset = i < moveOffsets.length ? moveOffsets[i] : moveOffsets[i] = 0;
              const index = offset + i;
              if (localCurrentIndex <= index && index < localMovePreviousIndex) {
                moveOffsets[i] = offset + 1;
              }
            }
            const previousIndex = record.previousIndex;
            moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
          }
        }
      }
      if (adjPreviousIndex !== currentIndex) {
        fn(record, adjPreviousIndex, currentIndex);
      }
    }
  }
  forEachPreviousItem(fn) {
    let record;
    for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
      fn(record);
    }
  }
  forEachAddedItem(fn) {
    let record;
    for (record = this._additionsHead; record !== null; record = record._nextAdded) {
      fn(record);
    }
  }
  forEachMovedItem(fn) {
    let record;
    for (record = this._movesHead; record !== null; record = record._nextMoved) {
      fn(record);
    }
  }
  forEachRemovedItem(fn) {
    let record;
    for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
      fn(record);
    }
  }
  forEachIdentityChange(fn) {
    let record;
    for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
      fn(record);
    }
  }
  diff(collection) {
    if (collection == null)
      collection = [];
    if (!isListLikeIterable(collection)) {
      throw new Error("Exception: Error trying to diff. Only arrays and iterables are allowed");
    }
    if (this.check(collection)) {
      return this;
    } else {
      return null;
    }
  }
  onDestroy() {
  }
  check(collection) {
    this._reset();
    let record = this._itHead;
    let mayBeDirty = false;
    let index;
    let item;
    let itemTrackBy;
    if (Array.isArray(collection)) {
      this.length = collection.length;
      for (let index2 = 0; index2 < this.length; index2++) {
        item = collection[index2];
        itemTrackBy = this._trackByFn(index2, item);
        if (record === null || !Object.is(record.trackById, itemTrackBy)) {
          record = this._mismatch(record, item, itemTrackBy, index2);
          mayBeDirty = true;
        } else {
          if (mayBeDirty) {
            record = this._verifyReinsertion(record, item, itemTrackBy, index2);
          }
          if (!Object.is(record.item, item))
            this._addIdentityChange(record, item);
        }
        record = record._next;
      }
    } else {
      index = 0;
      iterateListLike(collection, (item2) => {
        itemTrackBy = this._trackByFn(index, item2);
        if (record === null || !Object.is(record.trackById, itemTrackBy)) {
          record = this._mismatch(record, item2, itemTrackBy, index);
          mayBeDirty = true;
        } else {
          if (mayBeDirty) {
            record = this._verifyReinsertion(record, item2, itemTrackBy, index);
          }
          if (!Object.is(record.item, item2))
            this._addIdentityChange(record, item2);
        }
        record = record._next;
        index++;
      });
      this.length = index;
    }
    this._truncate(record);
    this.collection = collection;
    return this.isDirty;
  }
  /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity
   * changes.
   */
  get isDirty() {
    return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null || this._identityChangesHead !== null;
  }
  /**
   * Reset the state of the change objects to show no changes. This means set previousKey to
   * currentKey, and clear all of the queues (additions, moves, removals).
   * Set the previousIndexes of moved and added items to their currentIndexes
   * Reset the list of additions, moves and removals
   *
   * @internal
   */
  _reset() {
    if (this.isDirty) {
      let record;
      for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
        record._nextPrevious = record._next;
      }
      for (record = this._additionsHead; record !== null; record = record._nextAdded) {
        record.previousIndex = record.currentIndex;
      }
      this._additionsHead = this._additionsTail = null;
      for (record = this._movesHead; record !== null; record = record._nextMoved) {
        record.previousIndex = record.currentIndex;
      }
      this._movesHead = this._movesTail = null;
      this._removalsHead = this._removalsTail = null;
      this._identityChangesHead = this._identityChangesTail = null;
    }
  }
  /**
   * This is the core function which handles differences between collections.
   *
   * - `record` is the record which we saw at this position last time. If null then it is a new
   *   item.
   * - `item` is the current item in the collection
   * - `index` is the position of the item in the collection
   *
   * @internal
   */
  _mismatch(record, item, itemTrackBy, index) {
    let previousRecord;
    if (record === null) {
      previousRecord = this._itTail;
    } else {
      previousRecord = record._prev;
      this._remove(record);
    }
    record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
    if (record !== null) {
      if (!Object.is(record.item, item))
        this._addIdentityChange(record, item);
      this._reinsertAfter(record, previousRecord, index);
    } else {
      record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
      if (record !== null) {
        if (!Object.is(record.item, item))
          this._addIdentityChange(record, item);
        this._moveAfter(record, previousRecord, index);
      } else {
        record = this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index);
      }
    }
    return record;
  }
  /**
   * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
   *
   * Use case: `[a, a]` => `[b, a, a]`
   *
   * If we did not have this check then the insertion of `b` would:
   *   1) evict first `a`
   *   2) insert `b` at `0` index.
   *   3) leave `a` at index `1` as is. <-- this is wrong!
   *   3) reinsert `a` at index 2. <-- this is wrong!
   *
   * The correct behavior is:
   *   1) evict first `a`
   *   2) insert `b` at `0` index.
   *   3) reinsert `a` at index 1.
   *   3) move `a` at from `1` to `2`.
   *
   *
   * Double check that we have not evicted a duplicate item. We need to check if the item type may
   * have already been removed:
   * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
   * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
   * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
   * at the end.
   *
   * @internal
   */
  _verifyReinsertion(record, item, itemTrackBy, index) {
    let reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
    if (reinsertRecord !== null) {
      record = this._reinsertAfter(reinsertRecord, record._prev, index);
    } else if (record.currentIndex != index) {
      record.currentIndex = index;
      this._addToMoves(record, index);
    }
    return record;
  }
  /**
   * Get rid of any excess {@link IterableChangeRecord_}s from the previous collection
   *
   * - `record` The first excess {@link IterableChangeRecord_}.
   *
   * @internal
   */
  _truncate(record) {
    while (record !== null) {
      const nextRecord = record._next;
      this._addToRemovals(this._unlink(record));
      record = nextRecord;
    }
    if (this._unlinkedRecords !== null) {
      this._unlinkedRecords.clear();
    }
    if (this._additionsTail !== null) {
      this._additionsTail._nextAdded = null;
    }
    if (this._movesTail !== null) {
      this._movesTail._nextMoved = null;
    }
    if (this._itTail !== null) {
      this._itTail._next = null;
    }
    if (this._removalsTail !== null) {
      this._removalsTail._nextRemoved = null;
    }
    if (this._identityChangesTail !== null) {
      this._identityChangesTail._nextIdentityChange = null;
    }
  }
  /** @internal */
  _reinsertAfter(record, prevRecord, index) {
    if (this._unlinkedRecords !== null) {
      this._unlinkedRecords.remove(record);
    }
    const prev = record._prevRemoved;
    const next = record._nextRemoved;
    if (prev === null) {
      this._removalsHead = next;
    } else {
      prev._nextRemoved = next;
    }
    if (next === null) {
      this._removalsTail = prev;
    } else {
      next._prevRemoved = prev;
    }
    this._insertAfter(record, prevRecord, index);
    this._addToMoves(record, index);
    return record;
  }
  /** @internal */
  _moveAfter(record, prevRecord, index) {
    this._unlink(record);
    this._insertAfter(record, prevRecord, index);
    this._addToMoves(record, index);
    return record;
  }
  /** @internal */
  _addAfter(record, prevRecord, index) {
    this._insertAfter(record, prevRecord, index);
    if (this._additionsTail === null) {
      this._additionsTail = this._additionsHead = record;
    } else {
      this._additionsTail = this._additionsTail._nextAdded = record;
    }
    return record;
  }
  /** @internal */
  _insertAfter(record, prevRecord, index) {
    const next = prevRecord === null ? this._itHead : prevRecord._next;
    record._next = next;
    record._prev = prevRecord;
    if (next === null) {
      this._itTail = record;
    } else {
      next._prev = record;
    }
    if (prevRecord === null) {
      this._itHead = record;
    } else {
      prevRecord._next = record;
    }
    if (this._linkedRecords === null) {
      this._linkedRecords = new _DuplicateMap();
    }
    this._linkedRecords.put(record);
    record.currentIndex = index;
    return record;
  }
  /** @internal */
  _remove(record) {
    return this._addToRemovals(this._unlink(record));
  }
  /** @internal */
  _unlink(record) {
    if (this._linkedRecords !== null) {
      this._linkedRecords.remove(record);
    }
    const prev = record._prev;
    const next = record._next;
    if (prev === null) {
      this._itHead = next;
    } else {
      prev._next = next;
    }
    if (next === null) {
      this._itTail = prev;
    } else {
      next._prev = prev;
    }
    return record;
  }
  /** @internal */
  _addToMoves(record, toIndex) {
    if (record.previousIndex === toIndex) {
      return record;
    }
    if (this._movesTail === null) {
      this._movesTail = this._movesHead = record;
    } else {
      this._movesTail = this._movesTail._nextMoved = record;
    }
    return record;
  }
  _addToRemovals(record) {
    if (this._unlinkedRecords === null) {
      this._unlinkedRecords = new _DuplicateMap();
    }
    this._unlinkedRecords.put(record);
    record.currentIndex = null;
    record._nextRemoved = null;
    if (this._removalsTail === null) {
      this._removalsTail = this._removalsHead = record;
      record._prevRemoved = null;
    } else {
      record._prevRemoved = this._removalsTail;
      this._removalsTail = this._removalsTail._nextRemoved = record;
    }
    return record;
  }
  /** @internal */
  _addIdentityChange(record, item) {
    record.item = item;
    if (this._identityChangesTail === null) {
      this._identityChangesTail = this._identityChangesHead = record;
    } else {
      this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
    }
    return record;
  }
};
var IterableChangeRecord_ = class {
  constructor(item, trackById) {
    this.item = item;
    this.trackById = trackById;
    this.currentIndex = null;
    this.previousIndex = null;
    this._nextPrevious = null;
    this._prev = null;
    this._next = null;
    this._prevDup = null;
    this._nextDup = null;
    this._prevRemoved = null;
    this._nextRemoved = null;
    this._nextAdded = null;
    this._nextMoved = null;
    this._nextIdentityChange = null;
  }
};
var _DuplicateItemRecordList = class {
  constructor() {
    this._head = null;
    this._tail = null;
  }
  /**
   * Append the record to the list of duplicates.
   *
   * Note: by design all records in the list of duplicates hold the same value in record.item.
   */
  add(record) {
    if (this._head === null) {
      this._head = this._tail = record;
      record._nextDup = null;
      record._prevDup = null;
    } else {
      this._tail._nextDup = record;
      record._prevDup = this._tail;
      record._nextDup = null;
      this._tail = record;
    }
  }
  // Returns a IterableChangeRecord_ having IterableChangeRecord_.trackById == trackById and
  // IterableChangeRecord_.currentIndex >= atOrAfterIndex
  get(trackById, atOrAfterIndex) {
    let record;
    for (record = this._head; record !== null; record = record._nextDup) {
      if ((atOrAfterIndex === null || atOrAfterIndex <= record.currentIndex) && Object.is(record.trackById, trackById)) {
        return record;
      }
    }
    return null;
  }
  /**
   * Remove one {@link IterableChangeRecord_} from the list of duplicates.
   *
   * Returns whether the list of duplicates is empty.
   */
  remove(record) {
    const prev = record._prevDup;
    const next = record._nextDup;
    if (prev === null) {
      this._head = next;
    } else {
      prev._nextDup = next;
    }
    if (next === null) {
      this._tail = prev;
    } else {
      next._prevDup = prev;
    }
    return this._head === null;
  }
};
var _DuplicateMap = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  put(record) {
    const key = record.trackById;
    let duplicates = this.map.get(key);
    if (!duplicates) {
      duplicates = new _DuplicateItemRecordList();
      this.map.set(key, duplicates);
    }
    duplicates.add(record);
  }
  /**
   * Retrieve the `value` using key. Because the IterableChangeRecord_ value may be one which we
   * have already iterated over, we use the `atOrAfterIndex` to pretend it is not there.
   *
   * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
   * have any more `a`s needs to return the second `a`.
   */
  get(trackById, atOrAfterIndex) {
    const key = trackById;
    const recordList = this.map.get(key);
    return recordList ? recordList.get(trackById, atOrAfterIndex) : null;
  }
  /**
   * Removes a {@link IterableChangeRecord_} from the list of duplicates.
   *
   * The list of duplicates also is removed from the map if it gets empty.
   */
  remove(record) {
    const key = record.trackById;
    const recordList = this.map.get(key);
    if (recordList.remove(record)) {
      this.map.delete(key);
    }
    return record;
  }
  get isEmpty() {
    return this.map.size === 0;
  }
  clear() {
    this.map.clear();
  }
};
function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
  const previousIndex = item.previousIndex;
  if (previousIndex === null)
    return previousIndex;
  let moveOffset = 0;
  if (moveOffsets && previousIndex < moveOffsets.length) {
    moveOffset = moveOffsets[previousIndex];
  }
  return previousIndex + addRemoveOffset + moveOffset;
}
var ListRender = class {
  constructor(board) {
    this.board = board;
    this.children = [];
    this.instances = [];
    this.contexts = [];
    this.differ = null;
    this.initialized = false;
  }
  initialize(children, childrenContext) {
    this.initialized = true;
    this.children = children;
    children.forEach((descendant, index) => {
      NODE_TO_INDEX.set(descendant, index);
      NODE_TO_PARENT.set(descendant, childrenContext.parent);
      const context2 = getContext(this.board, descendant, index, childrenContext.parent);
      const componentType = getComponentType(this.board, context2);
      const instance = createPluginComponent(this.board, componentType, context2, childrenContext);
      this.instances.push(instance);
      this.contexts.push(context2);
    });
    this.differ = new DefaultIterableDiffer(trackBy);
    this.differ.diff(children);
  }
  update(children, childrenContext) {
    if (!this.initialized) {
      this.initialize(children, childrenContext);
      return;
    }
    if (!this.differ) {
      throw new Error("Exception: Can not find differ ");
    }
    const { board, parent } = childrenContext;
    const diffResult = this.differ.diff(children);
    if (diffResult) {
      const newContexts = [];
      const newInstances = [];
      let currentIndexForFirstElement = null;
      diffResult.forEachItem((record) => {
        var _a;
        NODE_TO_INDEX.set(record.item, record.currentIndex);
        NODE_TO_PARENT.set(record.item, childrenContext.parent);
        const previousContext = record.previousIndex === null ? void 0 : this.contexts[record.previousIndex];
        const context2 = getContext(board, record.item, record.currentIndex, parent, previousContext);
        if (record.previousIndex === null) {
          const componentType = getComponentType(board, context2);
          const componentRef = createPluginComponent(board, componentType, context2, childrenContext);
          newContexts.push(context2);
          newInstances.push(componentRef);
        } else {
          const instance = this.instances[record.previousIndex];
          instance.context = context2;
          newInstances.push(instance);
          newContexts.push(context2);
        }
        if (record.item === this.children[0] || record.item.id === ((_a = this.children[0]) == null ? void 0 : _a.id)) {
          currentIndexForFirstElement = record.currentIndex;
        }
      });
      diffResult.forEachOperation((record) => {
        if (record.currentIndex === null) {
          const componentRef = this.instances[record.previousIndex];
          componentRef == null ? void 0 : componentRef.destroy();
        }
        if (record.previousIndex !== null && record.currentIndex !== null) {
          mountOnItemMove(record.item, record.currentIndex, childrenContext, currentIndexForFirstElement);
        }
      });
      this.instances = newInstances;
      this.contexts = newContexts;
      this.children = children;
    } else {
      const newContexts = [];
      this.children.forEach((element, index) => {
        NODE_TO_INDEX.set(element, index);
        NODE_TO_PARENT.set(element, childrenContext.parent);
        const previousContext = this.contexts[index];
        const previousInstance = this.instances[index];
        const context2 = getContext(board, element, index, parent, previousContext);
        previousInstance.context = context2;
        newContexts.push(context2);
      });
      this.contexts = newContexts;
    }
  }
  destroy() {
    this.children.forEach((element, index) => {
      if (this.instances[index]) {
        this.instances[index].destroy();
      }
    });
    this.instances = [];
    this.children = [];
    this.contexts = [];
    this.initialized = false;
    this.differ = null;
  }
};
var trackBy = (index, element) => {
  return element.id;
};
var createPluginComponent = (board, componentType, context2, childrenContext) => {
  const instance = new componentType();
  instance.context = context2;
  board.normalizeElement(context2);
  try {
    instance.initialize();
  } catch (error) {
    if (isDebug()) {
      console.error("list-render-initialize", error, "context", context2);
    }
  }
  const g = instance.getContainerG();
  mountElementG(context2.index, g, childrenContext);
  instance.initializeListRender();
  return instance;
};
var getComponentType = (board, context2) => {
  const result = board.drawElement(context2);
  return result;
};
var getContext = (board, element, index, parent, previousContext) => {
  var _a;
  let isSelected = isSelectedElement(board, element);
  const previousElement = previousContext && previousContext.element;
  if (previousElement && previousElement !== element && isSelectedElement(board, previousElement)) {
    isSelected = true;
    replaceSelectedElement(board, previousElement, element);
  }
  const context2 = {
    element,
    parent,
    board,
    selected: isSelected,
    index,
    hasThemeChanged: !!((_a = board.operations) == null ? void 0 : _a.find((op) => op.type === "set_theme"))
  };
  return context2;
};
var mountElementG = (index, g, childrenContext, currentIndexForFirstElement = null) => {
  const { parent, parentG } = childrenContext;
  if (PlaitBoard.isBoard(parent)) {
    if (index > 0) {
      const previousElement = parent.children[index - 1];
      const previousContainerG = PlaitElement.getContainerG(previousElement, { suppressThrow: false });
      previousContainerG.insertAdjacentElement("afterend", g);
    } else {
      if (currentIndexForFirstElement !== null) {
        const firstElement = parent.children[currentIndexForFirstElement];
        const firstContainerG = firstElement && PlaitElement.getContainerG(firstElement, { suppressThrow: true });
        if (firstElement && firstContainerG) {
          parentG.insertBefore(g, firstContainerG);
        } else {
          throw new Error("fail to mount container on moving");
        }
      } else {
        parentG.append(g);
      }
    }
  } else {
    if (index > 0) {
      const previousElement = parent.children[index - 1];
      const previousElementG = PlaitElement.getElementG(previousElement);
      previousElementG.insertAdjacentElement("afterend", g);
    } else {
      if (currentIndexForFirstElement) {
        const nextElement = parent.children[currentIndexForFirstElement];
        const nextPath = nextElement && PlaitBoard.findPath(childrenContext.board, nextElement);
        const first2 = nextPath && PlaitNode.first(childrenContext.board, nextPath);
        const firstContainerG = first2 && PlaitElement.getContainerG(first2, { suppressThrow: false });
        if (firstContainerG) {
          parentG.insertBefore(g, firstContainerG);
        } else {
          throw new Error("fail to mount container on moving");
        }
      } else {
        let parentElementG = PlaitElement.getElementG(parent);
        parentG.insertBefore(g, parentElementG);
      }
    }
  }
};
var mountOnItemMove = (element, index, childrenContext, currentIndexForFirstElement) => {
  const containerG = PlaitElement.getContainerG(element, { suppressThrow: false });
  mountElementG(index, containerG, childrenContext, currentIndexForFirstElement);
  if (element.children && !PlaitElement.isRootElement(element) && childrenContext.board.isExpanded(element)) {
    element.children.forEach((child, index2) => {
      mountOnItemMove(child, index2, { ...childrenContext, parent: element }, null);
    });
  }
};
var ElementFlavour = class {
  get hasChildren() {
    return !!this.element.children;
  }
  set context(value) {
    if (hasBeforeContextChange(this)) {
      this.beforeContextChange(value);
    }
    const previousContext = this._context;
    this._context = value;
    if (this.initialized) {
      const elementG = this.getElementG();
      const containerG = this.getContainerG();
      NODE_TO_G.set(this.element, elementG);
      NODE_TO_CONTAINER_G.set(this.element, containerG);
      getElementMap(this.board).set(this.element.id, this.element);
      ELEMENT_TO_REF.set(this.element, this.ref);
      this.updateListRender();
      if (hasOnContextChanged(this)) {
        this.onContextChanged(value, previousContext);
      }
    } else {
      if (PlaitElement.isRootElement(this.element) && this.hasChildren) {
        this._g = createG();
        this._containerG = createG();
        this._containerG.append(this._g);
      } else {
        this._g = createG();
        this._containerG = this._g;
      }
      NODE_TO_G.set(this.element, this._g);
      NODE_TO_CONTAINER_G.set(this.element, this._containerG);
      ELEMENT_TO_REF.set(this.element, this.ref);
      getElementMap(this.board).set(this.element.id, this.element);
    }
  }
  get context() {
    return this._context;
  }
  get element() {
    return this.context && this.context.element;
  }
  get board() {
    return this.context && this.context.board;
  }
  get selected() {
    return this.context && this.context.selected;
  }
  getContainerG() {
    return this._containerG;
  }
  getElementG() {
    return this._g;
  }
  constructor(ref) {
    this.ref = ref;
    this.initialized = false;
  }
  initialize() {
    if (this.element.type) {
      this.getContainerG().setAttribute(`plait-${this.element.type}`, "true");
    }
    if (this.hasChildren) {
      if (PlaitElement.isRootElement(this.element)) {
        this._rootContainerG = this._containerG;
      } else {
        const path = PlaitBoard.findPath(this.board, this.element);
        const rootNode = PlaitNode.get(this.board, path.slice(0, 1));
        this._rootContainerG = PlaitElement.getContainerG(rootNode, { suppressThrow: false });
      }
    }
    this.getContainerG().setAttribute("plait-data-id", this.element.id);
    this.initialized = true;
  }
  initializeListRender() {
    if (this.hasChildren) {
      this.listRender = new ListRender(this.board);
      if (this.board.isExpanded(this.element)) {
        this.listRender.initialize(this.element.children, this.initializeChildrenContext());
      }
    }
  }
  getRef() {
    return this.ref;
  }
  updateListRender() {
    if (this.hasChildren) {
      if (!this.listRender) {
        throw new Error("incorrectly initialize list render");
      }
      if (this.board.isExpanded(this.element)) {
        this.listRender.update(this.element.children, this.initializeChildrenContext());
      } else {
        if (this.listRender.initialized) {
          this.listRender.destroy();
        }
      }
    }
  }
  initializeChildrenContext() {
    if (!this._rootContainerG) {
      throw new Error("can not resolve root container g");
    }
    return {
      board: this.board,
      parent: this.element,
      parentG: this._rootContainerG
    };
  }
  destroy() {
    var _a;
    if (NODE_TO_G.get(this.element) === this._g) {
      NODE_TO_G.delete(this.element);
    }
    getElementMap(this.board).delete(this.element.id);
    if (NODE_TO_CONTAINER_G.get(this.element) === this._containerG) {
      NODE_TO_CONTAINER_G.delete(this.element);
    }
    if (ELEMENT_TO_REF.get(this.element) === this.ref) {
      ELEMENT_TO_REF.set(this.element, this.ref);
    }
    removeSelectedElement(this.board, this.element);
    this.getContainerG().remove();
    (_a = this.listRender) == null ? void 0 : _a.destroy();
  }
};
var PlaitBoardContext = class {
  constructor() {
    this._stable = new Subject();
    this.uploadingFiles = [];
  }
  getUploadingFile(url) {
    return this.uploadingFiles.find((file) => file.url === url);
  }
  setUploadingFile(file) {
    return this.uploadingFiles.push(file);
  }
  removeUploadingFile(fileEntry) {
    this.uploadingFiles = this.uploadingFiles.filter((file) => file.url !== fileEntry.url);
  }
  onStable() {
    return this._stable.asObservable();
  }
  nextStable() {
    this._stable.next("");
  }
};
var PathRef = {
  transform(ref, op) {
    const { current } = ref;
    if (current == null) {
      return;
    }
    const path = Path.transform(current, op);
    ref.current = path;
    if (path == null) {
      ref.unref();
    }
  }
};
function createBoard(children, options) {
  const board = {
    viewport: {
      zoom: 1
    },
    children,
    theme: { themeColorMode: ThemeColorMode.default },
    operations: [],
    history: {
      redos: [],
      undos: []
    },
    selection: null,
    options: options || {
      readonly: false,
      hideScrollbar: false,
      disabledScrollOnNonFocus: false
    },
    pointer: (options == null ? void 0 : options.readonly) ? PlaitPointerType.hand : PlaitPointerType.selection,
    undo: () => {
    },
    redo: () => {
    },
    apply: (operation) => {
      for (const ref of board.pathRefs()) {
        PathRef.transform(ref, operation);
      }
      board.operations.push(operation);
      Transforms.transform(board, operation);
      if (!FLUSHING.get(board)) {
        FLUSHING.set(board, true);
        Promise.resolve().then(() => {
          FLUSHING.set(board, false);
          board.onChange();
          board.afterChange();
          board.operations = [];
        });
      }
    },
    pathRef: (path, options2) => {
      const affinity = (options2 == null ? void 0 : options2.affinity) || "forward";
      const ref = {
        current: path,
        affinity,
        unref() {
          const { current } = ref;
          const pathRefs = board.pathRefs();
          pathRefs.delete(ref);
          ref.current = null;
          return current;
        }
      };
      const refs = board.pathRefs();
      refs.add(ref);
      return ref;
    },
    pathRefs: () => {
      let refs = PATH_REFS.get(board);
      if (!refs) {
        refs = /* @__PURE__ */ new Set();
        PATH_REFS.set(board, refs);
      }
      return refs;
    },
    onChange: () => {
    },
    afterChange: () => {
    },
    drawSelectionRectangle: () => {
      return drawSelectionRectangleG(board);
    },
    mousedown: (event) => {
    },
    mousemove: (event) => {
    },
    mouseleave: (event) => {
    },
    globalMousemove: (event) => {
    },
    mouseup: (event) => {
    },
    globalMouseup: (event) => {
    },
    keyDown: (event) => {
    },
    globalKeyDown: (event) => {
    },
    keyUp: (event) => {
    },
    dblClick: (event) => {
    },
    buildFragment: (clipboardContext, rectangle, operationType, originData) => clipboardContext,
    insertFragment: (clipboardData, targetPoint, operationType) => {
    },
    deleteFragment: (elements) => {
      CoreTransforms.removeElements(board, elements);
    },
    getDeletedFragment: (data) => data,
    getRelatedFragment: (data, originData) => data,
    normalizeElement: (context2) => {
    },
    drawElement: (context2) => {
      throw new Error(`can not resolve plugin element component type: ${context2.element.type}`);
    },
    isWithinSelection: (element) => false,
    isRectangleHit: (element) => false,
    isHit: (element) => false,
    isInsidePoint: (element) => false,
    getOneHitElement: (data) => data[0],
    isRecursion: (element) => true,
    isMovable: (element) => false,
    getRectangle: (element) => null,
    applyTheme: (element) => {
    },
    isAlign: (element) => false,
    pointerDown: (pointer) => {
    },
    pointerMove: (pointer) => {
    },
    pointerUp: (pointer) => {
    },
    pointerCancel: (pointer) => {
    },
    pointerOut: (pointer) => {
    },
    pointerLeave: (pointer) => {
    },
    globalPointerMove: (pointer) => {
    },
    globalPointerUp: (pointer) => {
    },
    drop: (event) => {
      return false;
    },
    isImageBindingAllowed: (element) => false,
    canAddToGroup: (element) => true,
    canSetZIndex: (element) => true,
    isExpanded: (element) => true
  };
  return board;
}
function withBoard(board) {
  const { onChange, afterChange } = board;
  board.onChange = () => {
    const onContextChange = BOARD_TO_ON_CHANGE.get(board);
    if (onContextChange) {
      onContextChange();
    }
    onChange();
  };
  board.afterChange = () => {
    const afterContextChange = BOARD_TO_AFTER_CHANGE.get(board);
    if (afterContextChange) {
      afterContextChange();
    }
    afterChange();
  };
  return board;
}
var isSmartHand = (board, event) => {
  return PlaitBoard.isPointer(board, PlaitPointerType.selection) && isMobileDeviceEvent(event);
};
var ShortcutKey = "Space";
function withHandPointer(board) {
  const { pointerDown, pointerMove, globalPointerUp, keyDown, keyUp, pointerUp } = board;
  let isHandMoving = false;
  let movingPoint = null;
  let pointerDownEvent = null;
  let hasWheelPressed = false;
  let beingPressedShortcutKey = false;
  board.pointerDown = (event) => {
    const options = board.getPluginOptions(PlaitPluginKey.withHand);
    const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
    const isHitTarget = isHitElement(board, point);
    const canEnterHandMode = (options == null ? void 0 : options.isHandMode(board, event)) || PlaitBoard.isPointer(board, PlaitPointerType.hand) || isSmartHand(board, event) && !isHitTarget || beingPressedShortcutKey;
    if (canEnterHandMode && isMainPointer(event)) {
      movingPoint = {
        x: event.x,
        y: event.y
      };
      if (!PlaitBoard.isPointer(board, PlaitPointerType.hand)) {
        PlaitBoard.getBoardContainer(board).classList.add("viewport-moving");
      }
    } else if (isWheelPointer(event)) {
      hasWheelPressed = true;
      event.preventDefault();
      movingPoint = {
        x: event.x,
        y: event.y
      };
      isHandMoving = true;
      PlaitBoard.getBoardContainer(board).classList.add("viewport-moving");
    }
    pointerDownEvent = event;
    pointerDown(event);
  };
  board.pointerMove = (event) => {
    const options = board.getPluginOptions(PlaitPluginKey.withHand);
    const triggerDistance = DRAG_SELECTION_PRESS_AND_MOVE_BUFFER + 4;
    if (movingPoint && !isHandMoving && !isSelectionMoving(board) && pointerDownEvent && distanceBetweenPointAndPoint(pointerDownEvent.x, pointerDownEvent.y, event.x, event.y) > triggerDistance && !isMovingElements(board)) {
      isHandMoving = true;
      PlaitBoard.getBoardContainer(board).classList.add("viewport-moving");
    }
    const canEnterHandMode = (options == null ? void 0 : options.isHandMode(board, event)) || PlaitBoard.isPointer(board, PlaitPointerType.hand) || isSmartHand(board, event) || hasWheelPressed || beingPressedShortcutKey;
    if (canEnterHandMode && isHandMoving && movingPoint && !isSelectionMoving(board) && !isMovingElements(board)) {
      const viewportContainer = PlaitBoard.getViewportContainer(board);
      const left = viewportContainer.scrollLeft - (event.x - movingPoint.x);
      const top = viewportContainer.scrollTop - (event.y - movingPoint.y);
      updateViewportContainerScroll(board, left, top, false);
      movingPoint.x = event.x;
      movingPoint.y = event.y;
    }
    pointerMove(event);
  };
  board.pointerUp = (event) => {
    if (isHandMoving) {
      return;
    }
    pointerUp(event);
  };
  board.globalPointerUp = (event) => {
    if (movingPoint) {
      movingPoint = null;
    }
    isHandMoving = false;
    PlaitBoard.getBoardContainer(board).classList.remove("viewport-moving");
    hasWheelPressed = false;
    globalPointerUp(event);
  };
  board.keyDown = (event) => {
    if (event.code === ShortcutKey) {
      if (!board.options.readonly && !PlaitBoard.isPointer(board, PlaitPointerType.hand)) {
        beingPressedShortcutKey = true;
        setSelectionOptions(board, { isDisabledSelection: true });
        PlaitBoard.getBoardContainer(board).classList.add("viewport-moving");
      }
      event.preventDefault();
    }
    keyDown(event);
  };
  board.keyUp = (event) => {
    if (!board.options.readonly && event.code === ShortcutKey) {
      beingPressedShortcutKey = false;
      setSelectionOptions(board, { isDisabledSelection: false });
      PlaitBoard.getBoardContainer(board).classList.remove("viewport-moving");
    }
    keyUp(event);
  };
  return board;
}
function withHistory(board) {
  const { apply, keyDown } = board;
  board.history = { undos: [], redos: [] };
  board.redo = () => {
    const { history } = board;
    const { redos } = history;
    if (redos.length > 0) {
      const batch = redos[redos.length - 1];
      PlaitHistoryBoard.withoutSaving(board, () => {
        for (const op of batch) {
          board.apply(op);
        }
      });
      history.redos.pop();
      history.undos.push(batch);
    }
  };
  board.undo = () => {
    const { history } = board;
    const { undos } = history;
    if (undos.length > 0) {
      const batch = undos[undos.length - 1];
      PlaitHistoryBoard.withoutSaving(board, () => {
        const inverseOps = batch.map(PlaitOperation.inverse).reverse();
        for (const op of inverseOps) {
          board.apply(op);
        }
      });
      history.redos.push(batch);
      history.undos.pop();
    }
  };
  board.apply = (op) => {
    const { operations, history } = board;
    const { undos } = history;
    const lastBatch = undos[undos.length - 1];
    const lastOp = lastBatch && lastBatch[lastBatch.length - 1];
    let save = PlaitHistoryBoard.isSaving(board);
    let merge3 = PlaitHistoryBoard.isMerging(board);
    if (save == null) {
      save = shouldSave(op, lastOp);
    }
    if (save) {
      if (!merge3) {
        if (lastBatch == null) {
          merge3 = false;
        } else if (operations.length !== 0) {
          merge3 = true;
        } else {
          merge3 = shouldMerge(op, lastOp);
        }
      }
      if (PlaitHistoryBoard.isSplittingOnce(board)) {
        merge3 = false;
        PlaitHistoryBoard.setSplittingOnce(board, void 0);
      }
      if (lastBatch && merge3) {
        lastBatch.push(op);
      } else {
        const batch = [op];
        undos.push(batch);
      }
      while (undos.length > 100) {
        undos.shift();
      }
      if (shouldClear(op)) {
        history.redos = [];
      }
    }
    apply(op);
  };
  board.keyDown = (event) => {
    if ((0, import_is_hotkey.isHotkey)("mod+z", event)) {
      board.undo();
      return;
    }
    if ((0, import_is_hotkey.isHotkey)("mod+shift+z", event)) {
      board.redo();
      return;
    }
    keyDown(event);
  };
  return board;
}
var withHotkey = (board) => {
  const { keyDown, keyUp, globalKeyDown } = board;
  board.keyDown = (event) => {
    const options = board.getPluginOptions(PlaitPluginKey.withSelection);
    if (!PlaitBoard.isReadonly(board) && options.isMultipleSelection && (0, import_is_hotkey.isHotkey)("mod+a", event)) {
      event.preventDefault();
      let elements = [];
      depthFirstRecursion(board, (node) => {
        if (PlaitBoard.isBoard(node)) {
          return;
        }
        elements.push(node);
      }, (node) => {
        if (PlaitBoard.isBoard(node) || board.isRecursion(node)) {
          return true;
        } else {
          return false;
        }
      }, true);
      Transforms.addSelectionWithTemporaryElements(board, elements);
      return;
    }
    if (!PlaitBoard.isReadonly(board)) {
      if ((0, import_is_hotkey.isKeyHotkey)("mod+]", event)) {
        event.preventDefault();
        Transforms.moveUp(board);
        return;
      }
      if ((0, import_is_hotkey.isKeyHotkey)("mod+[", event)) {
        event.preventDefault();
        Transforms.moveDown(board);
        return;
      }
      if ((0, import_is_hotkey.isKeyHotkey)("mod+option+‘", event)) {
        event.preventDefault();
        Transforms.moveToTop(board);
        return;
      }
      if ((0, import_is_hotkey.isKeyHotkey)("mod+option+“", event)) {
        event.preventDefault();
        Transforms.moveToBottom(board);
        return;
      }
    }
    const selectedElements = getSelectedElements(board);
    if (!PlaitBoard.isReadonly(board) && selectedElements.length > 0) {
      if ((0, import_is_hotkey.isKeyHotkey)("mod+d", event)) {
        event.preventDefault();
        duplicateElements(board);
        return;
      }
    }
    if (!PlaitBoard.isReadonly(board) && selectedElements.length > 0 && (hotkeys.isDeleteBackward(event) || hotkeys.isDeleteForward(event))) {
      event.preventDefault();
      deleteFragment(board);
    }
    keyDown(event);
  };
  board.keyUp = (event) => {
    keyUp(event);
  };
  board.globalKeyDown = (event) => {
    if (PlaitBoard.getMovingPointInBoard(board) || PlaitBoard.isMovingPointInBoard(board)) {
      if ((0, import_is_hotkey.isHotkey)(["mod+=", "mod++"], { byKey: true })(event)) {
        event.preventDefault();
        BoardTransforms.updateZoom(board, board.viewport.zoom + 0.1);
        return;
      }
      if ((0, import_is_hotkey.isHotkey)(["mod+shift+=", "mod+shift++"], { byKey: true })(event)) {
        event.preventDefault();
        BoardTransforms.fitViewport(board);
        return;
      }
      if ((0, import_is_hotkey.isHotkey)(["mod+-", "mod+shift+-"])(event)) {
        event.preventDefault();
        BoardTransforms.updateZoom(board, board.viewport.zoom - 0.1);
        return;
      }
      if ((0, import_is_hotkey.isHotkey)(["mod+0", "mod+shift+0"], { byKey: true })(event)) {
        event.preventDefault();
        BoardTransforms.updateZoom(board, 1);
        return;
      }
    }
    globalKeyDown(event);
  };
  return board;
};
function getSnapMovingRef(board, activeRectangle, activeElements) {
  const snapRectangles = getSnapRectangles(board, activeElements);
  const snapG = createG();
  let snapDelta = getPointLineDelta(activeRectangle, snapRectangles);
  const pointLinesG = drawMovingPointSnapLines(board, snapDelta, activeRectangle, snapRectangles);
  snapG.append(pointLinesG);
  const result = getGapSnapLinesAndDelta(board, snapDelta, activeRectangle, snapRectangles);
  snapDelta = result.snapDelta;
  snapG.append(result.snapG);
  return { ...snapDelta, snapG };
}
function getPointLineDeltas(activeRectangle, snapRectangles, isHorizontal) {
  const axis = getTripleAxis(activeRectangle, isHorizontal);
  const deltaStart = getMinPointDelta(snapRectangles, axis[0], isHorizontal);
  const deltaMiddle = getMinPointDelta(snapRectangles, axis[1], isHorizontal);
  const deltaEnd = getMinPointDelta(snapRectangles, axis[2], isHorizontal);
  return [deltaStart, deltaMiddle, deltaEnd];
}
function getPointLineDelta(activeRectangle, snapRectangles) {
  let snapDelta = {
    deltaX: 0,
    deltaY: 0
  };
  function getDelta(isHorizontal) {
    let delta = 0;
    const deltas = getPointLineDeltas(activeRectangle, snapRectangles, isHorizontal);
    for (let i = 0; i < deltas.length; i++) {
      if (Math.abs(deltas[i]) < SNAP_TOLERANCE) {
        delta = deltas[i];
        break;
      }
    }
    return delta;
  }
  snapDelta.deltaX = getDelta(true);
  snapDelta.deltaY = getDelta(false);
  return snapDelta;
}
function updateActiveRectangle(snapDelta, activeRectangle) {
  const { deltaX, deltaY } = snapDelta;
  const { x, y, width, height } = activeRectangle;
  return {
    x: x + deltaX,
    y: y + deltaY,
    width,
    height
  };
}
function drawMovingPointSnapLines(board, snapDelta, activeRectangle, snapRectangles) {
  const newActiveRectangle = updateActiveRectangle(snapDelta, activeRectangle);
  return drawPointSnapLines(board, newActiveRectangle, snapRectangles, true, true, true);
}
function getGapSnapLinesAndDelta(board, snapDelta, activeRectangle, snapRectangles) {
  let deltaX = snapDelta.deltaX;
  let deltaY = snapDelta.deltaY;
  const gapHorizontalResult = getGapLinesAndDelta(activeRectangle, snapRectangles, true);
  const gapVerticalResult = getGapLinesAndDelta(activeRectangle, snapRectangles, false);
  const gapSnapLines = [...gapHorizontalResult.lines, ...gapVerticalResult.lines];
  if (gapHorizontalResult.delta) {
    deltaX = gapHorizontalResult.delta;
  }
  if (gapVerticalResult.delta) {
    deltaY = gapVerticalResult.delta;
  }
  return {
    snapDelta: { deltaX, deltaY },
    snapG: drawSolidLines(board, gapSnapLines)
  };
}
function getGapLinesAndDelta(activeRectangle, snapRectangles, isHorizontal) {
  var _a, _b;
  let lines = [];
  let delta = 0;
  let rectangles = [];
  const axis = isHorizontal ? "x" : "y";
  const side = isHorizontal ? "width" : "height";
  const activeRectangleCenter = activeRectangle[axis] + activeRectangle[side] / 2;
  snapRectangles.forEach((rec) => {
    const isCross = isHorizontal ? isHorizontalCross(rec, activeRectangle) : isVerticalCross(rec, activeRectangle);
    if (isCross && !RectangleClient.isHit(rec, activeRectangle)) {
      rectangles.push(rec);
    }
  });
  rectangles = [...rectangles, activeRectangle].sort((a, b) => a[axis] - b[axis]);
  const refArray = [];
  let gapDistance = 0;
  let beforeIndex = void 0;
  let afterIndex = void 0;
  for (let i = 0; i < rectangles.length; i++) {
    for (let j = i + 1; j < rectangles.length; j++) {
      const before = rectangles[i];
      const after = rectangles[j];
      const distance = after[axis] - (before[axis] + before[side]);
      let dif = Infinity;
      if ((_a = refArray[i]) == null ? void 0 : _a.after) {
        refArray[i].after.push({ distance, index: j });
      } else {
        refArray[i] = { ...refArray[i], after: [{ distance, index: j }] };
      }
      if ((_b = refArray[j]) == null ? void 0 : _b.before) {
        refArray[j].before.push({ distance, index: i });
      } else {
        refArray[j] = { ...refArray[j], before: [{ distance, index: i }] };
      }
      let _center = (before[axis] + before[side] + after[axis]) / 2;
      dif = Math.abs(_center - activeRectangleCenter);
      if (dif < SNAP_TOLERANCE) {
        gapDistance = (after[axis] - (before[axis] + before[side]) - activeRectangle[side]) / 2;
        delta = _center - activeRectangleCenter;
        beforeIndex = i;
        afterIndex = j;
      }
      const distanceRight = after[axis] - (before[axis] + before[side]);
      _center = after[axis] + after[side] + distanceRight + activeRectangle[side] / 2;
      dif = Math.abs(_center - activeRectangleCenter);
      if ((!gapDistance || gapDistance !== distanceRight) && dif < SNAP_TOLERANCE) {
        gapDistance = distanceRight;
        beforeIndex = j;
        delta = _center - activeRectangleCenter;
      }
      const distanceBefore = after[axis] - (before[axis] + before[side]);
      _center = before[axis] - distanceBefore - activeRectangle[side] / 2;
      dif = Math.abs(_center - activeRectangleCenter);
      if (!gapDistance && dif < SNAP_TOLERANCE) {
        gapDistance = distanceBefore;
        afterIndex = i;
        delta = _center - activeRectangleCenter;
      }
    }
  }
  const activeIndex = rectangles.indexOf(activeRectangle);
  let beforeIndexes = [];
  let afterIndexes = [];
  if (beforeIndex !== void 0) {
    beforeIndexes.push(beforeIndex);
    findRectangle(gapDistance, refArray[beforeIndex], "before", beforeIndexes);
  }
  if (afterIndex !== void 0) {
    afterIndexes.push(afterIndex);
    findRectangle(gapDistance, refArray[afterIndex], "after", afterIndexes);
  }
  if (beforeIndexes.length || afterIndexes.length) {
    const indexArr = [...beforeIndexes.reverse(), activeIndex, ...afterIndexes];
    activeRectangle[axis] += delta;
    for (let i = 1; i < indexArr.length; i++) {
      lines.push(getLinePoints(rectangles[indexArr[i - 1]], rectangles[indexArr[i]]));
    }
  }
  function findRectangle(distance, ref, direction, rectangleIndexes) {
    const arr = ref[direction];
    const index = refArray.indexOf(ref);
    if (index === 0 && direction === "before" || index === refArray.length - 1 && direction === "after")
      return;
    for (let i = 0; i < arr.length; i++) {
      if (Math.abs(arr[i].distance - distance) < 0.1) {
        rectangleIndexes.push(arr[i].index);
        findRectangle(distance, refArray[arr[i].index], direction, rectangleIndexes);
        return;
      }
    }
  }
  function getLinePoints(beforeRectangle, afterRectangle) {
    const oppositeAxis = axis === "x" ? "y" : "x";
    const oppositeSide = side === "width" ? "height" : "width";
    const snap = [
      beforeRectangle[oppositeAxis],
      beforeRectangle[oppositeAxis] + beforeRectangle[oppositeSide],
      afterRectangle[oppositeAxis],
      afterRectangle[oppositeAxis] + afterRectangle[oppositeSide]
    ];
    const sortArr = snap.sort((a, b) => a - b);
    const average = (sortArr[1] + sortArr[2]) / 2;
    const offset = 3;
    return isHorizontal ? [
      [beforeRectangle.x + beforeRectangle.width + offset, average],
      [afterRectangle.x - offset, average]
    ] : [
      [average, beforeRectangle.y + beforeRectangle.height + offset],
      [average, afterRectangle.y - offset]
    ];
  }
  return { delta, lines };
}
function isHorizontalCross(rectangle, other) {
  return !(rectangle.y + rectangle.height < other.y || rectangle.y > other.y + other.height);
}
function isVerticalCross(rectangle, other) {
  return !(rectangle.x + rectangle.width < other.x || rectangle.x > other.x + other.width);
}
function withMoving(board) {
  const { pointerDown, pointerMove, globalPointerUp, globalPointerMove, globalKeyDown, keyUp } = board;
  let offsetX = 0;
  let offsetY = 0;
  let isPreventDefault = false;
  let startPoint;
  let activeElements = [];
  let snapG = null;
  let activeElementsRectangle = null;
  let selectedTargetElements = null;
  let hitTargetElement = void 0;
  let isHitSelectedTarget = void 0;
  let pendingNodesG = null;
  board.globalKeyDown = (event) => {
    if (!PlaitBoard.isReadonly(board)) {
      if ((0, import_is_hotkey.isKeyHotkey)("option", event)) {
        event.preventDefault();
        if (startPoint && activeElements.length && !PlaitBoard.hasBeenTextEditing(board)) {
          pendingNodesG = drawPendingNodesG(board, activeElements, offsetX, offsetY);
          pendingNodesG && PlaitBoard.getElementTopHost(board).append(pendingNodesG);
        }
      }
    }
    globalKeyDown(event);
  };
  board.keyUp = (event) => {
    if (!PlaitBoard.isReadonly(board)) {
      if (pendingNodesG && startPoint && activeElements.length && !PlaitBoard.hasBeenTextEditing(board)) {
        event.preventDefault();
        const currentElements = updatePoints(board, activeElements, offsetX, offsetY);
        PlaitBoard.getBoardContainer(board).classList.add("element-moving");
        cacheMovingElements(board, currentElements);
      }
    }
    pendingNodesG == null ? void 0 : pendingNodesG.remove();
    keyUp(event);
  };
  board.pointerDown = (event) => {
    if (PlaitBoard.isReadonly(board) || !PlaitBoard.isPointer(board, PlaitPointerType.selection) || !isMainPointer(event)) {
      pointerDown(event);
      return;
    }
    const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
    hitTargetElement = getHitElementByPoint(board, point, (el) => board.isMovable(el));
    selectedTargetElements = getSelectedTargetElements(board);
    isHitSelectedTarget = hitTargetElement && selectedTargetElements.includes(hitTargetElement);
    if (hitTargetElement && isHitSelectedTarget) {
      startPoint = point;
      activeElements = selectedTargetElements;
      activeElementsRectangle = getRectangleByElements(board, activeElements, true);
    } else if (hitTargetElement) {
      startPoint = point;
      const relatedElements = board.getRelatedFragment([], [hitTargetElement]);
      activeElements = [...getElementsInGroupByElement(board, hitTargetElement), ...relatedElements];
      activeElementsRectangle = getRectangleByElements(board, activeElements, true);
    } else {
      const targetRectangle = selectedTargetElements.length > 0 && getRectangleByElements(board, selectedTargetElements, false);
      const isHitInTargetRectangle = targetRectangle && RectangleClient.isPointInRectangle(targetRectangle, point);
      if (isHitInTargetRectangle) {
        startPoint = point;
        activeElements = selectedTargetElements;
        activeElementsRectangle = targetRectangle;
      }
    }
    pointerDown(event);
  };
  board.pointerMove = (event) => {
    if (startPoint && activeElements.length && !PlaitBoard.hasBeenTextEditing(board)) {
      if (!isPreventDefault) {
        isPreventDefault = true;
      }
      snapG == null ? void 0 : snapG.remove();
      pendingNodesG == null ? void 0 : pendingNodesG.remove();
      const endPoint = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
      offsetX = endPoint[0] - startPoint[0];
      offsetY = endPoint[1] - startPoint[1];
      const distance = distanceBetweenPointAndPoint(...endPoint, ...startPoint);
      if (distance > PRESS_AND_MOVE_BUFFER || getMovingElements(board).length > 0) {
        if (hitTargetElement && !isHitSelectedTarget && selectedTargetElements && selectedTargetElements.length > 0) {
          addSelectionWithTemporaryElements(board, []);
          hitTargetElement = void 0;
          selectedTargetElements = null;
          isHitSelectedTarget = void 0;
        }
        throttleRAF(board, "with-moving", () => {
          if (!activeElementsRectangle) {
            return;
          }
          const newRectangle = {
            ...activeElementsRectangle,
            x: activeElementsRectangle.x + offsetX,
            y: activeElementsRectangle.y + offsetY
          };
          const activeRectangle = getRectangleByAngle(newRectangle, getSelectionAngle(activeElements));
          const ref = getSnapMovingRef(board, activeRectangle, activeElements);
          offsetX += ref.deltaX;
          offsetY += ref.deltaY;
          snapG = ref.snapG;
          snapG.classList.add(ACTIVE_MOVING_CLASS_NAME);
          PlaitBoard.getElementTopHost(board).append(snapG);
          if (event.altKey) {
            pendingNodesG = drawPendingNodesG(board, activeElements, offsetX, offsetY);
            pendingNodesG && PlaitBoard.getElementTopHost(board).append(pendingNodesG);
          } else {
            const currentElements = updatePoints(board, activeElements, offsetX, offsetY);
            PlaitBoard.getBoardContainer(board).classList.add("element-moving");
            cacheMovingElements(board, currentElements);
          }
        });
      }
    }
    if (isPreventDefault) {
      event.preventDefault();
    }
    pointerMove(event);
  };
  board.globalPointerMove = (event) => {
    if (startPoint) {
      const inPlaitBoardElement = isInPlaitBoard(board, event.x, event.y);
      if (!inPlaitBoardElement) {
        cancelMove(board);
      }
    }
    globalPointerMove(event);
  };
  board.globalPointerUp = (event) => {
    if (event.altKey && activeElements.length) {
      const validElements = getValidElements(board, activeElements);
      const rectangle = getRectangleByElements(board, validElements, false);
      duplicateElements(board, validElements, [rectangle.x + offsetX, rectangle.y + offsetY]);
    }
    isPreventDefault = false;
    hitTargetElement = void 0;
    selectedTargetElements = null;
    isHitSelectedTarget = void 0;
    if (startPoint) {
      cancelMove(board);
    }
    globalPointerUp(event);
  };
  function cancelMove(board2) {
    snapG == null ? void 0 : snapG.remove();
    pendingNodesG == null ? void 0 : pendingNodesG.remove();
    startPoint = null;
    activeElementsRectangle = null;
    offsetX = 0;
    offsetY = 0;
    activeElements = [];
    if (isMovingElements(board2)) {
      removeMovingElements(board2);
    }
    MERGING.set(board2, false);
    PlaitBoard.getBoardContainer(board2).classList.remove("element-moving");
  }
  return withArrowMoving(board);
}
function withArrowMoving(board) {
  const { keyDown, keyUp } = board;
  board.keyDown = (event) => {
    const selectedElements = getSelectedElements(board);
    if (!PlaitBoard.isReadonly(board) && selectedElements.length > 0 && (hotkeys.isArrow(event) || hotkeys.isExtendArrow(event))) {
      event.preventDefault();
      const isShift = event.shiftKey ? true : false;
      const offset = [0, 0];
      const buffer2 = isShift ? 10 : 1;
      switch (true) {
        case (hotkeys.isMoveUp(event) || hotkeys.isExtendUp(event)): {
          offset[1] = -buffer2;
          break;
        }
        case (hotkeys.isMoveDown(event) || hotkeys.isExtendDown(event)): {
          offset[1] = buffer2;
          break;
        }
        case (hotkeys.isMoveBackward(event) || hotkeys.isExtendBackward(event)): {
          offset[0] = -buffer2;
          break;
        }
        case (hotkeys.isMoveForward(event) || hotkeys.isExtendForward(event)): {
          offset[0] = buffer2;
          break;
        }
      }
      const targetElements = getSelectedTargetElements(board);
      throttleRAF(board, "with-arrow-moving", () => {
        updatePoints(board, targetElements, offset[0], offset[1]);
      });
    }
    keyDown(event);
  };
  board.keyUp = (event) => {
    MERGING.set(board, false);
    keyUp(event);
  };
  return board;
}
function getSelectedTargetElements(board) {
  const selectedElements = getSelectedElements(board);
  const movableElements = board.children.filter((item) => board.isMovable(item));
  const targetElements = selectedElements.filter((element) => {
    return movableElements.includes(element);
  });
  const relatedElements = board.getRelatedFragment([]);
  targetElements.push(...relatedElements);
  return targetElements;
}
function getValidElements(board, activeElements) {
  const validElements = [...activeElements].filter((element) => !PlaitGroupElement.isGroup(element) && PlaitElement.isRootElement(element));
  return validElements;
}
function updatePoints(board, activeElements, offsetX, offsetY) {
  const validElements = getValidElements(board, activeElements);
  const currentElements = validElements.map((element) => {
    const points = element.points || [];
    const newPoints = points.map((p) => [p[0] + offsetX, p[1] + offsetY]);
    const index = NODE_TO_INDEX.get(element);
    Transforms.setNode(board, {
      points: newPoints
    }, [index]);
    MERGING.set(board, true);
    return PlaitNode.get(board, [index]);
  });
  return currentElements;
}
function drawPendingNodesG(board, activeElements, offsetX, offsetY) {
  let pendingNodesG = null;
  const elements = [];
  const validElements = getValidElements(board, activeElements);
  validElements.forEach((element) => {
    depthFirstRecursion(element, (node) => {
      elements.push(node);
    }, () => true);
  });
  elements.forEach((item) => {
    let rectangle = board.getRectangle(item);
    if (rectangle) {
      rectangle = {
        x: rectangle.x + offsetX,
        y: rectangle.y + offsetY,
        width: rectangle.width,
        height: rectangle.height
      };
      const movingG = drawRectangle(board, rectangle, {
        stroke: SELECTION_BORDER_COLOR,
        strokeWidth: 1,
        fill: SELECTION_FILL_COLOR,
        fillStyle: "solid"
      });
      if (!pendingNodesG) {
        pendingNodesG = createG();
        pendingNodesG.classList.add(ACTIVE_MOVING_CLASS_NAME);
      }
      const angle = getAngleByElement(item);
      angle && setAngleForG(movingG, RectangleClient.getCenterPoint(rectangle), angle);
      pendingNodesG.append(movingG);
    }
  });
  return pendingNodesG;
}
var withOptions = (board) => {
  const pluginOptions = /* @__PURE__ */ new Map();
  const newBoard = board;
  newBoard.getPluginOptions = (key) => {
    return pluginOptions.get(key);
  };
  newBoard.setPluginOptions = (key, options) => {
    const oldOptions = newBoard.getPluginOptions(key) || {};
    pluginOptions.set(key, { ...oldOptions, ...options });
  };
  return newBoard;
};
function withRelatedFragment(board) {
  const { buildFragment } = board;
  board.buildFragment = (clipboardContext, rectangle, operationType, originData) => {
    let relatedFragment = board.getRelatedFragment(originData || []);
    if (relatedFragment) {
      if (originData == null ? void 0 : originData.length) {
        relatedFragment = relatedFragment.filter((item) => !originData.map((element) => element.id).includes(item.id));
      }
      if (relatedFragment.length) {
        const addition = {
          text: "",
          type: WritableClipboardType.elements,
          elements: relatedFragment
        };
        clipboardContext = addOrCreateClipboardContext(clipboardContext, addition);
      }
    }
    return buildFragment(clipboardContext, rectangle, operationType, originData);
  };
  return board;
}
function withSelection(board) {
  const { pointerDown, pointerUp, pointerMove, globalPointerUp, onChange, afterChange, drawSelectionRectangle } = board;
  let screenStart = null;
  let screenEnd = null;
  let selectionMovingG;
  let selectionRectangleG;
  let isShift = false;
  let timerId = null;
  let pointerDownEvent = null;
  board.pointerDown = (event) => {
    if (!isShift && event.shiftKey) {
      isShift = true;
    }
    if (isShift && !event.shiftKey) {
      isShift = false;
    }
    const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
    const isHitTarget = isHitElement(board, point);
    const options = getSelectionOptions(board);
    if (PlaitBoard.isPointer(board, PlaitPointerType.selection) && isMainPointer(event) && !isHitTarget && options.isMultipleSelection && !options.isDisabledSelection) {
      if (isMobileDeviceEvent(event)) {
        timerId = setTimeout(() => {
          screenStart = [event.x, event.y];
          timerId = null;
        }, 120);
      } else {
        screenStart = [event.x, event.y];
      }
    }
    pointerDownEvent = event;
    pointerDown(event);
  };
  board.pointerMove = (event) => {
    if (timerId && pointerDownEvent && distanceBetweenPointAndPoint(pointerDownEvent.x, pointerDownEvent.y, event.x, event.y) > DRAG_SELECTION_PRESS_AND_MOVE_BUFFER) {
      clearTimeout(timerId);
      timerId = null;
    }
    if (PlaitBoard.isPointer(board, PlaitPointerType.selection) && screenStart) {
      event.preventDefault();
      screenEnd = [event.x, event.y];
      const rectangle = RectangleClient.getRectangleByPoints([
        toActivePoint(board, ...screenStart),
        toActivePoint(board, ...screenEnd)
      ]);
      selectionMovingG == null ? void 0 : selectionMovingG.remove();
      throttleRAF(board, "with-selection", () => {
        if (screenStart && screenEnd) {
          Transforms.setSelection(board, {
            anchor: toViewBoxPoint(board, toHostPoint(board, screenStart[0], screenStart[1])),
            focus: toViewBoxPoint(board, toHostPoint(board, screenEnd[0], screenEnd[1]))
          });
        }
      });
      setSelectionMoving(board);
      selectionMovingG = drawRectangle(board, rectangle, {
        stroke: SELECTION_BORDER_COLOR,
        strokeWidth: 1,
        fill: SELECTION_FILL_COLOR,
        fillStyle: "solid"
      });
      PlaitBoard.getActiveHost(board).append(selectionMovingG);
    }
    pointerMove(event);
  };
  board.pointerUp = (event) => {
    const isSetSelectionPointer = PlaitBoard.isPointer(board, PlaitPointerType.selection) || PlaitBoard.isPointer(board, PlaitPointerType.hand);
    const isSkip = !isMainPointer(event) || isDragging(board) || !isSetSelectionPointer;
    if (isSkip) {
      pointerUp(event);
      return;
    }
    const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
    const selection = { anchor: point, focus: point };
    Transforms.setSelection(board, selection);
    pointerUp(event);
  };
  board.globalPointerUp = (event) => {
    if (screenStart && screenEnd) {
      selectionMovingG == null ? void 0 : selectionMovingG.remove();
      clearSelectionMoving(board);
      Transforms.setSelection(board, {
        anchor: toViewBoxPoint(board, toHostPoint(board, screenStart[0], screenStart[1])),
        focus: toViewBoxPoint(board, toHostPoint(board, screenEnd[0], screenEnd[1]))
      });
    }
    const options = getSelectionOptions(board);
    if (PlaitBoard.isFocus(board) && !options.isPreventClearSelection) {
      const isInBoard = event.target instanceof Node && PlaitBoard.getBoardContainer(board).contains(event.target);
      const isInDocument = event.target instanceof Node && document.contains(event.target);
      const isAttachedElement = event.target instanceof Element && event.target.closest(`.${ATTACHED_ELEMENT_CLASS_NAME}`);
      if (!isInBoard && !screenStart && !isAttachedElement && isInDocument) {
        Transforms.setSelection(board, null);
      }
    }
    screenStart = null;
    screenEnd = null;
    if (timerId) {
      clearTimeout(timerId);
      timerId = null;
    }
    pointerDownEvent = null;
    globalPointerUp(event);
  };
  board.onChange = () => {
    const options = getSelectionOptions(board);
    if (options.isDisabledSelection) {
      clearSelectedElement(board);
    }
    board.operations.forEach((op) => {
      if (op.type === "remove_node") {
        removeSelectedElement(board, op.node, true);
      }
    });
    if (isHandleSelection(board) && hasSetSelectionOperation(board)) {
      try {
        if (!isShift) {
          selectionRectangleG == null ? void 0 : selectionRectangleG.remove();
        }
        const temporaryElements = getTemporaryElements(board);
        if (temporaryElements) {
          cacheSelectedElements(board, [...temporaryElements]);
        } else {
          let elements = getHitElementsBySelection(board);
          if (!options.isMultipleSelection && elements.length > 1) {
            elements = [elements[0]];
          }
          const isHitElementWithGroup = elements.some((item) => item.groupId);
          const selectedElements = getSelectedElements(board);
          if (isHitElementWithGroup) {
            setSelectedElementsWithGroup(board, elements, isShift);
          } else {
            if (board.selection && Selection.isCollapsed(board.selection)) {
              const element = board.getOneHitElement(elements);
              if (element) {
                elements = [element];
              }
            }
            if (isShift) {
              const newElements2 = [...selectedElements];
              if (board.selection && Selection.isCollapsed(board.selection)) {
                elements.forEach((element) => {
                  if (newElements2.includes(element)) {
                    newElements2.splice(newElements2.indexOf(element), 1);
                  } else {
                    newElements2.push(element);
                  }
                });
                cacheSelectedElements(board, newElements2);
              } else {
                elements.forEach((element) => {
                  if (!newElements2.includes(element)) {
                    newElements2.push(element);
                  }
                });
                cacheSelectedElements(board, [...newElements2]);
              }
            } else {
              cacheSelectedElements(board, [...elements]);
            }
          }
        }
        const newElements = getSelectedElements(board);
        deleteTemporaryElements(board);
        if (!isSelectionMoving(board)) {
          selectionRectangleG == null ? void 0 : selectionRectangleG.remove();
          if (newElements.length > 1) {
            selectionRectangleG = board.drawSelectionRectangle();
            PlaitBoard.getActiveHost(board).append(selectionRectangleG);
          }
        }
      } catch (error) {
        console.error(error);
      }
    }
    onChange();
  };
  board.afterChange = () => {
    if (isHandleSelection(board) && !hasSetSelectionOperation(board)) {
      try {
        const currentSelectedElements = getSelectedElements(board);
        if (currentSelectedElements.length && currentSelectedElements.length > 1) {
          selectionRectangleG == null ? void 0 : selectionRectangleG.remove();
          selectionRectangleG = board.drawSelectionRectangle();
          PlaitBoard.getActiveHost(board).append(selectionRectangleG);
        } else {
          selectionRectangleG == null ? void 0 : selectionRectangleG.remove();
        }
      } catch (error) {
        console.error(error);
      }
    }
    afterChange();
  };
  setSelectionOptions(board, {
    isMultipleSelection: true,
    isDisabledSelection: false,
    isPreventClearSelection: false
  });
  return board;
}
var withI18n = (board) => {
  const newBoard = board;
  newBoard.getI18nValue = (key) => {
    console.warn(`I18n key "${key}" is not found.`);
    return null;
  };
  return newBoard;
};
var getI18nValue = (board, key, defaultValue = "") => {
  const i18nBoard = board;
  return i18nBoard.getI18nValue(key) || defaultValue;
};
var createTestingBoard = (plugins, children, options = { readonly: false, hideScrollbar: true, disabledScrollOnNonFocus: false }) => {
  let board = createBoard(children, options);
  plugins.forEach((plugin) => {
    board = plugin(board);
  });
  KEY_TO_ELEMENT_MAP.set(board, /* @__PURE__ */ new Map());
  return board;
};
var fakeNodeWeakMap = (object) => {
  const children = object.children || [];
  children.forEach((value, index) => {
    NODE_TO_PARENT.set(value, object);
    NODE_TO_INDEX.set(value, index);
    fakeNodeWeakMap(value);
  });
};
var clearNodeWeakMap = (object) => {
  const children = object.children || [];
  children.forEach((value) => {
    NODE_TO_PARENT.delete(value);
    NODE_TO_INDEX.delete(value);
    clearNodeWeakMap(value);
  });
};
var uniqueIds = 0;
function createMouseEvent(type, clientX = 0, clientY = 0, offsetX = 1, offsetY = 1, button = 0, modifiers = {}) {
  const screenX = clientX;
  const screenY = clientY;
  const event = new MouseEvent(type, {
    bubbles: true,
    cancelable: true,
    composed: true,
    // Required for shadow DOM events.
    view: window,
    detail: 0,
    relatedTarget: null,
    screenX,
    screenY,
    clientX,
    clientY,
    ctrlKey: modifiers.control,
    altKey: modifiers.alt,
    shiftKey: modifiers.shift,
    metaKey: modifiers.meta,
    button,
    buttons: 1
  });
  if (offsetX != null) {
    defineReadonlyEventProperty(event, "offsetX", offsetX);
  }
  if (offsetY != null) {
    defineReadonlyEventProperty(event, "offsetY", offsetY);
  }
  return event;
}
function createPointerEvent(type, clientX = 0, clientY = 0, offsetX, offsetY, options = { isPrimary: true }) {
  const event = new PointerEvent(type, {
    bubbles: true,
    cancelable: true,
    composed: true,
    // Required for shadow DOM events.
    view: window,
    clientX,
    clientY,
    ...options
  });
  if (offsetX != null) {
    defineReadonlyEventProperty(event, "offsetX", offsetX);
  }
  if (offsetY != null) {
    defineReadonlyEventProperty(event, "offsetY", offsetY);
  }
  return event;
}
function createTouchEvent(type, pageX = 0, pageY = 0, clientX = 0, clientY = 0) {
  const event = document.createEvent("UIEvent");
  const touchDetails = { pageX, pageY, clientX, clientY, identifier: uniqueIds++ };
  event.initUIEvent(type, true, true, window, 0);
  defineReadonlyEventProperty(event, "touches", [touchDetails]);
  defineReadonlyEventProperty(event, "targetTouches", [touchDetails]);
  defineReadonlyEventProperty(event, "changedTouches", [touchDetails]);
  return event;
}
function createKeyboardEvent(type, keyCode = 0, key = "", modifiers = {}) {
  return new KeyboardEvent(type, {
    bubbles: true,
    cancelable: true,
    composed: true,
    // Required for shadow DOM events.
    view: window,
    keyCode,
    key,
    shiftKey: modifiers.shift,
    metaKey: modifiers.meta,
    altKey: modifiers.alt,
    ctrlKey: modifiers.control
  });
}
function createFakeEvent(type, bubbles = false, cancelable = true, composed = true) {
  return new Event(type, { bubbles, cancelable, composed });
}
function defineReadonlyEventProperty(event, propertyName, value) {
  Object.defineProperty(event, propertyName, { get: () => value, configurable: true });
}
function createModModifierKeys() {
  const modifiers = IS_MAC ? { meta: true } : { control: true };
  return modifiers;
}

export {
  fromEvent,
  timer,
  MAC_ENTER,
  BACKSPACE,
  TAB,
  NUM_CENTER,
  ENTER,
  SHIFT,
  CONTROL,
  ALT,
  PAUSE,
  CAPS_LOCK,
  ESCAPE,
  SPACE,
  PAGE_UP,
  PAGE_DOWN,
  END,
  HOME,
  LEFT_ARROW,
  UP_ARROW,
  RIGHT_ARROW,
  DOWN_ARROW,
  PLUS_SIGN,
  PRINT_SCREEN,
  INSERT,
  DELETE,
  ZERO,
  ONE,
  TWO,
  THREE,
  FOUR,
  FIVE,
  SIX,
  SEVEN,
  EIGHT,
  NINE,
  FF_SEMICOLON,
  FF_EQUALS,
  QUESTION_MARK,
  AT_SIGN,
  A,
  B,
  C,
  D,
  E,
  F,
  G,
  H,
  I,
  J,
  K,
  L,
  M,
  N,
  O,
  P,
  Q,
  R,
  S,
  T,
  U,
  V,
  W,
  X,
  Y,
  Z,
  META,
  MAC_WK_CMD_LEFT,
  MAC_WK_CMD_RIGHT,
  CONTEXT_MENU,
  NUMPAD_ZERO,
  NUMPAD_ONE,
  NUMPAD_TWO,
  NUMPAD_THREE,
  NUMPAD_FOUR,
  NUMPAD_FIVE,
  NUMPAD_SIX,
  NUMPAD_SEVEN,
  NUMPAD_EIGHT,
  NUMPAD_NINE,
  NUMPAD_MULTIPLY,
  NUMPAD_PLUS,
  NUMPAD_MINUS,
  NUMPAD_PERIOD,
  NUMPAD_DIVIDE,
  F1,
  F2,
  F3,
  F4,
  F5,
  F6,
  F7,
  F8,
  F9,
  F10,
  F11,
  F12,
  NUM_LOCK,
  SCROLL_LOCK,
  FIRST_MEDIA,
  FF_MINUS,
  MUTE,
  VOLUME_DOWN,
  VOLUME_UP,
  FF_MUTE,
  FF_VOLUME_DOWN,
  LAST_MEDIA,
  FF_VOLUME_UP,
  SEMICOLON,
  EQUALS,
  COMMA,
  DASH,
  PERIOD,
  SLASH,
  APOSTROPHE,
  TILDE,
  OPEN_SQUARE_BRACKET,
  BACKSLASH,
  CLOSE_SQUARE_BRACKET,
  SINGLE_QUOTE,
  MAC_META,
  ResizeCursorClass,
  CursorClass,
  RESIZE_CURSORS,
  ATTACHED_ELEMENT_CLASS_NAME,
  ACTIVE_STROKE_WIDTH,
  SNAPPING_STROKE_WIDTH,
  SELECTION_RECTANGLE_CLASS_NAME,
  SELECTION_RECTANGLE_BOUNDING_CLASS_NAME,
  ZOOM_STEP,
  MIN_ZOOM,
  MAX_ZOOM,
  HOST_CLASS_NAME,
  ACTIVE_MOVING_CLASS_NAME,
  ROTATE_HANDLE_CLASS_NAME,
  RESIZE_HANDLE_CLASS_NAME,
  SCROLL_BAR_WIDTH,
  MAX_RADIUS,
  POINTER_BUTTON,
  PRESS_AND_MOVE_BUFFER,
  DRAG_SELECTION_PRESS_AND_MOVE_BUFFER,
  HIT_DISTANCE_BUFFER,
  hasBeforeContextChange,
  hasOnContextChanged,
  IS_BOARD_CACHE,
  FLUSHING,
  NODE_TO_INDEX,
  NODE_TO_PARENT,
  KEY_TO_ELEMENT_MAP,
  NODE_TO_G,
  NODE_TO_CONTAINER_G,
  IS_TEXT_EDITABLE,
  BOARD_TO_ON_CHANGE,
  BOARD_TO_AFTER_CHANGE,
  BOARD_TO_ROUGH_SVG,
  BOARD_TO_HOST,
  BOARD_TO_CONTEXT,
  IS_BOARD_ALIVE,
  BOARD_TO_ELEMENT_HOST,
  BOARD_TO_SELECTED_ELEMENT,
  BOARD_TO_MOVING_POINT_IN_BOARD,
  BOARD_TO_MOVING_POINT,
  BOARD_TO_VIEWPORT_ORIGINATION,
  BOARD_TO_IS_SELECTION_MOVING,
  BOARD_TO_TEMPORARY_ELEMENTS,
  BOARD_TO_MOVING_ELEMENT,
  PATH_REFS,
  ELEMENT_TO_REF,
  isNullOrUndefined,
  normalizePoint,
  rgbaToHEX,
  isContextmenu,
  uniqueById,
  findLastIndex,
  findIndex2 as findIndex,
  isIndicesContinuous,
  Viewport,
  Path,
  PlaitNode,
  RectangleClient,
  distanceBetweenPointAndSegment,
  getNearestPointBetweenPointAndSegment,
  distanceBetweenPointAndSegments,
  getNearestPointBetweenPointAndSegments,
  getNearestPointBetweenPointAndDiscreteSegments,
  getNearestPointBetweenPointAndEllipse,
  rotate,
  distanceBetweenPointAndPoint,
  distanceBetweenPointAndRectangle,
  isLineHitLine,
  isLineHitRectangle,
  isLineHitRectangleEdge,
  isSingleLineHitRectangleEdge,
  isPointInPolygon,
  isPointInEllipse,
  isPointInRoundRectangle,
  catmullRomFitting,
  getEllipseTangentSlope,
  getVectorFromPointAndSlope,
  toDomPrecision,
  toFixed,
  ceilToDecimal,
  approximately,
  getCrossingPointsBetweenEllipseAndSegment,
  getPointBetween,
  getEllipseArcCenter,
  getNearestPointBetweenPointAndArc,
  isInPlaitBoard,
  getRealScrollBarWidth,
  NS,
  createG,
  createPath,
  createRect,
  setStrokeLinecap,
  setPathStrokeLinecap,
  createMask,
  createSVG,
  createText,
  isDOMElement,
  isDOMNode,
  hasInputOrTextareaTarget,
  isSecondaryPointer,
  isMainPointer,
  isWheelPointer,
  createForeignObject,
  updateForeignObject,
  updateForeignObjectWidth,
  IS_MAC,
  IS_IOS,
  IS_APPLE,
  IS_FIREFOX,
  IS_SAFARI,
  IS_EDGE_LEGACY,
  IS_CHROME,
  IS_CHROME_LEGACY,
  IS_WINDOWS,
  shouldMerge,
  shouldSave,
  shouldClear,
  PlaitHistoryBoard,
  hotkeys,
  idCreator,
  depthFirstRecursion,
  getIsRecursionFunc,
  SELECTION_BORDER_COLOR,
  SELECTION_FILL_COLOR,
  Selection,
  PlaitElement,
  sortElements,
  DebugGenerator,
  createDebugGenerator,
  isDebug,
  PlaitPluginKey,
  getHitElementsBySelection,
  getHitElementsByPoint,
  getHitElementByPoint,
  getHitSelectedElements,
  cacheSelectedElements,
  getSelectedElements,
  addSelectedElement,
  removeSelectedElement,
  replaceSelectedElement,
  clearSelectedElement,
  isSelectedElement,
  temporaryDisableSelection,
  isHitSelectedRectangle,
  isHitElement,
  drawRoundRectangle,
  drawRectangle,
  arrowPoints,
  drawArrow,
  drawCircle,
  drawLine,
  drawLinearPath,
  drawBezierPath,
  BoardTransforms,
  getViewBox,
  toHostPoint,
  toActiveRectangleFromViewBoxRectangle,
  toActivePointFromViewBoxPoint,
  toActivePoint,
  toScreenPointFromActivePoint,
  toViewBoxPoint,
  toViewBoxPoints,
  toScreenPointFromHostPoint,
  toHostPointFromViewBoxPoint,
  VIEWPORT_PADDING_RATIO,
  getViewportContainerRect,
  getElementHostBBox,
  clampZoomLevel,
  prepareElementBBox,
  calculateViewBox,
  calcNewViewBox,
  getViewBoxCenterPoint,
  setSVGViewBox,
  updateViewportOffset,
  updateViewportContainerScroll,
  updateViewportByScrolling,
  initializeViewportContainer,
  initializeViewBox,
  updateViewBox,
  initializeViewportOffset,
  updateViewportOrigination,
  clearViewportOrigination,
  getViewportOrigination,
  isFromScrolling,
  setIsFromScrolling,
  isFromViewportChange,
  setIsFromViewportChange,
  scrollToRectangle,
  throttleRAF,
  debounce2 as debounce,
  getElementsIndices,
  getHighestIndexOfElement,
  moveElementsToNewPath,
  IS_DRAGGING,
  isDragging,
  setDragging,
  getMovingElements,
  isMovingElements,
  removeMovingElements,
  cacheMovingElements,
  toImage,
  downloadImage,
  WritableClipboardType,
  WritableClipboardOperationType,
  buildPlaitHtml,
  getClipboardFromHtml,
  stripHtml,
  getProbablySupportsClipboardWrite,
  getProbablySupportsClipboardWriteText,
  getProbablySupportsClipboardRead,
  createClipboardContext,
  addClipboardContext,
  addOrCreateClipboardContext,
  replaceAngleBrackets,
  reverseReplaceAngleBrackets,
  setDataTransferClipboard,
  setDataTransferClipboardText,
  getDataTransferClipboard,
  getDataTransferClipboardText,
  getClipboardData,
  setClipboardData,
  isSelectionMoving,
  setSelectionMoving,
  clearSelectionMoving,
  isHandleSelection,
  hasSetSelectionOperation,
  getTemporaryElements,
  getTemporaryRef,
  deleteTemporaryElements,
  drawSelectionRectangleG,
  setSelectedElementsWithGroup,
  cacheSelectedElementsWithGroupOnShift,
  cacheSelectedElementsWithGroup,
  getSelectionOptions,
  setSelectionOptions,
  getElementsInGroup,
  getAllElementsInGroup,
  getRectangleByGroup,
  getGroupByElement,
  getHighestGroup,
  getElementsInGroupByElement,
  isSelectedElementOrGroup,
  isSelectedAllElementsInGroup,
  filterSelectedGroups,
  getSelectedGroups,
  getHighestSelectedGroup,
  getHighestSelectedGroups,
  getSelectedIsolatedElements,
  getSelectedIsolatedElementsCanAddToGroup,
  getHighestSelectedElements,
  createGroupRectangleG,
  createGroup,
  nonGroupInHighestSelectedElements,
  hasSelectedElementsInSameGroup,
  canAddGroup,
  canRemoveGroup,
  getEditingGroup,
  moveElementsToNewPathAfterAddGroup,
  deleteFragment,
  setFragment,
  duplicateElements,
  SNAP_TOLERANCE,
  getSnapRectangles,
  getBarPoint,
  getMinPointDelta,
  getNearestDelta,
  getTripleAxis,
  getNearestPointRectangle,
  isSnapPoint,
  drawPointSnapLines,
  drawDashedLines,
  drawSolidLines,
  getOneMoveOptions,
  getAllMoveOptions,
  canSetZIndex,
  isMobileDeviceEvent,
  isPencilEvent,
  isTouchEvent,
  isMouseEvent,
  CoreTransforms,
  Transforms,
  rotatePoints,
  getSelectionAngle,
  hasSameAngle,
  getRotatedBoundingRectangle,
  getOffsetAfterRotate,
  rotatedDataPoints,
  hasValidAngle,
  isValidAngle,
  rotatePointsByElement,
  rotatePointsByAngle,
  rotateAntiPointsByElement,
  getRectangleByAngle,
  isAxisChangedByAngle,
  degreesToRadians,
  radiansToDegrees,
  rotateElements,
  normalizeAngle,
  getAngleBetweenPoints,
  getAngleByElement,
  setAngleForG,
  getRectangleByElements,
  getBoundingRectangleByElements,
  getBoardRectangle,
  getElementById,
  getElementMap,
  findElements,
  ThemeColorMode,
  DEFAULT_COLOR,
  DefaultThemeColor,
  ColorfulThemeColor,
  SoftThemeColor,
  RetroThemeColor,
  DarkThemeColor,
  StarryThemeColor,
  ThemeColors,
  PlaitBoard,
  PlaitPointerType,
  isSetViewportOperation,
  isSetSelectionOperation,
  isSetThemeOperation,
  inverse,
  PlaitOperation,
  Point,
  SAVING,
  MERGING,
  HISTORY,
  SPLITTING_ONCE,
  Direction,
  isHorizontalDirection,
  isVerticalDirection,
  PlaitGroupElement,
  ListRender,
  mountElementG,
  ElementFlavour,
  PlaitBoardContext,
  createBoard,
  withBoard,
  withHandPointer,
  withHistory,
  withHotkey,
  withMoving,
  withArrowMoving,
  getSelectedTargetElements,
  getValidElements,
  updatePoints,
  drawPendingNodesG,
  withOptions,
  withRelatedFragment,
  withSelection,
  withI18n,
  getI18nValue,
  createTestingBoard,
  fakeNodeWeakMap,
  clearNodeWeakMap,
  createMouseEvent,
  createPointerEvent,
  createTouchEvent,
  createKeyboardEvent,
  createFakeEvent,
  createModModifierKeys
};
/*! Bundled license information:

@plait/core/fesm2022/plait-core.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@plait/core/fesm2022/plait-core.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)
*/
//# sourceMappingURL=chunk-6V4XCDNF.js.map
