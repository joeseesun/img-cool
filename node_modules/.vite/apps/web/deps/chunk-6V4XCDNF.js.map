{
  "version": 3,
  "sources": ["../../../../rxjs/src/internal/util/isFunction.ts", "../../../../rxjs/src/internal/util/createErrorClass.ts", "../../../../rxjs/src/internal/util/UnsubscriptionError.ts", "../../../../rxjs/src/internal/util/arrRemove.ts", "../../../../rxjs/src/internal/Subscription.ts", "../../../../rxjs/src/internal/config.ts", "../../../../rxjs/src/internal/scheduler/timeoutProvider.ts", "../../../../rxjs/src/internal/util/reportUnhandledError.ts", "../../../../rxjs/src/internal/util/noop.ts", "../../../../rxjs/src/internal/NotificationFactories.ts", "../../../../rxjs/src/internal/util/errorContext.ts", "../../../../rxjs/src/internal/Subscriber.ts", "../../../../rxjs/src/internal/symbol/observable.ts", "../../../../rxjs/src/internal/util/identity.ts", "../../../../rxjs/src/internal/util/pipe.ts", "../../../../rxjs/src/internal/Observable.ts", "../../../../rxjs/src/internal/util/lift.ts", "../../../../rxjs/src/internal/operators/OperatorSubscriber.ts", "../../../../rxjs/src/internal/operators/refCount.ts", "../../../../rxjs/src/internal/observable/ConnectableObservable.ts", "../../../../rxjs/src/internal/scheduler/performanceTimestampProvider.ts", "../../../../rxjs/src/internal/scheduler/animationFrameProvider.ts", "../../../../rxjs/src/internal/observable/dom/animationFrames.ts", "../../../../rxjs/src/internal/util/ObjectUnsubscribedError.ts", "../../../../rxjs/src/internal/Subject.ts", "../../../../rxjs/src/internal/BehaviorSubject.ts", "../../../../rxjs/src/internal/scheduler/dateTimestampProvider.ts", "../../../../rxjs/src/internal/ReplaySubject.ts", "../../../../rxjs/src/internal/AsyncSubject.ts", "../../../../rxjs/src/internal/scheduler/Action.ts", "../../../../rxjs/src/internal/scheduler/intervalProvider.ts", "../../../../rxjs/src/internal/scheduler/AsyncAction.ts", "../../../../rxjs/src/internal/util/Immediate.ts", "../../../../rxjs/src/internal/scheduler/immediateProvider.ts", "../../../../rxjs/src/internal/scheduler/AsapAction.ts", "../../../../rxjs/src/internal/Scheduler.ts", "../../../../rxjs/src/internal/scheduler/AsyncScheduler.ts", "../../../../rxjs/src/internal/scheduler/AsapScheduler.ts", "../../../../rxjs/src/internal/scheduler/asap.ts", "../../../../rxjs/src/internal/scheduler/async.ts", "../../../../rxjs/src/internal/scheduler/QueueAction.ts", "../../../../rxjs/src/internal/scheduler/QueueScheduler.ts", "../../../../rxjs/src/internal/scheduler/queue.ts", "../../../../rxjs/src/internal/scheduler/AnimationFrameAction.ts", "../../../../rxjs/src/internal/scheduler/AnimationFrameScheduler.ts", "../../../../rxjs/src/internal/scheduler/animationFrame.ts", "../../../../rxjs/src/internal/scheduler/VirtualTimeScheduler.ts", "../../../../rxjs/src/internal/observable/empty.ts", "../../../../rxjs/src/internal/util/isScheduler.ts", "../../../../rxjs/src/internal/util/args.ts", "../../../../rxjs/src/internal/util/isArrayLike.ts", "../../../../rxjs/src/internal/util/isPromise.ts", "../../../../rxjs/src/internal/util/isInteropObservable.ts", "../../../../rxjs/src/internal/util/isAsyncIterable.ts", "../../../../rxjs/src/internal/util/throwUnobservableError.ts", "../../../../rxjs/src/internal/symbol/iterator.ts", "../../../../rxjs/src/internal/util/isIterable.ts", "../../../../rxjs/src/internal/util/isReadableStreamLike.ts", "../../../../rxjs/src/internal/observable/innerFrom.ts", "../../../../rxjs/src/internal/util/executeSchedule.ts", "../../../../rxjs/src/internal/operators/observeOn.ts", "../../../../rxjs/src/internal/operators/subscribeOn.ts", "../../../../rxjs/src/internal/scheduled/scheduleObservable.ts", "../../../../rxjs/src/internal/scheduled/schedulePromise.ts", "../../../../rxjs/src/internal/scheduled/scheduleArray.ts", "../../../../rxjs/src/internal/scheduled/scheduleIterable.ts", "../../../../rxjs/src/internal/scheduled/scheduleAsyncIterable.ts", "../../../../rxjs/src/internal/scheduled/scheduleReadableStreamLike.ts", "../../../../rxjs/src/internal/scheduled/scheduled.ts", "../../../../rxjs/src/internal/observable/from.ts", "../../../../rxjs/src/internal/observable/of.ts", "../../../../rxjs/src/internal/observable/throwError.ts", "../../../../rxjs/src/internal/Notification.ts", "../../../../rxjs/src/internal/util/EmptyError.ts", "../../../../rxjs/src/internal/util/ArgumentOutOfRangeError.ts", "../../../../rxjs/src/internal/util/NotFoundError.ts", "../../../../rxjs/src/internal/util/SequenceError.ts", "../../../../rxjs/src/internal/util/isDate.ts", "../../../../rxjs/src/internal/operators/timeout.ts", "../../../../rxjs/src/internal/operators/map.ts", "../../../../rxjs/src/internal/util/mapOneOrManyArgs.ts", "../../../../rxjs/src/internal/util/argsArgArrayOrObject.ts", "../../../../rxjs/src/internal/operators/mergeInternals.ts", "../../../../rxjs/src/internal/operators/mergeMap.ts", "../../../../rxjs/src/internal/observable/fromEvent.ts", "../../../../rxjs/src/internal/observable/timer.ts", "../../../../rxjs/src/internal/observable/never.ts", "../../../../rxjs/src/internal/util/argsOrArgArray.ts", "../../../../packages/core/src/constants/keycodes.ts", "../../../../packages/core/src/constants/cursor.ts", "../../../../packages/core/src/constants/selection.ts", "../../../../packages/core/src/constants/zoom.ts", "../../../../packages/core/src/constants/index.ts", "../../../../packages/core/src/core/element/context-change.ts", "../../../../packages/core/src/utils/weak-maps.ts", "../../../../packages/core/src/utils/helper.ts", "../../../../packages/core/src/interfaces/viewport.ts", "../../../../packages/core/src/interfaces/path.ts", "../../../../packages/core/src/interfaces/node.ts", "../../../../packages/core/src/transforms/general.ts", "../../../../packages/core/src/interfaces/rectangle-client.ts", "../../../../packages/core/src/utils/math.ts", "../../../../packages/core/src/utils/board.ts", "../../../../packages/core/src/utils/dom/common.ts", "../../../../packages/core/src/utils/dom/foreign.ts", "../../../../packages/core/src/utils/dom/environment.ts", "../../../../packages/core/src/utils/environment.ts", "../../../../packages/core/src/utils/history.ts", "../../../../packages/core/src/utils/hotkeys.ts", "../../../../packages/core/src/utils/id-creator.ts", "../../../../packages/core/src/utils/tree.ts", "../../../../packages/core/src/interfaces/selection.ts", "../../../../packages/core/src/interfaces/element.ts", "../../../../packages/core/src/utils/position.ts", "../../../../packages/core/src/utils/debug.ts", "../../../../packages/core/src/interfaces/plugin.ts", "../../../../packages/core/src/utils/selected-element.ts", "../../../../packages/core/src/utils/drawing/rectangle.ts", "../../../../packages/core/src/utils/drawing/arrow.ts", "../../../../packages/core/src/utils/drawing/circle.ts", "../../../../packages/core/src/utils/drawing/line.ts", "../../../../packages/core/src/transforms/viewport.ts", "../../../../packages/core/src/transforms/theme.ts", "../../../../packages/core/src/transforms/board.ts", "../../../../packages/core/src/utils/to-point.ts", "../../../../packages/core/src/utils/viewport.ts", "../../../../packages/core/src/transforms/node.ts", "../../../../packages/core/src/utils/common.ts", "../../../../packages/core/src/utils/dnd.ts", "../../../../packages/core/src/utils/moving-element.ts", "../../../../packages/core/src/utils/to-image.ts", "../../../../packages/core/src/utils/clipboard/types.ts", "../../../../packages/core/src/utils/clipboard/common.ts", "../../../../packages/core/src/utils/clipboard/data-transfer.ts", "../../../../packages/core/src/utils/clipboard/navigator-clipboard.ts", "../../../../packages/core/src/utils/clipboard/clipboard.ts", "../../../../packages/core/src/utils/selection.ts", "../../../../packages/core/src/utils/group.ts", "../../../../packages/core/src/utils/fragment.ts", "../../../../packages/core/src/utils/snap/snap.ts", "../../../../packages/core/src/utils/z-index.ts", "../../../../packages/core/src/utils/pointer.ts", "../../../../packages/core/src/transforms/group.ts", "../../../../packages/core/src/transforms/selection.ts", "../../../../packages/core/src/transforms/z-index.ts", "../../../../packages/core/src/transforms/element.ts", "../../../../packages/core/src/transforms/index.ts", "../../../../packages/core/src/utils/angle.ts", "../../../../packages/core/src/utils/element.ts", "../../../../packages/core/src/interfaces/theme.ts", "../../../../packages/core/src/interfaces/board.ts", "../../../../packages/core/src/interfaces/pointer.ts", "../../../../packages/core/src/interfaces/custom-types.ts", "../../../../packages/core/src/interfaces/operation.ts", "../../../../packages/core/src/interfaces/point.ts", "../../../../packages/core/src/interfaces/history.ts", "../../../../packages/core/src/interfaces/direction.ts", "../../../../packages/core/src/interfaces/group.ts", "../../../../packages/core/src/utils/iterable.ts", "../../../../packages/core/src/differs/default_iterable_differ.ts", "../../../../packages/core/src/core/list-render.ts", "../../../../packages/core/src/core/element/element-flavour.ts", "../../../../packages/core/src/context.ts", "../../../../packages/core/src/interfaces/path-ref.ts", "../../../../packages/core/src/plugins/create-board.ts", "../../../../packages/core/src/plugins/with-board.ts", "../../../../packages/core/src/utils/mobile.ts", "../../../../packages/core/src/plugins/with-hand.ts", "../../../../packages/core/src/plugins/with-history.ts", "../../../../packages/core/src/plugins/with-hotkey.ts", "../../../../packages/core/src/utils/snap/snap-moving.ts", "../../../../packages/core/src/plugins/with-moving.ts", "../../../../packages/core/src/plugins/with-options.ts", "../../../../packages/core/src/plugins/with-related-fragment.ts", "../../../../packages/core/src/plugins/with-selection.ts", "../../../../packages/core/src/plugins/with-i18n.ts", "../../../../packages/core/src/testing/core/create-board.ts", "../../../../packages/core/src/testing/core/fake-weak-map.ts", "../../../../packages/core/src/testing/fake-events/event-objects.ts", "../../../../packages/core/src/public-api.ts", "../../../../packages/core/src/plait-core.ts"],
  "sourcesContent": ["/**\n * Returns true if the object is a function.\n * @param value The value to check\n */\nexport function isFunction(value: any): value is (...args: any[]) => any {\n  return typeof value === 'function';\n}\n", "/**\n * Used to create Error subclasses until the community moves away from ES5.\n *\n * This is because compiling from TypeScript down to ES5 has issues with subclassing Errors\n * as well as other built-in types: https://github.com/Microsoft/TypeScript/issues/12123\n *\n * @param createImpl A factory function to create the actual constructor implementation. The returned\n * function should be a named function that calls `_super` internally.\n */\nexport function createErrorClass<T>(createImpl: (_super: any) => any): T {\n  const _super = (instance: any) => {\n    Error.call(instance);\n    instance.stack = new Error().stack;\n  };\n\n  const ctorFunc = createImpl(_super);\n  ctorFunc.prototype = Object.create(Error.prototype);\n  ctorFunc.prototype.constructor = ctorFunc;\n  return ctorFunc;\n}\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface UnsubscriptionError extends Error {\n  readonly errors: any[];\n}\n\nexport interface UnsubscriptionErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (errors: any[]): UnsubscriptionError;\n}\n\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport const UnsubscriptionError: UnsubscriptionErrorCtor = createErrorClass(\n  (_super) =>\n    function UnsubscriptionErrorImpl(this: any, errors: (Error | string)[]) {\n      _super(this);\n      this.message = errors\n        ? `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}`\n        : '';\n      this.name = 'UnsubscriptionError';\n      this.errors = errors;\n    }\n);\n", "/**\n * Removes an item from an array, mutating it.\n * @param arr The array to remove the item from\n * @param item The item to remove\n */\nexport function arrRemove<T>(arr: T[] | undefined | null, item: T) {\n  if (arr) {\n    const index = arr.indexOf(item);\n    0 <= index && arr.splice(index, 1);\n  }\n}\n", "import { isFunction } from './util/isFunction';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { SubscriptionLike, TeardownLogic, Unsubscribable } from './types';\nimport { arrRemove } from './util/arrRemove';\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n */\nexport class Subscription implements SubscriptionLike {\n  public static EMPTY = (() => {\n    const empty = new Subscription();\n    empty.closed = true;\n    return empty;\n  })();\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   */\n  public closed = false;\n\n  private _parentage: Subscription[] | Subscription | null = null;\n\n  /**\n   * The list of registered finalizers to execute upon unsubscription. Adding and removing from this\n   * list occurs in the {@link #add} and {@link #remove} methods.\n   */\n  private _finalizers: Exclude<TeardownLogic, void>[] | null = null;\n\n  /**\n   * @param initialTeardown A function executed first as part of the finalization\n   * process that is kicked off when {@link #unsubscribe} is called.\n   */\n  constructor(private initialTeardown?: () => void) {}\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   */\n  unsubscribe(): void {\n    let errors: any[] | undefined;\n\n    if (!this.closed) {\n      this.closed = true;\n\n      // Remove this from it's parents.\n      const { _parentage } = this;\n      if (_parentage) {\n        this._parentage = null;\n        if (Array.isArray(_parentage)) {\n          for (const parent of _parentage) {\n            parent.remove(this);\n          }\n        } else {\n          _parentage.remove(this);\n        }\n      }\n\n      const { initialTeardown: initialFinalizer } = this;\n      if (isFunction(initialFinalizer)) {\n        try {\n          initialFinalizer();\n        } catch (e) {\n          errors = e instanceof UnsubscriptionError ? e.errors : [e];\n        }\n      }\n\n      const { _finalizers } = this;\n      if (_finalizers) {\n        this._finalizers = null;\n        for (const finalizer of _finalizers) {\n          try {\n            execFinalizer(finalizer);\n          } catch (err) {\n            errors = errors ?? [];\n            if (err instanceof UnsubscriptionError) {\n              errors = [...errors, ...err.errors];\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n\n      if (errors) {\n        throw new UnsubscriptionError(errors);\n      }\n    }\n  }\n\n  /**\n   * Adds a finalizer to this subscription, so that finalization will be unsubscribed/called\n   * when this subscription is unsubscribed. If this subscription is already {@link #closed},\n   * because it has already been unsubscribed, then whatever finalizer is passed to it\n   * will automatically be executed (unless the finalizer itself is also a closed subscription).\n   *\n   * Closed Subscriptions cannot be added as finalizers to any subscription. Adding a closed\n   * subscription to a any subscription will result in no operation. (A noop).\n   *\n   * Adding a subscription to itself, or adding `null` or `undefined` will not perform any\n   * operation at all. (A noop).\n   *\n   * `Subscription` instances that are added to this instance will automatically remove themselves\n   * if they are unsubscribed. Functions and {@link Unsubscribable} objects that you wish to remove\n   * will need to be removed manually with {@link #remove}\n   *\n   * @param teardown The finalization logic to add to this subscription.\n   */\n  add(teardown: TeardownLogic): void {\n    // Only add the finalizer if it's not undefined\n    // and don't add a subscription to itself.\n    if (teardown && teardown !== this) {\n      if (this.closed) {\n        // If this subscription is already closed,\n        // execute whatever finalizer is handed to it automatically.\n        execFinalizer(teardown);\n      } else {\n        if (teardown instanceof Subscription) {\n          // We don't add closed subscriptions, and we don't add the same subscription\n          // twice. Subscription unsubscribe is idempotent.\n          if (teardown.closed || teardown._hasParent(this)) {\n            return;\n          }\n          teardown._addParent(this);\n        }\n        (this._finalizers = this._finalizers ?? []).push(teardown);\n      }\n    }\n  }\n\n  /**\n   * Checks to see if a this subscription already has a particular parent.\n   * This will signal that this subscription has already been added to the parent in question.\n   * @param parent the parent to check for\n   */\n  private _hasParent(parent: Subscription) {\n    const { _parentage } = this;\n    return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));\n  }\n\n  /**\n   * Adds a parent to this subscription so it can be removed from the parent if it\n   * unsubscribes on it's own.\n   *\n   * NOTE: THIS ASSUMES THAT {@link _hasParent} HAS ALREADY BEEN CHECKED.\n   * @param parent The parent subscription to add\n   */\n  private _addParent(parent: Subscription) {\n    const { _parentage } = this;\n    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;\n  }\n\n  /**\n   * Called on a child when it is removed via {@link #remove}.\n   * @param parent The parent to remove\n   */\n  private _removeParent(parent: Subscription) {\n    const { _parentage } = this;\n    if (_parentage === parent) {\n      this._parentage = null;\n    } else if (Array.isArray(_parentage)) {\n      arrRemove(_parentage, parent);\n    }\n  }\n\n  /**\n   * Removes a finalizer from this subscription that was previously added with the {@link #add} method.\n   *\n   * Note that `Subscription` instances, when unsubscribed, will automatically remove themselves\n   * from every other `Subscription` they have been added to. This means that using the `remove` method\n   * is not a common thing and should be used thoughtfully.\n   *\n   * If you add the same finalizer instance of a function or an unsubscribable object to a `Subscription` instance\n   * more than once, you will need to call `remove` the same number of times to remove all instances.\n   *\n   * All finalizer instances are removed to free up memory upon unsubscription.\n   *\n   * @param teardown The finalizer to remove from this subscription\n   */\n  remove(teardown: Exclude<TeardownLogic, void>): void {\n    const { _finalizers } = this;\n    _finalizers && arrRemove(_finalizers, teardown);\n\n    if (teardown instanceof Subscription) {\n      teardown._removeParent(this);\n    }\n  }\n}\n\nexport const EMPTY_SUBSCRIPTION = Subscription.EMPTY;\n\nexport function isSubscription(value: any): value is Subscription {\n  return (\n    value instanceof Subscription ||\n    (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe))\n  );\n}\n\nfunction execFinalizer(finalizer: Unsubscribable | (() => void)) {\n  if (isFunction(finalizer)) {\n    finalizer();\n  } else {\n    finalizer.unsubscribe();\n  }\n}\n", "import { Subscriber } from './Subscriber';\nimport { ObservableNotification } from './types';\n\n/**\n * The {@link GlobalConfig} object for RxJS. It is used to configure things\n * like how to react on unhandled errors.\n */\nexport const config: GlobalConfig = {\n  onUnhandledError: null,\n  onStoppedNotification: null,\n  Promise: undefined,\n  useDeprecatedSynchronousErrorHandling: false,\n  useDeprecatedNextContext: false,\n};\n\n/**\n * The global configuration object for RxJS, used to configure things\n * like how to react on unhandled errors. Accessible via {@link config}\n * object.\n */\nexport interface GlobalConfig {\n  /**\n   * A registration point for unhandled errors from RxJS. These are errors that\n   * cannot were not handled by consuming code in the usual subscription path. For\n   * example, if you have this configured, and you subscribe to an observable without\n   * providing an error handler, errors from that subscription will end up here. This\n   * will _always_ be called asynchronously on another job in the runtime. This is because\n   * we do not want errors thrown in this user-configured handler to interfere with the\n   * behavior of the library.\n   */\n  onUnhandledError: ((err: any) => void) | null;\n\n  /**\n   * A registration point for notifications that cannot be sent to subscribers because they\n   * have completed, errored or have been explicitly unsubscribed. By default, next, complete\n   * and error notifications sent to stopped subscribers are noops. However, sometimes callers\n   * might want a different behavior. For example, with sources that attempt to report errors\n   * to stopped subscribers, a caller can configure RxJS to throw an unhandled error instead.\n   * This will _always_ be called asynchronously on another job in the runtime. This is because\n   * we do not want errors thrown in this user-configured handler to interfere with the\n   * behavior of the library.\n   */\n  onStoppedNotification: ((notification: ObservableNotification<any>, subscriber: Subscriber<any>) => void) | null;\n\n  /**\n   * The promise constructor used by default for {@link Observable#toPromise toPromise} and {@link Observable#forEach forEach}\n   * methods.\n   *\n   * @deprecated As of version 8, RxJS will no longer support this sort of injection of a\n   * Promise constructor. If you need a Promise implementation other than native promises,\n   * please polyfill/patch Promise as you see appropriate. Will be removed in v8.\n   */\n  Promise?: PromiseConstructorLike;\n\n  /**\n   * If true, turns on synchronous error rethrowing, which is a deprecated behavior\n   * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe\n   * call in a try/catch block. It also enables producer interference, a nasty bug\n   * where a multicast can be broken for all observers by a downstream consumer with\n   * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BUY TIME\n   * FOR MIGRATION REASONS.\n   *\n   * @deprecated As of version 8, RxJS will no longer support synchronous throwing\n   * of unhandled errors. All errors will be thrown on a separate call stack to prevent bad\n   * behaviors described above. Will be removed in v8.\n   */\n  useDeprecatedSynchronousErrorHandling: boolean;\n\n  /**\n   * If true, enables an as-of-yet undocumented feature from v5: The ability to access\n   * `unsubscribe()` via `this` context in `next` functions created in observers passed\n   * to `subscribe`.\n   *\n   * This is being removed because the performance was severely problematic, and it could also cause\n   * issues when types other than POJOs are passed to subscribe as subscribers, as they will likely have\n   * their `this` context overwritten.\n   *\n   * @deprecated As of version 8, RxJS will no longer support altering the\n   * context of next functions provided as part of an observer to Subscribe. Instead,\n   * you will have access to a subscription or a signal or token that will allow you to do things like\n   * unsubscribe and test closed status. Will be removed in v8.\n   */\n  useDeprecatedNextContext: boolean;\n}\n", "import type { TimerHandle } from './timerHandle';\ntype SetTimeoutFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\ntype ClearTimeoutFunction = (handle: TimerHandle) => void;\n\ninterface TimeoutProvider {\n  setTimeout: SetTimeoutFunction;\n  clearTimeout: ClearTimeoutFunction;\n  delegate:\n    | {\n        setTimeout: SetTimeoutFunction;\n        clearTimeout: ClearTimeoutFunction;\n      }\n    | undefined;\n}\n\nexport const timeoutProvider: TimeoutProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setTimeout(handler: () => void, timeout?: number, ...args) {\n    const { delegate } = timeoutProvider;\n    if (delegate?.setTimeout) {\n      return delegate.setTimeout(handler, timeout, ...args);\n    }\n    return setTimeout(handler, timeout, ...args);\n  },\n  clearTimeout(handle) {\n    const { delegate } = timeoutProvider;\n    return (delegate?.clearTimeout || clearTimeout)(handle as any);\n  },\n  delegate: undefined,\n};\n", "import { config } from '../config';\nimport { timeoutProvider } from '../scheduler/timeoutProvider';\n\n/**\n * Handles an error on another job either with the user-configured {@link onUnhandledError},\n * or by throwing it on that new job so it can be picked up by `window.onerror`, `process.on('error')`, etc.\n *\n * This should be called whenever there is an error that is out-of-band with the subscription\n * or when an error hits a terminal boundary of the subscription and no error handler was provided.\n *\n * @param err the error to report\n */\nexport function reportUnhandledError(err: any) {\n  timeoutProvider.setTimeout(() => {\n    const { onUnhandledError } = config;\n    if (onUnhandledError) {\n      // Execute the user-configured error handler.\n      onUnhandledError(err);\n    } else {\n      // Throw so it is picked up by the runtime's uncaught error mechanism.\n      throw err;\n    }\n  });\n}\n", "/* tslint:disable:no-empty */\nexport function noop() { }\n", "import { CompleteNotification, NextNotification, ErrorNotification } from './types';\n\n/**\n * A completion object optimized for memory use and created to be the\n * same \"shape\" as other notifications in v8.\n * @internal\n */\nexport const COMPLETE_NOTIFICATION = (() => createNotification('C', undefined, undefined) as CompleteNotification)();\n\n/**\n * Internal use only. Creates an optimized error notification that is the same \"shape\"\n * as other notifications.\n * @internal\n */\nexport function errorNotification(error: any): ErrorNotification {\n  return createNotification('E', undefined, error) as any;\n}\n\n/**\n * Internal use only. Creates an optimized next notification that is the same \"shape\"\n * as other notifications.\n * @internal\n */\nexport function nextNotification<T>(value: T) {\n  return createNotification('N', value, undefined) as NextNotification<T>;\n}\n\n/**\n * Ensures that all notifications created internally have the same \"shape\" in v8.\n *\n * TODO: This is only exported to support a crazy legacy test in `groupBy`.\n * @internal\n */\nexport function createNotification(kind: 'N' | 'E' | 'C', value: any, error: any) {\n  return {\n    kind,\n    value,\n    error,\n  };\n}\n", "import { config } from '../config';\n\nlet context: { errorThrown: boolean; error: any } | null = null;\n\n/**\n * Handles dealing with errors for super-gross mode. Creates a context, in which\n * any synchronously thrown errors will be passed to {@link captureError}. Which\n * will record the error such that it will be rethrown after the call back is complete.\n * TODO: Remove in v8\n * @param cb An immediately executed function.\n */\nexport function errorContext(cb: () => void) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    const isRoot = !context;\n    if (isRoot) {\n      context = { errorThrown: false, error: null };\n    }\n    cb();\n    if (isRoot) {\n      const { errorThrown, error } = context!;\n      context = null;\n      if (errorThrown) {\n        throw error;\n      }\n    }\n  } else {\n    // This is the general non-deprecated path for everyone that\n    // isn't crazy enough to use super-gross mode (useDeprecatedSynchronousErrorHandling)\n    cb();\n  }\n}\n\n/**\n * Captures errors only in super-gross mode.\n * @param err the error to capture\n */\nexport function captureError(err: any) {\n  if (config.useDeprecatedSynchronousErrorHandling && context) {\n    context.errorThrown = true;\n    context.error = err;\n  }\n}\n", "import { isFunction } from './util/isFunction';\nimport { Observer, ObservableNotification } from './types';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param next The `next` callback of an Observer.\n   * @param error The `error` callback of an\n   * Observer.\n   * @param complete The `complete` callback of an\n   * Observer.\n   * @return A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   * @deprecated Do not use. Will be removed in v8. There is no replacement for this\n   * method, and there is no reason to be creating instances of `Subscriber` directly.\n   * If you have a specific use case, please file an issue.\n   */\n  static create<T>(next?: (x?: T) => void, error?: (e?: any) => void, complete?: () => void): Subscriber<T> {\n    return new SafeSubscriber(next, error, complete);\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected isStopped: boolean = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected destination: Subscriber<any> | Observer<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * There is no reason to directly create an instance of Subscriber. This type is exported for typings reasons.\n   */\n  constructor(destination?: Subscriber<any> | Observer<any>) {\n    super();\n    if (destination) {\n      this.destination = destination;\n      // Automatically chain subscriptions together here.\n      // if destination is a Subscription, then it is a Subscriber.\n      if (isSubscription(destination)) {\n        destination.add(this);\n      }\n    } else {\n      this.destination = EMPTY_OBSERVER;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param value The `next` value.\n   */\n  next(value: T): void {\n    if (this.isStopped) {\n      handleStoppedNotification(nextNotification(value), this);\n    } else {\n      this._next(value!);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached `Error`. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param err The `error` exception.\n   */\n  error(err?: any): void {\n    if (this.isStopped) {\n      handleStoppedNotification(errorNotification(err), this);\n    } else {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   */\n  complete(): void {\n    if (this.isStopped) {\n      handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n    } else {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (!this.closed) {\n      this.isStopped = true;\n      super.unsubscribe();\n      this.destination = null!;\n    }\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    try {\n      this.destination.error(err);\n    } finally {\n      this.unsubscribe();\n    }\n  }\n\n  protected _complete(): void {\n    try {\n      this.destination.complete();\n    } finally {\n      this.unsubscribe();\n    }\n  }\n}\n\n/**\n * This bind is captured here because we want to be able to have\n * compatibility with monoid libraries that tend to use a method named\n * `bind`. In particular, a library called Monio requires this.\n */\nconst _bind = Function.prototype.bind;\n\nfunction bind<Fn extends (...args: any[]) => any>(fn: Fn, thisArg: any): Fn {\n  return _bind.call(fn, thisArg);\n}\n\n/**\n * Internal optimization only, DO NOT EXPOSE.\n * @internal\n */\nclass ConsumerObserver<T> implements Observer<T> {\n  constructor(private partialObserver: Partial<Observer<T>>) {}\n\n  next(value: T): void {\n    const { partialObserver } = this;\n    if (partialObserver.next) {\n      try {\n        partialObserver.next(value);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n\n  error(err: any): void {\n    const { partialObserver } = this;\n    if (partialObserver.error) {\n      try {\n        partialObserver.error(err);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    } else {\n      handleUnhandledError(err);\n    }\n  }\n\n  complete(): void {\n    const { partialObserver } = this;\n    if (partialObserver.complete) {\n      try {\n        partialObserver.complete();\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n}\n\nexport class SafeSubscriber<T> extends Subscriber<T> {\n  constructor(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((e?: any) => void) | null,\n    complete?: (() => void) | null\n  ) {\n    super();\n\n    let partialObserver: Partial<Observer<T>>;\n    if (isFunction(observerOrNext) || !observerOrNext) {\n      // The first argument is a function, not an observer. The next\n      // two arguments *could* be observers, or they could be empty.\n      partialObserver = {\n        next: (observerOrNext ?? undefined) as ((value: T) => void) | undefined,\n        error: error ?? undefined,\n        complete: complete ?? undefined,\n      };\n    } else {\n      // The first argument is a partial observer.\n      let context: any;\n      if (this && config.useDeprecatedNextContext) {\n        // This is a deprecated path that made `this.unsubscribe()` available in\n        // next handler functions passed to subscribe. This only exists behind a flag\n        // now, as it is *very* slow.\n        context = Object.create(observerOrNext);\n        context.unsubscribe = () => this.unsubscribe();\n        partialObserver = {\n          next: observerOrNext.next && bind(observerOrNext.next, context),\n          error: observerOrNext.error && bind(observerOrNext.error, context),\n          complete: observerOrNext.complete && bind(observerOrNext.complete, context),\n        };\n      } else {\n        // The \"normal\" path. Just use the partial observer directly.\n        partialObserver = observerOrNext;\n      }\n    }\n\n    // Wrap the partial observer to ensure it's a full observer, and\n    // make sure proper error handling is accounted for.\n    this.destination = new ConsumerObserver(partialObserver);\n  }\n}\n\nfunction handleUnhandledError(error: any) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    captureError(error);\n  } else {\n    // Ideal path, we report this as an unhandled error,\n    // which is thrown on a new call stack.\n    reportUnhandledError(error);\n  }\n}\n\n/**\n * An error handler used when no error handler was supplied\n * to the SafeSubscriber -- meaning no error handler was supplied\n * do the `subscribe` call on our observable.\n * @param err The error to handle\n */\nfunction defaultErrorHandler(err: any) {\n  throw err;\n}\n\n/**\n * A handler for notifications that cannot be sent to a stopped subscriber.\n * @param notification The notification being sent.\n * @param subscriber The stopped subscriber.\n */\nfunction handleStoppedNotification(notification: ObservableNotification<any>, subscriber: Subscriber<any>) {\n  const { onStoppedNotification } = config;\n  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\n}\n\n/**\n * The observer used as a stub for subscriptions where the user did not\n * pass any arguments to `subscribe`. Comes with the default error handling\n * behavior.\n */\nexport const EMPTY_OBSERVER: Readonly<Observer<any>> & { closed: true } = {\n  closed: true,\n  next: noop,\n  error: defaultErrorHandler,\n  complete: noop,\n};\n", "/**\n * Symbol.observable or a string \"@@observable\". Used for interop\n *\n * @deprecated We will no longer be exporting this symbol in upcoming versions of RxJS.\n * Instead polyfill and use Symbol.observable directly *or* use https://www.npmjs.com/package/symbol-observable\n */\nexport const observable: string | symbol = (() => (typeof Symbol === 'function' && Symbol.observable) || '@@observable')();\n", "/**\n * This function takes one parameter and just returns it. Simply put,\n * this is like `<T>(x: T): T => x`.\n *\n * ## Examples\n *\n * This is useful in some cases when using things like `mergeMap`\n *\n * ```ts\n * import { interval, take, map, range, mergeMap, identity } from 'rxjs';\n *\n * const source$ = interval(1000).pipe(take(5));\n *\n * const result$ = source$.pipe(\n *   map(i => range(i)),\n *   mergeMap(identity) // same as mergeMap(x => x)\n * );\n *\n * result$.subscribe({\n *   next: console.log\n * });\n * ```\n *\n * Or when you want to selectively apply an operator\n *\n * ```ts\n * import { interval, take, identity } from 'rxjs';\n *\n * const shouldLimit = () => Math.random() < 0.5;\n *\n * const source$ = interval(1000);\n *\n * const result$ = source$.pipe(shouldLimit() ? take(5) : identity);\n *\n * result$.subscribe({\n *   next: console.log\n * });\n * ```\n *\n * @param x Any value that is returned by this function\n * @returns The value passed as the first parameter to this function\n */\nexport function identity<T>(x: T): T {\n  return x;\n}\n", "import { identity } from './identity';\nimport { UnaryFunction } from '../types';\n\nexport function pipe(): typeof identity;\nexport function pipe<T, A>(fn1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>\n): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>\n): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>\n): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>\n): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>\n): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>,\n  fn9: UnaryFunction<H, I>\n): UnaryFunction<T, I>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>,\n  fn9: UnaryFunction<H, I>,\n  ...fns: UnaryFunction<any, any>[]\n): UnaryFunction<T, unknown>;\n\n/**\n * pipe() can be called on one or more functions, each of which can take one argument (\"UnaryFunction\")\n * and uses it to return a value.\n * It returns a function that takes one argument, passes it to the first UnaryFunction, and then\n * passes the result to the next one, passes that result to the next one, and so on.  \n */\nexport function pipe(...fns: Array<UnaryFunction<any, any>>): UnaryFunction<any, any> {\n  return pipeFromArray(fns);\n}\n\n/** @internal */\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  if (fns.length === 0) {\n    return identity as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input as any);\n  };\n}\n", "import { Operator } from './Operator';\nimport { SafeSubscriber, Subscriber } from './Subscriber';\nimport { isSubscription, Subscription } from './Subscription';\nimport { TeardownLogic, OperatorFunction, Subscribable, Observer } from './types';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\nimport { isFunction } from './util/isFunction';\nimport { errorContext } from './util/errorContext';\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n */\nexport class Observable<T> implements Subscribable<T> {\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  source: Observable<any> | undefined;\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  operator: Operator<any, T> | undefined;\n\n  /**\n   * @param subscribe The function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new Observable by calling the Observable constructor\n   * @param subscribe the subscriber function to be passed to the Observable constructor\n   * @return A new observable.\n   * @deprecated Use `new Observable()` instead. Will be removed in v8.\n   */\n  static create: (...args: any[]) => any = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  };\n\n  /**\n   * Creates a new Observable, with this Observable instance as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @param operator the operator defining the operation to take on the observable\n   * @return A new observable with the Operator applied.\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * If you have implemented an operator using `lift`, it is recommended that you create an\n   * operator by simply returning `new Observable()` directly. See \"Creating new operators from\n   * scratch\" section here: https://rxjs.dev/guide/operators\n   */\n  lift<R>(operator?: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observerOrNext?: Partial<Observer<T>> | ((value: T) => void)): Subscription;\n  /** @deprecated Instead of passing separate callback arguments, use an observer argument. Signatures taking separate callback arguments will be removed in v8. Details: https://rxjs.dev/deprecations/subscribe-arguments */\n  subscribe(next?: ((value: T) => void) | null, error?: ((error: any) => void) | null, complete?: (() => void) | null): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to Observable's constructor, but most of the time it is\n   * a library implementation, which defines what will be emitted by an Observable, and when it be will emitted. This means\n   * that calling `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * the thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * of the following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular, do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, if the `error` method is not provided and an error happens,\n   * it will be thrown asynchronously. Errors thrown asynchronously cannot be caught using `try`/`catch`. Instead,\n   * use the {@link onUnhandledError} configuration option or use a runtime handler (like `window.onerror` or\n   * `process.on('error)`) to be notified of unhandled errors. Because of this, it's recommended that you provide\n   * an `error` method to avoid missing thrown errors.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where the first function is equivalent\n   * of a `next` method, the second of an `error` method and the third of a `complete` method. Just as in case of an Observer,\n   * if you do not need to listen for something, you can omit a function by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to the `error` function, as with an Observer, if not provided, errors emitted by an Observable will be thrown asynchronously.\n   *\n   * You can, however, subscribe with no parameters at all. This may be the case where you're not interested in terminal events\n   * and you also handled emissions internally by using operators (e.g. using `tap`).\n   *\n   * Whichever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop the work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a `scheduler`.\n   *\n   * #### Examples\n   *\n   * Subscribe with an {@link guide/observer Observer}\n   *\n   * ```ts\n   * import { of } from 'rxjs';\n   *\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() {\n   *     // We actually could just remove this method,\n   *     // since we do not really care about errors right now.\n   *   },\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   *   .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // 'Adding: 1'\n   * // 'Adding: 2'\n   * // 'Adding: 3'\n   * // 'Sum equals: 6'\n   * ```\n   *\n   * Subscribe with functions ({@link deprecations/subscribe-arguments deprecated})\n   *\n   * ```ts\n   * import { of } from 'rxjs'\n   *\n   * let sum = 0;\n   *\n   * of(1, 2, 3).subscribe(\n   *   value => {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   () => console.log('Sum equals: ' + sum)\n   * );\n   *\n   * // Logs:\n   * // 'Adding: 1'\n   * // 'Adding: 2'\n   * // 'Adding: 3'\n   * // 'Sum equals: 6'\n   * ```\n   *\n   * Cancel a subscription\n   *\n   * ```ts\n   * import { interval } from 'rxjs';\n   *\n   * const subscription = interval(1000).subscribe({\n   *   next(num) {\n   *     console.log(num)\n   *   },\n   *   complete() {\n   *     // Will not be called, even when cancelling subscription.\n   *     console.log('completed!');\n   *   }\n   * });\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // 'unsubscribed!' after 2.5s\n   * ```\n   *\n   * @param observerOrNext Either an {@link Observer} with some or all callback methods,\n   * or the `next` handler that is called for each value emitted from the subscribed Observable.\n   * @param error A handler for a terminal event resulting from an error. If no error handler is provided,\n   * the error will be thrown asynchronously as unhandled.\n   * @param complete A handler for a terminal event resulting from successful completion.\n   * @return A subscription reference to the registered handlers.\n   */\n  subscribe(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((error: any) => void) | null,\n    complete?: (() => void) | null\n  ): Subscription {\n    const subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);\n\n    errorContext(() => {\n      const { operator, source } = this;\n      subscriber.add(\n        operator\n          ? // We're dealing with a subscription in the\n            // operator chain to one of our lifted operators.\n            operator.call(subscriber, source)\n          : source\n          ? // If `source` has a value, but `operator` does not, something that\n            // had intimate knowledge of our API, like our `Subject`, must have\n            // set it. We're going to just call `_subscribe` directly.\n            this._subscribe(subscriber)\n          : // In all other cases, we're likely wrapping a user-provided initializer\n            // function, so we need to catch errors and handle them appropriately.\n            this._trySubscribe(subscriber)\n      );\n    });\n\n    return subscriber;\n  }\n\n  /** @internal */\n  protected _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      // We don't need to return anything in this case,\n      // because it's just going to try to `add()` to a subscription\n      // above.\n      sink.error(err);\n    }\n  }\n\n  /**\n   * Used as a NON-CANCELLABLE means of subscribing to an observable, for use with\n   * APIs that expect promises, like `async/await`. You cannot unsubscribe from this.\n   *\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\n   * observable does not complete, you will end up with a promise that is hung up, and\n   * potentially all of the state of an async function hanging out in memory. To avoid\n   * this situation, look into adding something like {@link timeout}, {@link take},\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\n   *\n   * #### Example\n   *\n   * ```ts\n   * import { interval, take } from 'rxjs';\n   *\n   * const source$ = interval(1000).pipe(take(4));\n   *\n   * async function getTotal() {\n   *   let total = 0;\n   *\n   *   await source$.forEach(value => {\n   *     total += value;\n   *     console.log('observable -> ' + value);\n   *   });\n   *\n   *   return total;\n   * }\n   *\n   * getTotal().then(\n   *   total => console.log('Total: ' + total)\n   * );\n   *\n   * // Expected:\n   * // 'observable -> 0'\n   * // 'observable -> 1'\n   * // 'observable -> 2'\n   * // 'observable -> 3'\n   * // 'Total: 6'\n   * ```\n   *\n   * @param next A handler for each value emitted by the observable.\n   * @return A promise that either resolves on observable completion or\n   * rejects with the handled error.\n   */\n  forEach(next: (value: T) => void): Promise<void>;\n\n  /**\n   * @param next a handler for each value emitted by the observable\n   * @param promiseCtor a constructor function used to instantiate the Promise\n   * @return a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   * @deprecated Passing a Promise constructor will no longer be available\n   * in upcoming versions of RxJS. This is because it adds weight to the library, for very\n   * little benefit. If you need this functionality, it is recommended that you either\n   * polyfill Promise, or you create an adapter to convert the returned native promise\n   * to whatever promise implementation you wanted. Will be removed in v8.\n   */\n  forEach(next: (value: T) => void, promiseCtor: PromiseConstructorLike): Promise<void>;\n\n  forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor<void>((resolve, reject) => {\n      const subscriber = new SafeSubscriber<T>({\n        next: (value) => {\n          try {\n            next(value);\n          } catch (err) {\n            reject(err);\n            subscriber.unsubscribe();\n          }\n        },\n        error: reject,\n        complete: resolve,\n      });\n      this.subscribe(subscriber);\n    }) as Promise<void>;\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    return this.source?.subscribe(subscriber);\n  }\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @return This instance of the observable.\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>;\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;\n  pipe<A, B, C, D>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>\n  ): Observable<D>;\n  pipe<A, B, C, D, E>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>\n  ): Observable<E>;\n  pipe<A, B, C, D, E, F>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>\n  ): Observable<F>;\n  pipe<A, B, C, D, E, F, G>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>\n  ): Observable<G>;\n  pipe<A, B, C, D, E, F, G, H>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>\n  ): Observable<H>;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>,\n    op9: OperatorFunction<H, I>\n  ): Observable<I>;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>,\n    op9: OperatorFunction<H, I>,\n    ...operations: OperatorFunction<any, any>[]\n  ): Observable<unknown>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   *\n   * ## Example\n   *\n   * ```ts\n   * import { interval, filter, map, scan } from 'rxjs';\n   *\n   * interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x));\n   * ```\n   *\n   * @return The Observable result of all the operators having been called\n   * in the order they were passed in.\n   */\n  pipe(...operations: OperatorFunction<any, any>[]): Observable<any> {\n    return pipeFromArray(operations)(this);\n  }\n\n  /* tslint:disable:max-line-length */\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(): Promise<T | undefined>;\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(PromiseCtor: typeof Promise): Promise<T | undefined>;\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(PromiseCtor: PromiseConstructorLike): Promise<T | undefined>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Subscribe to this Observable and get a Promise resolving on\n   * `complete` with the last emission (if any).\n   *\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\n   * observable does not complete, you will end up with a promise that is hung up, and\n   * potentially all of the state of an async function hanging out in memory. To avoid\n   * this situation, look into adding something like {@link timeout}, {@link take},\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\n   *\n   * @param [promiseCtor] a constructor function used to instantiate\n   * the Promise\n   * @return A Promise that resolves with the last value emit, or\n   * rejects on an error. If there were no emissions, Promise\n   * resolves with undefined.\n   * @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise\n   */\n  toPromise(promiseCtor?: PromiseConstructorLike): Promise<T | undefined> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor((resolve, reject) => {\n      let value: T | undefined;\n      this.subscribe(\n        (x: T) => (value = x),\n        (err: any) => reject(err),\n        () => resolve(value)\n      );\n    }) as Promise<T | undefined>;\n  }\n}\n\n/**\n * Decides between a passed promise constructor from consuming code,\n * A default configured promise constructor, and the native promise\n * constructor and returns it. If nothing can be found, it will throw\n * an error.\n * @param promiseCtor The optional promise constructor to passed by consuming code\n */\nfunction getPromiseCtor(promiseCtor: PromiseConstructorLike | undefined) {\n  return promiseCtor ?? config.Promise ?? Promise;\n}\n\nfunction isObserver<T>(value: any): value is Observer<T> {\n  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);\n}\n\nfunction isSubscriber<T>(value: any): value is Subscriber<T> {\n  return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));\n}\n", "import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction } from '../types';\nimport { isFunction } from './isFunction';\n\n/**\n * Used to determine if an object is an Observable with a lift function.\n */\nexport function hasLift(source: any): source is { lift: InstanceType<typeof Observable>['lift'] } {\n  return isFunction(source?.lift);\n}\n\n/**\n * Creates an `OperatorFunction`. Used to define operators throughout the library in a concise way.\n * @param init The logic to connect the liftedSource to the subscriber at the moment of subscription.\n */\nexport function operate<T, R>(\n  init: (liftedSource: Observable<T>, subscriber: Subscriber<R>) => (() => void) | void\n): OperatorFunction<T, R> {\n  return (source: Observable<T>) => {\n    if (hasLift(source)) {\n      return source.lift(function (this: Subscriber<R>, liftedSource: Observable<T>) {\n        try {\n          return init(liftedSource, this);\n        } catch (err) {\n          this.error(err);\n        }\n      });\n    }\n    throw new TypeError('Unable to lift unknown Observable type');\n  };\n}\n", "import { Subscriber } from '../Subscriber';\n\n/**\n * Creates an instance of an `OperatorSubscriber`.\n * @param destination The downstream subscriber.\n * @param onNext Handles next values, only called if this subscriber is not stopped or closed. Any\n * error that occurs in this function is caught and sent to the `error` method of this subscriber.\n * @param onError Handles errors from the subscription, any errors that occur in this handler are caught\n * and send to the `destination` error handler.\n * @param onComplete Handles completion notification from the subscription. Any errors that occur in\n * this handler are sent to the `destination` error handler.\n * @param onFinalize Additional teardown logic here. This will only be called on teardown if the\n * subscriber itself is not already closed. This is called after all other teardown logic is executed.\n */\nexport function createOperatorSubscriber<T>(\n  destination: Subscriber<any>,\n  onNext?: (value: T) => void,\n  onComplete?: () => void,\n  onError?: (err: any) => void,\n  onFinalize?: () => void\n): Subscriber<T> {\n  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);\n}\n\n/**\n * A generic helper for allowing operators to be created with a Subscriber and\n * use closures to capture necessary state from the operator function itself.\n */\nexport class OperatorSubscriber<T> extends Subscriber<T> {\n  /**\n   * Creates an instance of an `OperatorSubscriber`.\n   * @param destination The downstream subscriber.\n   * @param onNext Handles next values, only called if this subscriber is not stopped or closed. Any\n   * error that occurs in this function is caught and sent to the `error` method of this subscriber.\n   * @param onError Handles errors from the subscription, any errors that occur in this handler are caught\n   * and send to the `destination` error handler.\n   * @param onComplete Handles completion notification from the subscription. Any errors that occur in\n   * this handler are sent to the `destination` error handler.\n   * @param onFinalize Additional finalization logic here. This will only be called on finalization if the\n   * subscriber itself is not already closed. This is called after all other finalization logic is executed.\n   * @param shouldUnsubscribe An optional check to see if an unsubscribe call should truly unsubscribe.\n   * NOTE: This currently **ONLY** exists to support the strange behavior of {@link groupBy}, where unsubscription\n   * to the resulting observable does not actually disconnect from the source if there are active subscriptions\n   * to any grouped observable. (DO NOT EXPOSE OR USE EXTERNALLY!!!)\n   */\n  constructor(\n    destination: Subscriber<any>,\n    onNext?: (value: T) => void,\n    onComplete?: () => void,\n    onError?: (err: any) => void,\n    private onFinalize?: () => void,\n    private shouldUnsubscribe?: () => boolean\n  ) {\n    // It's important - for performance reasons - that all of this class's\n    // members are initialized and that they are always initialized in the same\n    // order. This will ensure that all OperatorSubscriber instances have the\n    // same hidden class in V8. This, in turn, will help keep the number of\n    // hidden classes involved in property accesses within the base class as\n    // low as possible. If the number of hidden classes involved exceeds four,\n    // the property accesses will become megamorphic and performance penalties\n    // will be incurred - i.e. inline caches won't be used.\n    //\n    // The reasons for ensuring all instances have the same hidden class are\n    // further discussed in this blog post from Benedikt Meurer:\n    // https://benediktmeurer.de/2018/03/23/impact-of-polymorphism-on-component-based-frameworks-like-react/\n    super(destination);\n    this._next = onNext\n      ? function (this: OperatorSubscriber<T>, value: T) {\n          try {\n            onNext(value);\n          } catch (err) {\n            destination.error(err);\n          }\n        }\n      : super._next;\n    this._error = onError\n      ? function (this: OperatorSubscriber<T>, err: any) {\n          try {\n            onError(err);\n          } catch (err) {\n            // Send any errors that occur down stream.\n            destination.error(err);\n          } finally {\n            // Ensure finalization.\n            this.unsubscribe();\n          }\n        }\n      : super._error;\n    this._complete = onComplete\n      ? function (this: OperatorSubscriber<T>) {\n          try {\n            onComplete();\n          } catch (err) {\n            // Send any errors that occur down stream.\n            destination.error(err);\n          } finally {\n            // Ensure finalization.\n            this.unsubscribe();\n          }\n        }\n      : super._complete;\n  }\n\n  unsubscribe() {\n    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\n      const { closed } = this;\n      super.unsubscribe();\n      // Execute additional teardown if we have any and we didn't already do so.\n      !closed && this.onFinalize?.();\n    }\n  }\n}\n", "import { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Make a {@link ConnectableObservable} behave like a ordinary observable and automates the way\n * you can connect to it.\n *\n * Internally it counts the subscriptions to the observable and subscribes (only once) to the source if\n * the number of subscriptions is larger than 0. If the number of subscriptions is smaller than 1, it\n * unsubscribes from the source. This way you can make sure that everything before the *published*\n * refCount has only a single subscription independently of the number of subscribers to the target\n * observable.\n *\n * Note that using the {@link share} operator is exactly the same as using the `multicast(() => new Subject())` operator\n * (making the observable hot) and the *refCount* operator in a sequence.\n *\n * ![](refCount.png)\n *\n * ## Example\n *\n * In the following example there are two intervals turned into connectable observables\n * by using the *publish* operator. The first one uses the *refCount* operator, the\n * second one does not use it. You will notice that a connectable observable does nothing\n * until you call its connect function.\n *\n * ```ts\n * import { interval, tap, publish, refCount } from 'rxjs';\n *\n * // Turn the interval observable into a ConnectableObservable (hot)\n * const refCountInterval = interval(400).pipe(\n *   tap(num => console.log(`refCount ${ num }`)),\n *   publish(),\n *   refCount()\n * );\n *\n * const publishedInterval = interval(400).pipe(\n *   tap(num => console.log(`publish ${ num }`)),\n *   publish()\n * );\n *\n * refCountInterval.subscribe();\n * refCountInterval.subscribe();\n * // 'refCount 0' -----> 'refCount 1' -----> etc\n * // All subscriptions will receive the same value and the tap (and\n * // every other operator) before the `publish` operator will be executed\n * // only once per event independently of the number of subscriptions.\n *\n * publishedInterval.subscribe();\n * // Nothing happens until you call .connect() on the observable.\n * ```\n *\n * @return A function that returns an Observable that automates the connection\n * to ConnectableObservable.\n * @see {@link ConnectableObservable}\n * @see {@link share}\n * @see {@link publish}\n * @deprecated Replaced with the {@link share} operator. How `share` is used\n * will depend on the connectable observable you created just prior to the\n * `refCount` operator.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function refCount<T>(): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let connection: Subscription | null = null;\n\n    (source as any)._refCount++;\n\n    const refCounter = createOperatorSubscriber(subscriber, undefined, undefined, undefined, () => {\n      if (!source || (source as any)._refCount <= 0 || 0 < --(source as any)._refCount) {\n        connection = null;\n        return;\n      }\n\n      ///\n      // Compare the local RefCountSubscriber's connection Subscription to the\n      // connection Subscription on the shared ConnectableObservable. In cases\n      // where the ConnectableObservable source synchronously emits values, and\n      // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n      // execution continues to here before the RefCountOperator has a chance to\n      // supply the RefCountSubscriber with the shared connection Subscription.\n      // For example:\n      // ```\n      // range(0, 10).pipe(\n      //   publish(),\n      //   refCount(),\n      //   take(5),\n      // )\n      // .subscribe();\n      // ```\n      // In order to account for this case, RefCountSubscriber should only dispose\n      // the ConnectableObservable's shared connection Subscription if the\n      // connection Subscription exists, *and* either:\n      //   a. RefCountSubscriber doesn't have a reference to the shared connection\n      //      Subscription yet, or,\n      //   b. RefCountSubscriber's connection Subscription reference is identical\n      //      to the shared connection Subscription\n      ///\n\n      const sharedConnection = (source as any)._connection;\n      const conn = connection;\n      connection = null;\n\n      if (sharedConnection && (!conn || sharedConnection === conn)) {\n        sharedConnection.unsubscribe();\n      }\n\n      subscriber.unsubscribe();\n    });\n\n    source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      connection = (source as ConnectableObservable<T>).connect();\n    }\n  });\n}\n", "import { Subject } from '../Subject';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { hasLift } from '../util/lift';\n\n/**\n * @class ConnectableObservable<T>\n * @deprecated Will be removed in v8. Use {@link connectable} to create a connectable observable.\n * If you are using the `refCount` method of `ConnectableObservable`, use the {@link share} operator\n * instead.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport class ConnectableObservable<T> extends Observable<T> {\n  protected _subject: Subject<T> | null = null;\n  protected _refCount: number = 0;\n  protected _connection: Subscription | null = null;\n\n  /**\n   * @param source The source observable\n   * @param subjectFactory The factory that creates the subject used internally.\n   * @deprecated Will be removed in v8. Use {@link connectable} to create a connectable observable.\n   * `new ConnectableObservable(source, factory)` is equivalent to\n   * `connectable(source, { connector: factory })`.\n   * When the `refCount()` method is needed, the {@link share} operator should be used instead:\n   * `new ConnectableObservable(source, factory).refCount()` is equivalent to\n   * `source.pipe(share({ connector: factory }))`.\n   * Details: https://rxjs.dev/deprecations/multicasting\n   */\n  constructor(public source: Observable<T>, protected subjectFactory: () => Subject<T>) {\n    super();\n    // If we have lift, monkey patch that here. This is done so custom observable\n    // types will compose through multicast. Otherwise the resulting observable would\n    // simply be an instance of `ConnectableObservable`.\n    if (hasLift(source)) {\n      this.lift = source.lift;\n    }\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>) {\n    return this.getSubject().subscribe(subscriber);\n  }\n\n  protected getSubject(): Subject<T> {\n    const subject = this._subject;\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n    return this._subject!;\n  }\n\n  protected _teardown() {\n    this._refCount = 0;\n    const { _connection } = this;\n    this._subject = this._connection = null;\n    _connection?.unsubscribe();\n  }\n\n  /**\n   * @deprecated {@link ConnectableObservable} will be removed in v8. Use {@link connectable} instead.\n   * Details: https://rxjs.dev/deprecations/multicasting\n   */\n  connect(): Subscription {\n    let connection = this._connection;\n    if (!connection) {\n      connection = this._connection = new Subscription();\n      const subject = this.getSubject();\n      connection.add(\n        this.source.subscribe(\n          createOperatorSubscriber(\n            subject as any,\n            undefined,\n            () => {\n              this._teardown();\n              subject.complete();\n            },\n            (err) => {\n              this._teardown();\n              subject.error(err);\n            },\n            () => this._teardown()\n          )\n        )\n      );\n\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      }\n    }\n    return connection;\n  }\n\n  /**\n   * @deprecated {@link ConnectableObservable} will be removed in v8. Use the {@link share} operator instead.\n   * Details: https://rxjs.dev/deprecations/multicasting\n   */\n  refCount(): Observable<T> {\n    return higherOrderRefCount()(this) as Observable<T>;\n  }\n}\n", "import { TimestampProvider } from '../types';\n\ninterface PerformanceTimestampProvider extends TimestampProvider {\n  delegate: TimestampProvider | undefined;\n}\n\nexport const performanceTimestampProvider: PerformanceTimestampProvider = {\n  now() {\n    // Use the variable rather than `this` so that the function can be called\n    // without being bound to the provider.\n    return (performanceTimestampProvider.delegate || performance).now();\n  },\n  delegate: undefined,\n};\n", "import { Subscription } from '../Subscription';\n\ninterface AnimationFrameProvider {\n  schedule(callback: FrameRequestCallback): Subscription;\n  requestAnimationFrame: typeof requestAnimationFrame;\n  cancelAnimationFrame: typeof cancelAnimationFrame;\n  delegate:\n    | {\n        requestAnimationFrame: typeof requestAnimationFrame;\n        cancelAnimationFrame: typeof cancelAnimationFrame;\n      }\n    | undefined;\n}\n\nexport const animationFrameProvider: AnimationFrameProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  schedule(callback) {\n    let request = requestAnimationFrame;\n    let cancel: typeof cancelAnimationFrame | undefined = cancelAnimationFrame;\n    const { delegate } = animationFrameProvider;\n    if (delegate) {\n      request = delegate.requestAnimationFrame;\n      cancel = delegate.cancelAnimationFrame;\n    }\n    const handle = request((timestamp) => {\n      // Clear the cancel function. The request has been fulfilled, so\n      // attempting to cancel the request upon unsubscription would be\n      // pointless.\n      cancel = undefined;\n      callback(timestamp);\n    });\n    return new Subscription(() => cancel?.(handle));\n  },\n  requestAnimationFrame(...args) {\n    const { delegate } = animationFrameProvider;\n    return (delegate?.requestAnimationFrame || requestAnimationFrame)(...args);\n  },\n  cancelAnimationFrame(...args) {\n    const { delegate } = animationFrameProvider;\n    return (delegate?.cancelAnimationFrame || cancelAnimationFrame)(...args);\n  },\n  delegate: undefined,\n};\n", "import { Observable } from '../../Observable';\nimport { TimestampProvider } from '../../types';\nimport { performanceTimestampProvider } from '../../scheduler/performanceTimestampProvider';\nimport { animationFrameProvider } from '../../scheduler/animationFrameProvider';\n\n/**\n * An observable of animation frames\n *\n * Emits the amount of time elapsed since subscription and the timestamp on each animation frame.\n * Defaults to milliseconds provided to the requestAnimationFrame's callback. Does not end on its own.\n *\n * Every subscription will start a separate animation loop. Since animation frames are always scheduled\n * by the browser to occur directly before a repaint, scheduling more than one animation frame synchronously\n * should not be much different or have more overhead than looping over an array of events during\n * a single animation frame. However, if for some reason the developer would like to ensure the\n * execution of animation-related handlers are all executed during the same task by the engine,\n * the `share` operator can be used.\n *\n * This is useful for setting up animations with RxJS.\n *\n * ## Examples\n *\n * Tweening a div to move it on the screen\n *\n * ```ts\n * import { animationFrames, map, takeWhile, endWith } from 'rxjs';\n *\n * function tween(start: number, end: number, duration: number) {\n *   const diff = end - start;\n *   return animationFrames().pipe(\n *     // Figure out what percentage of time has passed\n *     map(({ elapsed }) => elapsed / duration),\n *     // Take the vector while less than 100%\n *     takeWhile(v => v < 1),\n *     // Finish with 100%\n *     endWith(1),\n *     // Calculate the distance traveled between start and end\n *     map(v => v * diff + start)\n *   );\n * }\n *\n * // Setup a div for us to move around\n * const div = document.createElement('div');\n * document.body.appendChild(div);\n * div.style.position = 'absolute';\n * div.style.width = '40px';\n * div.style.height = '40px';\n * div.style.backgroundColor = 'lime';\n * div.style.transform = 'translate3d(10px, 0, 0)';\n *\n * tween(10, 200, 4000).subscribe(x => {\n *   div.style.transform = `translate3d(${ x }px, 0, 0)`;\n * });\n * ```\n *\n * Providing a custom timestamp provider\n *\n * ```ts\n * import { animationFrames, TimestampProvider } from 'rxjs';\n *\n * // A custom timestamp provider\n * let now = 0;\n * const customTSProvider: TimestampProvider = {\n *   now() { return now++; }\n * };\n *\n * const source$ = animationFrames(customTSProvider);\n *\n * // Log increasing numbers 0...1...2... on every animation frame.\n * source$.subscribe(({ elapsed }) => console.log(elapsed));\n * ```\n *\n * @param timestampProvider An object with a `now` method that provides a numeric timestamp\n */\nexport function animationFrames(timestampProvider?: TimestampProvider) {\n  return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;\n}\n\n/**\n * Does the work of creating the observable for `animationFrames`.\n * @param timestampProvider The timestamp provider to use to create the observable\n */\nfunction animationFramesFactory(timestampProvider?: TimestampProvider) {\n  return new Observable<{ timestamp: number; elapsed: number }>((subscriber) => {\n    // If no timestamp provider is specified, use performance.now() - as it\n    // will return timestamps 'compatible' with those passed to the run\n    // callback and won't be affected by NTP adjustments, etc.\n    const provider = timestampProvider || performanceTimestampProvider;\n\n    // Capture the start time upon subscription, as the run callback can remain\n    // queued for a considerable period of time and the elapsed time should\n    // represent the time elapsed since subscription - not the time since the\n    // first rendered animation frame.\n    const start = provider.now();\n\n    let id = 0;\n    const run = () => {\n      if (!subscriber.closed) {\n        id = animationFrameProvider.requestAnimationFrame((timestamp: DOMHighResTimeStamp | number) => {\n          id = 0;\n          // Use the provider's timestamp to calculate the elapsed time. Note that\n          // this means - if the caller hasn't passed a provider - that\n          // performance.now() will be used instead of the timestamp that was\n          // passed to the run callback. The reason for this is that the timestamp\n          // passed to the callback can be earlier than the start time, as it\n          // represents the time at which the browser decided it would render any\n          // queued frames - and that time can be earlier the captured start time.\n          const now = provider.now();\n          subscriber.next({\n            timestamp: timestampProvider ? now : timestamp,\n            elapsed: now - start,\n          });\n          run();\n        });\n      }\n    };\n\n    run();\n\n    return () => {\n      if (id) {\n        animationFrameProvider.cancelAnimationFrame(id);\n      }\n    };\n  });\n}\n\n/**\n * In the common case, where the timestamp provided by the rAF API is used,\n * we use this shared observable to reduce overhead.\n */\nconst DEFAULT_ANIMATION_FRAMES = animationFramesFactory();\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface ObjectUnsubscribedError extends Error {}\n\nexport interface ObjectUnsubscribedErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): ObjectUnsubscribedError;\n}\n\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nexport const ObjectUnsubscribedError: ObjectUnsubscribedErrorCtor = createErrorClass(\n  (_super) =>\n    function ObjectUnsubscribedErrorImpl(this: any) {\n      _super(this);\n      this.name = 'ObjectUnsubscribedError';\n      this.message = 'object unsubscribed';\n    }\n);\n", "import { Operator } from './Operator';\nimport { Observable } from './Observable';\nimport { Subscriber } from './Subscriber';\nimport { Subscription, EMPTY_SUBSCRIPTION } from './Subscription';\nimport { Observer, SubscriptionLike, TeardownLogic } from './types';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { arrRemove } from './util/arrRemove';\nimport { errorContext } from './util/errorContext';\n\n/**\n * A Subject is a special type of Observable that allows values to be\n * multicasted to many Observers. Subjects are like EventEmitters.\n *\n * Every Subject is an Observable and an Observer. You can subscribe to a\n * Subject, and you can call next to feed values as well as error and complete.\n */\nexport class Subject<T> extends Observable<T> implements SubscriptionLike {\n  closed = false;\n\n  private currentObservers: Observer<T>[] | null = null;\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  observers: Observer<T>[] = [];\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  isStopped = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  hasError = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  thrownError: any = null;\n\n  /**\n   * Creates a \"subject\" by basically gluing an observer to an observable.\n   *\n   * @deprecated Recommended you do not use. Will be removed at some point in the future. Plans for replacement still under discussion.\n   */\n  static create: (...args: any[]) => any = <T>(destination: Observer<T>, source: Observable<T>): AnonymousSubject<T> => {\n    return new AnonymousSubject<T>(destination, source);\n  };\n\n  constructor() {\n    // NOTE: This must be here to obscure Observable's constructor.\n    super();\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const subject = new AnonymousSubject(this, this);\n    subject.operator = operator as any;\n    return subject as any;\n  }\n\n  /** @internal */\n  protected _throwIfClosed() {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n  }\n\n  next(value: T) {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        if (!this.currentObservers) {\n          this.currentObservers = Array.from(this.observers);\n        }\n        for (const observer of this.currentObservers) {\n          observer.next(value);\n        }\n      }\n    });\n  }\n\n  error(err: any) {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        this.hasError = this.isStopped = true;\n        this.thrownError = err;\n        const { observers } = this;\n        while (observers.length) {\n          observers.shift()!.error(err);\n        }\n      }\n    });\n  }\n\n  complete() {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        this.isStopped = true;\n        const { observers } = this;\n        while (observers.length) {\n          observers.shift()!.complete();\n        }\n      }\n    });\n  }\n\n  unsubscribe() {\n    this.isStopped = this.closed = true;\n    this.observers = this.currentObservers = null!;\n  }\n\n  get observed() {\n    return this.observers?.length > 0;\n  }\n\n  /** @internal */\n  protected _trySubscribe(subscriber: Subscriber<T>): TeardownLogic {\n    this._throwIfClosed();\n    return super._trySubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._throwIfClosed();\n    this._checkFinalizedStatuses(subscriber);\n    return this._innerSubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _innerSubscribe(subscriber: Subscriber<any>) {\n    const { hasError, isStopped, observers } = this;\n    if (hasError || isStopped) {\n      return EMPTY_SUBSCRIPTION;\n    }\n    this.currentObservers = null;\n    observers.push(subscriber);\n    return new Subscription(() => {\n      this.currentObservers = null;\n      arrRemove(observers, subscriber);\n    });\n  }\n\n  /** @internal */\n  protected _checkFinalizedStatuses(subscriber: Subscriber<any>) {\n    const { hasError, thrownError, isStopped } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (isStopped) {\n      subscriber.complete();\n    }\n  }\n\n  /**\n   * Creates a new Observable with this Subject as the source. You can do this\n   * to create custom Observer-side logic of the Subject and conceal it from\n   * code that uses the Observable.\n   * @return Observable that this Subject casts to.\n   */\n  asObservable(): Observable<T> {\n    const observable: any = new Observable<T>();\n    observable.source = this;\n    return observable;\n  }\n}\n\nexport class AnonymousSubject<T> extends Subject<T> {\n  constructor(\n    /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n    public destination?: Observer<T>,\n    source?: Observable<T>\n  ) {\n    super();\n    this.source = source;\n  }\n\n  next(value: T) {\n    this.destination?.next?.(value);\n  }\n\n  error(err: any) {\n    this.destination?.error?.(err);\n  }\n\n  complete() {\n    this.destination?.complete?.();\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    return this.source?.subscribe(subscriber) ?? EMPTY_SUBSCRIPTION;\n  }\n}\n", "import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\n\n/**\n * A variant of Subject that requires an initial value and emits its current\n * value whenever it is subscribed to.\n */\nexport class BehaviorSubject<T> extends Subject<T> {\n  constructor(private _value: T) {\n    super();\n  }\n\n  get value(): T {\n    return this.getValue();\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    const subscription = super._subscribe(subscriber);\n    !subscription.closed && subscriber.next(this._value);\n    return subscription;\n  }\n\n  getValue(): T {\n    const { hasError, thrownError, _value } = this;\n    if (hasError) {\n      throw thrownError;\n    }\n    this._throwIfClosed();\n    return _value;\n  }\n\n  next(value: T): void {\n    super.next((this._value = value));\n  }\n}\n", "import { TimestampProvider } from '../types';\n\ninterface DateTimestampProvider extends TimestampProvider {\n  delegate: TimestampProvider | undefined;\n}\n\nexport const dateTimestampProvider: DateTimestampProvider = {\n  now() {\n    // Use the variable rather than `this` so that the function can be called\n    // without being bound to the provider.\n    return (dateTimestampProvider.delegate || Date).now();\n  },\n  delegate: undefined,\n};\n", "import { Subject } from './Subject';\nimport { TimestampProvider } from './types';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\n\n/**\n * A variant of {@link Subject} that \"replays\" old values to new subscribers by emitting them when they first subscribe.\n *\n * `ReplaySubject` has an internal buffer that will store a specified number of values that it has observed. Like `Subject`,\n * `ReplaySubject` \"observes\" values by having them passed to its `next` method. When it observes a value, it will store that\n * value for a time determined by the configuration of the `ReplaySubject`, as passed to its constructor.\n *\n * When a new subscriber subscribes to the `ReplaySubject` instance, it will synchronously emit all values in its buffer in\n * a First-In-First-Out (FIFO) manner. The `ReplaySubject` will also complete, if it has observed completion; and it will\n * error if it has observed an error.\n *\n * There are two main configuration items to be concerned with:\n *\n * 1. `bufferSize` - This will determine how many items are stored in the buffer, defaults to infinite.\n * 2. `windowTime` - The amount of time to hold a value in the buffer before removing it from the buffer.\n *\n * Both configurations may exist simultaneously. So if you would like to buffer a maximum of 3 values, as long as the values\n * are less than 2 seconds old, you could do so with a `new ReplaySubject(3, 2000)`.\n *\n * ### Differences with BehaviorSubject\n *\n * `BehaviorSubject` is similar to `new ReplaySubject(1)`, with a couple of exceptions:\n *\n * 1. `BehaviorSubject` comes \"primed\" with a single value upon construction.\n * 2. `ReplaySubject` will replay values, even after observing an error, where `BehaviorSubject` will not.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n * @see {@link shareReplay}\n */\nexport class ReplaySubject<T> extends Subject<T> {\n  private _buffer: (T | number)[] = [];\n  private _infiniteTimeWindow = true;\n\n  /**\n   * @param _bufferSize The size of the buffer to replay on subscription\n   * @param _windowTime The amount of time the buffered items will stay buffered\n   * @param _timestampProvider An object with a `now()` method that provides the current timestamp. This is used to\n   * calculate the amount of time something has been buffered.\n   */\n  constructor(\n    private _bufferSize = Infinity,\n    private _windowTime = Infinity,\n    private _timestampProvider: TimestampProvider = dateTimestampProvider\n  ) {\n    super();\n    this._infiniteTimeWindow = _windowTime === Infinity;\n    this._bufferSize = Math.max(1, _bufferSize);\n    this._windowTime = Math.max(1, _windowTime);\n  }\n\n  next(value: T): void {\n    const { isStopped, _buffer, _infiniteTimeWindow, _timestampProvider, _windowTime } = this;\n    if (!isStopped) {\n      _buffer.push(value);\n      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);\n    }\n    this._trimBuffer();\n    super.next(value);\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._throwIfClosed();\n    this._trimBuffer();\n\n    const subscription = this._innerSubscribe(subscriber);\n\n    const { _infiniteTimeWindow, _buffer } = this;\n    // We use a copy here, so reentrant code does not mutate our array while we're\n    // emitting it to a new subscriber.\n    const copy = _buffer.slice();\n    for (let i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {\n      subscriber.next(copy[i] as T);\n    }\n\n    this._checkFinalizedStatuses(subscriber);\n\n    return subscription;\n  }\n\n  private _trimBuffer() {\n    const { _bufferSize, _timestampProvider, _buffer, _infiniteTimeWindow } = this;\n    // If we don't have an infinite buffer size, and we're over the length,\n    // use splice to truncate the old buffer values off. Note that we have to\n    // double the size for instances where we're not using an infinite time window\n    // because we're storing the values and the timestamps in the same array.\n    const adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;\n    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);\n\n    // Now, if we're not in an infinite time window, remove all values where the time is\n    // older than what is allowed.\n    if (!_infiniteTimeWindow) {\n      const now = _timestampProvider.now();\n      let last = 0;\n      // Search the array for the first timestamp that isn't expired and\n      // truncate the buffer up to that point.\n      for (let i = 1; i < _buffer.length && (_buffer[i] as number) <= now; i += 2) {\n        last = i;\n      }\n      last && _buffer.splice(0, last + 1);\n    }\n  }\n}\n", "import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\n\n/**\n * A variant of Subject that only emits a value when it completes. It will emit\n * its latest value to all its observers on completion.\n */\nexport class AsyncSubject<T> extends Subject<T> {\n  private _value: T | null = null;\n  private _hasValue = false;\n  private _isComplete = false;\n\n  /** @internal */\n  protected _checkFinalizedStatuses(subscriber: Subscriber<T>) {\n    const { hasError, _hasValue, _value, thrownError, isStopped, _isComplete } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (isStopped || _isComplete) {\n      _hasValue && subscriber.next(_value!);\n      subscriber.complete();\n    }\n  }\n\n  next(value: T): void {\n    if (!this.isStopped) {\n      this._value = value;\n      this._hasValue = true;\n    }\n  }\n\n  complete(): void {\n    const { _hasValue, _value, _isComplete } = this;\n    if (!_isComplete) {\n      this._isComplete = true;\n      _hasValue && super.next(_value!);\n      super.complete();\n    }\n  }\n}\n", "import { Scheduler } from '../Scheduler';\nimport { Subscription } from '../Subscription';\nimport { SchedulerAction } from '../types';\n\n/**\n * A unit of work to be executed in a `scheduler`. An action is typically\n * created from within a {@link SchedulerLike} and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n */\nexport class Action<T> extends Subscription {\n  constructor(scheduler: Scheduler, work: (this: SchedulerAction<T>, state?: T) => void) {\n    super();\n  }\n  /**\n   * Schedules this action on its parent {@link SchedulerLike} for execution. May be passed\n   * some context object, `state`. May happen at some point in the future,\n   * according to the `delay` parameter, if specified.\n   * @param state Some contextual data that the `work` function uses when called by the\n   * Scheduler.\n   * @param delay Time to wait before executing the work, where the time unit is implicit\n   * and defined by the Scheduler.\n   * @return A subscription in order to be able to unsubscribe the scheduled work.\n   */\n  public schedule(state?: T, delay: number = 0): Subscription {\n    return this;\n  }\n}\n", "import type { TimerHandle } from './timerHandle';\ntype SetIntervalFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\ntype ClearIntervalFunction = (handle: TimerHandle) => void;\n\ninterface IntervalProvider {\n  setInterval: SetIntervalFunction;\n  clearInterval: ClearIntervalFunction;\n  delegate:\n    | {\n        setInterval: SetIntervalFunction;\n        clearInterval: ClearIntervalFunction;\n      }\n    | undefined;\n}\n\nexport const intervalProvider: IntervalProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setInterval(handler: () => void, timeout?: number, ...args) {\n    const { delegate } = intervalProvider;\n    if (delegate?.setInterval) {\n      return delegate.setInterval(handler, timeout, ...args);\n    }\n    return setInterval(handler, timeout, ...args);\n  },\n  clearInterval(handle) {\n    const { delegate } = intervalProvider;\n    return (delegate?.clearInterval || clearInterval)(handle as any);\n  },\n  delegate: undefined,\n};\n", "import { Action } from './Action';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { intervalProvider } from './intervalProvider';\nimport { arrRemove } from '../util/arrRemove';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsyncAction<T> extends Action<T> {\n  public id: TimerHandle | undefined;\n  public state?: T;\n  // @ts-ignore: Property has no initializer and is not definitely assigned\n  public delay: number;\n  protected pending: boolean = false;\n\n  constructor(protected scheduler: AsyncScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (this.closed) {\n      return this;\n    }\n\n    // Always replace the current state with the new state.\n    this.state = state;\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n\n    //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n    this.pending = true;\n\n    this.delay = delay;\n    // If this action has already an async Id, don't request a new one.\n    this.id = this.id ?? this.requestAsyncId(scheduler, this.id, delay);\n\n    return this;\n  }\n\n  protected requestAsyncId(scheduler: AsyncScheduler, _id?: TimerHandle, delay: number = 0): TimerHandle {\n    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);\n  }\n\n  protected recycleAsyncId(_scheduler: AsyncScheduler, id?: TimerHandle, delay: number | null = 0): TimerHandle | undefined {\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\n    if (delay != null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n    if (id != null) {\n      intervalProvider.clearInterval(id);\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Immediately executes this action and the `work` it contains.\n   */\n  public execute(state: T, delay: number): any {\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n\n  protected _execute(state: T, _delay: number): any {\n    let errored: boolean = false;\n    let errorValue: any;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      // HACK: Since code elsewhere is relying on the \"truthiness\" of the\n      // return here, we can't have it return \"\" or 0 or false.\n      // TODO: Clean this up when we refactor schedulers mid-version-8 or so.\n      errorValue = e ? e : new Error('Scheduled action threw falsy error');\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n\n  unsubscribe() {\n    if (!this.closed) {\n      const { id, scheduler } = this;\n      const { actions } = scheduler;\n\n      this.work = this.state = this.scheduler = null!;\n      this.pending = false;\n\n      arrRemove(actions, this);\n      if (id != null) {\n        this.id = this.recycleAsyncId(scheduler, id, null);\n      }\n\n      this.delay = null!;\n      super.unsubscribe();\n    }\n  }\n}\n", "let nextHandle = 1;\n// The promise needs to be created lazily otherwise it won't be patched by Zones\nlet resolved: Promise<any>;\nconst activeHandles: { [key: number]: any } = {};\n\n/**\n * Finds the handle in the list of active handles, and removes it.\n * Returns `true` if found, `false` otherwise. Used both to clear\n * Immediate scheduled tasks, and to identify if a task should be scheduled.\n */\nfunction findAndClearHandle(handle: number): boolean {\n  if (handle in activeHandles) {\n    delete activeHandles[handle];\n    return true;\n  }\n  return false;\n}\n\n/**\n * Helper functions to schedule and unschedule microtasks.\n */\nexport const Immediate = {\n  setImmediate(cb: () => void): number {\n    const handle = nextHandle++;\n    activeHandles[handle] = true;\n    if (!resolved) {\n      resolved = Promise.resolve();\n    }\n    resolved.then(() => findAndClearHandle(handle) && cb());\n    return handle;\n  },\n\n  clearImmediate(handle: number): void {\n    findAndClearHandle(handle);\n  },\n};\n\n/**\n * Used for internal testing purposes only. Do not export from library.\n */\nexport const TestTools = {\n  pending() {\n    return Object.keys(activeHandles).length;\n  }\n};\n", "import { Immediate } from '../util/Immediate';\nimport type { TimerHandle } from './timerHandle';\nconst { setImmediate, clearImmediate } = Immediate;\n\ntype SetImmediateFunction = (handler: () => void, ...args: any[]) => TimerHandle;\ntype ClearImmediateFunction = (handle: TimerHandle) => void;\n\ninterface ImmediateProvider {\n  setImmediate: SetImmediateFunction;\n  clearImmediate: ClearImmediateFunction;\n  delegate:\n    | {\n        setImmediate: SetImmediateFunction;\n        clearImmediate: ClearImmediateFunction;\n      }\n    | undefined;\n}\n\nexport const immediateProvider: ImmediateProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setImmediate(...args) {\n    const { delegate } = immediateProvider;\n    return (delegate?.setImmediate || setImmediate)(...args);\n  },\n  clearImmediate(handle) {\n    const { delegate } = immediateProvider;\n    return (delegate?.clearImmediate || clearImmediate)(handle as any);\n  },\n  delegate: undefined,\n};\n", "import { AsyncAction } from './AsyncAction';\nimport { AsapScheduler } from './AsapScheduler';\nimport { SchedulerAction } from '../types';\nimport { immediateProvider } from './immediateProvider';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsapAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: AsapScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If a microtask has already been scheduled, don't schedule another\n    // one. If a microtask hasn't been scheduled yet, schedule one now. Return\n    // the current scheduled microtask id.\n    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));\n  }\n\n  protected recycleAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle | undefined {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if (delay != null ? delay > 0 : this.delay > 0) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue has no remaining actions with the same async id,\n    // cancel the requested microtask and set the scheduled flag to undefined\n    // so the next AsapAction will request its own.\n    const { actions } = scheduler;\n    if (id != null && actions[actions.length - 1]?.id !== id) {\n      immediateProvider.clearImmediate(id);\n      if (scheduler._scheduled === id) {\n        scheduler._scheduled = undefined;\n      }\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n", "import { Action } from './scheduler/Action';\nimport { Subscription } from './Subscription';\nimport { SchedulerLike, SchedulerAction } from './types';\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\n\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an `Action`.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @deprecated Scheduler is an internal implementation detail of RxJS, and\n * should not be used directly. Rather, create your own class and implement\n * {@link SchedulerLike}. Will be made internal in v8.\n */\nexport class Scheduler implements SchedulerLike {\n  public static now: () => number = dateTimestampProvider.now;\n\n  constructor(private schedulerActionCtor: typeof Action, now: () => number = Scheduler.now) {\n    this.now = now;\n  }\n\n  /**\n   * A getter method that returns a number representing the current time\n   * (at the time this function was called) according to the scheduler's own\n   * internal clock.\n   * @return A number that represents the current time. May or may not\n   * have a relation to wall-clock time. May or may not refer to a time unit\n   * (e.g. milliseconds).\n   */\n  public now: () => number;\n\n  /**\n   * Schedules a function, `work`, for execution. May happen at some point in\n   * the future, according to the `delay` parameter, if specified. May be passed\n   * some context object, `state`, which will be passed to the `work` function.\n   *\n   * The given arguments will be processed an stored as an Action object in a\n   * queue of actions.\n   *\n   * @param work A function representing a task, or some unit of work to be\n   * executed by the Scheduler.\n   * @param delay Time to wait before executing the work, where the time unit is\n   * implicit and defined by the Scheduler itself.\n   * @param state Some contextual data that the `work` function uses when called\n   * by the Scheduler.\n   * @return A subscription in order to be able to unsubscribe the scheduled work.\n   */\n  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    return new this.schedulerActionCtor<T>(this, work).schedule(state, delay);\n  }\n}\n", "import { Scheduler } from '../Scheduler';\nimport { Action } from './Action';\nimport { AsyncAction } from './AsyncAction';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsyncScheduler extends Scheduler {\n  public actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @internal\n   */\n  public _active: boolean = false;\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @internal\n   */\n  public _scheduled: TimerHandle | undefined;\n\n  constructor(SchedulerAction: typeof Action, now: () => number = Scheduler.now) {\n    super(SchedulerAction, now);\n  }\n\n  public flush(action: AsyncAction<any>): void {\n    const { actions } = this;\n\n    if (this._active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this._active = true;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions.shift()!)); // exhaust the scheduler queue\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions.shift()!)) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n", "import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\nexport class AsapScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n    this._active = true;\n    // The async id that effects a call to flush is stored in _scheduled.\n    // Before executing an action, it's necessary to check the action's async\n    // id to determine whether it's supposed to be executed in the current\n    // flush.\n    // Previous implementations of this method used a count to determine this,\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\n    // are removed from the actions array and that can shift actions that are\n    // scheduled to be executed in a subsequent flush into positions at which\n    // they are executed within the current flush.\n    const flushId = this._scheduled;\n    this._scheduled = undefined;\n\n    const { actions } = this;\n    let error: any;\n    action = action || actions.shift()!;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n", "import { AsapAction } from './AsapAction';\nimport { AsapScheduler } from './AsapScheduler';\n\n/**\n *\n * Asap Scheduler\n *\n * <span class=\"informal\">Perform task as fast as it can be performed asynchronously</span>\n *\n * `asap` scheduler behaves the same as {@link asyncScheduler} scheduler when you use it to delay task\n * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing\n * code to end and then it will try to execute given task as fast as possible.\n *\n * `asap` scheduler will do its best to minimize time between end of currently executing code\n * and start of scheduled task. This makes it best candidate for performing so called \"deferring\".\n * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves\n * some (although minimal) unwanted delay.\n *\n * Note that using `asap` scheduler does not necessarily mean that your task will be first to process\n * after currently executing code. In particular, if some task was also scheduled with `asap` before,\n * that task will execute first. That being said, if you need to schedule task asynchronously, but\n * as soon as possible, `asap` scheduler is your best bet.\n *\n * ## Example\n * Compare async and asap scheduler<\n * ```ts\n * import { asapScheduler, asyncScheduler } from 'rxjs';\n *\n * asyncScheduler.schedule(() => console.log('async')); // scheduling 'async' first...\n * asapScheduler.schedule(() => console.log('asap'));\n *\n * // Logs:\n * // \"asap\"\n * // \"async\"\n * // ... but 'asap' goes first!\n * ```\n */\n\nexport const asapScheduler = new AsapScheduler(AsapAction);\n\n/**\n * @deprecated Renamed to {@link asapScheduler}. Will be removed in v8.\n */\nexport const asap = asapScheduler;\n", "import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asapScheduler} scheduler.\n *\n * ## Examples\n * Use async scheduler to delay task\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * const task = () => console.log('it works!');\n *\n * asyncScheduler.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n * ```\n *\n * Use async scheduler to repeat task in intervals\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * asyncScheduler.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n * ```\n */\n\nexport const asyncScheduler = new AsyncScheduler(AsyncAction);\n\n/**\n * @deprecated Renamed to {@link asyncScheduler}. Will be removed in v8.\n */\nexport const async = asyncScheduler;\n", "import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { QueueScheduler } from './QueueScheduler';\nimport { SchedulerAction } from '../types';\nimport { TimerHandle } from './timerHandle';\n\nexport class QueueAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: QueueScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (delay > 0) {\n      return super.schedule(state, delay);\n    }\n    this.delay = delay;\n    this.state = state;\n    this.scheduler.flush(this);\n    return this;\n  }\n\n  public execute(state: T, delay: number): any {\n    return delay > 0 || this.closed ? super.execute(state, delay) : this._execute(state, delay);\n  }\n\n  protected requestAsyncId(scheduler: QueueScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n\n    if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n\n    // Otherwise flush the scheduler starting with this action.\n    scheduler.flush(this);\n\n    // HACK: In the past, this was returning `void`. However, `void` isn't a valid\n    // `TimerHandle`, and generally the return value here isn't really used. So the\n    // compromise is to return `0` which is both \"falsy\" and a valid `TimerHandle`,\n    // as opposed to refactoring every other instanceo of `requestAsyncId`.\n    return 0;\n  }\n}\n", "import { AsyncScheduler } from './AsyncScheduler';\n\nexport class QueueScheduler extends AsyncScheduler {\n}\n", "import { QueueAction } from './QueueAction';\nimport { QueueScheduler } from './QueueScheduler';\n\n/**\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queue` scheduler, when used with delay, behaves the same as {@link asyncScheduler} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queue` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * ## Examples\n * Schedule recursively first, then do something\n * ```ts\n * import { queueScheduler } from 'rxjs';\n *\n * queueScheduler.schedule(() => {\n *   queueScheduler.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n * ```\n *\n * Reschedule itself recursively\n * ```ts\n * import { queueScheduler } from 'rxjs';\n *\n * queueScheduler.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n * ```\n */\n\nexport const queueScheduler = new QueueScheduler(QueueAction);\n\n/**\n * @deprecated Renamed to {@link queueScheduler}. Will be removed in v8.\n */\nexport const queue = queueScheduler;\n", "import { AsyncAction } from './AsyncAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\nimport { SchedulerAction } from '../types';\nimport { animationFrameProvider } from './animationFrameProvider';\nimport { TimerHandle } from './timerHandle';\n\nexport class AnimationFrameAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: AnimationFrameScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AnimationFrameScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If an animation frame has already been requested, don't request another\n    // one. If an animation frame hasn't been requested yet, request one. Return\n    // the current animation frame request id.\n    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(() => scheduler.flush(undefined)));\n  }\n\n  protected recycleAsyncId(scheduler: AnimationFrameScheduler, id?: TimerHandle, delay: number = 0): TimerHandle | undefined {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if (delay != null ? delay > 0 : this.delay > 0) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue has no remaining actions with the same async id,\n    // cancel the requested animation frame and set the scheduled flag to\n    // undefined so the next AnimationFrameAction will request its own.\n    const { actions } = scheduler;\n    if (id != null && id === scheduler._scheduled && actions[actions.length - 1]?.id !== id) {\n      animationFrameProvider.cancelAnimationFrame(id as number);\n      scheduler._scheduled = undefined;\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n", "import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\nexport class AnimationFrameScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n    this._active = true;\n    // The async id that effects a call to flush is stored in _scheduled.\n    // Before executing an action, it's necessary to check the action's async\n    // id to determine whether it's supposed to be executed in the current\n    // flush.\n    // Previous implementations of this method used a count to determine this,\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\n    // are removed from the actions array and that can shift actions that are\n    // scheduled to be executed in a subsequent flush into positions at which\n    // they are executed within the current flush.\n    let flushId;\n    if (action) {\n      flushId = action.id;\n    } else {\n      flushId = this._scheduled;\n      this._scheduled = undefined;\n    }\n\n    const { actions } = this;\n    let error: any;\n    action = action || actions.shift()!;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n", "import { AnimationFrameAction } from './AnimationFrameAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\n\n/**\n *\n * Animation Frame Scheduler\n *\n * <span class=\"informal\">Perform task when `window.requestAnimationFrame` would fire</span>\n *\n * When `animationFrame` scheduler is used with delay, it will fall back to {@link asyncScheduler} scheduler\n * behaviour.\n *\n * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.\n * It makes sure scheduled task will happen just before next browser content repaint,\n * thus performing animations as efficiently as possible.\n *\n * ## Example\n * Schedule div height animation\n * ```ts\n * // html: <div style=\"background: #0ff;\"></div>\n * import { animationFrameScheduler } from 'rxjs';\n *\n * const div = document.querySelector('div');\n *\n * animationFrameScheduler.schedule(function(height) {\n *   div.style.height = height + \"px\";\n *\n *   this.schedule(height + 1);  // `this` references currently executing Action,\n *                               // which we reschedule with new state\n * }, 0, 0);\n *\n * // You will see a div element growing in height\n * ```\n */\n\nexport const animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);\n\n/**\n * @deprecated Renamed to {@link animationFrameScheduler}. Will be removed in v8.\n */\nexport const animationFrame = animationFrameScheduler;\n", "import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { SchedulerAction } from '../types';\nimport { TimerHandle } from './timerHandle';\n\nexport class VirtualTimeScheduler extends AsyncScheduler {\n  /** @deprecated Not used in VirtualTimeScheduler directly. Will be removed in v8. */\n  static frameTimeFactor = 10;\n\n  /**\n   * The current frame for the state of the virtual scheduler instance. The difference\n   * between two \"frames\" is synonymous with the passage of \"virtual time units\". So if\n   * you record `scheduler.frame` to be `1`, then later, observe `scheduler.frame` to be at `11`,\n   * that means `10` virtual time units have passed.\n   */\n  public frame: number = 0;\n\n  /**\n   * Used internally to examine the current virtual action index being processed.\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  public index: number = -1;\n\n  /**\n   * This creates an instance of a `VirtualTimeScheduler`. Experts only. The signature of\n   * this constructor is likely to change in the long run.\n   *\n   * @param schedulerActionCtor The type of Action to initialize when initializing actions during scheduling.\n   * @param maxFrames The maximum number of frames to process before stopping. Used to prevent endless flush cycles.\n   */\n  constructor(schedulerActionCtor: typeof AsyncAction = VirtualAction as any, public maxFrames: number = Infinity) {\n    super(schedulerActionCtor, () => this.frame);\n  }\n\n  /**\n   * Prompt the Scheduler to execute all of its queued actions, therefore\n   * clearing its queue.\n   */\n  public flush(): void {\n    const { actions, maxFrames } = this;\n    let error: any;\n    let action: AsyncAction<any> | undefined;\n\n    while ((action = actions[0]) && action.delay <= maxFrames) {\n      actions.shift();\n      this.frame = action.delay;\n\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    }\n\n    if (error) {\n      while ((action = actions.shift())) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n\nexport class VirtualAction<T> extends AsyncAction<T> {\n  protected active: boolean = true;\n\n  constructor(\n    protected scheduler: VirtualTimeScheduler,\n    protected work: (this: SchedulerAction<T>, state?: T) => void,\n    protected index: number = (scheduler.index += 1)\n  ) {\n    super(scheduler, work);\n    this.index = scheduler.index = index;\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (Number.isFinite(delay)) {\n      if (!this.id) {\n        return super.schedule(state, delay);\n      }\n      this.active = false;\n      // If an action is rescheduled, we save allocations by mutating its state,\n      // pushing it to the end of the scheduler queue, and recycling the action.\n      // But since the VirtualTimeScheduler is used for testing, VirtualActions\n      // must be immutable so they can be inspected later.\n      const action = new VirtualAction(this.scheduler, this.work);\n      this.add(action);\n      return action.schedule(state, delay);\n    } else {\n      // If someone schedules something with Infinity, it'll never happen. So we\n      // don't even schedule it.\n      return Subscription.EMPTY;\n    }\n  }\n\n  protected requestAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): TimerHandle {\n    this.delay = scheduler.frame + delay;\n    const { actions } = scheduler;\n    actions.push(this);\n    (actions as Array<VirtualAction<T>>).sort(VirtualAction.sortActions);\n    return 1;\n  }\n\n  protected recycleAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): TimerHandle | undefined {\n    return undefined;\n  }\n\n  protected _execute(state: T, delay: number): any {\n    if (this.active === true) {\n      return super._execute(state, delay);\n    }\n  }\n\n  private static sortActions<T>(a: VirtualAction<T>, b: VirtualAction<T>) {\n    if (a.delay === b.delay) {\n      if (a.index === b.index) {\n        return 0;\n      } else if (a.index > b.index) {\n        return 1;\n      } else {\n        return -1;\n      }\n    } else if (a.delay > b.delay) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n}\n", "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n\n/**\n * A simple Observable that emits no items to the Observer and immediately\n * emits a complete notification.\n *\n * <span class=\"informal\">Just emits 'complete', and nothing else.</span>\n *\n * ![](empty.png)\n *\n * A simple Observable that only emits the complete notification. It can be used\n * for composing with other Observables, such as in a {@link mergeMap}.\n *\n * ## Examples\n *\n * Log complete notification\n *\n * ```ts\n * import { EMPTY } from 'rxjs';\n *\n * EMPTY.subscribe({\n *   next: () => console.log('Next'),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Outputs\n * // Complete!\n * ```\n *\n * Emit the number 7, then complete\n *\n * ```ts\n * import { EMPTY, startWith } from 'rxjs';\n *\n * const result = EMPTY.pipe(startWith(7));\n * result.subscribe(x => console.log(x));\n *\n * // Outputs\n * // 7\n * ```\n *\n * Map and flatten only odd numbers to the sequence `'a'`, `'b'`, `'c'`\n *\n * ```ts\n * import { interval, mergeMap, of, EMPTY } from 'rxjs';\n *\n * const interval$ = interval(1000);\n * const result = interval$.pipe(\n *   mergeMap(x => x % 2 === 1 ? of('a', 'b', 'c') : EMPTY),\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following to the console:\n * // x is equal to the count on the interval, e.g. (0, 1, 2, 3, ...)\n * // x will occur every 1000ms\n * // if x % 2 is equal to 1, print a, b, c (each on its own)\n * // if x % 2 is not equal to 1, nothing will be output\n * ```\n *\n * @see {@link Observable}\n * @see {@link NEVER}\n * @see {@link of}\n * @see {@link throwError}\n */\nexport const EMPTY = new Observable<never>((subscriber) => subscriber.complete());\n\n/**\n * @param scheduler A {@link SchedulerLike} to use for scheduling\n * the emission of the complete notification.\n * @deprecated Replaced with the {@link EMPTY} constant or {@link scheduled} (e.g. `scheduled([], scheduler)`). Will be removed in v8.\n */\nexport function empty(scheduler?: SchedulerLike) {\n  return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\n\nfunction emptyScheduled(scheduler: SchedulerLike) {\n  return new Observable<never>((subscriber) => scheduler.schedule(() => subscriber.complete()));\n}\n", "import { SchedulerLike } from '../types';\nimport { isFunction } from './isFunction';\n\nexport function isScheduler(value: any): value is SchedulerLike {\n  return value && isFunction(value.schedule);\n}\n", "import { SchedulerLike } from '../types';\nimport { isFunction } from './isFunction';\nimport { isScheduler } from './isScheduler';\n\nfunction last<T>(arr: T[]): T | undefined {\n  return arr[arr.length - 1];\n}\n\nexport function popResultSelector(args: any[]): ((...args: unknown[]) => unknown) | undefined {\n  return isFunction(last(args)) ? args.pop() : undefined;\n}\n\nexport function popScheduler(args: any[]): SchedulerLike | undefined {\n  return isScheduler(last(args)) ? args.pop() : undefined;\n}\n\nexport function popNumber(args: any[], defaultValue: number): number {\n  return typeof last(args) === 'number' ? args.pop()! : defaultValue;\n}\n", "export const isArrayLike = (<T>(x: any): x is ArrayLike<T> => x && typeof x.length === 'number' && typeof x !== 'function');", "import { isFunction } from \"./isFunction\";\n\n/**\n * Tests to see if the object is \"thennable\".\n * @param value the object to test\n */\nexport function isPromise(value: any): value is PromiseLike<any> {\n  return isFunction(value?.then);\n}\n", "import { InteropObservable } from '../types';\nimport { observable as Symbol_observable } from '../symbol/observable';\nimport { isFunction } from './isFunction';\n\n/** Identifies an input as being Observable (but not necessary an Rx Observable) */\nexport function isInteropObservable(input: any): input is InteropObservable<any> {\n  return isFunction(input[Symbol_observable]);\n}\n", "import { isFunction } from './isFunction';\n\nexport function isAsyncIterable<T>(obj: any): obj is AsyncIterable<T> {\n  return Symbol.asyncIterator && isFunction(obj?.[Symbol.asyncIterator]);\n}\n", "/**\n * Creates the TypeError to throw if an invalid object is passed to `from` or `scheduled`.\n * @param input The object that was passed.\n */\nexport function createInvalidObservableTypeError(input: any) {\n  // TODO: We should create error codes that can be looked up, so this can be less verbose.\n  return new TypeError(\n    `You provided ${\n      input !== null && typeof input === 'object' ? 'an invalid object' : `'${input}'`\n    } where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`\n  );\n}\n", "export function getSymbolIterator(): symbol {\n  if (typeof Symbol !== 'function' || !Symbol.iterator) {\n    return '@@iterator' as any;\n  }\n\n  return Symbol.iterator;\n}\n\nexport const iterator = getSymbolIterator();\n", "import { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from './isFunction';\n\n/** Identifies an input as being an Iterable */\nexport function isIterable(input: any): input is Iterable<any> {\n  return isFunction(input?.[Symbol_iterator]);\n}\n", "import { ReadableStreamLike } from '../types';\nimport { isFunction } from './isFunction';\n\nexport async function* readableStreamLikeToAsyncGenerator<T>(readableStream: ReadableStreamLike<T>): AsyncGenerator<T> {\n  const reader = readableStream.getReader();\n  try {\n    while (true) {\n      const { value, done } = await reader.read();\n      if (done) {\n        return;\n      }\n      yield value!;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nexport function isReadableStreamLike<T>(obj: any): obj is ReadableStreamLike<T> {\n  // We don't want to use instanceof checks because they would return\n  // false for instances from another Realm, like an <iframe>.\n  return isFunction(obj?.getReader);\n}\n", "import { isArrayLike } from '../util/isArrayLike';\nimport { isPromise } from '../util/isPromise';\nimport { Observable } from '../Observable';\nimport { ObservableInput, ObservedValueOf, ReadableStreamLike } from '../types';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isIterable } from '../util/isIterable';\nimport { isReadableStreamLike, readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\nimport { Subscriber } from '../Subscriber';\nimport { isFunction } from '../util/isFunction';\nimport { reportUnhandledError } from '../util/reportUnhandledError';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\nexport function innerFrom<O extends ObservableInput<any>>(input: O): Observable<ObservedValueOf<O>>;\nexport function innerFrom<T>(input: ObservableInput<T>): Observable<T> {\n  if (input instanceof Observable) {\n    return input;\n  }\n  if (input != null) {\n    if (isInteropObservable(input)) {\n      return fromInteropObservable(input);\n    }\n    if (isArrayLike(input)) {\n      return fromArrayLike(input);\n    }\n    if (isPromise(input)) {\n      return fromPromise(input);\n    }\n    if (isAsyncIterable(input)) {\n      return fromAsyncIterable(input);\n    }\n    if (isIterable(input)) {\n      return fromIterable(input);\n    }\n    if (isReadableStreamLike(input)) {\n      return fromReadableStreamLike(input);\n    }\n  }\n\n  throw createInvalidObservableTypeError(input);\n}\n\n/**\n * Creates an RxJS Observable from an object that implements `Symbol.observable`.\n * @param obj An object that properly implements `Symbol.observable`.\n */\nexport function fromInteropObservable<T>(obj: any) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    const obs = obj[Symbol_observable]();\n    if (isFunction(obs.subscribe)) {\n      return obs.subscribe(subscriber);\n    }\n    // Should be caught by observable subscribe function error handling.\n    throw new TypeError('Provided object does not correctly implement Symbol.observable');\n  });\n}\n\n/**\n * Synchronously emits the values of an array like and completes.\n * This is exported because there are creation functions and operators that need to\n * make direct use of the same logic, and there's no reason to make them run through\n * `from` conditionals because we *know* they're dealing with an array.\n * @param array The array to emit values from\n */\nexport function fromArrayLike<T>(array: ArrayLike<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    // Loop over the array and emit each value. Note two things here:\n    // 1. We're making sure that the subscriber is not closed on each loop.\n    //    This is so we don't continue looping over a very large array after\n    //    something like a `take`, `takeWhile`, or other synchronous unsubscription\n    //    has already unsubscribed.\n    // 2. In this form, reentrant code can alter that array we're looping over.\n    //    This is a known issue, but considered an edge case. The alternative would\n    //    be to copy the array before executing the loop, but this has\n    //    performance implications.\n    for (let i = 0; i < array.length && !subscriber.closed; i++) {\n      subscriber.next(array[i]);\n    }\n    subscriber.complete();\n  });\n}\n\nexport function fromPromise<T>(promise: PromiseLike<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    promise\n      .then(\n        (value) => {\n          if (!subscriber.closed) {\n            subscriber.next(value);\n            subscriber.complete();\n          }\n        },\n        (err: any) => subscriber.error(err)\n      )\n      .then(null, reportUnhandledError);\n  });\n}\n\nexport function fromIterable<T>(iterable: Iterable<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    for (const value of iterable) {\n      subscriber.next(value);\n      if (subscriber.closed) {\n        return;\n      }\n    }\n    subscriber.complete();\n  });\n}\n\nexport function fromAsyncIterable<T>(asyncIterable: AsyncIterable<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    process(asyncIterable, subscriber).catch((err) => subscriber.error(err));\n  });\n}\n\nexport function fromReadableStreamLike<T>(readableStream: ReadableStreamLike<T>) {\n  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));\n}\n\nasync function process<T>(asyncIterable: AsyncIterable<T>, subscriber: Subscriber<T>) {\n  for await (const value of asyncIterable) {\n    subscriber.next(value);\n    // A side-effect may have closed our subscriber,\n    // check before the next iteration.\n    if (subscriber.closed) {\n      return;\n    }\n  }\n  subscriber.complete();\n}\n", "import { Subscription } from '../Subscription';\nimport { SchedulerAction, SchedulerLike } from '../types';\n\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay: number,\n  repeat: true\n): void;\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay?: number,\n  repeat?: false\n): Subscription;\n\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay = 0,\n  repeat = false\n): Subscription | void {\n  const scheduleSubscription = scheduler.schedule(function (this: SchedulerAction<any>) {\n    work();\n    if (repeat) {\n      parentSubscription.add(this.schedule(null, delay));\n    } else {\n      this.unsubscribe();\n    }\n  }, delay);\n\n  parentSubscription.add(scheduleSubscription);\n\n  if (!repeat) {\n    // Because user-land scheduler implementations are unlikely to properly reuse\n    // Actions for repeat scheduling, we can't trust that the returned subscription\n    // will control repeat subscription scenarios. So we're trying to avoid using them\n    // incorrectly within this library.\n    return scheduleSubscription;\n  }\n}\n", "/** @prettier */\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * ## Example\n *\n * Ensure values in subscribe are called just before browser repaint\n *\n * ```ts\n * import { interval, observeOn, animationFrameScheduler } from 'rxjs';\n *\n * const someDiv = document.createElement('div');\n * someDiv.style.cssText = 'width: 200px;background: #09c';\n * document.body.appendChild(someDiv);\n * const intervals = interval(10);      // Intervals are scheduled\n *                                      // with async scheduler by default...\n * intervals.pipe(\n *   observeOn(animationFrameScheduler) // ...but we will observe on animationFrame\n * )                                    // scheduler to ensure smooth animation.\n * .subscribe(val => {\n *   someDiv.style.height = val + 'px';\n * });\n * ```\n *\n * @see {@link delay}\n *\n * @param scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param delay Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return A function that returns an Observable that emits the same\n * notifications as the source Observable, but with provided scheduler.\n */\nexport function observeOn<T>(scheduler: SchedulerLike, delay = 0): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => executeSchedule(subscriber, scheduler, () => subscriber.next(value), delay),\n        () => executeSchedule(subscriber, scheduler, () => subscriber.complete(), delay),\n        (err) => executeSchedule(subscriber, scheduler, () => subscriber.error(err), delay)\n      )\n    );\n  });\n}\n", "import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\n\n/**\n * Asynchronously subscribes Observers to this Observable on the specified {@link SchedulerLike}.\n *\n * With `subscribeOn` you can decide what type of scheduler a specific Observable will be using when it is subscribed to.\n *\n * Schedulers control the speed and order of emissions to observers from an Observable stream.\n *\n * ![](subscribeOn.png)\n *\n * ## Example\n *\n * Given the following code:\n *\n * ```ts\n * import { of, merge } from 'rxjs';\n *\n * const a = of(1, 2, 3);\n * const b = of(4, 5, 6);\n *\n * merge(a, b).subscribe(console.log);\n *\n * // Outputs\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * // 6\n * ```\n *\n * Both Observable `a` and `b` will emit their values directly and synchronously once they are subscribed to.\n *\n * If we instead use the `subscribeOn` operator declaring that we want to use the {@link asyncScheduler} for values emitted by Observable `a`:\n *\n * ```ts\n * import { of, subscribeOn, asyncScheduler, merge } from 'rxjs';\n *\n * const a = of(1, 2, 3).pipe(subscribeOn(asyncScheduler));\n * const b = of(4, 5, 6);\n *\n * merge(a, b).subscribe(console.log);\n *\n * // Outputs\n * // 4\n * // 5\n * // 6\n * // 1\n * // 2\n * // 3\n * ```\n *\n * The reason for this is that Observable `b` emits its values directly and synchronously like before\n * but the emissions from `a` are scheduled on the event loop because we are now using the {@link asyncScheduler} for that specific Observable.\n *\n * @param scheduler The {@link SchedulerLike} to perform subscription actions on.\n * @param delay A delay to pass to the scheduler to delay subscriptions\n * @return A function that returns an Observable modified so that its\n * subscriptions happen on the specified {@link SchedulerLike}.\n */\nexport function subscribeOn<T>(scheduler: SchedulerLike, delay: number = 0): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    subscriber.add(scheduler.schedule(() => source.subscribe(subscriber), delay));\n  });\n}\n", "import { innerFrom } from '../observable/innerFrom';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nimport { InteropObservable, SchedulerLike } from '../types';\n\nexport function scheduleObservable<T>(input: InteropObservable<T>, scheduler: SchedulerLike) {\n  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n", "import { innerFrom } from '../observable/innerFrom';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nimport { SchedulerLike } from '../types';\n\nexport function schedulePromise<T>(input: PromiseLike<T>, scheduler: SchedulerLike) {\n  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n", "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n\nexport function scheduleArray<T>(input: ArrayLike<T>, scheduler: SchedulerLike) {\n  return new Observable<T>((subscriber) => {\n    // The current array index.\n    let i = 0;\n    // Start iterating over the array like on a schedule.\n    return scheduler.schedule(function () {\n      if (i === input.length) {\n        // If we have hit the end of the array like in the\n        // previous job, we can complete.\n        subscriber.complete();\n      } else {\n        // Otherwise let's next the value at the current index,\n        // then increment our index.\n        subscriber.next(input[i++]);\n        // If the last emission didn't cause us to close the subscriber\n        // (via take or some side effect), reschedule the job and we'll\n        // make another pass.\n        if (!subscriber.closed) {\n          this.schedule();\n        }\n      }\n    });\n  });\n}\n", "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from '../util/isFunction';\nimport { executeSchedule } from '../util/executeSchedule';\n\n/**\n * Used in {@link scheduled} to create an observable from an Iterable.\n * @param input The iterable to create an observable from\n * @param scheduler The scheduler to use\n */\nexport function scheduleIterable<T>(input: Iterable<T>, scheduler: SchedulerLike) {\n  return new Observable<T>((subscriber) => {\n    let iterator: Iterator<T, T>;\n\n    // Schedule the initial creation of the iterator from\n    // the iterable. This is so the code in the iterable is\n    // not called until the scheduled job fires.\n    executeSchedule(subscriber, scheduler, () => {\n      // Create the iterator.\n      iterator = (input as any)[Symbol_iterator]();\n\n      executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          let value: T;\n          let done: boolean | undefined;\n          try {\n            // Pull the value out of the iterator\n            ({ value, done } = iterator.next());\n          } catch (err) {\n            // We got an error while pulling from the iterator\n            subscriber.error(err);\n            return;\n          }\n\n          if (done) {\n            // If it is \"done\" we just complete. This mimics the\n            // behavior of JavaScript's `for..of` consumption of\n            // iterables, which will not emit the value from an iterator\n            // result of `{ done: true: value: 'here' }`.\n            subscriber.complete();\n          } else {\n            // The iterable is not done, emit the value.\n            subscriber.next(value);\n          }\n        },\n        0,\n        true\n      );\n    });\n\n    // During finalization, if we see this iterator has a `return` method,\n    // then we know it is a Generator, and not just an Iterator. So we call\n    // the `return()` function. This will ensure that any `finally { }` blocks\n    // inside of the generator we can hit will be hit properly.\n    return () => isFunction(iterator?.return) && iterator.return();\n  });\n}\n", "import { SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nimport { executeSchedule } from '../util/executeSchedule';\n\nexport function scheduleAsyncIterable<T>(input: AsyncIterable<T>, scheduler: SchedulerLike) {\n  if (!input) {\n    throw new Error('Iterable cannot be null');\n  }\n  return new Observable<T>((subscriber) => {\n    executeSchedule(subscriber, scheduler, () => {\n      const iterator = input[Symbol.asyncIterator]();\n      executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          iterator.next().then((result) => {\n            if (result.done) {\n              // This will remove the subscriptions from\n              // the parent subscription.\n              subscriber.complete();\n            } else {\n              subscriber.next(result.value);\n            }\n          });\n        },\n        0,\n        true\n      );\n    });\n  });\n}\n", "import { SchedulerLike, ReadableStreamLike } from '../types';\nimport { Observable } from '../Observable';\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\n\nexport function scheduleReadableStreamLike<T>(input: ReadableStreamLike<T>, scheduler: SchedulerLike): Observable<T> {\n  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);\n}\n", "import { scheduleObservable } from './scheduleObservable';\nimport { schedulePromise } from './schedulePromise';\nimport { scheduleArray } from './scheduleArray';\nimport { scheduleIterable } from './scheduleIterable';\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isPromise } from '../util/isPromise';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isIterable } from '../util/isIterable';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isReadableStreamLike } from '../util/isReadableStreamLike';\nimport { scheduleReadableStreamLike } from './scheduleReadableStreamLike';\n\n/**\n * Converts from a common {@link ObservableInput} type to an observable where subscription and emissions\n * are scheduled on the provided scheduler.\n *\n * @see {@link from}\n * @see {@link of}\n *\n * @param input The observable, array, promise, iterable, etc you would like to schedule\n * @param scheduler The scheduler to use to schedule the subscription and emissions from\n * the returned observable.\n */\nexport function scheduled<T>(input: ObservableInput<T>, scheduler: SchedulerLike): Observable<T> {\n  if (input != null) {\n    if (isInteropObservable(input)) {\n      return scheduleObservable(input, scheduler);\n    }\n    if (isArrayLike(input)) {\n      return scheduleArray(input, scheduler);\n    }\n    if (isPromise(input)) {\n      return schedulePromise(input, scheduler);\n    }\n    if (isAsyncIterable(input)) {\n      return scheduleAsyncIterable(input, scheduler);\n    }\n    if (isIterable(input)) {\n      return scheduleIterable(input, scheduler);\n    }\n    if (isReadableStreamLike(input)) {\n      return scheduleReadableStreamLike(input, scheduler);\n    }\n  }\n  throw createInvalidObservableTypeError(input);\n}\n", "import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike, ObservedValueOf } from '../types';\nimport { scheduled } from '../scheduled/scheduled';\nimport { innerFrom } from './innerFrom';\n\nexport function from<O extends ObservableInput<any>>(input: O): Observable<ObservedValueOf<O>>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function from<O extends ObservableInput<any>>(input: O, scheduler: SchedulerLike | undefined): Observable<ObservedValueOf<O>>;\n\n/**\n * Creates an Observable from an Array, an array-like object, a Promise, an iterable object, or an Observable-like object.\n *\n * <span class=\"informal\">Converts almost anything to an Observable.</span>\n *\n * ![](from.png)\n *\n * `from` converts various other objects and data types into Observables. It also converts a Promise, an array-like, or an\n * <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable\" target=\"_blank\">iterable</a>\n * object into an Observable that emits the items in that promise, array, or iterable. A String, in this context, is treated\n * as an array of characters. Observable-like objects (contains a function named with the ES2015 Symbol for Observable) can also be\n * converted through this operator.\n *\n * ## Examples\n *\n * Converts an array to an Observable\n *\n * ```ts\n * import { from } from 'rxjs';\n *\n * const array = [10, 20, 30];\n * const result = from(array);\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 10\n * // 20\n * // 30\n * ```\n *\n * Convert an infinite iterable (from a generator) to an Observable\n *\n * ```ts\n * import { from, take } from 'rxjs';\n *\n * function* generateDoubles(seed) {\n *    let i = seed;\n *    while (true) {\n *      yield i;\n *      i = 2 * i; // double it\n *    }\n * }\n *\n * const iterator = generateDoubles(3);\n * const result = from(iterator).pipe(take(10));\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 3\n * // 6\n * // 12\n * // 24\n * // 48\n * // 96\n * // 192\n * // 384\n * // 768\n * // 1536\n * ```\n *\n * With `asyncScheduler`\n *\n * ```ts\n * import { from, asyncScheduler } from 'rxjs';\n *\n * console.log('start');\n *\n * const array = [10, 20, 30];\n * const result = from(array, asyncScheduler);\n *\n * result.subscribe(x => console.log(x));\n *\n * console.log('end');\n *\n * // Logs:\n * // 'start'\n * // 'end'\n * // 10\n * // 20\n * // 30\n * ```\n *\n * @see {@link fromEvent}\n * @see {@link fromEventPattern}\n *\n * @param input A subscription object, a Promise, an Observable-like,\n * an Array, an iterable, or an array-like object to be converted.\n * @param scheduler An optional {@link SchedulerLike} on which to schedule the emission of values.\n * @return An Observable converted from {@link ObservableInput}.\n */\nexport function from<T>(input: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T> {\n  return scheduler ? scheduled(input, scheduler) : innerFrom(input);\n}\n", "import { SchedulerLike, ValueFromArray } from '../types';\nimport { Observable } from '../Observable';\nimport { popScheduler } from '../util/args';\nimport { from } from './from';\n\n// Devs are more likely to pass null or undefined than they are a scheduler\n// without accompanying values. To make things easier for (naughty) devs who\n// use the `strictNullChecks: false` TypeScript compiler option, these\n// overloads with explicit null and undefined values are included.\n\nexport function of(value: null): Observable<null>;\nexport function of(value: undefined): Observable<undefined>;\n\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function of(scheduler: SchedulerLike): Observable<never>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function of<A extends readonly unknown[]>(...valuesAndScheduler: [...A, SchedulerLike]): Observable<ValueFromArray<A>>;\n\nexport function of(): Observable<never>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function of<T>(): Observable<T>;\nexport function of<T>(value: T): Observable<T>;\nexport function of<A extends readonly unknown[]>(...values: A): Observable<ValueFromArray<A>>;\n\n/**\n * Converts the arguments to an observable sequence.\n *\n * <span class=\"informal\">Each argument becomes a `next` notification.</span>\n *\n * ![](of.png)\n *\n * Unlike {@link from}, it does not do any flattening and emits each argument in whole\n * as a separate `next` notification.\n *\n * ## Examples\n *\n * Emit the values `10, 20, 30`\n *\n * ```ts\n * import { of } from 'rxjs';\n *\n * of(10, 20, 30)\n *   .subscribe({\n *     next: value => console.log('next:', value),\n *     error: err => console.log('error:', err),\n *     complete: () => console.log('the end'),\n *   });\n *\n * // Outputs\n * // next: 10\n * // next: 20\n * // next: 30\n * // the end\n * ```\n *\n * Emit the array `[1, 2, 3]`\n *\n * ```ts\n * import { of } from 'rxjs';\n *\n * of([1, 2, 3])\n *   .subscribe({\n *     next: value => console.log('next:', value),\n *     error: err => console.log('error:', err),\n *     complete: () => console.log('the end'),\n *   });\n *\n * // Outputs\n * // next: [1, 2, 3]\n * // the end\n * ```\n *\n * @see {@link from}\n * @see {@link range}\n *\n * @param args A comma separated list of arguments you want to be emitted.\n * @return An Observable that synchronously emits the arguments described\n * above and then immediately completes.\n */\nexport function of<T>(...args: Array<T | SchedulerLike>): Observable<T> {\n  const scheduler = popScheduler(args);\n  return from(args as T[], scheduler);\n}\n", "import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { SchedulerLike } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/**\n * Creates an observable that will create an error instance and push it to the consumer as an error\n * immediately upon subscription.\n *\n * <span class=\"informal\">Just errors and does nothing else</span>\n *\n * ![](throw.png)\n *\n * This creation function is useful for creating an observable that will create an error and error every\n * time it is subscribed to. Generally, inside of most operators when you might want to return an errored\n * observable, this is unnecessary. In most cases, such as in the inner return of {@link concatMap},\n * {@link mergeMap}, {@link defer}, and many others, you can simply throw the error, and RxJS will pick\n * that up and notify the consumer of the error.\n *\n * ## Example\n *\n * Create a simple observable that will create a new error with a timestamp and log it\n * and the message every time you subscribe to it\n *\n * ```ts\n * import { throwError } from 'rxjs';\n *\n * let errorCount = 0;\n *\n * const errorWithTimestamp$ = throwError(() => {\n *   const error: any = new Error(`This is error number ${ ++errorCount }`);\n *   error.timestamp = Date.now();\n *   return error;\n * });\n *\n * errorWithTimestamp$.subscribe({\n *   error: err => console.log(err.timestamp, err.message)\n * });\n *\n * errorWithTimestamp$.subscribe({\n *   error: err => console.log(err.timestamp, err.message)\n * });\n *\n * // Logs the timestamp and a new error message for each subscription\n * ```\n *\n * ### Unnecessary usage\n *\n * Using `throwError` inside of an operator or creation function\n * with a callback, is usually not necessary\n *\n * ```ts\n * import { of, concatMap, timer, throwError } from 'rxjs';\n *\n * const delays$ = of(1000, 2000, Infinity, 3000);\n *\n * delays$.pipe(\n *   concatMap(ms => {\n *     if (ms < 10000) {\n *       return timer(ms);\n *     } else {\n *       // This is probably overkill.\n *       return throwError(() => new Error(`Invalid time ${ ms }`));\n *     }\n *   })\n * )\n * .subscribe({\n *   next: console.log,\n *   error: console.error\n * });\n * ```\n *\n * You can just throw the error instead\n *\n * ```ts\n * import { of, concatMap, timer } from 'rxjs';\n *\n * const delays$ = of(1000, 2000, Infinity, 3000);\n *\n * delays$.pipe(\n *   concatMap(ms => {\n *     if (ms < 10000) {\n *       return timer(ms);\n *     } else {\n *       // Cleaner and easier to read for most folks.\n *       throw new Error(`Invalid time ${ ms }`);\n *     }\n *   })\n * )\n * .subscribe({\n *   next: console.log,\n *   error: console.error\n * });\n * ```\n *\n * @param errorFactory A factory function that will create the error instance that is pushed.\n */\nexport function throwError(errorFactory: () => any): Observable<never>;\n\n/**\n * Returns an observable that will error with the specified error immediately upon subscription.\n *\n * @param error The error instance to emit\n * @deprecated Support for passing an error value will be removed in v8. Instead, pass a factory function to `throwError(() => new Error('test'))`. This is\n * because it will create the error at the moment it should be created and capture a more appropriate stack trace. If\n * for some reason you need to create the error ahead of time, you can still do that: `const err = new Error('test'); throwError(() => err);`.\n */\nexport function throwError(error: any): Observable<never>;\n\n/**\n * Notifies the consumer of an error using a given scheduler by scheduling it at delay `0` upon subscription.\n *\n * @param errorOrErrorFactory An error instance or error factory\n * @param scheduler A scheduler to use to schedule the error notification\n * @deprecated The `scheduler` parameter will be removed in v8.\n * Use `throwError` in combination with {@link observeOn}: `throwError(() => new Error('test')).pipe(observeOn(scheduler));`.\n * Details: https://rxjs.dev/deprecations/scheduler-argument\n */\nexport function throwError(errorOrErrorFactory: any, scheduler: SchedulerLike): Observable<never>;\n\nexport function throwError(errorOrErrorFactory: any, scheduler?: SchedulerLike): Observable<never> {\n  const errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : () => errorOrErrorFactory;\n  const init = (subscriber: Subscriber<never>) => subscriber.error(errorFactory());\n  return new Observable(scheduler ? (subscriber) => scheduler.schedule(init as any, 0, subscriber) : init);\n}\n", "import { PartialObserver, ObservableNotification, CompleteNotification, NextNotification, ErrorNotification } from './types';\nimport { Observable } from './Observable';\nimport { EMPTY } from './observable/empty';\nimport { of } from './observable/of';\nimport { throwError } from './observable/throwError';\nimport { isFunction } from './util/isFunction';\n\n// TODO: When this enum is removed, replace it with a type alias. See #4556.\n/**\n * @deprecated Use a string literal instead. `NotificationKind` will be replaced with a type alias in v8.\n * It will not be replaced with a const enum as those are not compatible with isolated modules.\n */\nexport enum NotificationKind {\n  NEXT = 'N',\n  ERROR = 'E',\n  COMPLETE = 'C',\n}\n\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n * @deprecated It is NOT recommended to create instances of `Notification` directly.\n * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n * Will be removed in v8.\n */\nexport class Notification<T> {\n  /**\n   * A value signifying that the notification will \"next\" if observed. In truth,\n   * This is really synonymous with just checking `kind === \"N\"`.\n   * @deprecated Will be removed in v8. Instead, just check to see if the value of `kind` is `\"N\"`.\n   */\n  readonly hasValue: boolean;\n\n  /**\n   * Creates a \"Next\" notification object.\n   * @param kind Always `'N'`\n   * @param value The value to notify with if observed.\n   * @deprecated Internal implementation detail. Use {@link Notification#createNext createNext} instead.\n   */\n  constructor(kind: 'N', value?: T);\n  /**\n   * Creates an \"Error\" notification object.\n   * @param kind Always `'E'`\n   * @param value Always `undefined`\n   * @param error The error to notify with if observed.\n   * @deprecated Internal implementation detail. Use {@link Notification#createError createError} instead.\n   */\n  constructor(kind: 'E', value: undefined, error: any);\n  /**\n   * Creates a \"completion\" notification object.\n   * @param kind Always `'C'`\n   * @deprecated Internal implementation detail. Use {@link Notification#createComplete createComplete} instead.\n   */\n  constructor(kind: 'C');\n  constructor(public readonly kind: 'N' | 'E' | 'C', public readonly value?: T, public readonly error?: any) {\n    this.hasValue = kind === 'N';\n  }\n\n  /**\n   * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n   * If the handler is missing it will do nothing. Even if the notification is an error, if\n   * there is no error handler on the observer, an error will not be thrown, it will noop.\n   * @param observer The observer to notify.\n   */\n  observe(observer: PartialObserver<T>): void {\n    return observeNotification(this as ObservableNotification<T>, observer);\n  }\n\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @param complete A complete handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void, error: (err: any) => void, complete: () => void): void;\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void, error: (err: any) => void): void;\n  /**\n   * Executes the next handler if the Notification is of `kind` `\"N\"`. Otherwise\n   * this will not error, and it will be a noop.\n   * @param next The next handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void): void;\n  do(nextHandler: (value: T) => void, errorHandler?: (err: any) => void, completeHandler?: () => void): void {\n    const { kind, value, error } = this;\n    return kind === 'N' ? nextHandler?.(value!) : kind === 'E' ? errorHandler?.(error) : completeHandler?.();\n  }\n\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @param complete A complete handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void, error: (err: any) => void, complete: () => void): void;\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void, error: (err: any) => void): void;\n  /**\n   * Executes the next handler if the Notification is of `kind` `\"N\"`. Otherwise\n   * this will not error, and it will be a noop.\n   * @param next The next handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void): void;\n\n  /**\n   * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n   * If the handler is missing it will do nothing. Even if the notification is an error, if\n   * there is no error handler on the observer, an error will not be thrown, it will noop.\n   * @param observer The observer to notify.\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(observer: PartialObserver<T>): void;\n  accept(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void) {\n    return isFunction((nextOrObserver as any)?.next)\n      ? this.observe(nextOrObserver as PartialObserver<T>)\n      : this.do(nextOrObserver as (value: T) => void, error as any, complete as any);\n  }\n\n  /**\n   * Returns a simple Observable that just delivers the notification represented\n   * by this Notification instance.\n   *\n   * @deprecated Will be removed in v8. To convert a `Notification` to an {@link Observable},\n   * use {@link of} and {@link dematerialize}: `of(notification).pipe(dematerialize())`.\n   */\n  toObservable(): Observable<T> {\n    const { kind, value, error } = this;\n    // Select the observable to return by `kind`\n    const result =\n      kind === 'N'\n        ? // Next kind. Return an observable of that value.\n          of(value!)\n        : //\n        kind === 'E'\n        ? // Error kind. Return an observable that emits the error.\n          throwError(() => error)\n        : //\n        kind === 'C'\n        ? // Completion kind. Kind is \"C\", return an observable that just completes.\n          EMPTY\n        : // Unknown kind, return falsy, so we error below.\n          0;\n    if (!result) {\n      // TODO: consider removing this check. The only way to cause this would be to\n      // use the Notification constructor directly in a way that is not type-safe.\n      // and direct use of the Notification constructor is deprecated.\n      throw new TypeError(`Unexpected notification kind ${kind}`);\n    }\n    return result;\n  }\n\n  private static completeNotification = new Notification('C') as Notification<never> & CompleteNotification;\n  /**\n   * A shortcut to create a Notification instance of the type `next` from a\n   * given value.\n   * @param value The `next` value.\n   * @return The \"next\" Notification representing the argument.\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createNext<T>(value: T) {\n    return new Notification('N', value) as Notification<T> & NextNotification<T>;\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `error` from a\n   * given error.\n   * @param err The `error` error.\n   * @return The \"error\" Notification representing the argument.\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createError(err?: any) {\n    return new Notification('E', undefined, err) as Notification<never> & ErrorNotification;\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `complete`.\n   * @return The valueless \"complete\" Notification.\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createComplete(): Notification<never> & CompleteNotification {\n    return Notification.completeNotification;\n  }\n}\n\n/**\n * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n * If the handler is missing it will do nothing. Even if the notification is an error, if\n * there is no error handler on the observer, an error will not be thrown, it will noop.\n * @param notification The notification object to observe.\n * @param observer The observer to notify.\n */\nexport function observeNotification<T>(notification: ObservableNotification<T>, observer: PartialObserver<T>) {\n  const { kind, value, error } = notification as any;\n  if (typeof kind !== 'string') {\n    throw new TypeError('Invalid notification, missing \"kind\"');\n  }\n  kind === 'N' ? observer.next?.(value!) : kind === 'E' ? observer.error?.(error) : observer.complete?.();\n}\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface EmptyError extends Error {}\n\nexport interface EmptyErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): EmptyError;\n}\n\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n * @see {@link firstValueFrom}\n * @see {@link lastValueFrom}\n */\nexport const EmptyError: EmptyErrorCtor = createErrorClass(\n  (_super) =>\n    function EmptyErrorImpl(this: any) {\n      _super(this);\n      this.name = 'EmptyError';\n      this.message = 'no elements in sequence';\n    }\n);\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface ArgumentOutOfRangeError extends Error {}\n\nexport interface ArgumentOutOfRangeErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): ArgumentOutOfRangeError;\n}\n\n/**\n * An error thrown when an element was queried at a certain index of an\n * Observable, but no such index or position exists in that sequence.\n *\n * @see {@link elementAt}\n * @see {@link take}\n * @see {@link takeLast}\n */\nexport const ArgumentOutOfRangeError: ArgumentOutOfRangeErrorCtor = createErrorClass(\n  (_super) =>\n    function ArgumentOutOfRangeErrorImpl(this: any) {\n      _super(this);\n      this.name = 'ArgumentOutOfRangeError';\n      this.message = 'argument out of range';\n    }\n);\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface NotFoundError extends Error {}\n\nexport interface NotFoundErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (message: string): NotFoundError;\n}\n\n/**\n * An error thrown when a value or values are missing from an\n * observable sequence.\n *\n * @see {@link operators/single}\n */\nexport const NotFoundError: NotFoundErrorCtor = createErrorClass(\n  (_super) =>\n    function NotFoundErrorImpl(this: any, message: string) {\n      _super(this);\n      this.name = 'NotFoundError';\n      this.message = message;\n    }\n);\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface SequenceError extends Error {}\n\nexport interface SequenceErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (message: string): SequenceError;\n}\n\n/**\n * An error thrown when something is wrong with the sequence of\n * values arriving on the observable.\n *\n * @see {@link operators/single}\n */\nexport const SequenceError: SequenceErrorCtor = createErrorClass(\n  (_super) =>\n    function SequenceErrorImpl(this: any, message: string) {\n      _super(this);\n      this.name = 'SequenceError';\n      this.message = message;\n    }\n);\n", "/**\n * Checks to see if a value is not only a `Date` object,\n * but a *valid* `Date` object that can be converted to a\n * number. For example, `new Date('blah')` is indeed an\n * `instanceof Date`, however it cannot be converted to a\n * number.\n */\nexport function isValidDate(value: any): value is Date {\n  return value instanceof Date && !isNaN(value as any);\n}\n", "import { asyncScheduler } from '../scheduler/async';\nimport { MonoTypeOperatorFunction, SchedulerLike, OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\nimport { isValidDate } from '../util/isDate';\nimport { Subscription } from '../Subscription';\nimport { operate } from '../util/lift';\nimport { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createErrorClass } from '../util/createErrorClass';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { executeSchedule } from '../util/executeSchedule';\n\nexport interface TimeoutConfig<T, O extends ObservableInput<unknown> = ObservableInput<T>, M = unknown> {\n  /**\n   * The time allowed between values from the source before timeout is triggered.\n   */\n  each?: number;\n\n  /**\n   * The relative time as a `number` in milliseconds, or a specific time as a `Date` object,\n   * by which the first value must arrive from the source before timeout is triggered.\n   */\n  first?: number | Date;\n\n  /**\n   * The scheduler to use with time-related operations within this operator. Defaults to {@link asyncScheduler}\n   */\n  scheduler?: SchedulerLike;\n\n  /**\n   * A factory used to create observable to switch to when timeout occurs. Provides\n   * a {@link TimeoutInfo} about the source observable's emissions and what delay or\n   * exact time triggered the timeout.\n   */\n  with?: (info: TimeoutInfo<T, M>) => O;\n\n  /**\n   * Optional additional metadata you can provide to code that handles\n   * the timeout, will be provided through the {@link TimeoutError}.\n   * This can be used to help identify the source of a timeout or pass along\n   * other information related to the timeout.\n   */\n  meta?: M;\n}\n\nexport interface TimeoutInfo<T, M = unknown> {\n  /** Optional metadata that was provided to the timeout configuration. */\n  readonly meta: M;\n  /** The number of messages seen before the timeout */\n  readonly seen: number;\n  /** The last message seen */\n  readonly lastValue: T | null;\n}\n\n/**\n * An error emitted when a timeout occurs.\n */\nexport interface TimeoutError<T = unknown, M = unknown> extends Error {\n  /**\n   * The information provided to the error by the timeout\n   * operation that created the error. Will be `null` if\n   * used directly in non-RxJS code with an empty constructor.\n   * (Note that using this constructor directly is not recommended,\n   * you should create your own errors)\n   */\n  info: TimeoutInfo<T, M> | null;\n}\n\nexport interface TimeoutErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new <T = unknown, M = unknown>(info?: TimeoutInfo<T, M>): TimeoutError<T, M>;\n}\n\n/**\n * An error thrown by the {@link timeout} operator.\n *\n * Provided so users can use as a type and do quality comparisons.\n * We recommend you do not subclass this or create instances of this class directly.\n * If you have need of a error representing a timeout, you should\n * create your own error class and use that.\n *\n * @see {@link timeout}\n */\nexport const TimeoutError: TimeoutErrorCtor = createErrorClass(\n  (_super) =>\n    function TimeoutErrorImpl(this: any, info: TimeoutInfo<any> | null = null) {\n      _super(this);\n      this.message = 'Timeout has occurred';\n      this.name = 'TimeoutError';\n      this.info = info;\n    }\n);\n\n/**\n * If `with` is provided, this will return an observable that will switch to a different observable if the source\n * does not push values within the specified time parameters.\n *\n * <span class=\"informal\">The most flexible option for creating a timeout behavior.</span>\n *\n * The first thing to know about the configuration is if you do not provide a `with` property to the configuration,\n * when timeout conditions are met, this operator will emit a {@link TimeoutError}. Otherwise, it will use the factory\n * function provided by `with`, and switch your subscription to the result of that. Timeout conditions are provided by\n * the settings in `first` and `each`.\n *\n * The `first` property can be either a `Date` for a specific time, a `number` for a time period relative to the\n * point of subscription, or it can be skipped. This property is to check timeout conditions for the arrival of\n * the first value from the source _only_. The timings of all subsequent values  from the source will be checked\n * against the time period provided by `each`, if it was provided.\n *\n * The `each` property can be either a `number` or skipped. If a value for `each` is provided, it represents the amount of\n * time the resulting observable will wait between the arrival of values from the source before timing out. Note that if\n * `first` is _not_ provided, the value from `each` will be used to check timeout conditions for the arrival of the first\n * value and all subsequent values. If `first` _is_ provided, `each` will only be use to check all values after the first.\n *\n * ## Examples\n *\n * Emit a custom error if there is too much time between values\n *\n * ```ts\n * import { interval, timeout, throwError } from 'rxjs';\n *\n * class CustomTimeoutError extends Error {\n *   constructor() {\n *     super('It was too slow');\n *     this.name = 'CustomTimeoutError';\n *   }\n * }\n *\n * const slow$ = interval(900);\n *\n * slow$.pipe(\n *   timeout({\n *     each: 1000,\n *     with: () => throwError(() => new CustomTimeoutError())\n *   })\n * )\n * .subscribe({\n *   error: console.error\n * });\n * ```\n *\n * Switch to a faster observable if your source is slow.\n *\n * ```ts\n * import { interval, timeout } from 'rxjs';\n *\n * const slow$ = interval(900);\n * const fast$ = interval(500);\n *\n * slow$.pipe(\n *   timeout({\n *     each: 1000,\n *     with: () => fast$,\n *   })\n * )\n * .subscribe(console.log);\n * ```\n * @param config The configuration for the timeout.\n */\nexport function timeout<T, O extends ObservableInput<unknown>, M = unknown>(\n  config: TimeoutConfig<T, O, M> & { with: (info: TimeoutInfo<T, M>) => O }\n): OperatorFunction<T, T | ObservedValueOf<O>>;\n\n/**\n * Returns an observable that will error or switch to a different observable if the source does not push values\n * within the specified time parameters.\n *\n * <span class=\"informal\">The most flexible option for creating a timeout behavior.</span>\n *\n * The first thing to know about the configuration is if you do not provide a `with` property to the configuration,\n * when timeout conditions are met, this operator will emit a {@link TimeoutError}. Otherwise, it will use the factory\n * function provided by `with`, and switch your subscription to the result of that. Timeout conditions are provided by\n * the settings in `first` and `each`.\n *\n * The `first` property can be either a `Date` for a specific time, a `number` for a time period relative to the\n * point of subscription, or it can be skipped. This property is to check timeout conditions for the arrival of\n * the first value from the source _only_. The timings of all subsequent values  from the source will be checked\n * against the time period provided by `each`, if it was provided.\n *\n * The `each` property can be either a `number` or skipped. If a value for `each` is provided, it represents the amount of\n * time the resulting observable will wait between the arrival of values from the source before timing out. Note that if\n * `first` is _not_ provided, the value from `each` will be used to check timeout conditions for the arrival of the first\n * value and all subsequent values. If `first` _is_ provided, `each` will only be use to check all values after the first.\n *\n * ### Handling TimeoutErrors\n *\n * If no `with` property was provided, subscriptions to the resulting observable may emit an error of {@link TimeoutError}.\n * The timeout error provides useful information you can examine when you're handling the error. The most common way to handle\n * the error would be with {@link catchError}, although you could use {@link tap} or just the error handler in your `subscribe` call\n * directly, if your error handling is only a side effect (such as notifying the user, or logging).\n *\n * In this case, you would check the error for `instanceof TimeoutError` to validate that the error was indeed from `timeout`, and\n * not from some other source. If it's not from `timeout`, you should probably rethrow it if you're in a `catchError`.\n *\n * ## Examples\n *\n * Emit a {@link TimeoutError} if the first value, and _only_ the first value, does not arrive within 5 seconds\n *\n * ```ts\n * import { interval, timeout } from 'rxjs';\n *\n * // A random interval that lasts between 0 and 10 seconds per tick\n * const source$ = interval(Math.round(Math.random() * 10_000));\n *\n * source$.pipe(\n *   timeout({ first: 5_000 })\n * )\n * .subscribe({\n *   next: console.log,\n *   error: console.error\n * });\n * ```\n *\n * Emit a {@link TimeoutError} if the source waits longer than 5 seconds between any two values or the first value\n * and subscription.\n *\n * ```ts\n * import { timer, timeout, expand } from 'rxjs';\n *\n * const getRandomTime = () => Math.round(Math.random() * 10_000);\n *\n * // An observable that waits a random amount of time between each delivered value\n * const source$ = timer(getRandomTime())\n *   .pipe(expand(() => timer(getRandomTime())));\n *\n * source$\n *   .pipe(timeout({ each: 5_000 }))\n *   .subscribe({\n *     next: console.log,\n *     error: console.error\n *   });\n * ```\n *\n * Emit a {@link TimeoutError} if the source does not emit before 7 seconds, _or_ if the source waits longer than\n * 5 seconds between any two values after the first.\n *\n * ```ts\n * import { timer, timeout, expand } from 'rxjs';\n *\n * const getRandomTime = () => Math.round(Math.random() * 10_000);\n *\n * // An observable that waits a random amount of time between each delivered value\n * const source$ = timer(getRandomTime())\n *   .pipe(expand(() => timer(getRandomTime())));\n *\n * source$\n *   .pipe(timeout({ first: 7_000, each: 5_000 }))\n *   .subscribe({\n *     next: console.log,\n *     error: console.error\n *   });\n * ```\n */\nexport function timeout<T, M = unknown>(config: Omit<TimeoutConfig<T, any, M>, 'with'>): OperatorFunction<T, T>;\n\n/**\n * Returns an observable that will error if the source does not push its first value before the specified time passed as a `Date`.\n * This is functionally the same as `timeout({ first: someDate })`.\n *\n * <span class=\"informal\">Errors if the first value doesn't show up before the given date and time</span>\n *\n * ![](timeout.png)\n *\n * @param first The date to at which the resulting observable will timeout if the source observable\n * does not emit at least one value.\n * @param scheduler The scheduler to use. Defaults to {@link asyncScheduler}.\n */\nexport function timeout<T>(first: Date, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns an observable that will error if the source does not push a value within the specified time in milliseconds.\n * This is functionally the same as `timeout({ each: milliseconds })`.\n *\n * <span class=\"informal\">Errors if it waits too long between any value</span>\n *\n * ![](timeout.png)\n *\n * @param each The time allowed between each pushed value from the source before the resulting observable\n * will timeout.\n * @param scheduler The scheduler to use. Defaults to {@link asyncScheduler}.\n */\nexport function timeout<T>(each: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n *\n * ![](timeout.png)\n *\n * @see {@link timeoutWith}\n *\n * @return A function that returns an Observable that mirrors behaviour of the\n * source Observable, unless timeout happens when it throws an error.\n */\nexport function timeout<T, O extends ObservableInput<any>, M>(\n  config: number | Date | TimeoutConfig<T, O, M>,\n  schedulerArg?: SchedulerLike\n): OperatorFunction<T, T | ObservedValueOf<O>> {\n  // Intentionally terse code.\n  // If the first argument is a valid `Date`, then we use it as the `first` config.\n  // Otherwise, if the first argument is a `number`, then we use it as the `each` config.\n  // Otherwise, it can be assumed the first argument is the configuration object itself, and\n  // we destructure that into what we're going to use, setting important defaults as we do.\n  // NOTE: The default for `scheduler` will be the `scheduler` argument if it exists, or\n  // it will default to the `asyncScheduler`.\n  const {\n    first,\n    each,\n    with: _with = timeoutErrorFactory,\n    scheduler = schedulerArg ?? asyncScheduler,\n    meta = null!,\n  } = (isValidDate(config) ? { first: config } : typeof config === 'number' ? { each: config } : config) as TimeoutConfig<T, O, M>;\n\n  if (first == null && each == null) {\n    // Ensure timeout was provided at runtime.\n    throw new TypeError('No timeout provided.');\n  }\n\n  return operate((source, subscriber) => {\n    // This subscription encapsulates our subscription to the\n    // source for this operator. We're capturing it separately,\n    // because if there is a `with` observable to fail over to,\n    // we want to unsubscribe from our original subscription, and\n    // hand of the subscription to that one.\n    let originalSourceSubscription: Subscription;\n    // The subscription for our timeout timer. This changes\n    // every time we get a new value.\n    let timerSubscription: Subscription;\n    // A bit of state we pass to our with and error factories to\n    // tell what the last value we saw was.\n    let lastValue: T | null = null;\n    // A bit of state we pass to the with and error factories to\n    // tell how many values we have seen so far.\n    let seen = 0;\n    const startTimer = (delay: number) => {\n      timerSubscription = executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          try {\n            originalSourceSubscription.unsubscribe();\n            innerFrom(\n              _with!({\n                meta,\n                lastValue,\n                seen,\n              })\n            ).subscribe(subscriber);\n          } catch (err) {\n            subscriber.error(err);\n          }\n        },\n        delay\n      );\n    };\n\n    originalSourceSubscription = source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          // clear the timer so we can emit and start another one.\n          timerSubscription?.unsubscribe();\n          seen++;\n          // Emit\n          subscriber.next((lastValue = value));\n          // null | undefined are both < 0. Thanks, JavaScript.\n          each! > 0 && startTimer(each!);\n        },\n        undefined,\n        undefined,\n        () => {\n          if (!timerSubscription?.closed) {\n            timerSubscription?.unsubscribe();\n          }\n          // Be sure not to hold the last value in memory after unsubscription\n          // it could be quite large.\n          lastValue = null;\n        }\n      )\n    );\n\n    // Intentionally terse code.\n    // If we've `seen` a value, that means the \"first\" clause was met already, if it existed.\n    //   it also means that a timer was already started for \"each\" (in the next handler above).\n    // If `first` was provided, and it's a number, then use it.\n    // If `first` was provided and it's not a number, it's a Date, and we get the difference between it and \"now\".\n    // If `first` was not provided at all, then our first timer will be the value from `each`.\n    !seen && startTimer(first != null ? (typeof first === 'number' ? first : +first - scheduler!.now()) : each!);\n  });\n}\n\n/**\n * The default function to use to emit an error when timeout occurs and a `with` function\n * is not specified.\n * @param info The information about the timeout to pass along to the error\n */\nfunction timeoutErrorFactory(info: TimeoutInfo<any>): Observable<never> {\n  throw new TimeoutError(info);\n}\n", "import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function map<T, R>(project: (value: T, index: number) => R): OperatorFunction<T, R>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function map<T, R, A>(project: (this: A, value: T, index: number) => R, thisArg: A): OperatorFunction<T, R>;\n\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * ![](map.png)\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * ## Example\n *\n * Map every click to the `clientX` position of that click\n *\n * ```ts\n * import { fromEvent, map } from 'rxjs';\n *\n * const clicks = fromEvent<PointerEvent>(document, 'click');\n * const positions = clicks.pipe(map(ev => ev.clientX));\n *\n * positions.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param project The function to apply to each `value` emitted by the source\n * Observable. The `index` parameter is the number `i` for the i-th emission\n * that has happened since the subscription, starting from the number `0`.\n * @param thisArg An optional argument to define what `this` is in the\n * `project` function.\n * @return A function that returns an Observable that emits the values from the\n * source Observable transformed by the given `project` function.\n */\nexport function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): OperatorFunction<T, R> {\n  return operate((source, subscriber) => {\n    // The index of the value from the source. Used with projection.\n    let index = 0;\n    // Subscribe to the source, all errors and completions are sent along\n    // to the consumer.\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value: T) => {\n        // Call the projection function with the appropriate this context,\n        // and send the resulting value to the consumer.\n        subscriber.next(project.call(thisArg, value, index++));\n      })\n    );\n  });\n}\n", "import { OperatorFunction } from \"../types\";\nimport { map } from \"../operators/map\";\n\nconst { isArray } = Array;\n\nfunction callOrApply<T, R>(fn: ((...values: T[]) => R), args: T|T[]): R {\n    return isArray(args) ? fn(...args) : fn(args);\n}\n\n/**\n * Used in several -- mostly deprecated -- situations where we need to \n * apply a list of arguments or a single argument to a result selector.\n */\nexport function mapOneOrManyArgs<T, R>(fn: ((...values: T[]) => R)): OperatorFunction<T|T[], R> {\n    return map(args => callOrApply(fn, args))\n}", "const { isArray } = Array;\nconst { getPrototypeOf, prototype: objectProto, keys: getKeys } = Object;\n\n/**\n * Used in functions where either a list of arguments, a single array of arguments, or a\n * dictionary of arguments can be returned. Returns an object with an `args` property with\n * the arguments in an array, if it is a dictionary, it will also return the `keys` in another\n * property.\n */\nexport function argsArgArrayOrObject<T, O extends Record<string, T>>(args: T[] | [O] | [T[]]): { args: T[]; keys: string[] | null } {\n  if (args.length === 1) {\n    const first = args[0];\n    if (isArray(first)) {\n      return { args: first, keys: null };\n    }\n    if (isPOJO(first)) {\n      const keys = getKeys(first);\n      return {\n        args: keys.map((key) => first[key]),\n        keys,\n      };\n    }\n  }\n\n  return { args: args as T[], keys: null };\n}\n\nfunction isPOJO(obj: any): obj is object {\n  return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto;\n}\n", "import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subscriber } from '../Subscriber';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * A process embodying the general \"merge\" strategy. This is used in\n * `mergeMap` and `mergeScan` because the logic is otherwise nearly identical.\n * @param source The original source observable\n * @param subscriber The consumer subscriber\n * @param project The projection function to get our inner sources\n * @param concurrent The number of concurrent inner subscriptions\n * @param onBeforeNext Additional logic to apply before nexting to our consumer\n * @param expand If `true` this will perform an \"expand\" strategy, which differs only\n * in that it recurses, and the inner subscription must be schedule-able.\n * @param innerSubScheduler A scheduler to use to schedule inner subscriptions,\n * this is to support the expand strategy, mostly, and should be deprecated\n */\nexport function mergeInternals<T, R>(\n  source: Observable<T>,\n  subscriber: Subscriber<R>,\n  project: (value: T, index: number) => ObservableInput<R>,\n  concurrent: number,\n  onBeforeNext?: (innerValue: R) => void,\n  expand?: boolean,\n  innerSubScheduler?: SchedulerLike,\n  additionalFinalizer?: () => void\n) {\n  // Buffered values, in the event of going over our concurrency limit\n  const buffer: T[] = [];\n  // The number of active inner subscriptions.\n  let active = 0;\n  // An index to pass to our accumulator function\n  let index = 0;\n  // Whether or not the outer source has completed.\n  let isComplete = false;\n\n  /**\n   * Checks to see if we can complete our result or not.\n   */\n  const checkComplete = () => {\n    // If the outer has completed, and nothing is left in the buffer,\n    // and we don't have any active inner subscriptions, then we can\n    // Emit the state and complete.\n    if (isComplete && !buffer.length && !active) {\n      subscriber.complete();\n    }\n  };\n\n  // If we're under our concurrency limit, just start the inner subscription, otherwise buffer and wait.\n  const outerNext = (value: T) => (active < concurrent ? doInnerSub(value) : buffer.push(value));\n\n  const doInnerSub = (value: T) => {\n    // If we're expanding, we need to emit the outer values and the inner values\n    // as the inners will \"become outers\" in a way as they are recursively fed\n    // back to the projection mechanism.\n    expand && subscriber.next(value as any);\n\n    // Increment the number of active subscriptions so we can track it\n    // against our concurrency limit later.\n    active++;\n\n    // A flag used to show that the inner observable completed.\n    // This is checked during finalization to see if we should\n    // move to the next item in the buffer, if there is on.\n    let innerComplete = false;\n\n    // Start our inner subscription.\n    innerFrom(project(value, index++)).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (innerValue) => {\n          // `mergeScan` has additional handling here. For example\n          // taking the inner value and updating state.\n          onBeforeNext?.(innerValue);\n\n          if (expand) {\n            // If we're expanding, then just recurse back to our outer\n            // handler. It will emit the value first thing.\n            outerNext(innerValue as any);\n          } else {\n            // Otherwise, emit the inner value.\n            subscriber.next(innerValue);\n          }\n        },\n        () => {\n          // Flag that we have completed, so we know to check the buffer\n          // during finalization.\n          innerComplete = true;\n        },\n        // Errors are passed to the destination.\n        undefined,\n        () => {\n          // During finalization, if the inner completed (it wasn't errored or\n          // cancelled), then we want to try the next item in the buffer if\n          // there is one.\n          if (innerComplete) {\n            // We have to wrap this in a try/catch because it happens during\n            // finalization, possibly asynchronously, and we want to pass\n            // any errors that happen (like in a projection function) to\n            // the outer Subscriber.\n            try {\n              // INNER SOURCE COMPLETE\n              // Decrement the active count to ensure that the next time\n              // we try to call `doInnerSub`, the number is accurate.\n              active--;\n              // If we have more values in the buffer, try to process those\n              // Note that this call will increment `active` ahead of the\n              // next conditional, if there were any more inner subscriptions\n              // to start.\n              while (buffer.length && active < concurrent) {\n                const bufferedValue = buffer.shift()!;\n                // Particularly for `expand`, we need to check to see if a scheduler was provided\n                // for when we want to start our inner subscription. Otherwise, we just start\n                // are next inner subscription.\n                if (innerSubScheduler) {\n                  executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));\n                } else {\n                  doInnerSub(bufferedValue);\n                }\n              }\n              // Check to see if we can complete, and complete if so.\n              checkComplete();\n            } catch (err) {\n              subscriber.error(err);\n            }\n          }\n        }\n      )\n    );\n  };\n\n  // Subscribe to our source observable.\n  source.subscribe(\n    createOperatorSubscriber(subscriber, outerNext, () => {\n      // Outer completed, make a note of it, and check to see if we can complete everything.\n      isComplete = true;\n      checkComplete();\n    })\n  );\n\n  // Additional finalization (for when the destination is torn down).\n  // Other finalization is added implicitly via subscription above.\n  return () => {\n    additionalFinalizer?.();\n  };\n}\n", "import { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { map } from './map';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { mergeInternals } from './mergeInternals';\nimport { isFunction } from '../util/isFunction';\n\n/* tslint:disable:max-line-length */\nexport function mergeMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  concurrent?: number\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function mergeMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: undefined,\n  concurrent?: number\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function mergeMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R,\n  concurrent?: number\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * ![](mergeMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * ## Example\n *\n * Map and flatten each letter to an Observable ticking every 1 second\n *\n * ```ts\n * import { of, mergeMap, interval, map } from 'rxjs';\n *\n * const letters = of('a', 'b', 'c');\n * const result = letters.pipe(\n *   mergeMap(x => interval(1000).pipe(map(i => x + i)))\n * );\n *\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a, b, c every second with respective ascending integers\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param project A function that, when applied to an item emitted by the source\n * Observable, returns an Observable.\n * @param concurrent Maximum number of `ObservableInput`s being subscribed to concurrently.\n * @return A function that returns an Observable that emits the result of\n * applying the projection function (and the optional deprecated\n * `resultSelector`) to each item emitted by the source Observable and merging\n * the results of the Observables obtained from this transformation.\n */\nexport function mergeMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: ((outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R) | number,\n  concurrent: number = Infinity\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  if (isFunction(resultSelector)) {\n    // DEPRECATED PATH\n    return mergeMap((a, i) => map((b: any, ii: number) => resultSelector(a, b, i, ii))(innerFrom(project(a, i))), concurrent);\n  } else if (typeof resultSelector === 'number') {\n    concurrent = resultSelector;\n  }\n\n  return operate((source, subscriber) => mergeInternals(source, subscriber, project, concurrent));\n}\n", "import { innerFrom } from '../observable/innerFrom';\nimport { Observable } from '../Observable';\nimport { mergeMap } from '../operators/mergeMap';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isFunction } from '../util/isFunction';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\n\n// These constants are used to create handler registry functions using array mapping below.\nconst nodeEventEmitterMethods = ['addListener', 'removeListener'] as const;\nconst eventTargetMethods = ['addEventListener', 'removeEventListener'] as const;\nconst jqueryMethods = ['on', 'off'] as const;\n\nexport interface NodeStyleEventEmitter {\n  addListener(eventName: string | symbol, handler: NodeEventHandler): this;\n  removeListener(eventName: string | symbol, handler: NodeEventHandler): this;\n}\n\nexport type NodeEventHandler = (...args: any[]) => void;\n\n// For APIs that implement `addListener` and `removeListener` methods that may\n// not use the same arguments or return EventEmitter values\n// such as React Native\nexport interface NodeCompatibleEventEmitter {\n  addListener(eventName: string, handler: NodeEventHandler): void | {};\n  removeListener(eventName: string, handler: NodeEventHandler): void | {};\n}\n\n// Use handler types like those in @types/jquery. See:\n// https://github.com/DefinitelyTyped/DefinitelyTyped/blob/847731ba1d7fa6db6b911c0e43aa0afe596e7723/types/jquery/misc.d.ts#L6395\nexport interface JQueryStyleEventEmitter<TContext, T> {\n  on(eventName: string, handler: (this: TContext, t: T, ...args: any[]) => any): void;\n  off(eventName: string, handler: (this: TContext, t: T, ...args: any[]) => any): void;\n}\n\nexport interface EventListenerObject<E> {\n  handleEvent(evt: E): void;\n}\n\nexport interface HasEventTargetAddRemove<E> {\n  addEventListener(\n    type: string,\n    listener: ((evt: E) => void) | EventListenerObject<E> | null,\n    options?: boolean | AddEventListenerOptions\n  ): void;\n  removeEventListener(\n    type: string,\n    listener: ((evt: E) => void) | EventListenerObject<E> | null,\n    options?: EventListenerOptions | boolean\n  ): void;\n}\n\nexport interface EventListenerOptions {\n  capture?: boolean;\n  passive?: boolean;\n  once?: boolean;\n}\n\nexport interface AddEventListenerOptions extends EventListenerOptions {\n  once?: boolean;\n  passive?: boolean;\n}\n\nexport function fromEvent<T>(target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>, eventName: string): Observable<T>;\nexport function fromEvent<T, R>(\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\n  eventName: string,\n  resultSelector: (event: T) => R\n): Observable<R>;\nexport function fromEvent<T>(\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\n  eventName: string,\n  options: EventListenerOptions\n): Observable<T>;\nexport function fromEvent<T, R>(\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\n  eventName: string,\n  options: EventListenerOptions,\n  resultSelector: (event: T) => R\n): Observable<R>;\n\nexport function fromEvent(target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>, eventName: string): Observable<unknown>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function fromEvent<T>(target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>, eventName: string): Observable<T>;\nexport function fromEvent<R>(\n  target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>,\n  eventName: string,\n  resultSelector: (...args: any[]) => R\n): Observable<R>;\n\nexport function fromEvent(\n  target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>,\n  eventName: string\n): Observable<unknown>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function fromEvent<T>(target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>, eventName: string): Observable<T>;\nexport function fromEvent<R>(\n  target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>,\n  eventName: string,\n  resultSelector: (...args: any[]) => R\n): Observable<R>;\n\nexport function fromEvent<T>(\n  target: JQueryStyleEventEmitter<any, T> | ArrayLike<JQueryStyleEventEmitter<any, T>>,\n  eventName: string\n): Observable<T>;\nexport function fromEvent<T, R>(\n  target: JQueryStyleEventEmitter<any, T> | ArrayLike<JQueryStyleEventEmitter<any, T>>,\n  eventName: string,\n  resultSelector: (value: T, ...args: any[]) => R\n): Observable<R>;\n\n/**\n * Creates an Observable that emits events of a specific type coming from the\n * given event target.\n *\n * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n * EventEmitter events or others.</span>\n *\n * ![](fromEvent.png)\n *\n * `fromEvent` accepts as a first argument event target, which is an object with methods\n * for registering event handler functions. As a second argument it takes string that indicates\n * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n * which are described in detail below. If your event target does not match any of the ones listed,\n * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n * handler functions have different names, but they all accept a string describing event type\n * and function itself, which will be called whenever said event happens.\n *\n * Every time resulting Observable is subscribed, event handler function will be registered\n * to event target on given event type. When that event fires, value\n * passed as a first argument to registered function will be emitted by output Observable.\n * When Observable is unsubscribed, function will be unregistered from event target.\n *\n * Note that if event target calls registered function with more than one argument, second\n * and following arguments will not appear in resulting stream. In order to get access to them,\n * you can pass to `fromEvent` optional project function, which will be called with all arguments\n * passed to event handler. Output Observable will then emit value returned by project function,\n * instead of the usual value.\n *\n * Remember that event targets listed below are checked via duck typing. It means that\n * no matter what kind of object you have and no matter what environment you work in,\n * you can safely use `fromEvent` on that object if it exposes described methods (provided\n * of course they behave as was described above). So for example if Node.js library exposes\n * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n * a good choice.\n *\n * If the API you use is more callback then event handler oriented (subscribed\n * callback function fires only once and thus there is no need to manually\n * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n * instead.\n *\n * `fromEvent` supports following types of event targets:\n *\n * **DOM EventTarget**\n *\n * This is an object with `addEventListener` and `removeEventListener` methods.\n *\n * In the browser, `addEventListener` accepts - apart from event type string and event\n * handler function arguments - optional third parameter, which is either an object or boolean,\n * both used for additional configuration how and when passed function will be called. When\n * `fromEvent` is used with event target of that type, you can provide this values\n * as third parameter as well.\n *\n * **Node.js EventEmitter**\n *\n * An object with `addListener` and `removeListener` methods.\n *\n * **JQuery-style event target**\n *\n * An object with `on` and `off` methods\n *\n * **DOM NodeList**\n *\n * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n *\n * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n * it contains and install event handler function in every of them. When returned Observable\n * is unsubscribed, function will be removed from all Nodes.\n *\n * **DOM HtmlCollection**\n *\n * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n * installed and removed in each of elements.\n *\n *\n * ## Examples\n *\n * Emit clicks happening on the DOM document\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * clicks.subscribe(x => console.log(x));\n *\n * // Results in:\n * // MouseEvent object logged to console every time a click\n * // occurs on the document.\n * ```\n *\n * Use `addEventListener` with capture option\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * // note optional configuration parameter which will be passed to addEventListener\n * const clicksInDocument = fromEvent(document, 'click', { capture: true });\n * const clicksInDiv = fromEvent(div, 'click');\n *\n * clicksInDocument.subscribe(() => console.log('document'));\n * clicksInDiv.subscribe(() => console.log('div'));\n *\n * // By default events bubble UP in DOM tree, so normally\n * // when we would click on div in document\n * // \"div\" would be logged first and then \"document\".\n * // Since we specified optional `capture` option, document\n * // will catch event when it goes DOWN DOM tree, so console\n * // will log \"document\" and then \"div\".\n * ```\n *\n * @see {@link bindCallback}\n * @see {@link bindNodeCallback}\n * @see {@link fromEventPattern}\n *\n * @param target The DOM EventTarget, Node.js EventEmitter, JQuery-like event target,\n * NodeList or HTMLCollection to attach the event handler to.\n * @param eventName The event name of interest, being emitted by the `target`.\n * @param options Options to pass through to the underlying `addListener`,\n * `addEventListener` or `on` functions.\n * @param resultSelector A mapping function used to transform events. It takes the\n * arguments from the event handler and should return a single value.\n * @return An Observable emitting events registered through `target`'s\n * listener handlers.\n */\nexport function fromEvent<T>(\n  target: any,\n  eventName: string,\n  options?: EventListenerOptions | ((...args: any[]) => T),\n  resultSelector?: (...args: any[]) => T\n): Observable<T> {\n  if (isFunction(options)) {\n    resultSelector = options;\n    options = undefined;\n  }\n  if (resultSelector) {\n    return fromEvent<T>(target, eventName, options as EventListenerOptions).pipe(mapOneOrManyArgs(resultSelector));\n  }\n\n  // Figure out our add and remove methods. In order to do this,\n  // we are going to analyze the target in a preferred order, if\n  // the target matches a given signature, we take the two \"add\" and \"remove\"\n  // method names and apply them to a map to create opposite versions of the\n  // same function. This is because they all operate in duplicate pairs,\n  // `addListener(name, handler)`, `removeListener(name, handler)`, for example.\n  // The call only differs by method name, as to whether or not you're adding or removing.\n  const [add, remove] =\n    // If it is an EventTarget, we need to use a slightly different method than the other two patterns.\n    isEventTarget(target)\n      ? eventTargetMethods.map((methodName) => (handler: any) => target[methodName](eventName, handler, options as EventListenerOptions))\n      : // In all other cases, the call pattern is identical with the exception of the method names.\n      isNodeStyleEventEmitter(target)\n      ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))\n      : isJQueryStyleEventEmitter(target)\n      ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))\n      : [];\n\n  // If add is falsy, it's because we didn't match a pattern above.\n  // Check to see if it is an ArrayLike, because if it is, we want to\n  // try to apply fromEvent to all of it's items. We do this check last,\n  // because there are may be some types that are both ArrayLike *and* implement\n  // event registry points, and we'd rather delegate to that when possible.\n  if (!add) {\n    if (isArrayLike(target)) {\n      return mergeMap((subTarget: any) => fromEvent(subTarget, eventName, options as EventListenerOptions))(\n        innerFrom(target)\n      ) as Observable<T>;\n    }\n  }\n\n  // If add is falsy and we made it here, it's because we didn't\n  // match any valid target objects above.\n  if (!add) {\n    throw new TypeError('Invalid event target');\n  }\n\n  return new Observable<T>((subscriber) => {\n    // The handler we are going to register. Forwards the event object, by itself, or\n    // an array of arguments to the event handler, if there is more than one argument,\n    // to the consumer.\n    const handler = (...args: any[]) => subscriber.next(1 < args.length ? args : args[0]);\n    // Do the work of adding the handler to the target.\n    add(handler);\n    // When we finalize, we want to remove the handler and free up memory.\n    return () => remove!(handler);\n  });\n}\n\n/**\n * Used to create `add` and `remove` functions to register and unregister event handlers\n * from a target in the most common handler pattern, where there are only two arguments.\n * (e.g.  `on(name, fn)`, `off(name, fn)`, `addListener(name, fn)`, or `removeListener(name, fn)`)\n * @param target The target we're calling methods on\n * @param eventName The event name for the event we're creating register or unregister functions for\n */\nfunction toCommonHandlerRegistry(target: any, eventName: string) {\n  return (methodName: string) => (handler: any) => target[methodName](eventName, handler);\n}\n\n/**\n * Checks to see if the target implements the required node-style EventEmitter methods\n * for adding and removing event handlers.\n * @param target the object to check\n */\nfunction isNodeStyleEventEmitter(target: any): target is NodeStyleEventEmitter {\n  return isFunction(target.addListener) && isFunction(target.removeListener);\n}\n\n/**\n * Checks to see if the target implements the required jQuery-style EventEmitter methods\n * for adding and removing event handlers.\n * @param target the object to check\n */\nfunction isJQueryStyleEventEmitter(target: any): target is JQueryStyleEventEmitter<any, any> {\n  return isFunction(target.on) && isFunction(target.off);\n}\n\n/**\n * Checks to see if the target implements the required EventTarget methods\n * for adding and removing event handlers.\n * @param target the object to check\n */\nfunction isEventTarget(target: any): target is HasEventTargetAddRemove<any> {\n  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);\n}\n", "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { async as asyncScheduler } from '../scheduler/async';\nimport { isScheduler } from '../util/isScheduler';\nimport { isValidDate } from '../util/isDate';\n\n/**\n * Creates an observable that will wait for a specified time period, or exact date, before\n * emitting the number 0.\n *\n * <span class=\"informal\">Used to emit a notification after a delay.</span>\n *\n * This observable is useful for creating delays in code, or racing against other values\n * for ad-hoc timeouts.\n *\n * The `delay` is specified by default in milliseconds, however providing a custom scheduler could\n * create a different behavior.\n *\n * ## Examples\n *\n * Wait 3 seconds and start another observable\n *\n * You might want to use `timer` to delay subscription to an\n * observable by a set amount of time. Here we use a timer with\n * {@link concatMapTo} or {@link concatMap} in order to wait\n * a few seconds and start a subscription to a source.\n *\n * ```ts\n * import { of, timer, concatMap } from 'rxjs';\n *\n * // This could be any observable\n * const source = of(1, 2, 3);\n *\n * timer(3000)\n *   .pipe(concatMap(() => source))\n *   .subscribe(console.log);\n * ```\n *\n * Take all values until the start of the next minute\n *\n * Using a `Date` as the trigger for the first emission, you can\n * do things like wait until midnight to fire an event, or in this case,\n * wait until a new minute starts (chosen so the example wouldn't take\n * too long to run) in order to stop watching a stream. Leveraging\n * {@link takeUntil}.\n *\n * ```ts\n * import { interval, takeUntil, timer } from 'rxjs';\n *\n * // Build a Date object that marks the\n * // next minute.\n * const currentDate = new Date();\n * const startOfNextMinute = new Date(\n *   currentDate.getFullYear(),\n *   currentDate.getMonth(),\n *   currentDate.getDate(),\n *   currentDate.getHours(),\n *   currentDate.getMinutes() + 1\n * );\n *\n * // This could be any observable stream\n * const source = interval(1000);\n *\n * const result = source.pipe(\n *   takeUntil(timer(startOfNextMinute))\n * );\n *\n * result.subscribe(console.log);\n * ```\n *\n * ### Known Limitations\n *\n * - The {@link asyncScheduler} uses `setTimeout` which has limitations for how far in the future it can be scheduled.\n *\n * - If a `scheduler` is provided that returns a timestamp other than an epoch from `now()`, and\n * a `Date` object is passed to the `dueTime` argument, the calculation for when the first emission\n * should occur will be incorrect. In this case, it would be best to do your own calculations\n * ahead of time, and pass a `number` in as the `dueTime`.\n *\n * @param due If a `number`, the amount of time in milliseconds to wait before emitting.\n * If a `Date`, the exact time at which to emit.\n * @param scheduler The scheduler to use to schedule the delay. Defaults to {@link asyncScheduler}.\n */\nexport function timer(due: number | Date, scheduler?: SchedulerLike): Observable<0>;\n\n/**\n * Creates an observable that starts an interval after a specified delay, emitting incrementing numbers -- starting at `0` --\n * on each interval after words.\n *\n * The `delay` and `intervalDuration` are specified by default in milliseconds, however providing a custom scheduler could\n * create a different behavior.\n *\n * ## Example\n *\n * ### Start an interval that starts right away\n *\n * Since {@link interval} waits for the passed delay before starting,\n * sometimes that's not ideal. You may want to start an interval immediately.\n * `timer` works well for this. Here we have both side-by-side so you can\n * see them in comparison.\n *\n * Note that this observable will never complete.\n *\n * ```ts\n * import { timer, interval } from 'rxjs';\n *\n * timer(0, 1000).subscribe(n => console.log('timer', n));\n * interval(1000).subscribe(n => console.log('interval', n));\n * ```\n *\n * ### Known Limitations\n *\n * - The {@link asyncScheduler} uses `setTimeout` which has limitations for how far in the future it can be scheduled.\n *\n * - If a `scheduler` is provided that returns a timestamp other than an epoch from `now()`, and\n * a `Date` object is passed to the `dueTime` argument, the calculation for when the first emission\n * should occur will be incorrect. In this case, it would be best to do your own calculations\n * ahead of time, and pass a `number` in as the `startDue`.\n * @param startDue If a `number`, is the time to wait before starting the interval.\n * If a `Date`, is the exact time at which to start the interval.\n * @param intervalDuration The delay between each value emitted in the interval. Passing a\n * negative number here will result in immediate completion after the first value is emitted, as though\n * no `intervalDuration` was passed at all.\n * @param scheduler The scheduler to use to schedule the delay. Defaults to {@link asyncScheduler}.\n */\nexport function timer(startDue: number | Date, intervalDuration: number, scheduler?: SchedulerLike): Observable<number>;\n\n/**\n * @deprecated The signature allowing `undefined` to be passed for `intervalDuration` will be removed in v8. Use the `timer(dueTime, scheduler?)` signature instead.\n */\nexport function timer(dueTime: number | Date, unused: undefined, scheduler?: SchedulerLike): Observable<0>;\n\nexport function timer(\n  dueTime: number | Date = 0,\n  intervalOrScheduler?: number | SchedulerLike,\n  scheduler: SchedulerLike = asyncScheduler\n): Observable<number> {\n  // Since negative intervalDuration is treated as though no\n  // interval was specified at all, we start with a negative number.\n  let intervalDuration = -1;\n\n  if (intervalOrScheduler != null) {\n    // If we have a second argument, and it's a scheduler,\n    // override the scheduler we had defaulted. Otherwise,\n    // it must be an interval.\n    if (isScheduler(intervalOrScheduler)) {\n      scheduler = intervalOrScheduler;\n    } else {\n      // Note that this *could* be negative, in which case\n      // it's like not passing an intervalDuration at all.\n      intervalDuration = intervalOrScheduler;\n    }\n  }\n\n  return new Observable((subscriber) => {\n    // If a valid date is passed, calculate how long to wait before\n    // executing the first value... otherwise, if it's a number just schedule\n    // that many milliseconds (or scheduler-specified unit size) in the future.\n    let due = isValidDate(dueTime) ? +dueTime - scheduler!.now() : dueTime;\n\n    if (due < 0) {\n      // Ensure we don't schedule in the future.\n      due = 0;\n    }\n\n    // The incrementing value we emit.\n    let n = 0;\n\n    // Start the timer.\n    return scheduler.schedule(function () {\n      if (!subscriber.closed) {\n        // Emit the next value and increment.\n        subscriber.next(n++);\n\n        if (0 <= intervalDuration) {\n          // If we have a interval after the initial timer,\n          // reschedule with the period.\n          this.schedule(undefined, intervalDuration);\n        } else {\n          // We didn't have an interval. So just complete.\n          subscriber.complete();\n        }\n      }\n    }, due);\n  });\n}\n", "import { Observable } from '../Observable';\nimport { noop } from '../util/noop';\n\n/**\n * An Observable that emits no items to the Observer and never completes.\n *\n * ![](never.png)\n *\n * A simple Observable that emits neither values nor errors nor the completion\n * notification. It can be used for testing purposes or for composing with other\n * Observables. Please note that by never emitting a complete notification, this\n * Observable keeps the subscription from being disposed automatically.\n * Subscriptions need to be manually disposed.\n *\n * ##  Example\n *\n * Emit the number 7, then never emit anything else (not even complete)\n *\n * ```ts\n * import { NEVER, startWith } from 'rxjs';\n *\n * const info = () => console.log('Will not be called');\n *\n * const result = NEVER.pipe(startWith(7));\n * result.subscribe({\n *   next: x => console.log(x),\n *   error: info,\n *   complete: info\n * });\n * ```\n *\n * @see {@link Observable}\n * @see {@link EMPTY}\n * @see {@link of}\n * @see {@link throwError}\n */\nexport const NEVER = new Observable<never>(noop);\n\n/**\n * @deprecated Replaced with the {@link NEVER} constant. Will be removed in v8.\n */\nexport function never() {\n  return NEVER;\n}\n", "const { isArray } = Array;\n\n/**\n * Used in operators and functions that accept either a list of arguments, or an array of arguments\n * as a single argument.\n */\nexport function argsOrArgArray<T>(args: (T | T[])[]): T[] {\n  return args.length === 1 && isArray(args[0]) ? args[0] : (args as T[]);\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport const MAC_ENTER = 3;\nexport const BACKSPACE = 8;\nexport const TAB = 9;\nexport const NUM_CENTER = 12;\nexport const ENTER = 13;\nexport const SHIFT = 16;\nexport const CONTROL = 17;\nexport const ALT = 18;\nexport const PAUSE = 19;\nexport const CAPS_LOCK = 20;\nexport const ESCAPE = 27;\nexport const SPACE = 32;\nexport const PAGE_UP = 33;\nexport const PAGE_DOWN = 34;\nexport const END = 35;\nexport const HOME = 36;\nexport const LEFT_ARROW = 37;\nexport const UP_ARROW = 38;\nexport const RIGHT_ARROW = 39;\nexport const DOWN_ARROW = 40;\nexport const PLUS_SIGN = 43;\nexport const PRINT_SCREEN = 44;\nexport const INSERT = 45;\nexport const DELETE = 46;\nexport const ZERO = 48;\nexport const ONE = 49;\nexport const TWO = 50;\nexport const THREE = 51;\nexport const FOUR = 52;\nexport const FIVE = 53;\nexport const SIX = 54;\nexport const SEVEN = 55;\nexport const EIGHT = 56;\nexport const NINE = 57;\nexport const FF_SEMICOLON = 59; // Firefox (Gecko) fires this for semicolon instead of 186\nexport const FF_EQUALS = 61; // Firefox (Gecko) fires this for equals instead of 187\nexport const QUESTION_MARK = 63;\nexport const AT_SIGN = 64;\nexport const A = 65;\nexport const B = 66;\nexport const C = 67;\nexport const D = 68;\nexport const E = 69;\nexport const F = 70;\nexport const G = 71;\nexport const H = 72;\nexport const I = 73;\nexport const J = 74;\nexport const K = 75;\nexport const L = 76;\nexport const M = 77;\nexport const N = 78;\nexport const O = 79;\nexport const P = 80;\nexport const Q = 81;\nexport const R = 82;\nexport const S = 83;\nexport const T = 84;\nexport const U = 85;\nexport const V = 86;\nexport const W = 87;\nexport const X = 88;\nexport const Y = 89;\nexport const Z = 90;\nexport const META = 91; // WIN_KEY_LEFT\nexport const MAC_WK_CMD_LEFT = 91;\nexport const MAC_WK_CMD_RIGHT = 93;\nexport const CONTEXT_MENU = 93;\nexport const NUMPAD_ZERO = 96;\nexport const NUMPAD_ONE = 97;\nexport const NUMPAD_TWO = 98;\nexport const NUMPAD_THREE = 99;\nexport const NUMPAD_FOUR = 100;\nexport const NUMPAD_FIVE = 101;\nexport const NUMPAD_SIX = 102;\nexport const NUMPAD_SEVEN = 103;\nexport const NUMPAD_EIGHT = 104;\nexport const NUMPAD_NINE = 105;\nexport const NUMPAD_MULTIPLY = 106;\nexport const NUMPAD_PLUS = 107;\nexport const NUMPAD_MINUS = 109;\nexport const NUMPAD_PERIOD = 110;\nexport const NUMPAD_DIVIDE = 111;\nexport const F1 = 112;\nexport const F2 = 113;\nexport const F3 = 114;\nexport const F4 = 115;\nexport const F5 = 116;\nexport const F6 = 117;\nexport const F7 = 118;\nexport const F8 = 119;\nexport const F9 = 120;\nexport const F10 = 121;\nexport const F11 = 122;\nexport const F12 = 123;\nexport const NUM_LOCK = 144;\nexport const SCROLL_LOCK = 145;\nexport const FIRST_MEDIA = 166;\nexport const FF_MINUS = 173;\nexport const MUTE = 173; // Firefox (Gecko) fires 181 for MUTE\nexport const VOLUME_DOWN = 174; // Firefox (Gecko) fires 182 for VOLUME_DOWN\nexport const VOLUME_UP = 175; // Firefox (Gecko) fires 183 for VOLUME_UP\nexport const FF_MUTE = 181;\nexport const FF_VOLUME_DOWN = 182;\nexport const LAST_MEDIA = 183;\nexport const FF_VOLUME_UP = 183;\nexport const SEMICOLON = 186; // Firefox (Gecko) fires 59 for SEMICOLON\nexport const EQUALS = 187; // Firefox (Gecko) fires 61 for EQUALS\nexport const COMMA = 188;\nexport const DASH = 189; // Firefox (Gecko) fires 173 for DASH/MINUS\nexport const PERIOD = 190;\nexport const SLASH = 191;\nexport const APOSTROPHE = 192;\nexport const TILDE = 192;\nexport const OPEN_SQUARE_BRACKET = 219;\nexport const BACKSLASH = 220;\nexport const CLOSE_SQUARE_BRACKET = 221;\nexport const SINGLE_QUOTE = 222;\nexport const MAC_META = 224;\n", "export enum ResizeCursorClass {\n    ew = 'ew-resize',\n    ns = 'ns-resize',\n    nesw = 'nesw-resize',\n    nwse = 'nwse-resize'\n}\n\nexport enum CursorClass {\n    crosshair = 'crosshair'\n}\n\nexport const RESIZE_CURSORS = [ResizeCursorClass.ns, ResizeCursorClass.nesw, ResizeCursorClass.ew, ResizeCursorClass.nwse];\n", "export const ATTACHED_ELEMENT_CLASS_NAME = 'plait-board-attached';\n\nexport const ACTIVE_STROKE_WIDTH = 1;\n\nexport const SNAPPING_STROKE_WIDTH = 2;\n\nexport const SELECTION_RECTANGLE_CLASS_NAME = 'selection-rectangle';\n\nexport const SELECTION_RECTANGLE_BOUNDING_CLASS_NAME = 'selection-rectangle-bounding';\n", "export const ZOOM_STEP = 0.1;\nexport const MIN_ZOOM = 0.1;\nexport const MAX_ZOOM = 4;\n", "export * from './keycodes';\nexport * from './cursor';\nexport * from './selection';\nexport * from './zoom';\n\nexport const HOST_CLASS_NAME = 'plait-board-container';\n\nexport const ACTIVE_MOVING_CLASS_NAME = 'active-with-moving';\n\nexport const ROTATE_HANDLE_CLASS_NAME = 'rotate-handle';\n\nexport const RESIZE_HANDLE_CLASS_NAME = 'resize-handle';\n\nexport const SCROLL_BAR_WIDTH = 20;\n\nexport const MAX_RADIUS = 16;\n\nexport const POINTER_BUTTON = {\n    MAIN: 0,\n    WHEEL: 1,\n    SECONDARY: 2,\n    TOUCH: -1\n} as const;\n\nexport const PRESS_AND_MOVE_BUFFER = 3;\n\nexport const DRAG_SELECTION_PRESS_AND_MOVE_BUFFER = 10;\n\nexport const HIT_DISTANCE_BUFFER = 5;\n", "import { PlaitBoard, PlaitElement } from '../../interfaces';\nimport { PlaitPluginElementContext } from './context';\n\nexport interface BeforeContextChange<T extends PlaitElement = PlaitElement, K extends PlaitBoard = PlaitBoard> {\n    beforeContextChange: (value: PlaitPluginElementContext<T>) => void;\n}\n\nexport interface OnContextChanged<T extends PlaitElement = PlaitElement, K extends PlaitBoard = PlaitBoard> {\n    onContextChanged: (value: PlaitPluginElementContext<T, K>, previous: PlaitPluginElementContext<T, K>) => void;\n}\n\nexport function hasBeforeContextChange<T extends PlaitElement = PlaitElement, K extends PlaitBoard = PlaitBoard>(\n    value: any\n): value is BeforeContextChange<T, K> {\n    if (value.beforeContextChange) {\n        return true;\n    }\n    return false;\n}\n\nexport function hasOnContextChanged<T extends PlaitElement = PlaitElement, K extends PlaitBoard = PlaitBoard>(\n    value: any\n): value is OnContextChanged<T, K> {\n    if (value.onContextChanged) {\n        return true;\n    }\n    return false;\n}\n", "import { RoughSVG } from 'roughjs/bin/svg';\nimport { PlaitElement } from '../interfaces/element';\nimport { PlaitBoard } from '../interfaces/board';\nimport { Point } from '../interfaces/point';\nimport { Ancestor, PlaitNode } from '../interfaces/node';\nimport { PathRef } from '../interfaces/path-ref';\nimport { PlaitElementRef } from '../core/element/element-ref';\nimport { PlaitBoardContext } from '../context';\n\n// record richtext type status\nexport const IS_BOARD_CACHE = new WeakMap<Object, boolean>();\n\nexport const FLUSHING = new WeakMap<PlaitBoard, boolean>();\n\nexport const NODE_TO_INDEX = new WeakMap<PlaitNode, number>();\n\nexport const NODE_TO_PARENT = new WeakMap<PlaitNode, Ancestor>();\n\nexport const KEY_TO_ELEMENT_MAP = new WeakMap<PlaitBoard, Map<String, PlaitElement>>();\n\nexport const NODE_TO_G = new WeakMap<PlaitNode, SVGGElement>();\n\nexport const NODE_TO_CONTAINER_G = new WeakMap<PlaitNode, SVGGElement>();\n\nexport const IS_TEXT_EDITABLE = new WeakMap<PlaitBoard, boolean>();\n\nexport const BOARD_TO_ON_CHANGE = new WeakMap<PlaitBoard, () => void>();\n\nexport const BOARD_TO_AFTER_CHANGE = new WeakMap<PlaitBoard, () => void>();\n\nexport const BOARD_TO_ROUGH_SVG = new WeakMap<PlaitBoard, RoughSVG>();\n\nexport const BOARD_TO_HOST = new WeakMap<PlaitBoard, SVGSVGElement>();\n\nexport const BOARD_TO_CONTEXT = new WeakMap<PlaitBoard, PlaitBoardContext>();\n\nexport const IS_BOARD_ALIVE = new WeakMap<PlaitBoard, boolean>();\n\nexport const BOARD_TO_ELEMENT_HOST = new WeakMap<\n    PlaitBoard,\n    {\n        lowerHost: SVGGElement;\n        host: SVGGElement;\n        upperHost: SVGGElement;\n        topHost: SVGGElement;\n        activeHost: SVGGElement;\n        container: HTMLElement;\n        viewportContainer: HTMLElement;\n    }\n>();\n\nexport const BOARD_TO_SELECTED_ELEMENT = new WeakMap<PlaitBoard, PlaitElement[]>();\n\nexport const BOARD_TO_MOVING_POINT_IN_BOARD = new WeakMap<PlaitBoard, Point>();\n\nexport const BOARD_TO_MOVING_POINT = new WeakMap<PlaitBoard, Point>();\n\nexport const BOARD_TO_VIEWPORT_ORIGINATION = new WeakMap<PlaitBoard, Point>();\n\nexport const BOARD_TO_IS_SELECTION_MOVING = new WeakMap<PlaitBoard, boolean>();\n\n// save no standard selected elements\nexport const BOARD_TO_TEMPORARY_ELEMENTS = new WeakMap<PlaitBoard, { elements: PlaitElement[]; timeoutId: any }>();\n\nexport const BOARD_TO_MOVING_ELEMENT = new WeakMap<PlaitBoard, PlaitElement[]>();\n\nexport const PATH_REFS: WeakMap<PlaitBoard, Set<PathRef>> = new WeakMap();\n\nexport const ELEMENT_TO_REF: WeakMap<PlaitElement, PlaitElementRef> = new WeakMap();\n", "import { PlaitElement } from '../interfaces';\n\nexport function isNullOrUndefined(value: any) {\n    return value === null || value === undefined;\n}\n\n/**\n * get {x,y} point\n * @param point\n * @returns point\n */\nexport function normalizePoint(point: number[]) {\n    return Array.isArray(point)\n        ? {\n              x: point[0],\n              y: point[1]\n          }\n        : point;\n}\n\nexport const rgbaToHEX = (rgb: string, opacity: number) => {\n    return rgb + Math.floor(opacity * 255).toString(16);\n};\n\nexport function isContextmenu(event: MouseEvent) {\n    return event.button === 2;\n}\n\nexport function uniqueById(elements: PlaitElement[]) {\n    const uniqueMap = new Map();\n\n    elements.forEach(item => {\n        if (!uniqueMap.has(item.id)) {\n            uniqueMap.set(item.id, item);\n        }\n    });\n\n    return Array.from(uniqueMap.values());\n}\n\nexport const findLastIndex = <T>(\n    array: readonly T[],\n    cb: (element: T, index: number, array: readonly T[]) => boolean,\n    fromIndex: number = array.length - 1\n) => {\n    if (fromIndex < 0) {\n        fromIndex = array.length + fromIndex;\n    }\n    fromIndex = Math.min(array.length - 1, Math.max(fromIndex, 0));\n    let index = fromIndex + 1;\n    while (--index > -1) {\n        if (cb(array[index], index, array)) {\n            return index;\n        }\n    }\n    return -1;\n};\n\nexport const findIndex = <T>(\n    array: readonly T[],\n    cb: (element: T, index: number, array: readonly T[]) => boolean,\n    fromIndex: number = 0\n) => {\n    // fromIndex = 2\n    if (fromIndex < 0) {\n        fromIndex = array.length + fromIndex;\n    }\n    fromIndex = Math.min(array.length, Math.max(fromIndex, 0));\n    let index = fromIndex - 1;\n    while (++index < array.length) {\n        if (cb(array[index], index, array)) {\n            return index;\n        }\n    }\n    return -1;\n};\n\nexport const isIndicesContinuous = (indexes: number[]): boolean => {\n    indexes.sort((a, b) => a - b);\n    for (let i = 1; i < indexes.length; i++) {\n        if (indexes[i] !== indexes[i - 1] + 1) {\n            return false;\n        }\n    }\n    return true;\n};\n", "import { isNullOrUndefined } from '../utils/helper';\nimport { ExtendedType } from './custom-types';\nimport { Point } from './point';\n\nexport interface BaseViewport {\n    [key: string]: any;\n    zoom: number;\n    origination?: Point;\n}\n\nexport type Viewport = ExtendedType<'Viewport', BaseViewport>;\n\nexport interface ViewportInterface {\n    isViewport: (value: any) => value is Viewport;\n}\n\nexport const Viewport: ViewportInterface = {\n    isViewport: (value: any): value is Viewport => {\n        return !isNullOrUndefined(value.zoom) && !isNullOrUndefined(value.viewBackgroundColor);\n    }\n};\n\nexport interface FitViewportOptions {\n    maxWidth?: number;\n    limitHeight: number;\n    autoFitPadding: number;\n    containerClass: string;\n}\n", "import { PlaitOperation } from './operation';\n\nexport interface PathLevelsOptions {\n    reverse?: boolean;\n}\n\nexport type Path = number[];\n\nexport const Path = {\n    /**\n     * Get a list of ancestor paths for a given path.\n     *\n     * The paths are sorted from shallowest to deepest ancestor. However, if the\n     * `reverse: true` option is passed, they are reversed.\n     */\n    ancestors(path: Path, options: PathLevelsOptions = {}): Path[] {\n        const { reverse = false } = options;\n        let paths = Path.levels(path, options);\n\n        if (reverse) {\n            paths = paths.slice(1);\n        } else {\n            paths = paths.slice(0, -1);\n        }\n\n        return paths;\n    },\n    /**\n     * Get a list of paths at every level down to a path. Note: this is the same\n     * as `Path.ancestors`, but including the path itself.\n     *\n     * The paths are sorted from shallowest to deepest. However, if the `reverse:\n     * true` option is passed, they are reversed.\n     */\n    levels(path: Path, options: PathLevelsOptions = {}): Path[] {\n        const { reverse = false } = options;\n        const list: Path[] = [];\n\n        for (let i = 0; i <= path.length; i++) {\n            list.push(path.slice(0, i));\n        }\n\n        if (reverse) {\n            list.reverse();\n        }\n\n        return list;\n    },\n    parent(path: Path): Path {\n        if (path.length === 0) {\n            throw new Error(`Cannot get the parent path of the root path [${path}].`);\n        }\n\n        return path.slice(0, -1);\n    },\n    next(path: Path): Path {\n        if (path.length === 0) {\n            throw new Error(`Cannot get the next path of a root path [${path}], because it has no next index.`);\n        }\n        const last = path[path.length - 1];\n        return path.slice(0, -1).concat(last + 1);\n    },\n    hasPrevious(path: Path): boolean {\n        return path[path.length - 1] > 0;\n    },\n    previous(path: Path): Path {\n        if (path.length === 0) {\n            throw new Error(`Cannot get the previous path of a root path [${path}], because it has no previous index.`);\n        }\n\n        const last = path[path.length - 1];\n\n        if (last <= 0) {\n            throw new Error(`Cannot get the previous path of a first child path [${path}] because it would result in a negative index.`);\n        }\n\n        return path.slice(0, -1).concat(last - 1);\n    },\n    /**\n     * Check if a path is an ancestor of another.\n     */\n\n    isAncestor(path: Path, another: Path): boolean {\n        return path.length < another.length && Path.compare(path, another) === 0;\n    },\n    /**\n     * Compare a path to another, returning an integer indicating whether the path\n     * was before, at, or after the other.\n     *\n     * Note: Two paths of unequal length can still receive a `0` result if one is\n     * directly above or below the other. If you want exact matching, use\n     * [[Path.equals]] instead.\n     */\n    compare(path: Path, another: Path): -1 | 0 | 1 {\n        const min = Math.min(path.length, another.length);\n\n        for (let i = 0; i < min; i++) {\n            if (path[i] < another[i]) return -1;\n            if (path[i] > another[i]) return 1;\n        }\n\n        return 0;\n    },\n\n    /**\n     * Check if a path is exactly equal to another.\n     */\n\n    equals(path: Path, another: Path): boolean {\n        return path.length === another.length && path.every((n, i) => n === another[i]);\n    },\n    /**\n     * Check if a path ends before one of the indexes in another.\n     */\n\n    endsBefore(path: Path, another: Path): boolean {\n        const i = path.length - 1;\n        const as = path.slice(0, i);\n        const bs = another.slice(0, i);\n        const av = path[i];\n        const bv = another[i];\n        return Path.equals(as, bs) && av < bv;\n    },\n    /**\n     * Check if a path is a sibling of another.\n     */\n    isSibling(path: Path, another: Path): boolean {\n        if (path.length !== another.length) {\n            return false;\n        }\n\n        const as = path.slice(0, -1);\n        const bs = another.slice(0, -1);\n        const al = path[path.length - 1];\n        const bl = another[another.length - 1];\n        return al !== bl && Path.equals(as, bs);\n    },\n    transform(path: Path | null, operation: PlaitOperation): Path | null {\n        if (!path) return null;\n        // PERF: use destructing instead of immer\n        const p = [...path];\n\n        // PERF: Exit early if the operation is guaranteed not to have an effect.\n        if (path.length === 0) {\n            return p;\n        }\n\n        switch (operation.type) {\n            case 'insert_node': {\n                const { path: op } = operation;\n\n                if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {\n                    p[op.length - 1] += 1;\n                }\n\n                break;\n            }\n\n            case 'remove_node': {\n                const { path: op } = operation;\n\n                if (Path.equals(op, p) || Path.isAncestor(op, p)) {\n                    return null;\n                } else if (Path.endsBefore(op, p)) {\n                    p[op.length - 1] -= 1;\n                }\n\n                break;\n            }\n\n            case 'move_node': {\n                const { path: op, newPath: onp } = operation;\n\n                // If the old and new path are the same, it's a no-op.\n                if (Path.equals(op, onp)) {\n                    return p;\n                }\n\n                if (Path.isAncestor(op, p) || Path.equals(op, p)) {\n                    const copy = onp.slice();\n\n                    if (Path.endsBefore(op, onp) && op.length < onp.length) {\n                        copy[op.length - 1] -= 1;\n                    }\n\n                    return copy.concat(p.slice(op.length));\n                } else if (Path.isSibling(op, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {\n                    if (Path.endsBefore(op, p)) {\n                        p[op.length - 1] -= 1;\n                    } else {\n                        p[op.length - 1] += 1;\n                    }\n                } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {\n                    if (Path.endsBefore(op, p)) {\n                        p[op.length - 1] -= 1;\n                    }\n\n                    p[onp.length - 1] += 1;\n                } else if (Path.endsBefore(op, p)) {\n                    if (Path.equals(onp, p)) {\n                        p[onp.length - 1] += 1;\n                    }\n\n                    p[op.length - 1] -= 1;\n                }\n\n                break;\n            }\n        }\n        return p;\n    }\n};\n", "import { PlaitElement } from './element';\nimport { PlaitBoard } from './board';\nimport { Path } from './path';\n\nexport type PlaitNode = PlaitElement;\n\nexport type Ancestor = PlaitBoard | PlaitElement;\n\nexport interface NodeParentsOptions {\n    reverse?: boolean;\n}\n\nexport const PlaitNode = {\n    parent: (board: PlaitBoard, path: Path) => {\n        const parentPath = Path.parent(path);\n        const p = PlaitNode.get(board, parentPath);\n        return p;\n    },\n    /**\n     * Return a generator of all the ancestor nodes above a specific path.\n     *\n     * By default the order is top-down, from highest to lowest ancestor in\n     * the tree, but you can pass the `reverse: true` option to go bottom-up.\n     */\n    *parents(root: PlaitBoard, path: Path, options: NodeParentsOptions = {}): Generator<PlaitNode, void, undefined> {\n        for (const p of Path.ancestors(path, options)) {\n            const n = PlaitNode.get(root, p);\n            yield n;\n        }\n    },\n    get<T extends PlaitNode = PlaitNode>(root: PlaitBoard, path: Path): T {\n        let node: Ancestor = root;\n        for (let i = 0; i < path.length; i++) {\n            const p = path[i];\n            if (!node || !node.children || !node.children[p]) {\n                throw new Error(`Cannot find a descendant at path [${path}]`);\n            }\n            node = node.children[p];\n        }\n        return node as T;\n    },\n    last(board: PlaitBoard, path: Path) {\n        let n = PlaitNode.get(board, path);\n        while (n && n.children && n.children.length > 0) {\n            const i = n.children.length - 1;\n            n = n.children[i];\n        }\n        return n;\n    },\n    first(board: PlaitBoard, path: Path) {\n        const p = path.slice();\n        let n = PlaitNode.get(board, p);\n        if (!n.children || !board.isExpanded(n)) {\n            return n;\n        }\n        while (n && n.children && n.children.length > 0 && board.isExpanded(n)) {\n            if (n.children!.length === 0) {\n                break;\n            } else {\n                n = n.children![0];\n                p.push(0);\n            }\n        }\n        return n;\n    }\n};\n", "import { PlaitOperation } from '../interfaces/operation';\nimport { PlaitBoard } from '../interfaces/board';\nimport { createDraft, finishDraft, isDraft } from 'immer';\nimport { Viewport } from '../interfaces/viewport';\nimport { Selection } from '../interfaces/selection';\nimport { Ancestor, PlaitNode } from '../interfaces/node';\nimport { Path } from '../interfaces/path';\nimport { PlaitTheme } from '../interfaces/theme';\n\nexport interface GeneralTransforms {\n    transform: (board: PlaitBoard, op: PlaitOperation) => void;\n}\n\nconst applyToDraft = (board: PlaitBoard, selection: Selection | null, viewport: Viewport, theme: PlaitTheme, op: PlaitOperation) => {\n    switch (op.type) {\n        case 'insert_node': {\n            const { path, node } = op;\n            const parent = PlaitNode.parent(board, path);\n            const index = path[path.length - 1];\n\n            if (!parent.children || index > parent.children.length) {\n                throw new Error(\n                    `Cannot apply an \"insert_node\" operation at path [${path}] because the destination is past the end of the node.`\n                );\n            }\n\n            parent.children.splice(index, 0, node);\n            break;\n        }\n        case 'remove_node': {\n            const { path } = op;\n            const parent = PlaitNode.parent(board, path);\n            const index = path[path.length - 1];\n\n            if (!parent.children || index > parent.children.length) {\n                throw new Error(\n                    `Cannot apply an \"insert_node\" operation at path [${path}] because the destination is past the end of the node.`\n                );\n            }\n            parent.children.splice(index, 1);\n            break;\n        }\n        case 'move_node': {\n            const { path, newPath } = op;\n\n            if (Path.isAncestor(path, newPath)) {\n                throw new Error(`Cannot move a path [${path}] to new path [${newPath}] because the destination is inside itself.`);\n            }\n\n            const node = PlaitNode.get(board, path);\n            const parent = PlaitNode.parent(board, path);\n            const index = path[path.length - 1];\n\n            // This is tricky, but since the `path` and `newPath` both refer to\n            // the same snapshot in time, there's a mismatch. After either\n            // removing the original position, the second step's path can be out\n            // of date. So instead of using the `op.newPath` directly, we\n            // transform `op.path` to ascertain what the `newPath` would be after\n            // the operation was applied.\n            parent.children?.splice(index, 1);\n            const truePath = Path.transform(path, op)!;\n            const newParent = PlaitNode.get(board, Path.parent(truePath)) as Ancestor;\n            const newIndex = truePath[truePath.length - 1];\n\n            newParent.children?.splice(newIndex, 0, node);\n            break;\n        }\n        case 'set_node': {\n            const { path, properties, newProperties } = op;\n\n            if (path.length === 0) {\n                throw new Error(`Cannot set properties on the root node!`);\n            }\n\n            const node = PlaitNode.get(board, path);\n\n            for (const key in newProperties) {\n                const value = newProperties[key];\n\n                if (value == null) {\n                    delete node[key];\n                } else {\n                    node[key] = value;\n                }\n            }\n\n            // properties that were previously defined, but are now missing, must be deleted\n            for (const key in properties) {\n                if (!newProperties.hasOwnProperty(key)) {\n                    delete node[key];\n                }\n            }\n\n            break;\n        }\n        case 'set_viewport': {\n            const { newProperties } = op;\n            if (newProperties == null) {\n                viewport = newProperties;\n            } else {\n                if (viewport == null) {\n                    if (!Viewport.isViewport(newProperties)) {\n                        throw new Error(\n                            `Cannot apply an incomplete \"set_viewport\" operation properties ${JSON.stringify(\n                                newProperties\n                            )} when there is no current viewport.`\n                        );\n                    }\n                    viewport = { ...newProperties };\n                }\n\n                for (const key in newProperties) {\n                    const value = newProperties[key];\n\n                    if (value == null) {\n                        delete viewport[key];\n                    } else {\n                        viewport[key] = value;\n                    }\n                }\n            }\n            break;\n        }\n        case 'set_selection': {\n            const { newProperties } = op;\n            if (newProperties == null) {\n                selection = newProperties;\n            } else {\n                if (selection === null) {\n                    selection = op.newProperties;\n                } else {\n                    selection = newProperties;\n                }\n            }\n            break;\n        }\n        case 'set_theme': {\n            const { newProperties } = op;\n            theme = newProperties as PlaitTheme;\n            break;\n        }\n    }\n    return { selection, viewport, theme };\n};\n\nexport const GeneralTransforms: GeneralTransforms = {\n    /**\n     * Transform the board by an operation.\n     */\n    transform(board: PlaitBoard, op: PlaitOperation): void {\n        board.children = createDraft(board.children);\n        let viewport = board.viewport && createDraft(board.viewport);\n        let selection = board.selection && createDraft(board.selection);\n        let theme = board.theme && createDraft(board.theme);\n\n        try {\n            const state = applyToDraft(board, selection, viewport, theme, op);\n            viewport = state.viewport;\n            selection = state.selection;\n            theme = state.theme;\n        } finally {\n            board.children = finishDraft(board.children);\n\n            if (selection) {\n                board.selection = isDraft(selection) ? (finishDraft(selection) as Selection) : selection;\n            } else {\n                board.selection = null;\n            }\n\n            board.viewport = isDraft(viewport) ? (finishDraft(viewport) as Viewport) : viewport;\n            board.theme = isDraft(theme) ? finishDraft(theme) : theme;\n        }\n    }\n};\n", "import { rotate } from '../utils';\nimport { Point } from './point';\n\nexport interface RectangleClient {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n}\n\n/**\n * [x, y] x,y between 0 and 1\n * represents a point in the rectangle\n */\nexport type PointOfRectangle = [number, number];\n\nexport const RectangleClient = {\n    isHit: (origin: RectangleClient, target: RectangleClient) => {\n        return RectangleClient.isHitX(origin, target) && RectangleClient.isHitY(origin, target);\n    },\n    isHitX: (origin: RectangleClient, target: RectangleClient) => {\n        const minX = origin.x < target.x ? origin.x : target.x;\n        const maxX = origin.x + origin.width > target.x + target.width ? origin.x + origin.width : target.x + target.width;\n        // float calculate error( eg: 1.4210854715202004e-14 > 0)\n        if (Math.floor(maxX - minX - origin.width - target.width) <= 0) {\n            return true;\n        } else {\n            return false;\n        }\n    },\n    isHitY: (origin: RectangleClient, target: RectangleClient) => {\n        const minY = origin.y < target.y ? origin.y : target.y;\n        const maxY = origin.y + origin.height > target.y + target.height ? origin.y + origin.height : target.y + target.height;\n        // float calculate error( eg: 1.4210854715202004e-14 > 0)\n        if (Math.floor(maxY - minY - origin.height - target.height) <= 0) {\n            return true;\n        } else {\n            return false;\n        }\n    },\n    getPoints(rectangle: RectangleClient) {\n        return [\n            [rectangle.x, rectangle.y],\n            [rectangle.x + rectangle.width, rectangle.y + rectangle.height]\n        ] as [Point, Point];\n    },\n    getRectangleByCenterPoint(point: Point, width: number, height: number) {\n        return RectangleClient.getRectangleByPoint([point[0] - width / 2, point[1] - height / 2], width, height);\n    },\n    getRectangleByPoint(point: Point, width: number, height: number): RectangleClient {\n        return {\n            x: point[0],\n            y: point[1],\n            width,\n            height\n        };\n    },\n    getRectangleByPoints(points: Point[] | Point[][]): RectangleClient {\n        if (isPointArray(points)) {\n            points = [points];\n        }\n        let xMin = Infinity;\n        let yMin = Infinity;\n        let xMax = -Infinity;\n        let yMax = -Infinity;\n        for (const point of points) {\n            const xArray = point.map(ele => ele[0]);\n            const yArray = point.map(ele => ele[1]);\n            xMin = Math.min(xMin, ...xArray);\n            yMin = Math.min(yMin, ...yArray);\n            xMax = Math.max(xMax, ...xArray);\n            yMin = Math.min(yMin, ...yArray);\n            yMax = Math.max(yMax, ...yArray);\n        }\n        const rect = { x: xMin, y: yMin, width: xMax - xMin, height: yMax - yMin };\n        return rect;\n    },\n    getCornerPointsByPoints(points: Point[]) {\n        const xArray = points.map(ele => ele[0]);\n        const yArray = points.map(ele => ele[1]);\n        const xMin = Math.min(...xArray);\n        const xMax = Math.max(...xArray);\n        const yMin = Math.min(...yArray);\n        const yMax = Math.max(...yArray);\n        return [\n            [xMin, yMin],\n            [xMax, yMin],\n            [xMax, yMax],\n            [xMin, yMax]\n        ] as [Point, Point, Point, Point];\n    },\n    getOutlineRectangle: (rectangle: RectangleClient, offset: number) => {\n        return {\n            x: rectangle.x + offset,\n            y: rectangle.y + offset,\n            width: rectangle.width - offset * 2,\n            height: rectangle.height - offset * 2\n        };\n    },\n    inflate: (rectangle: RectangleClient, delta: number) => {\n        const half = delta / 2;\n        return {\n            x: rectangle.x - half,\n            y: rectangle.y - half,\n            width: rectangle.width + half * 2,\n            height: rectangle.height + half * 2\n        };\n    },\n    isEqual: (rectangle: RectangleClient, otherRectangle: RectangleClient) => {\n        return (\n            rectangle.x === otherRectangle.x &&\n            rectangle.y === otherRectangle.y &&\n            rectangle.width === otherRectangle.width &&\n            rectangle.height === otherRectangle.height\n        );\n    },\n    getCornerPoints: (rectangle: RectangleClient) => {\n        return [\n            [rectangle.x, rectangle.y],\n            [rectangle.x + rectangle.width, rectangle.y],\n            [rectangle.x + rectangle.width, rectangle.y + rectangle.height],\n            [rectangle.x, rectangle.y + rectangle.height]\n        ] as [Point, Point, Point, Point];\n    },\n    getCenterPoint: (rectangle: RectangleClient) => {\n        return [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height / 2] as Point;\n    },\n    getCenterPointByPoints: (points: Point[]) => {\n        return RectangleClient.getCenterPoint(RectangleClient.getRectangleByPoints(points));\n    },\n    getEdgeCenterPoints: (rectangle: RectangleClient) => {\n        return [\n            [rectangle.x + rectangle.width / 2, rectangle.y],\n            [rectangle.x + rectangle.width, rectangle.y + rectangle.height / 2],\n            [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height],\n            [rectangle.x, rectangle.y + rectangle.height / 2]\n        ] as [Point, Point, Point, Point];\n    },\n    getConnectionPoint: (rectangle: RectangleClient, point: PointOfRectangle) => {\n        return [rectangle.x + rectangle.width * point[0], rectangle.y + rectangle.height * point[1]] as Point;\n    },\n    expand(rectangle: RectangleClient, left: number, top: number = left, right: number = left, bottom: number = top) {\n        return {\n            x: rectangle.x - left,\n            y: rectangle.y - top,\n            width: rectangle.width + left + right,\n            height: rectangle.height + top + bottom\n        };\n    },\n    getGapCenter(rectangle1: RectangleClient, rectangle2: RectangleClient, isHorizontal: boolean) {\n        const axis = isHorizontal ? 'x' : 'y';\n        const side = isHorizontal ? 'width' : 'height';\n        const align = [rectangle1[axis], rectangle1[axis] + rectangle1[side], rectangle2[axis], rectangle2[axis] + rectangle2[side]];\n        const sortArr = align.sort((a, b) => a - b);\n        return (sortArr[1] + sortArr[2]) / 2;\n    },\n    isPointInRectangle(rectangle: RectangleClient, point: Point) {\n        const x = point[0],\n            y = point[1];\n        return x > rectangle.x && x < rectangle.x + rectangle.width && y > rectangle.y && y < rectangle.y + rectangle.height;\n    },\n    getBoundingRectangle(rectangles: RectangleClient[]): RectangleClient {\n        if (rectangles.length === 0) {\n            throw new Error('rectangles can not be empty array');\n        }\n        let minX = Number.MAX_VALUE;\n        let minY = Number.MAX_VALUE;\n        let maxX = Number.NEGATIVE_INFINITY;\n        let maxY = Number.NEGATIVE_INFINITY;\n        rectangles.forEach(rect => {\n            minX = Math.min(minX, rect.x);\n            minY = Math.min(minY, rect.y);\n            maxX = Math.max(maxX, rect.x + rect.width);\n            maxY = Math.max(maxY, rect.y + rect.height);\n        });\n        return {\n            x: minX,\n            y: minY,\n            width: maxX - minX,\n            height: maxY - minY\n        };\n    }\n};\n\nfunction isPointArray(data: Point[] | Point[][]): data is Point[] {\n    return (\n        Array.isArray(data) &&\n        data.every(item => Array.isArray(item) && item.length === 2 && typeof item[0] === 'number' && typeof item[1] === 'number')\n    );\n}\n", "import { Point, SVGArcCommand } from '../interfaces';\nimport { RectangleClient } from '../interfaces/rectangle-client';\n\n// https://stackoverflow.com/a/6853926/232122\nexport function distanceBetweenPointAndSegment(x: number, y: number, x1: number, y1: number, x2: number, y2: number) {\n    const A = x - x1;\n    const B = y - y1;\n    const C = x2 - x1;\n    const D = y2 - y1;\n\n    const dot = A * C + B * D;\n    const lenSquare = C * C + D * D;\n    let param = -1;\n    if (lenSquare !== 0) {\n        // in case of 0 length line\n        param = dot / lenSquare;\n    }\n\n    let xx, yy;\n    if (param < 0) {\n        xx = x1;\n        yy = y1;\n    } else if (param > 1) {\n        xx = x2;\n        yy = y2;\n    } else {\n        xx = x1 + param * C;\n        yy = y1 + param * D;\n    }\n\n    const dx = x - xx;\n    const dy = y - yy;\n    return Math.hypot(dx, dy);\n}\n\nexport function getNearestPointBetweenPointAndSegment(point: Point, linePoints: [Point, Point]) {\n    const x = point[0],\n        y = point[1],\n        x1 = linePoints[0][0],\n        y1 = linePoints[0][1],\n        x2 = linePoints[1][0],\n        y2 = linePoints[1][1];\n    const A = x - x1;\n    const B = y - y1;\n    const C = x2 - x1;\n    const D = y2 - y1;\n\n    const dot = A * C + B * D;\n    const lenSquare = C * C + D * D;\n    let param = -1;\n    if (lenSquare !== 0) {\n        // in case of 0 length line\n        param = dot / lenSquare;\n    }\n\n    let xx, yy;\n    if (param < 0) {\n        xx = x1;\n        yy = y1;\n    } else if (param > 1) {\n        xx = x2;\n        yy = y2;\n    } else {\n        xx = x1 + param * C;\n        yy = y1 + param * D;\n    }\n\n    return [xx, yy] as Point;\n}\n\nexport function distanceBetweenPointAndSegments(point: Point, points: Point[]) {\n    const len = points.length;\n    let distance = Infinity;\n    if (points.length === 1) {\n        return distanceBetweenPointAndPoint(...points[0], ...point);\n    }\n    for (let i = 0; i < len - 1; i++) {\n        const p = points[i];\n        const p2 = points[i + 1];\n        const currentDistance = distanceBetweenPointAndSegment(point[0], point[1], p[0], p[1], p2[0], p2[1]);\n        if (currentDistance < distance) {\n            distance = currentDistance;\n        }\n    }\n    return distance;\n}\n\nexport function getNearestPointBetweenPointAndSegments(point: Point, points: Point[], isClose: Boolean = true) {\n    const len = points.length;\n    let distance = Infinity;\n    let result: Point = point;\n\n    for (let i = 0; i < len; i++) {\n        const p = points[i];\n        if (i === len - 1 && !isClose) continue;\n        const p2 = i === len - 1 ? points[0] : points[i + 1];\n        const currentDistance = distanceBetweenPointAndSegment(point[0], point[1], p[0], p[1], p2[0], p2[1]);\n        if (currentDistance < distance) {\n            distance = currentDistance;\n            result = getNearestPointBetweenPointAndSegment(point, [p, p2]);\n        }\n    }\n    return result;\n}\n\nexport function getNearestPointBetweenPointAndDiscreteSegments(point: Point, segments: [Point, Point][]): Point {\n    let minDistance = Infinity;\n    let nearestPoint = point;\n\n    for (const segment of segments) {\n        const currentNearestPoint = getNearestPointBetweenPointAndSegment(point, segment);\n        const currentDistance = distanceBetweenPointAndPoint(point[0], point[1], currentNearestPoint[0], currentNearestPoint[1]);\n\n        if (currentDistance < minDistance) {\n            minDistance = currentDistance;\n            nearestPoint = currentNearestPoint;\n        }\n    }\n\n    return nearestPoint;\n}\n\nexport function getNearestPointBetweenPointAndEllipse(point: Point, center: Point, rx: number, ry: number): Point {\n    const rectangleClient = {\n        x: center[0] - rx,\n        y: center[1] - ry,\n        height: ry * 2,\n        width: rx * 2\n    };\n    // https://stackoverflow.com/a/46007540/232122\n    const px = Math.abs(point[0] - rectangleClient.x - rectangleClient.width / 2);\n    const py = Math.abs(point[1] - rectangleClient.y - rectangleClient.height / 2);\n\n    let tx = 0.707;\n    let ty = 0.707;\n\n    const a = Math.abs(rectangleClient.width) / 2;\n    const b = Math.abs(rectangleClient.height) / 2;\n\n    [0, 1, 2, 3].forEach((x) => {\n        const xx = a * tx;\n        const yy = b * ty;\n\n        const ex = ((a * a - b * b) * tx ** 3) / a;\n        const ey = ((b * b - a * a) * ty ** 3) / b;\n\n        const rx = xx - ex;\n        const ry = yy - ey;\n\n        const qx = px - ex;\n        const qy = py - ey;\n\n        const r = Math.hypot(ry, rx);\n        const q = Math.hypot(qy, qx);\n\n        tx = Math.min(1, Math.max(0, ((qx * r) / q + ex) / a));\n        ty = Math.min(1, Math.max(0, ((qy * r) / q + ey) / b));\n        const t = Math.hypot(ty, tx);\n        tx /= t;\n        ty /= t;\n    });\n    const signX = point[0] > center[0] ? 1 : -1;\n    const signY = point[1] > center[1] ? 1 : -1;\n\n    return [center[0] + a * tx * signX, center[1] + b * ty * signY];\n}\n\nexport function rotate(x1: number, y1: number, x2: number, y2: number, angle: number) {\n    // =()cos()sin+\n    // =()sin+()cos+.\n    // https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line\n    return [(x1 - x2) * Math.cos(angle) - (y1 - y2) * Math.sin(angle) + x2, (x1 - x2) * Math.sin(angle) + (y1 - y2) * Math.cos(angle) + y2];\n}\n\nexport function distanceBetweenPointAndPoint(x1: number, y1: number, x2: number, y2: number) {\n    const dx = x1 - x2;\n    const dy = y1 - y2;\n    return Math.hypot(dx, dy);\n}\n\n// https://stackoverflow.com/questions/5254838/calculating-distance-between-a-point-and-a-rectangular-box-nearest-point\nexport function distanceBetweenPointAndRectangle(x: number, y: number, rect: RectangleClient) {\n    var dx = Math.max(rect.x - x, 0, x - (rect.x + rect.width));\n    var dy = Math.max(rect.y - y, 0, y - (rect.y + rect.height));\n    return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport const isLineHitLine = (a: Point, b: Point, c: Point, d: Point): boolean => {\n    if (Point.isEquals(a, b) && Point.isEquals(c, d) && !Point.isEquals(a, c)) {\n        return false;\n    }\n\n    const crossProduct = (v1: Point, v2: Point) => v1[0] * v2[1] - v1[1] * v2[0];\n\n    const ab: Point = [b[0] - a[0], b[1] - a[1]];\n    const ac: Point = [c[0] - a[0], c[1] - a[1]];\n    const ad: Point = [d[0] - a[0], d[1] - a[1]];\n\n    const ca: Point = [a[0] - c[0], a[1] - c[1]];\n    const cb: Point = [b[0] - c[0], b[1] - c[1]];\n    const cd: Point = [d[0] - c[0], d[1] - c[1]];\n\n    return crossProduct(ab, ac) * crossProduct(ab, ad) <= 0 && crossProduct(cd, ca) * crossProduct(cd, cb) <= 0;\n};\n\nexport const isLineHitRectangle = (points: Point[], rectangle: RectangleClient) => {\n    if (points.length === 1) {\n        return RectangleClient.isPointInRectangle(rectangle, points[0]);\n    }\n    const rectanglePoints = RectangleClient.getCornerPoints(rectangle);\n    const len = points.length;\n    for (let i = 0; i < len; i++) {\n        const p1 = points[i];\n        const p2 = points[(i + 1) % len];\n        if (i === len - 1 && Point.isEquals(p1, p2)) continue;\n        const isHit = isSingleLineHitRectangleEdge(p1, p2, rectangle);\n        if (isHit || isPointInPolygon(p1, rectanglePoints) || isPointInPolygon(p2, rectanglePoints)) {\n            return true;\n        }\n    }\n    return false;\n};\n\nexport const isLineHitRectangleEdge = (points: Point[], rectangle: RectangleClient, isClose: boolean = true) => {\n    const len = points.length;\n    for (let i = 0; i < len; i++) {\n        if (i === len - 1 && !isClose) continue;\n        const p1 = points[i];\n        const p2 = points[(i + 1) % len];\n        const isHit = isSingleLineHitRectangleEdge(p1, p2, rectangle);\n        if (isHit) {\n            return true;\n        }\n    }\n    return false;\n};\n\nexport const isSingleLineHitRectangleEdge = (p1: Point, p2: Point, rectangle: RectangleClient) => {\n    const rectanglePoints = RectangleClient.getCornerPoints(rectangle);\n    return (\n        isLineHitLine(p1, p2, rectanglePoints[0], rectanglePoints[1]) ||\n        isLineHitLine(p1, p2, rectanglePoints[1], rectanglePoints[2]) ||\n        isLineHitLine(p1, p2, rectanglePoints[2], rectanglePoints[3]) ||\n        isLineHitLine(p1, p2, rectanglePoints[3], rectanglePoints[0])\n    );\n};\n\n//https://stackoverflow.com/questions/22521982/check-if-point-is-inside-a-polygon\nexport const isPointInPolygon = (point: Point, points: Point[]) => {\n    // ray-casting algorithm based on\n    // https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html\n\n    const x = point[0],\n        y = point[1];\n\n    let inside = false;\n    for (var i = 0, j = points.length - 1; i < points.length; j = i++) {\n        let xi = points[i][0],\n            yi = points[i][1];\n        let xj = points[j][0],\n            yj = points[j][1];\n\n        let intersect = yi > y != yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;\n        if (intersect) inside = !inside;\n    }\n    return inside;\n};\n\nexport const isPointInEllipse = (point: Point, center: Point, rx: number, ry: number, angle = 0) => {\n    const cosAngle = Math.cos(angle);\n    const sinAngle = Math.sin(angle);\n    const x1 = (point[0] - center[0]) * cosAngle + (point[1] - center[1]) * sinAngle;\n    const y1 = (point[1] - center[1]) * cosAngle - (point[0] - center[0]) * sinAngle;\n\n    return (x1 * x1) / (rx * rx) + (y1 * y1) / (ry * ry) <= 1;\n};\n\nexport const isPointInRoundRectangle = (point: Point, rectangle: RectangleClient, radius: number, angle = 0) => {\n    const { x: rectX, y: rectY, width, height } = rectangle;\n    const isInRectangle = point[0] >= rectX && point[0] <= rectX + width && point[1] >= rectY && point[1] <= rectY + height;\n    const handleLeftTop =\n        point[0] >= rectX &&\n        point[0] <= rectX + radius &&\n        point[1] >= rectY &&\n        point[1] <= rectY + radius &&\n        Math.hypot(point[0] - (rectX + radius), point[1] - (rectY + radius)) > radius;\n    const handleLeftBottom =\n        point[0] >= rectX &&\n        point[0] <= rectX + radius &&\n        point[1] >= rectY + height &&\n        point[1] <= rectY + height - radius &&\n        Math.hypot(point[0] - (rectX + radius), point[1] - (rectY + height - radius)) > radius;\n    const handleRightTop =\n        point[0] >= rectX + width - radius &&\n        point[0] <= rectX + width &&\n        point[1] >= rectY &&\n        point[1] <= rectY + radius &&\n        Math.hypot(point[0] - (rectX + width - radius), point[1] - (rectY + radius)) > radius;\n    const handleRightBottom =\n        point[0] >= rectX + width - radius &&\n        point[0] <= rectX + width &&\n        point[1] >= rectY + height - radius &&\n        point[1] <= rectY + height &&\n        Math.hypot(point[0] - (rectX + width - radius), point[1] - (rectY + height - radius)) > radius;\n    const isInCorner = handleLeftTop || handleLeftBottom || handleRightTop || handleRightBottom;\n\n    return isInRectangle && !isInCorner;\n};\n\n// https://gist.github.com/nicholaswmin/c2661eb11cad5671d816\nexport const catmullRomFitting = function (points: Point[]) {\n    const alpha = 0.5;\n    let p0, p1, p2, p3, bp1, bp2, d1, d2, d3, A, B, N, M;\n    var d3powA, d2powA, d3pow2A, d2pow2A, d1pow2A, d1powA;\n    const result: Point[] = [];\n    result.push([Math.round(points[0][0]), Math.round(points[0][1])]);\n    var length = points.length;\n    for (var i = 0; i < length - 1; i++) {\n        p0 = i == 0 ? points[0] : points[i - 1];\n        p1 = points[i];\n        p2 = points[i + 1];\n        p3 = i + 2 < length ? points[i + 2] : p2;\n\n        d1 = Math.sqrt(Math.pow(p0[0] - p1[0], 2) + Math.pow(p0[1] - p1[1], 2));\n        d2 = Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n        d3 = Math.sqrt(Math.pow(p2[0] - p3[0], 2) + Math.pow(p2[1] - p3[1], 2));\n\n        // Catmull-Rom to Cubic Bezier conversion matrix\n        // A = 2d1^2a + 3d1^a * d2^a + d3^2a\n        // B = 2d3^2a + 3d3^a * d2^a + d2^2a\n        // [   0             1            0          0          ]\n        // [   -d2^2a /N     A/N          d1^2a /N   0          ]\n        // [   0             d3^2a /M     B/M        -d2^2a /M  ]\n        // [   0             0            1          0          ]\n\n        d3powA = Math.pow(d3, alpha);\n        d3pow2A = Math.pow(d3, 2 * alpha);\n        d2powA = Math.pow(d2, alpha);\n        d2pow2A = Math.pow(d2, 2 * alpha);\n        d1powA = Math.pow(d1, alpha);\n        d1pow2A = Math.pow(d1, 2 * alpha);\n\n        A = 2 * d1pow2A + 3 * d1powA * d2powA + d2pow2A;\n        B = 2 * d3pow2A + 3 * d3powA * d2powA + d2pow2A;\n        N = 3 * d1powA * (d1powA + d2powA);\n        if (N > 0) {\n            N = 1 / N;\n        }\n        M = 3 * d3powA * (d3powA + d2powA);\n        if (M > 0) {\n            M = 1 / M;\n        }\n\n        bp1 = [(-d2pow2A * p0[0] + A * p1[0] + d1pow2A * p2[0]) * N, (-d2pow2A * p0[1] + A * p1[1] + d1pow2A * p2[1]) * N];\n        bp2 = [(d3pow2A * p1[0] + B * p2[0] - d2pow2A * p3[0]) * M, (d3pow2A * p1[1] + B * p2[1] - d2pow2A * p3[1]) * M];\n\n        if (bp1[0] == 0 && bp1[1] == 0) {\n            bp1 = p1;\n        }\n        if (bp2[0] == 0 && bp2[1] == 0) {\n            bp2 = p2;\n        }\n\n        result.push(bp1 as Point, bp2 as Point, p2 as Point);\n    }\n\n    return result;\n};\n\n/**\n * the result of slope is based on Cartesian coordinate system\n * x, y are based on the position in the Cartesian coordinate system\n */\nexport function getEllipseTangentSlope(x: number, y: number, a: number, b: number) {\n    if (Math.abs(y) === 0) {\n        return x > 0 ? -Infinity : Infinity;\n    }\n    const k = (-b * b * x) / (a * a * y);\n    return k;\n}\n\n/**\n * x, y are based on the position in the Cartesian coordinate system\n */\nexport function getVectorFromPointAndSlope(x: number, y: number, slope: number) {\n    if (slope === Infinity) {\n        return [0, -1] as Point;\n    } else if (slope === -Infinity) {\n        return [0, 1] as Point;\n    }\n    let vector = [1, -slope] as Point;\n    if (y < 0) {\n        vector = [-vector[0], -vector[1]];\n    }\n    return vector as Point;\n}\n\n/**\n * The DOM likes values to be fixed to 3 decimal places\n */\nexport function toDomPrecision(v: number) {\n    return +v.toFixed(4);\n}\n\nexport function toFixed(v: number) {\n    return +v.toFixed(2);\n}\n\nexport function ceilToDecimal(value: number, decimalPlaces: number) {\n    const factor = Math.pow(10, decimalPlaces);\n    return Math.ceil(value * factor) / factor;\n}\n\n/**\n * Whether two numbers numbers a and b are approximately equal.\n *\n * @param a - The first point.\n * @param b - The second point.\n * @public\n */\nexport function approximately(a: number, b: number, precision = 0.000001) {\n    return Math.abs(a - b) <= precision;\n}\n\n// https://medium.com/@steveruiz/find-the-points-where-a-line-segment-intercepts-an-angled-ellipse-in-javascript-typescript-e451524beece\nexport function getCrossingPointsBetweenEllipseAndSegment(\n    startPoint: Point,\n    endPoint: Point,\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    segment_only = true\n) {\n    // If the ellipse or line segment are empty, return no tValues.\n    if (rx === 0 || ry === 0 || (startPoint[0] === endPoint[0] && startPoint[1] === endPoint[1])) {\n        return [];\n    }\n\n    rx = rx < 0 ? rx : -rx;\n    ry = ry < 0 ? ry : -ry;\n\n    startPoint[0] -= cx;\n    startPoint[1] -= cy;\n    endPoint[0] -= cx;\n    endPoint[1] -= cy;\n\n    // Calculate the quadratic parameters.\n    var A =\n        ((endPoint[0] - startPoint[0]) * (endPoint[0] - startPoint[0])) / rx / rx +\n        ((endPoint[1] - startPoint[1]) * (endPoint[1] - startPoint[1])) / ry / ry;\n    var B = (2 * startPoint[0] * (endPoint[0] - startPoint[0])) / rx / rx + (2 * startPoint[1] * (endPoint[1] - startPoint[1])) / ry / ry;\n    var C = (startPoint[0] * startPoint[0]) / rx / rx + (startPoint[1] * startPoint[1]) / ry / ry - 1;\n\n    // Make a list of t values (normalized points on the line where intersections occur).\n    var tValues: number[] = [];\n\n    // Calculate the discriminant.\n    var discriminant = B * B - 4 * A * C;\n\n    if (discriminant === 0) {\n        // One real solution.\n        tValues.push(-B / 2 / A);\n    } else if (discriminant > 0) {\n        // Two real solutions.\n        tValues.push((-B + Math.sqrt(discriminant)) / 2 / A);\n        tValues.push((-B - Math.sqrt(discriminant)) / 2 / A);\n    }\n    return (\n        tValues\n            // Filter to only points that are on the segment.\n            .filter((t) => !segment_only || (t >= 0 && t <= 1))\n            // Solve for points.\n            .map((t) => [startPoint[0] + (endPoint[0] - startPoint[0]) * t + cx, startPoint[1] + (endPoint[1] - startPoint[1]) * t + cy])\n    );\n}\n\n/**\n * Get a point between two points.\n * @param x0 The x-axis coordinate of the first point.\n * @param y0 The y-axis coordinate of the first point.\n * @param x1 The x-axis coordinate of the second point.\n * @param y1 The y-axis coordinate of the second point.\n * @param d Normalized\n */\nexport function getPointBetween(x0: number, y0: number, x1: number, y1: number, d = 0.5) {\n    return [x0 + (x1 - x0) * d, y0 + (y1 - y0) * d];\n}\n\n/**\n * \n * @param point \n * @param startPoint \n * @param arcCommand SVG \n */\n/**\n * \n */\nexport function getEllipseArcCenter(startPoint: Point, arcCommand: SVGArcCommand): { center: Point; rx: number; ry: number } {\n    // 1. \n    const dx = (arcCommand.endX - startPoint[0]) / 2;\n    const dy = (arcCommand.endY - startPoint[1]) / 2;\n    const cosAngle = Math.cos(arcCommand.xAxisRotation);\n    const sinAngle = Math.sin(arcCommand.xAxisRotation);\n\n    // \n    const x1 = cosAngle * dx + sinAngle * dy;\n    const y1 = -sinAngle * dx + cosAngle * dy;\n\n    // 2. \n    const rx = Math.abs(arcCommand.rx);\n    const ry = Math.abs(arcCommand.ry);\n\n    // \n    const lambda = (x1 * x1) / (rx * rx) + (y1 * y1) / (ry * ry);\n    const factor = lambda > 1 ? Math.sqrt(lambda) : 1;\n\n    const adjustedRx = rx * factor;\n    const adjustedRy = ry * factor;\n\n    // \n    const sign = arcCommand.largeArcFlag === arcCommand.sweepFlag ? -1 : 1;\n    const sq =\n        (adjustedRx * adjustedRx * adjustedRy * adjustedRy - adjustedRx * adjustedRx * y1 * y1 - adjustedRy * adjustedRy * x1 * x1) /\n        (adjustedRx * adjustedRx * y1 * y1 + adjustedRy * adjustedRy * x1 * x1);\n    const coef = sign * Math.sqrt(Math.max(0, sq));\n\n    const centerX = coef * ((adjustedRx * y1) / adjustedRy);\n    const centerY = coef * (-(adjustedRy * x1) / adjustedRx);\n\n    // 3. \n    const cx = cosAngle * centerX - sinAngle * centerY + (startPoint[0] + arcCommand.endX) / 2;\n    const cy = sinAngle * centerX + cosAngle * centerY + (startPoint[1] + arcCommand.endY) / 2;\n\n    return {\n        center: [cx, cy],\n        rx: adjustedRx,\n        ry: adjustedRy\n    };\n}\n\nexport function getNearestPointBetweenPointAndArc(point: Point, startPoint: Point, arcCommand: SVGArcCommand): Point {\n    const { center, rx, ry } = getEllipseArcCenter(startPoint, arcCommand);\n\n    // \n    const nearestPoint = getNearestPointBetweenPointAndEllipse(point, center, rx, ry);\n\n    // \n    const startAngle = Math.atan2(startPoint[1] - center[1], startPoint[0] - center[0]);\n    const endAngle = Math.atan2(arcCommand.endY - center[1], arcCommand.endX - center[0]);\n    const pointAngle = Math.atan2(nearestPoint[1] - center[1], nearestPoint[0] - center[0]);\n\n    // \n    const isInArc = isAngleBetween(pointAngle, startAngle, endAngle, arcCommand.sweepFlag === 1);\n\n    if (isInArc) {\n        return nearestPoint;\n    }\n\n    // \n    const distanceToStart = distanceBetweenPointAndPoint(point[0], point[1], startPoint[0], startPoint[1]);\n    const distanceToEnd = distanceBetweenPointAndPoint(point[0], point[1], arcCommand.endX, arcCommand.endY);\n    return distanceToStart < distanceToEnd ? startPoint : [arcCommand.endX, arcCommand.endY];\n}\n\nfunction isAngleBetween(angle: number, start: number, end: number, clockwise: boolean): boolean {\n    //  [0, 2]\n    const normalize = (a: number) => ((a % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);\n\n    const a = normalize(angle);\n    const s = normalize(start);\n    const e = normalize(end);\n\n    if (clockwise) {\n        return s <= e ? a >= s && a <= e : a >= s || a <= e;\n    } else {\n        return s >= e ? a <= s && a >= e : a <= s || a >= e;\n    }\n}\n", "import { PlaitBoard } from '../interfaces/board';\nimport { distanceBetweenPointAndRectangle } from './math';\n\nexport type ViewBox = {\n    minX: number;\n    minY: number;\n    width: number;\n    height: number;\n    viewportWidth: number;\n    viewportHeight: number;\n};\n\nexport function isInPlaitBoard(board: PlaitBoard, x: number, y: number) {\n    const plaitBoardElement = PlaitBoard.getBoardContainer(board);\n    const plaitBoardRect = plaitBoardElement.getBoundingClientRect();\n    const distances = distanceBetweenPointAndRectangle(x, y, plaitBoardRect);\n    return distances === 0;\n}\n\nexport function getRealScrollBarWidth(board: PlaitBoard) {\n    const { hideScrollbar } = board.options;\n    let scrollBarWidth = 0;\n    if (!hideScrollbar) {\n        const viewportContainer = PlaitBoard.getViewportContainer(board);\n        scrollBarWidth = viewportContainer.offsetWidth - viewportContainer.clientWidth;\n    }\n    return scrollBarWidth;\n}\n", "import { Options } from 'roughjs/bin/core';\nimport { POINTER_BUTTON } from '../../constants';\nimport { RectangleClient } from '../../interfaces';\n\nexport const NS = 'http://www.w3.org/2000/svg';\n\nexport function createG() {\n    const newG = document.createElementNS(NS, 'g');\n    return newG;\n}\n\nexport function createPath() {\n    const newG = document.createElementNS(NS, 'path');\n    return newG;\n}\n\nexport function createRect(rectangle: RectangleClient, options?: Options) {\n    const rect = document.createElementNS(NS, 'rect');\n    rect.setAttribute('x', `${rectangle.x}`);\n    rect.setAttribute('y', `${rectangle.y}`);\n    rect.setAttribute('width', `${rectangle.width}`);\n    rect.setAttribute('height', `${rectangle.height}`);\n    for (let key in options) {\n        const optionKey = key as keyof Options;\n        rect.setAttribute(key, `${options[optionKey]}`);\n    }\n    return rect;\n}\n\nexport const setStrokeLinecap = (g: SVGGElement, value: 'round' | 'square') => {\n    g.setAttribute('stroke-linecap', value);\n};\n\nexport const setPathStrokeLinecap = (g: SVGGElement, value: 'round' | 'square') => {\n    g.querySelectorAll('path').forEach(path => {\n        path.setAttribute('stroke-linecap', value);\n    });\n};\n\nexport function createMask() {\n    return document.createElementNS(NS, 'mask');\n}\n\nexport function createSVG() {\n    const svg = document.createElementNS(NS, 'svg');\n    return svg;\n}\n\nexport function createText(x: number, y: number, fill: string, textContent: string) {\n    var text = document.createElementNS(NS, 'text');\n    text.setAttribute('x', `${x}`);\n    text.setAttribute('y', `${y}`);\n    text.setAttribute('fill', fill);\n    text.textContent = textContent;\n    return text;\n}\n\n/**\n * Check if a DOM node is an element node.\n */\nexport const isDOMElement = (value: any): value is Element => {\n    return isDOMNode(value) && value.nodeType === 1;\n};\n\n/**\n * Check if a value is a DOM node.\n */\nexport const isDOMNode = (value: any): value is Node => {\n    return value instanceof window.Node;\n};\n\nexport const hasInputOrTextareaTarget = (target: EventTarget | null) => {\n    if (isDOMElement(target)) {\n        if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {\n            return true;\n        }\n    }\n    return false;\n};\n\nexport const isSecondaryPointer = (event: MouseEvent) => {\n    return event.button === POINTER_BUTTON.SECONDARY;\n};\n\nexport const isMainPointer = (event: MouseEvent) => {\n    return event.button === POINTER_BUTTON.MAIN;\n};\n\nexport const isWheelPointer = (event: MouseEvent) => {\n    return event.button === POINTER_BUTTON.WHEEL;\n};\n", "import { ceilToDecimal } from '../math';\nimport { NS } from './common';\n\nexport function createForeignObject(x: number, y: number, width: number, height: number) {\n    var newForeignObject = document.createElementNS(NS, 'foreignObject');\n    newForeignObject.setAttribute('x', `${x}`);\n    newForeignObject.setAttribute('y', `${y}`);\n    newForeignObject.setAttribute('width', `${ceilToDecimal(width, 0)}`);\n    newForeignObject.setAttribute('height', `${height}`);\n    return newForeignObject;\n}\n\nexport function updateForeignObject(target: SVGForeignObjectElement | SVGGElement, width: number, height: number, x: number, y: number) {\n    const foreignObject = target instanceof SVGForeignObjectElement ? target : target.querySelector('foreignObject');\n    if (foreignObject) {\n        foreignObject.setAttribute('width', `${ceilToDecimal(width, 0)}`);\n        foreignObject.setAttribute('height', `${height}`);\n        foreignObject.setAttribute('x', `${x}`);\n        foreignObject.setAttribute('y', `${y}`);\n    }\n}\n\nexport function updateForeignObjectWidth(target: SVGForeignObjectElement | SVGGElement, width: number) {\n    const foreignObject = target instanceof SVGForeignObjectElement ? target : target.querySelector('foreignObject');\n    if (foreignObject) {\n        foreignObject.setAttribute('width', `${ceilToDecimal(width, 0)}`);\n    }\n}\n", "export const IS_MAC = typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\n", "export const IS_IOS =\n    typeof navigator !== 'undefined' &&\n    typeof window !== 'undefined' &&\n    /iPad|iPhone|iPod/.test(navigator.userAgent) &&\n    !(window as any).MSStream;\n\nexport const IS_APPLE = typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent);\n\nexport const IS_FIREFOX = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\n\nexport const IS_SAFARI = typeof navigator !== 'undefined' && /Version\\/[\\d\\.]+.*Safari/.test(navigator.userAgent);\n\n// \"modern\" Edge was released at 79.x\nexport const IS_EDGE_LEGACY = typeof navigator !== 'undefined' && /Edge?\\/(?:[0-6][0-9]|[0-7][0-8])/i.test(navigator.userAgent);\n\nexport const IS_CHROME = typeof navigator !== 'undefined' && /Chrome/i.test(navigator.userAgent);\n\n// Native beforeInput events don't work well with react on Chrome 75 and older, Chrome 76+ can use beforeInput\nexport const IS_CHROME_LEGACY = typeof navigator !== 'undefined' && /Chrome?\\/(?:[0-7][0-5]|[0-6][0-9])/i.test(navigator.userAgent);\n\nexport const IS_WINDOWS = typeof navigator !== 'undefined' && /Windows/.test(navigator.userAgent);", "// Credits to slate - https://github.com/ianstormtaylor/slate\n\nimport { MERGING, PlaitBoard, PlaitOperation, SAVING, SPLITTING_ONCE } from '../interfaces';\n\n/**\n * Check whether to merge an operation into the previous operation.\n */\n\nexport const shouldMerge = (op: PlaitOperation, prev: PlaitOperation | undefined): boolean => {\n    if (op.type === 'set_viewport' && op.type === prev?.type) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * Check whether an operation needs to be saved to the history.\n */\n\nexport const shouldSave = (op: PlaitOperation, prev: PlaitOperation | undefined): boolean => {\n    if (op.type === 'set_selection' || op.type === 'set_viewport') {\n        return false;\n    }\n\n    return true;\n};\n\n/**\n * Check whether an operation should clear the redos stack.\n */\n\nexport const shouldClear = (op: PlaitOperation): boolean => {\n    if (op.type === 'set_selection') {\n        return false;\n    }\n\n    return true;\n};\n\nexport const PlaitHistoryBoard = {\n    /**\n     * Get the saving flag's current value.\n     */\n    isSaving(board: PlaitBoard): boolean | undefined {\n        return SAVING.get(board);\n    },\n\n    /**\n     * Get the merge flag's current value.\n     */\n\n    isMerging(board: PlaitBoard): boolean | undefined {\n        return MERGING.get(board);\n    },\n\n    /**\n     * Get the splitting once flag's current value.\n     */\n\n    isSplittingOnce(board: PlaitBoard): boolean | undefined {\n        return SPLITTING_ONCE.get(board);\n    },\n\n    setSplittingOnce(board: PlaitBoard, value: boolean | undefined): void {\n        SPLITTING_ONCE.set(board, value);\n    },\n\n    /**\n     * Apply a series of changes inside a synchronous `fn`, These operations will\n     * be merged into the previous history.\n     */\n    withMerging(board: PlaitBoard, fn: () => void): void {\n        const prev = PlaitHistoryBoard.isMerging(board);\n        MERGING.set(board, true);\n        fn();\n        MERGING.set(board, prev);\n    },\n\n    /**\n     * Apply a series of changes inside a synchronous `fn`, ensuring that the first\n     * operation starts a new batch in the history. Subsequent operations will be\n     * merged as usual.\n     */\n    withNewBatch(board: PlaitBoard, fn: () => void): void {\n        const prev = PlaitHistoryBoard.isMerging(board);\n        MERGING.set(board, true);\n        SPLITTING_ONCE.set(board, true);\n        fn();\n        MERGING.set(board, prev);\n        SPLITTING_ONCE.delete(board);\n    },\n\n    /**\n     * Apply a series of changes inside a synchronous `fn`, without merging any of\n     * the new operations into previous save point in the history.\n     */\n\n    withoutMerging(board: PlaitBoard, fn: () => void): void {\n        const prev = PlaitHistoryBoard.isMerging(board);\n        MERGING.set(board, false);\n        fn();\n        MERGING.set(board, prev);\n    },\n    /**\n     * Apply a series of changes inside a synchronous `fn`, without saving any of\n     * their operations into the history.\n     */\n\n    withoutSaving(board: PlaitBoard, fn: () => void): void {\n        const prev = PlaitHistoryBoard.isSaving(board);\n        SAVING.set(board, false);\n        fn();\n        SAVING.set(board, prev);\n    }\n};\n", "import { isKeyHotkey } from 'is-hotkey';\nimport { IS_APPLE } from './environment';\n\n/**\n * Hotkey mappings for each platform.\n */\n\nconst HOTKEYS: any = {\n    bold: 'mod+b',\n    compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n    arrow: ['down', 'left', 'right', 'up'],\n    extendArrow: ['shift+down', 'shift+left', 'shift+right', 'shift+up'],\n    moveBackward: 'left',\n    moveForward: 'right',\n    moveUp: 'up',\n    moveDown: 'down',\n    moveWordBackward: 'ctrl+left',\n    moveWordForward: 'ctrl+right',\n    deleteBackward: 'shift?+backspace',\n    deleteForward: 'shift?+delete',\n    extendBackward: 'shift+left',\n    extendForward: 'shift+right',\n    extendUp: 'shift+up',\n    extendDown: 'shift+down',\n    italic: 'mod+i',\n    splitBlock: 'shift?+enter',\n    undo: 'mod+z',\n    shift: 'shift'\n};\n\nconst APPLE_HOTKEYS: any = {\n    moveLineBackward: 'opt+up',\n    moveLineForward: 'opt+down',\n    moveWordBackward: 'opt+left',\n    moveWordForward: 'opt+right',\n    deleteBackward: ['ctrl+backspace', 'ctrl+h'],\n    deleteForward: ['ctrl+delete', 'ctrl+d'],\n    deleteLineBackward: 'cmd+shift?+backspace',\n    deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n    deleteWordBackward: 'opt+shift?+backspace',\n    deleteWordForward: 'opt+shift?+delete',\n    extendLineBackward: 'opt+shift+up',\n    extendLineForward: 'opt+shift+down',\n    redo: 'cmd+shift+z',\n    transposeCharacter: 'ctrl+t'\n};\n\nconst WINDOWS_HOTKEYS: any = {\n    deleteWordBackward: 'ctrl+shift?+backspace',\n    deleteWordForward: 'ctrl+shift?+delete',\n    redo: ['ctrl+y', 'ctrl+shift+z']\n};\n\n/**\n * Create a platform-aware hotkey checker.\n */\n\nconst create = (key: string) => {\n    const generic = HOTKEYS[key];\n    const apple = APPLE_HOTKEYS[key];\n    const windows = WINDOWS_HOTKEYS[key];\n    const isGeneric = generic && isKeyHotkey(generic);\n    const isApple = apple && isKeyHotkey(apple);\n    const isWindows = windows && isKeyHotkey(windows);\n\n    return (event: KeyboardEvent) => {\n        if (isGeneric && isGeneric(event)) {\n            return true;\n        }\n        if (IS_APPLE && isApple && isApple(event)) {\n            return true;\n        }\n        if (!IS_APPLE && isWindows && isWindows(event)) {\n            return true;\n        }\n        return false;\n    };\n};\n\n/**\n * Hotkeys.\n */\n\nconst hotkeys = {\n    isBold: create('bold'),\n    isCompose: create('compose'),\n    isArrow: create('arrow'),\n    isMoveBackward: create('moveBackward'),\n    isMoveForward: create('moveForward'),\n    isMoveUp: create('moveUp'),\n    isMoveDown: create('moveDown'),\n    isDeleteBackward: create('deleteBackward'),\n    isDeleteForward: create('deleteForward'),\n    isDeleteLineBackward: create('deleteLineBackward'),\n    isDeleteLineForward: create('deleteLineForward'),\n    isDeleteWordBackward: create('deleteWordBackward'),\n    isDeleteWordForward: create('deleteWordForward'),\n    isExtendBackward: create('extendBackward'),\n    isExtendForward: create('extendForward'),\n    isExtendUp: create('extendUp'),\n    isExtendDown: create('extendDown'),\n    isExtendArrow: create('extendArrow'),\n    isExtendLineBackward: create('extendLineBackward'),\n    isExtendLineForward: create('extendLineForward'),\n    isItalic: create('italic'),\n    isMoveLineBackward: create('moveLineBackward'),\n    isMoveLineForward: create('moveLineForward'),\n    isMoveWordBackward: create('moveWordBackward'),\n    isMoveWordForward: create('moveWordForward'),\n    isRedo: create('redo'),\n    isSplitBlock: create('splitBlock'),\n    isTransposeCharacter: create('transposeCharacter'),\n    isUndo: create('undo'),\n    isShift: create('shift')\n};\nexport default hotkeys;\nexport { hotkeys };\n", "export function idCreator(length = 5) {\n    // remove numeral\n    const $chars = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz'; /**** Easily confusing characters are removed by default oOLl,9gq,Vv,Uu,I1****/\n    const maxPosition = $chars.length;\n    let key = '';\n    for (let i = 0; i < length; i++) {\n        key += $chars.charAt(Math.floor(Math.random() * maxPosition));\n    }\n    return key;\n}\n", "import { PlaitBoard } from '../interfaces/board';\nimport { PlaitElement } from '../interfaces/element';\n\nexport function depthFirstRecursion<T extends TreeNode = TreeNode>(\n    node: T,\n    callback: (node: T) => void,\n    recursion?: (node: T) => boolean,\n    isReverse?: boolean\n) {\n    if (node.children && (!recursion || recursion(node))) {\n        let children: TreeNode[] = [...node.children];\n        children = isReverse ? children.reverse() : children;\n        children.forEach(child => {\n            depthFirstRecursion(child as T, callback, recursion);\n        });\n    }\n    callback(node);\n}\n\nexport const getIsRecursionFunc = (board: PlaitBoard) => {\n    return (element: PlaitElement | PlaitBoard) => {\n        if (PlaitBoard.isBoard(element) || board.isRecursion(element)) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n};\n\nexport interface TreeNode {\n    children?: TreeNode[];\n}\n", "import { Point } from './point';\n\nexport const SELECTION_BORDER_COLOR = '#6698FF';\nexport const SELECTION_FILL_COLOR = '#6698FF25'; // opacity 0.25\n\nexport interface Selection {\n    anchor: Point;\n    focus: Point;\n}\n\nexport const Selection = {\n    isCollapsed(selection: Selection) {\n        if (selection.anchor[0] == selection.focus[0] && selection.anchor[1] === selection.focus[1]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n};\n", "import { ELEMENT_TO_REF, NODE_TO_CONTAINER_G, NODE_TO_G, NODE_TO_PARENT } from '../utils';\nimport { PlaitBoard } from './board';\nimport { Point } from './point';\nimport { PlaitElementRef } from '../core/element/element-ref';\n\nexport interface PlaitElement {\n    [key: string]: any;\n    id: string;\n    children?: PlaitElement[];\n    points?: Point[];\n    type?: string;\n    groupId?: string;\n    angle?: number;\n}\n\nexport const PlaitElement = {\n    isRootElement(value: PlaitElement) {\n        const parent = NODE_TO_PARENT.get(value);\n        if (parent && PlaitBoard.isBoard(parent)) {\n            return true;\n        } else {\n            return false;\n        }\n    },\n    getElementRef<T extends PlaitElementRef = PlaitElementRef>(value: PlaitElement) {\n        return ELEMENT_TO_REF.get(value) as T;\n    },\n    getElementG(value: PlaitElement) {\n        const g = NODE_TO_G.get(value);\n        if (!g) {\n            throw new Error(`can not resolve element g: ${JSON.stringify(value)}`);\n        }\n        return g;\n    },\n    hasMounted(element: PlaitElement) {\n        const containerG = PlaitElement.getContainerG(element, { suppressThrow: true });\n        if (containerG) {\n            return true;\n        } else {\n            return false;\n        }\n    },\n    getContainerG<T extends boolean>(\n        value: PlaitElement,\n        options: {\n            suppressThrow: T;\n        }\n    ): T extends true ? SVGGElement | null : SVGGElement {\n        const containerG = NODE_TO_CONTAINER_G.get(value) || null;\n        if (!containerG) {\n            if (options.suppressThrow) {\n                return null as T extends true ? SVGGElement | null : SVGGElement;\n            }\n            throw new Error('can not resolve container g');\n        }\n        return containerG;\n    }\n};\n\nexport interface ComponentType<T> {\n    new (...args: any[]): T;\n}\n\nexport interface ImageEntry {\n    url: string;\n    file: File;\n}\n", "import { PlaitBoard, PlaitElement } from '../interfaces';\n\nexport const sortElements = (board: PlaitBoard, elements: PlaitElement[], ascendingOrder = true) => {\n    return [...elements].sort((a: PlaitElement, b: PlaitElement) => {\n        const pathA = PlaitBoard.findPath(board, a);\n        const pathB = PlaitBoard.findPath(board, b);\n        return ascendingOrder ? pathA[0] - pathB[0] : pathB[0] - pathA[0];\n    });\n};\n", "import { Options } from 'roughjs/bin/core';\nimport { PlaitBoard, Point, RectangleClient } from '../interfaces';\n\nconst TEMPORARY_G = new Map();\n\nconst getTemporaryGArray = (debugKey: string): SVGGElement[] => {\n    return TEMPORARY_G.get(debugKey) || [];\n};\n\nconst setTemporaryGArray = (debugKey: string, gArray: SVGGElement[]) => {\n    TEMPORARY_G.set(debugKey, gArray);\n};\n\nexport class DebugGenerator {\n    constructor(private debugKey: string) {}\n    isDebug() {\n        return isDebug(this.debugKey);\n    }\n    clear() {\n        if (!this.isDebug()) {\n            return;\n        }\n        const gArray = getTemporaryGArray(this.debugKey);\n        setTemporaryGArray(this.debugKey, []);\n        gArray.forEach((g) => g.remove());\n    }\n    drawPolygon(board: PlaitBoard, points: Point[], options?: Options) {\n        if (!isDebug(this.debugKey)) {\n            return;\n        }\n        const polygonG = PlaitBoard.getRoughSVG(board).polygon(points, options || { stroke: 'red' });\n        polygonG.classList.add(this.debugKey);\n        PlaitBoard.getElementTopHost(board).append(polygonG);\n        const gArray = getTemporaryGArray(this.debugKey);\n        gArray.push(polygonG);\n        setTemporaryGArray(this.debugKey, gArray);\n        return polygonG;\n    }\n    drawLine(board: PlaitBoard, points: Point[], options?: Options) {\n        if (!isDebug(this.debugKey)) {\n            return;\n        }\n        const lineG = PlaitBoard.getRoughSVG(board).linearPath(points, options || { stroke: 'red' });\n        lineG.classList.add(this.debugKey);\n        PlaitBoard.getElementTopHost(board).append(lineG);\n        const gArray = getTemporaryGArray(this.debugKey);\n        gArray.push(lineG);\n        setTemporaryGArray(this.debugKey, gArray);\n        return lineG;\n    }\n    drawRectangle(board: PlaitBoard, data: Point[] | RectangleClient, options?: Options) {\n        if (!isDebug(this.debugKey)) {\n            return;\n        }\n        let rectangle: RectangleClient;\n        if (data instanceof Array) {\n            rectangle = RectangleClient.getRectangleByPoints(data);\n        } else {\n            rectangle = data;\n        }\n        const rectangleG = PlaitBoard.getRoughSVG(board).rectangle(\n            rectangle.x,\n            rectangle.y,\n            rectangle.width,\n            rectangle.height,\n            options || { stroke: 'red' }\n        );\n        rectangleG.classList.add(this.debugKey);\n        PlaitBoard.getElementTopHost(board).append(rectangleG);\n        const gArray = getTemporaryGArray(this.debugKey);\n        gArray.push(rectangleG);\n        setTemporaryGArray(this.debugKey, gArray);\n        return rectangleG;\n    }\n    drawCircles(board: PlaitBoard, points: Point[], diameter: number = 0, isCumulativeDiameter: boolean = false, options?: Options) {\n        if (!isDebug(this.debugKey)) {\n            return;\n        }\n        const result: SVGGElement[] = [];\n        points.forEach((p, i) => {\n            const circle = PlaitBoard.getRoughSVG(board).circle(\n                p[0],\n                p[1],\n                isCumulativeDiameter ? diameter * (i + 1) : diameter,\n                Object.assign({}, { stroke: 'red', fill: 'red', fillStyle: 'solid' }, options || {})\n            );\n            circle.classList.add(this.debugKey);\n            PlaitBoard.getElementTopHost(board).append(circle);\n            const gArray = getTemporaryGArray(this.debugKey);\n            gArray.push(circle);\n            result.push(circle);\n            setTemporaryGArray(this.debugKey, gArray);\n        });\n        return result;\n    }\n}\n\nexport const createDebugGenerator = (debugKey: string) => {\n    return new DebugGenerator(debugKey);\n};\n\nexport const isDebug = (key?: string) => {\n    const defaultKey = 'debug:plait';\n    return localStorage.getItem(key || defaultKey) === 'true';\n};\n", "import { PlaitBoard } from './board';\n\nexport type PlaitPlugin = (board: PlaitBoard) => PlaitBoard;\n\nexport interface WithPluginOptions {\n    disabled?: boolean;\n}\n\nexport interface WithSelectionPluginOptions extends WithPluginOptions {\n    isMultipleSelection: boolean;\n    isDisabledSelection: boolean;\n    isPreventClearSelection: boolean; // is clear selection on click outside of board container\n}\n\nexport interface WithHandPluginOptions extends WithPluginOptions {\n    isHandMode: (board: PlaitBoard, event: PointerEvent) => boolean;\n}\n\nexport enum PlaitPluginKey {\n    'withSelection' = 'withSelection',\n    'withHand' = 'withHand'\n}\n", "import { PlaitBoard } from '../interfaces/board';\nimport { Ancestor } from '../interfaces/node';\nimport { depthFirstRecursion, getIsRecursionFunc } from './tree';\nimport { BOARD_TO_SELECTED_ELEMENT } from './weak-maps';\nimport { Selection } from '../interfaces/selection';\nimport { PlaitElement } from '../interfaces/element';\nimport { Point } from '../interfaces/point';\nimport { sortElements } from './position';\nimport { RectangleClient } from '../interfaces/rectangle-client';\nimport { getRectangleByElements } from './element';\nimport { PlaitOptionsBoard } from '../plugins/with-options';\nimport { isDebug } from './debug';\nimport { PlaitPluginKey, WithSelectionPluginOptions } from '../interfaces/plugin';\n\nexport const getHitElementsBySelection = (\n    board: PlaitBoard,\n    selection?: Selection,\n    match: (element: PlaitElement) => boolean = () => true\n) => {\n    const newSelection = selection || (board.selection as Selection);\n    const rectangleHitElements: PlaitElement[] = [];\n    if (!newSelection) {\n        return [];\n    }\n    const isCollapsed = Selection.isCollapsed(newSelection);\n    if (isCollapsed) {\n        const hitElements = getHitElementsByPoint(board, newSelection.anchor, match);\n        if (hitElements?.length) {\n            return hitElements;\n        } else {\n            return [];\n        }\n    }\n    depthFirstRecursion<Ancestor>(\n        board,\n        (node) => {\n            if (!PlaitBoard.isBoard(node) && match(node)) {\n                let isRectangleHit = false;\n                try {\n                    isRectangleHit = board.isRectangleHit(node, newSelection);\n                } catch (error) {\n                    if (isDebug()) {\n                        console.error('isRectangleHit', error, 'node', node);\n                    }\n                }\n                if (isRectangleHit) {\n                    rectangleHitElements.push(node);\n                }\n            }\n        },\n        getIsRecursionFunc(board),\n        true\n    );\n    return rectangleHitElements;\n};\n\nexport const getHitElementsByPoint = (\n    board: PlaitBoard,\n    point: Point,\n    match: (element: PlaitElement) => boolean = () => true,\n    isStrict = true\n): PlaitElement[] => {\n    let hitElements: PlaitElement[] = [];\n    depthFirstRecursion<Ancestor>(\n        board,\n        (node) => {\n            if (PlaitBoard.isBoard(node) || !match(node) || !PlaitElement.hasMounted(node)) {\n                return;\n            }\n            let isHit = false;\n            try {\n                isHit = board.isHit(node, point, isStrict);\n            } catch (error) {\n                if (isDebug()) {\n                    console.error('isHit', error, 'node', node);\n                }\n            }\n            if (isHit) {\n                hitElements.push(node);\n                return;\n            }\n        },\n        getIsRecursionFunc(board),\n        true\n    );\n    return hitElements;\n};\n\nexport const getHitElementByPoint = (\n    board: PlaitBoard,\n    point: Point,\n    match: (element: PlaitElement) => boolean = () => true,\n    isStrict = true\n): undefined | PlaitElement => {\n    const pointHitElements = getHitElementsByPoint(board, point, match, isStrict);\n    const hitElement = board.getOneHitElement(pointHitElements);\n    return hitElement;\n};\n\nexport const getHitSelectedElements = (board: PlaitBoard, point: Point) => {\n    const selectedElements = getSelectedElements(board);\n    const targetRectangle = selectedElements.length > 0 && getRectangleByElements(board, selectedElements, false);\n    const isInTargetRectangle = targetRectangle && RectangleClient.isPointInRectangle(targetRectangle, point);\n    if (isInTargetRectangle) {\n        return selectedElements;\n    } else {\n        return [];\n    }\n};\n\nexport const cacheSelectedElements = (board: PlaitBoard, selectedElements: PlaitElement[]) => {\n    const sortedElements = sortElements(board, selectedElements);\n    BOARD_TO_SELECTED_ELEMENT.set(board, sortedElements);\n};\n\nexport const getSelectedElements = (board: PlaitBoard) => {\n    return BOARD_TO_SELECTED_ELEMENT.get(board) || [];\n};\n\nexport const addSelectedElement = (board: PlaitBoard, element: PlaitElement | PlaitElement[]) => {\n    let elements = [];\n    if (Array.isArray(element)) {\n        elements.push(...element);\n    } else {\n        elements.push(element);\n    }\n    const selectedElements = getSelectedElements(board);\n    cacheSelectedElements(board, [...selectedElements, ...elements]);\n};\n\nexport const removeSelectedElement = (board: PlaitBoard, element: PlaitElement, isRemoveChildren = false) => {\n    const selectedElements = getSelectedElements(board);\n    if (selectedElements.includes(element)) {\n        const targetElements: PlaitElement[] = [];\n        if (board.isRecursion(element) && isRemoveChildren) {\n            depthFirstRecursion(\n                element,\n                (node) => {\n                    targetElements.push(node);\n                },\n                (node) => board.isRecursion(node)\n            );\n        } else {\n            targetElements.push(element);\n        }\n        const newSelectedElements = selectedElements.filter((value) => !targetElements.includes(value));\n        cacheSelectedElements(board, newSelectedElements);\n    }\n};\n\nexport const replaceSelectedElement = (board: PlaitBoard, element: PlaitElement, newElement: PlaitElement) => {\n    const selectedElements = getSelectedElements(board);\n    selectedElements.splice(selectedElements.indexOf(element), 1, newElement);\n};\n\nexport const clearSelectedElement = (board: PlaitBoard) => {\n    cacheSelectedElements(board, []);\n};\n\nexport const isSelectedElement = (board: PlaitBoard, element: PlaitElement) => {\n    const selectedElements = getSelectedElements(board);\n    return !!selectedElements.find((value) => value === element);\n};\n\nexport const temporaryDisableSelection = (board: PlaitOptionsBoard) => {\n    const currentOptions = board.getPluginOptions(PlaitPluginKey.withSelection);\n    board.setPluginOptions<WithSelectionPluginOptions>(PlaitPluginKey.withSelection, {\n        isDisabledSelection: true\n    });\n    setTimeout(() => {\n        board.setPluginOptions<WithSelectionPluginOptions>(PlaitPluginKey.withSelection, { ...currentOptions });\n    }, 0);\n};\n\nexport const isHitSelectedRectangle = (board: PlaitBoard, point: Point) => {\n    const hitSelectedElements = getHitSelectedElements(board, point);\n    return hitSelectedElements.length > 0;\n};\n\nexport const isHitElement = (board: PlaitBoard, point: Point) => {\n    const hitElement = getHitElementByPoint(board, point);\n    return !!hitElement || isHitSelectedRectangle(board, point);\n};\n", "import { Options } from 'roughjs/bin/core';\nimport { RoughSVG } from 'roughjs/bin/svg';\nimport { MAX_RADIUS } from '../../constants';\nimport { PlaitBoard } from '../../interfaces/board';\nimport { RectangleClient } from '../../interfaces/rectangle-client';\nimport { setStrokeLinecap } from '../dom/common';\n\n/**\n * drawRoundRectangle\n */\nexport function drawRoundRectangle(\n    rs: RoughSVG,\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    options: Options,\n    outline = false,\n    borderRadius?: number\n) {\n    const width = Math.abs(x1 - x2);\n    const height = Math.abs(y1 - y2);\n\n    let radius = borderRadius || 0;\n    if (radius === 0) {\n        const defaultRadius = Math.min(width, height) / 8;\n        let radius = defaultRadius;\n        if (defaultRadius > MAX_RADIUS) {\n            radius = outline ? MAX_RADIUS + 2 : MAX_RADIUS;\n        }\n    }\n\n    const point1 = [x1 + radius, y1];\n    const point2 = [x2 - radius, y1];\n    const point3 = [x2, y1 + radius];\n    const point4 = [x2, y2 - radius];\n    const point5 = [x2 - radius, y2];\n    const point6 = [x1 + radius, y2];\n    const point7 = [x1, y2 - radius];\n    const point8 = [x1, y1 + radius];\n\n    const rectangleG = rs.path(\n        `M${point2[0]} ${point2[1]} A ${radius} ${radius}, 0, 0, 1, ${point3[0]} ${point3[1]} L ${point4[0]} ${point4[1]} A ${radius} ${radius}, 0, 0, 1, ${point5[0]} ${point5[1]} L ${point6[0]} ${point6[1]} A ${radius} ${radius}, 0, 0, 1, ${point7[0]} ${point7[1]} L ${point8[0]} ${point8[1]} A ${radius} ${radius}, 0, 0, 1, ${point1[0]} ${point1[1]} Z`,\n        options\n    );\n    setStrokeLinecap(rectangleG, 'round');\n    return rectangleG;\n}\n\nexport const drawRectangle = (board: PlaitBoard, rectangle: RectangleClient, options: Options) => {\n    const roughSVG = PlaitBoard.getRoughSVG(board);\n    const rectangleG = roughSVG.rectangle(rectangle.x, rectangle.y, rectangle.width, rectangle.height, options);\n    setStrokeLinecap(rectangleG, 'round');\n    return rectangleG;\n};\n", "import { rotate } from '../math';\nimport { RoughSVG } from 'roughjs/bin/svg';\nimport { Options } from 'roughjs/bin/core';\nimport { Point } from '../../interfaces';\n\nexport function arrowPoints(start: Point, end: Point, degree = 40) {\n    const width = Math.abs(start[0] - end[0]);\n    const height = Math.abs(start[1] - end[1]);\n    let hypotenuse = Math.hypot(width, height); // \n    const realRotateLine = hypotenuse / 2;\n    const rotateWidth = (realRotateLine / hypotenuse) * width;\n    const rotateHeight = (realRotateLine / hypotenuse) * height;\n    const rotatePoint = [\n        end[0] > start[0] ? end[0] - rotateWidth : end[0] + rotateWidth,\n        end[1] > start[1] ? end[1] - rotateHeight : end[1] + rotateHeight\n    ];\n    const pointRight = rotate(rotatePoint[0], rotatePoint[1], end[0], end[1], (degree * Math.PI) / 180) as Point;\n    const pointLeft = rotate(rotatePoint[0], rotatePoint[1], end[0], end[1], (-degree * Math.PI) / 180) as Point;\n    return { pointLeft, pointRight };\n}\n\nexport function drawArrow(rs: RoughSVG, start: Point, end: Point, options: Options, maxHypotenuseLength = 10, degree = 40): SVGGElement[] {\n    const { pointLeft, pointRight } = arrowPoints(start, end, degree);\n    const arrowLineLeft = rs.linearPath([pointLeft, end], options);\n    const arrowLineRight = rs.linearPath([pointRight, end], options);\n    return [arrowLineLeft, arrowLineRight];\n}\n", "import { RoughSVG } from 'roughjs/bin/svg';\nimport { Point } from '../../interfaces/point';\nimport { Options } from 'roughjs/bin/core';\n\nexport function drawCircle(roughSVG: RoughSVG, point: Point, diameter: number, options: Options): SVGGElement {\n    return roughSVG.circle(point[0], point[1], diameter, options);\n}\n", "import { RoughSVG } from 'roughjs/bin/svg';\nimport { Point } from '../../interfaces/point';\nimport { Options } from 'roughjs/bin/core';\nimport { createG, createPath } from '../dom/common';\n\nexport function drawLine(rs: RoughSVG, start: Point, end: Point, options: Options): SVGGElement {\n    return rs.linearPath([start, end], options);\n}\n\nexport function drawLinearPath(points: Point[], options?: Options, closePath?: boolean) {\n    const g = createG();\n    const path = createPath();\n\n    let polylinePath = '';\n    points.forEach((point, index) => {\n        if (index === 0) {\n            polylinePath += `M ${point[0]} ${point[1]} `;\n        } else {\n            polylinePath += `L ${point[0]} ${point[1]} `;\n        }\n    });\n\n    if (closePath) {\n        polylinePath += 'Z';\n    }\n\n    path.setAttribute('d', polylinePath);\n    path.setAttribute('stroke', `${options?.stroke}`);\n    path.setAttribute('stroke-width', `${options?.strokeWidth}`);\n    path.setAttribute('fill', `${options?.fill || 'none'}`);\n    options?.strokeLineDash && path.setAttribute('stroke-dasharray', `${options.strokeLineDash}`);\n    g.appendChild(path);\n    return g;\n}\n\nexport function drawBezierPath(points: Point[], options?: Options) {\n    const g = createG();\n    const path = createPath();\n\n    let polylinePath = '';\n    for (let i = 0; i < points.length - 3; i += 3) {\n        if (i === 0) {\n            polylinePath += `M ${points[0][0]} ${points[0][1]} `;\n        } else {\n            polylinePath += `C ${points[i + 1][0]} ${points[i + 1][1]}, ${points[i + 2][0]} ${points[i + 2][1]}, ${points[i + 3][0]} ${\n                points[i + 3][1]\n            }`;\n        }\n    }\n\n    path.setAttribute('d', polylinePath);\n    path.setAttribute('stroke', `${options?.stroke}`);\n    path.setAttribute('stroke-width', `${options?.strokeWidth}`);\n    path.setAttribute('fill', `none`);\n    g.appendChild(path);\n\n    return g;\n}\n", "import { SetViewportOperation } from '../interfaces/operation';\nimport { PlaitBoard } from '../interfaces/board';\nimport { Viewport } from '../interfaces/viewport';\n\nexport function setViewport(board: PlaitBoard, viewport: Viewport) {\n    const operation: SetViewportOperation = { type: 'set_viewport', properties: board.viewport, newProperties: viewport };\n    board.apply(operation);\n}\n\nexport interface ViewportTransforms {\n    setViewport: (board: PlaitBoard, viewport: Viewport) => void;\n}\n\nexport const ViewportTransforms: ViewportTransforms = {\n    setViewport\n};\n", "import { SetThemeOperation } from '../interfaces/operation';\nimport { PlaitBoard } from '../interfaces/board';\nimport { PlaitTheme } from '../interfaces';\n\nexport function setTheme(board: PlaitBoard, themeColorMode: PlaitTheme) {\n    const operation: SetThemeOperation = { type: 'set_theme', properties: board.theme, newProperties: themeColorMode };\n    board.apply(operation);\n}\n\nexport interface ThemeTransforms {\n    setTheme: (board: PlaitBoard, themeColorMode: PlaitTheme) => void;\n}\n\nexport const ViewportTransforms: ThemeTransforms = {\n    setTheme\n};\n", "import { ThemeColorMode } from '../interfaces/theme';\nimport { PlaitBoard } from '../interfaces/board';\nimport { Point } from '../interfaces/point';\nimport { getRectangleByElements } from '../utils/element';\nimport { distanceBetweenPointAndRectangle } from '../utils/math';\nimport {\n    clampZoomLevel,\n    clearViewportOrigination,\n    getViewBoxCenterPoint,\n    getViewportOrigination,\n    initializeViewportContainer\n} from '../utils/viewport';\nimport { setViewport } from './viewport';\nimport { depthFirstRecursion, getRealScrollBarWidth, getSelectedElements } from '../utils';\nimport { PlaitElement } from '../interfaces/element';\nimport { setTheme } from './theme';\nimport { FitViewportOptions } from '../interfaces/viewport';\nimport { PlaitPointerType } from '../interfaces/pointer';\n\nfunction updateViewport(board: PlaitBoard, origination: Point, zoom?: number) {\n    zoom = zoom ?? board.viewport.zoom;\n    setViewport(board, {\n        ...board.viewport,\n        zoom,\n        origination\n    });\n    clearViewportOrigination(board);\n}\n\nfunction updateZoom(board: PlaitBoard, newZoom: number, center?: Point) {\n    newZoom = clampZoomLevel(newZoom);\n\n    const nativeElement = PlaitBoard.getBoardContainer(board);\n    const nativeElementRect = nativeElement.getBoundingClientRect();\n    const boardContainerRect = PlaitBoard.getBoardContainer(board).getBoundingClientRect();\n    let focusPoint = [boardContainerRect.width / 2, boardContainerRect.height / 2];\n\n    if (center && distanceBetweenPointAndRectangle(center[0], center[1], nativeElementRect) === 0) {\n        focusPoint = [center[0] - nativeElementRect.x, center[1] - nativeElementRect.y];\n    }\n\n    const zoom = board.viewport.zoom;\n    const origination = getViewportOrigination(board);\n    const centerX = origination![0] + focusPoint[0] / zoom;\n    const centerY = origination![1] + focusPoint[1] / zoom;\n    const newOrigination = [centerX - focusPoint[0] / newZoom, centerY - focusPoint[1] / newZoom] as Point;\n    updateViewport(board, newOrigination, newZoom);\n}\n\nfunction fitViewport(board: PlaitBoard) {\n    let scrollBarWidth = getRealScrollBarWidth(board);\n\n    const boardContainerRect = PlaitBoard.getBoardContainer(board).getBoundingClientRect();\n    const elementHostBox = getRectangleByElements(board, board.children, true);\n    const zoom = board.viewport.zoom;\n    const autoFitPadding = 16;\n    const viewportWidth = boardContainerRect.width - 2 * autoFitPadding;\n    const viewportHeight = boardContainerRect.height - 2 * autoFitPadding;\n\n    let newZoom = zoom;\n    if (viewportWidth < elementHostBox.width || viewportHeight < elementHostBox.height) {\n        newZoom = Math.min(viewportWidth / elementHostBox.width, viewportHeight / elementHostBox.height);\n    } else {\n        newZoom = 1;\n    }\n\n    const centerPoint = getViewBoxCenterPoint(board);\n    const newOrigination = [\n        centerPoint[0] - boardContainerRect.width / 2 / newZoom + scrollBarWidth / 2 / zoom,\n        centerPoint[1] - boardContainerRect.height / 2 / newZoom + scrollBarWidth / 2 / zoom\n    ] as Point;\n    updateViewport(board, newOrigination, newZoom);\n}\n\nfunction fitViewportWidth(board: PlaitBoard, options: FitViewportOptions) {\n    let scrollBarWidth = getRealScrollBarWidth(board);\n\n    const boardContainer = PlaitBoard.getBoardContainer(board);\n    const boardContainerRectangle = boardContainer.getBoundingClientRect();\n\n    let finalWidth = 0;\n    if (options.maxWidth) {\n        finalWidth = options.maxWidth;\n    } else {\n        finalWidth = boardContainerRectangle.width;\n    }\n\n    const elementHostBox = getRectangleByElements(board, board.children, true);\n    const contentWidth = finalWidth - 2 * options.autoFitPadding;\n    let newZoom = 0;\n    if (contentWidth < elementHostBox.width) {\n        newZoom = Math.min(contentWidth / elementHostBox.width);\n    } else {\n        newZoom = 1;\n    }\n\n    let finalHeight = elementHostBox.height * newZoom + 2 * options.autoFitPadding;\n    if (finalHeight > options.limitHeight) {\n        const containerEl = boardContainer.closest(`.${options.containerClass}`) as HTMLElement;\n        containerEl.style.height = `${finalHeight}px`;\n        initializeViewportContainer(board);\n    } else {\n        finalHeight = options.limitHeight;\n    }\n\n    const centerX = elementHostBox.x + elementHostBox.width / 2;\n    const centerY = elementHostBox.y + elementHostBox.height / 2;\n    const newOrigination = [\n        centerX - finalWidth / 2 / newZoom + scrollBarWidth / 2 / newZoom,\n        centerY - finalHeight / 2 / newZoom + scrollBarWidth / 2 / newZoom\n    ] as Point;\n    updateViewport(board, newOrigination, newZoom);\n}\n\n/**\n * apply theme to every element (remove element custom properties)\n * invoke applyThemeColor\n */\nfunction updateThemeColor(board: PlaitBoard, mode: ThemeColorMode) {\n    mode = mode ?? board.theme.themeColorMode;\n    setTheme(board, { themeColorMode: mode });\n\n    depthFirstRecursion((board as unknown) as PlaitElement, element => {\n        board.applyTheme(element);\n    });\n}\n\nconst updatePointerType = <T extends string = PlaitPointerType>(board: PlaitBoard, pointer: T) => {\n    if (board.pointer === pointer) return;\n    board.pointer = pointer;\n};\n\nfunction moveToCenter(board: PlaitBoard, centerPoint: Point) {\n    const plaitElement = getSelectedElements(board)?.[0];\n    if (plaitElement) {\n        const boardContainerRect = PlaitBoard.getBoardContainer(board).getBoundingClientRect();\n        const scrollBarWidth = getRealScrollBarWidth(board);\n        const oldCenterPoint = getViewBoxCenterPoint(board);\n        const left = centerPoint[0] - oldCenterPoint[0];\n        const top = centerPoint[1] - oldCenterPoint[1];\n        const zoom = board.viewport.zoom;\n\n        const origination = [\n            left - boardContainerRect.width / 2 / zoom + scrollBarWidth / 2 / zoom,\n            top - boardContainerRect.height / 2 / zoom + scrollBarWidth / 2 / zoom\n        ] as Point;\n\n        setViewport(board, {\n            ...board.viewport,\n            origination\n        });\n        clearViewportOrigination(board);\n    }\n}\n\nexport const BoardTransforms = {\n    updatePointerType,\n    updateViewport,\n    fitViewport,\n    updateZoom,\n    updateThemeColor,\n    fitViewportWidth,\n    moveToCenter\n};\n", "import { RectangleClient } from '../interfaces';\nimport { PlaitBoard } from '../interfaces/board';\nimport { Point } from '../interfaces/point';\n\nexport const getViewBox = (board: PlaitBoard) => {\n    return PlaitBoard.getHost(board).viewBox.baseVal;\n};\n\n/**\n * Get the screen point starting from the upper left corner of the svg element (based on the svg screen coordinate system)\n * reference: https://github.com/worktile/plait/blob/develop/packages/core/src/utils/to-point.md\n */\nexport function toHostPoint(board: PlaitBoard, x: number, y: number): Point {\n    const host = PlaitBoard.getHost(board);\n    const rect = host.getBoundingClientRect();\n    return [x - rect.x, y - rect.y];\n}\n\nexport function toActiveRectangleFromViewBoxRectangle(board: PlaitBoard, rectangle: RectangleClient) {\n    const leftTop = [rectangle.x, rectangle.y] as Point;\n    const rightBottom = [rectangle.x + rectangle.width, rectangle.y + rectangle.height] as Point;\n    const leftTopOfActive = toActivePointFromViewBoxPoint(board, leftTop);\n    const rightBottomOfActive = toActivePointFromViewBoxPoint(board, rightBottom);\n    return RectangleClient.getRectangleByPoints([leftTopOfActive, rightBottomOfActive]);\n}\n\nexport function toActivePointFromViewBoxPoint(board: PlaitBoard, point: Point) {\n    const screenPoint = toScreenPointFromHostPoint(board, toHostPointFromViewBoxPoint(board, point));\n    return toActivePoint(board, screenPoint[0], screenPoint[1]);\n}\n\n/**\n * Get the screen point starting from the upper left corner of the svg element (based on the svg screen coordinate system)\n */\nexport function toActivePoint(board: PlaitBoard, x: number, y: number): Point {\n    const boardContainer = PlaitBoard.getBoardContainer(board);\n    const rect = boardContainer.getBoundingClientRect();\n    return [x - rect.x, y - rect.y];\n}\n\nexport function toScreenPointFromActivePoint(board: PlaitBoard, activePoint: Point): Point {\n    const boardContainer = PlaitBoard.getBoardContainer(board);\n    const rect = boardContainer.getBoundingClientRect();\n    return [rect.x + activePoint[0], rect.y + activePoint[1]];\n}\n\n/**\n * Get the point in the coordinate system of the svg viewBox\n * reference: https://github.com/worktile/plait/blob/develop/packages/core/src/utils/to-point.md\n */\nexport function toViewBoxPoint(board: PlaitBoard, hostPoint: Point) {\n    const viewBox = getViewBox(board);\n    const { zoom } = board.viewport;\n    const x = hostPoint[0] / zoom + viewBox.x;\n    const y = hostPoint[1] / zoom + viewBox.y;\n    const newPoint = [x, y] as Point;\n    return newPoint;\n}\n\nexport function toViewBoxPoints(board: PlaitBoard, hostPoints: Point[]) {\n    const newPoints = hostPoints.map((point) => {\n        return toViewBoxPoint(board, point);\n    });\n    return newPoints;\n}\n\n/**\n * `toHostPoint` reverse processing\n * Get the screen point starting from the upper left corner of the browser window or the viewport (based on the screen coordinate system)\n */\nexport function toScreenPointFromHostPoint(board: PlaitBoard, hostPoint: Point) {\n    const host = PlaitBoard.getHost(board);\n    const rect = host.getBoundingClientRect();\n    return [hostPoint[0] + rect.x, hostPoint[1] + rect.y] as Point;\n}\n\n/**\n * `toViewBoxPoint` reverse processing\n */\nexport function toHostPointFromViewBoxPoint(board: PlaitBoard, viewBoxPoint: Point) {\n    const { zoom } = board.viewport;\n    const viewBox = getViewBox(board);\n    const x = (viewBoxPoint[0] - viewBox.x) * zoom;\n    const y = (viewBoxPoint[1] - viewBox.y) * zoom;\n    return [x, y] as Point;\n}\n", "import { SCROLL_BAR_WIDTH } from '../constants';\nimport { MAX_ZOOM, MIN_ZOOM } from '../constants/zoom';\nimport { PlaitBoard, Point, RectangleClient } from '../interfaces';\nimport { BoardTransforms } from '../transforms/board';\nimport { getRectangleByElements } from './element';\nimport { approximately } from './math';\nimport { getViewBox, toHostPointFromViewBoxPoint, toViewBoxPoint } from './to-point';\nimport { BOARD_TO_VIEWPORT_ORIGINATION } from './weak-maps';\n\nexport const VIEWPORT_PADDING_RATIO = 0.75;\n\nexport interface ElementHostBBox {\n    left: number;\n    right: number;\n    top: number;\n    bottom: number;\n}\n\nconst IS_FROM_SCROLLING = new WeakMap<PlaitBoard, boolean>();\n\nconst IS_FROM_VIEWPORT_CHANGE = new WeakMap<PlaitBoard, boolean>();\n\nexport function getViewportContainerRect(board: PlaitBoard) {\n    const { hideScrollbar } = board.options;\n    const scrollBarWidth = hideScrollbar ? SCROLL_BAR_WIDTH : 0;\n    const viewportRect = PlaitBoard.getBoardContainer(board).getBoundingClientRect();\n\n    return {\n        width: viewportRect.width + scrollBarWidth,\n        height: viewportRect.height + scrollBarWidth\n    };\n}\n\nexport function getElementHostBBox(board: PlaitBoard, zoom: number): ElementHostBBox {\n    const childrenRect = getRectangleByElements(board, board.children, true);\n    let left: number;\n    let right: number;\n    let top: number;\n    let bottom: number;\n    left = childrenRect.x;\n    right = childrenRect.x + childrenRect.width;\n    top = childrenRect.y;\n    bottom = childrenRect.y + childrenRect.height;\n    return {\n        left,\n        right,\n        top,\n        bottom\n    };\n}\n\n/**\n * Normalize the scaling ratio, or return the corrected scaling ratio if the limit is exceeded\n */\nexport function clampZoomLevel(zoom: number, minZoom = MIN_ZOOM, maxZoom = MAX_ZOOM) {\n    return zoom < minZoom ? minZoom : zoom > maxZoom ? maxZoom : zoom;\n}\n\n/**\n * Prepares element bounding box with minimum size constraints\n */\nexport function prepareElementBBox(board: PlaitBoard, zoom: number): {\n    elementHostBBox: ElementHostBBox;\n    containerWidth: number;\n    containerHeight: number;\n    width: number;\n    height: number;\n} {\n    const boardContainerRectangle = PlaitBoard.getBoardContainer(board).getBoundingClientRect();\n    const elementHostBBox: ElementHostBBox = getElementHostBBox(board, zoom);\n    \n    const containerWidth = boardContainerRectangle.width;\n    const containerHeight = boardContainerRectangle.height;\n    \n    // Calculate bounding box dimensions\n    let width = elementHostBBox.right - elementHostBBox.left;\n    let height = elementHostBBox.bottom - elementHostBBox.top;\n    \n    // If elementHostBBox dimensions are smaller than container dimensions,\n    // use half of container dimensions as minimum size\n    const minWidth = containerWidth / 2;\n    const minHeight = containerHeight / 2;\n    \n    if (width < minWidth / zoom) {\n        // Center the content horizontally if applying minimum width\n        const center = elementHostBBox.left + width / 2;\n        elementHostBBox.left = center - minWidth / 2 / zoom;\n        elementHostBBox.right = center + minWidth / 2 / zoom;\n        width = minWidth / zoom;\n    }\n    \n    if (height < minHeight / zoom) {\n        // Center the content vertically if applying minimum height\n        const center = elementHostBBox.top + height / 2;\n        elementHostBBox.top = center - minHeight / 2 / zoom;\n        elementHostBBox.bottom = center + minHeight / 2 / zoom;\n        height = minHeight / zoom;\n    }\n    \n    return {\n        elementHostBBox,\n        containerWidth,\n        containerHeight,\n        width,\n        height\n    };\n}\n\n/**\n * Calculates viewBox based on element bounding box with padding\n */\nexport function calculateViewBox(\n    elementHostBBox: ElementHostBBox,\n    containerWidth: number,\n    containerHeight: number,\n    width: number,\n    height: number,\n    zoom: number,\n    paddingRatio: number = VIEWPORT_PADDING_RATIO\n): number[] {\n    const horizontalPaddingInViewBox = (containerWidth * paddingRatio) / zoom;\n    const verticalPaddingInViewBox = (containerHeight * paddingRatio) / zoom;\n    \n    return [\n        elementHostBBox.left - horizontalPaddingInViewBox,\n        elementHostBBox.top - verticalPaddingInViewBox,\n        width + horizontalPaddingInViewBox * 2,\n        height + verticalPaddingInViewBox * 2\n    ];\n}\n\nexport function calcNewViewBox(board: PlaitBoard, zoom: number) {\n    const { elementHostBBox, containerWidth, containerHeight, width, height } = prepareElementBBox(board, zoom);\n    \n    return calculateViewBox(\n        elementHostBBox,\n        containerWidth,\n        containerHeight,\n        width,\n        height,\n        zoom\n    );\n}\n\nexport function getViewBoxCenterPoint(board: PlaitBoard) {\n    const childrenRectangle = getRectangleByElements(board, board.children, true);\n    return [childrenRectangle.x + childrenRectangle.width / 2, childrenRectangle.y + childrenRectangle.height / 2] as Point;\n}\n\nexport function setSVGViewBox(board: PlaitBoard, viewBox: number[]) {\n    const zoom = board.viewport.zoom;\n    const hostElement = PlaitBoard.getHost(board);\n    hostElement.style.display = 'block';\n    hostElement.style.width = `${viewBox[2] * zoom}px`;\n    hostElement.style.height = `${viewBox[3] * zoom}px`;\n\n    if (viewBox && viewBox[2] > 0 && viewBox[3] > 0) {\n        hostElement.setAttribute('viewBox', viewBox.join(' '));\n    }\n}\n\nexport function updateViewportOffset(board: PlaitBoard) {\n    const origination = getViewportOrigination(board);\n    if (!origination) {\n        return;\n    }\n    const [scrollLeft, scrollTop] = toHostPointFromViewBoxPoint(board, origination);\n    updateViewportContainerScroll(board, scrollLeft, scrollTop);\n}\n\nexport function updateViewportContainerScroll(board: PlaitBoard, left: number, top: number, isFromViewportChange: boolean = true) {\n    const viewportContainer = PlaitBoard.getViewportContainer(board);\n    const previousScrollLeft = viewportContainer.scrollLeft;\n    const previousScrollTop = viewportContainer.scrollTop;\n    // scrollTop assign 11.8 will get 11.5 in chrome\n    // scrollTop assign 11.8 will get 11 in firefox, safari\n    // scrollTop assign 11.4 will get 11 in chrome, firefox, safari\n    // use approximately method to determine the new value is valid updating to avoid debouncing\n    if (!approximately(viewportContainer.scrollLeft, left, 1) || !approximately(viewportContainer.scrollTop, top, 1)) {\n        viewportContainer.scrollLeft = left;\n        viewportContainer.scrollTop = top;\n        const offsetWidth = viewportContainer.offsetWidth;\n        const offsetHeight = viewportContainer.offsetHeight;\n        if (previousScrollLeft === viewportContainer.scrollLeft && previousScrollTop === viewportContainer.scrollTop) {\n            // The scroll event cannot be triggered, so the origination is modified directly based on the scroll distance.\n            updateViewportByScrolling(board, previousScrollLeft, previousScrollTop);\n        } else {\n            const isValidLeftOrTop =\n                left > 0 &&\n                top > 0 &&\n                left < viewportContainer.scrollWidth - offsetWidth &&\n                top < viewportContainer.scrollHeight - offsetHeight;\n            if (isFromViewportChange && isValidLeftOrTop) {\n                setIsFromViewportChange(board, true);\n            }\n        }\n    }\n}\n\nexport function updateViewportByScrolling(board: PlaitBoard, scrollLeft: number, scrollTop: number) {\n    const origination = toViewBoxPoint(board, [scrollLeft, scrollTop]);\n    if (Point.isEquals(origination, getViewportOrigination(board))) {\n        return;\n    }\n    BoardTransforms.updateViewport(board, origination);\n    setIsFromScrolling(board, true);\n}\n\nexport function initializeViewportContainer(board: PlaitBoard) {\n    const { width, height } = getViewportContainerRect(board);\n    const viewportContainer = PlaitBoard.getViewportContainer(board);\n    viewportContainer.style.width = `${width}px`;\n    viewportContainer.style.height = `${height}px`;\n}\n\nexport function initializeViewBox(board: PlaitBoard) {\n    const zoom = board.viewport.zoom;\n    const viewBox = calcNewViewBox(board, zoom);\n    setSVGViewBox(board, viewBox);\n}\n\nexport function updateViewBox(board: PlaitBoard) {\n    const zoom = board.viewport.zoom;\n    const { elementHostBBox, containerWidth, containerHeight, width, height } = prepareElementBBox(board, zoom);\n    \n    // Use 0.5 ratio to check if contents are within current viewBox\n    const checkViewBox = calculateViewBox(\n        elementHostBBox,\n        containerWidth,\n        containerHeight,\n        width,\n        height,\n        zoom,\n        0.5 // Use smaller padding ratio for checking\n    );\n    \n    // Get current viewBox\n    const currentViewBox = getViewBox(board);\n    \n    // Only update if new viewBox is NOT contained within current viewBox\n    if (\n        checkViewBox[0] < currentViewBox.x ||\n        checkViewBox[1] < currentViewBox.y ||\n        checkViewBox[0] + checkViewBox[2] > currentViewBox.x + currentViewBox.width ||\n        checkViewBox[1] + checkViewBox[3] > currentViewBox.y + currentViewBox.height\n    ) {\n        // Update with larger padding ratio\n        const newViewBox = calculateViewBox(\n            elementHostBBox,\n            containerWidth,\n            containerHeight,\n            width,\n            height,\n            zoom,\n            VIEWPORT_PADDING_RATIO\n        );\n        setSVGViewBox(board, newViewBox);\n    }\n}\n\nexport function initializeViewportOffset(board: PlaitBoard) {\n    if (!board.viewport?.origination) {\n        const zoom = board.viewport.zoom;\n        const viewportContainerRect = PlaitBoard.getBoardContainer(board).getBoundingClientRect();\n        const viewBox = calcNewViewBox(board, zoom);\n        const centerX = viewBox[0] + viewBox[2] / 2;\n        const centerY = viewBox[1] + viewBox[3] / 2;\n        const origination = [centerX - viewportContainerRect.width / 2 / zoom, centerY - viewportContainerRect.height / 2 / zoom] as Point;\n        updateViewportOrigination(board, origination);\n        updateViewportOffset(board);\n        return;\n    }\n    updateViewportOffset(board);\n}\n\nexport const updateViewportOrigination = (board: PlaitBoard, origination: Point) => {\n    BOARD_TO_VIEWPORT_ORIGINATION.set(board, origination);\n};\n\nexport const clearViewportOrigination = (board: PlaitBoard) => {\n    BOARD_TO_VIEWPORT_ORIGINATION.delete(board);\n};\n\nexport const getViewportOrigination = (board: PlaitBoard) => {\n    const origination = BOARD_TO_VIEWPORT_ORIGINATION.get(board);\n    if (origination) {\n        return origination;\n    } else {\n        return board.viewport.origination;\n    }\n};\n\nexport const isFromScrolling = (board: PlaitBoard) => {\n    return !!IS_FROM_SCROLLING.get(board);\n};\n\nexport const setIsFromScrolling = (board: PlaitBoard, state: boolean) => {\n    IS_FROM_SCROLLING.set(board, state);\n};\n\nexport const isFromViewportChange = (board: PlaitBoard) => {\n    return !!IS_FROM_VIEWPORT_CHANGE.get(board);\n};\n\nexport const setIsFromViewportChange = (board: PlaitBoard, state: boolean) => {\n    IS_FROM_VIEWPORT_CHANGE.set(board, state);\n};\n\nexport function scrollToRectangle(board: PlaitBoard, client: RectangleClient) {}\n", "import { InsertNodeOperation, MoveNodeOperation, RemoveNodeOperation, SetNodeOperation } from '../interfaces/operation';\nimport { PlaitBoard } from '../interfaces/board';\nimport { PlaitNode } from '../interfaces/node';\nimport { Path } from '../interfaces/path';\n\nexport function insertNode(board: PlaitBoard, node: PlaitNode, path: Path) {\n    const operation: InsertNodeOperation = { type: 'insert_node', node, path };\n    board.apply(operation);\n}\n\nexport function setNode(board: PlaitBoard, props: Partial<PlaitNode>, path: Path) {\n    const properties: Partial<PlaitNode> = {};\n    const newProperties: Partial<PlaitNode> = {};\n    const node = PlaitNode.get(board, path);\n    for (const k in props) {\n        if (node[k] !== props[k]) {\n            if (node.hasOwnProperty(k)) {\n                properties[k] = node[k];\n            }\n            if (props[k] != null) newProperties[k] = props[k];\n        }\n    }\n    const operation: SetNodeOperation = { type: 'set_node', properties, newProperties, path };\n    board.apply(operation);\n}\n\nexport function removeNode(board: PlaitBoard, path: Path) {\n    const node = PlaitNode.get(board, path);\n    const operation: RemoveNodeOperation = { type: 'remove_node', path, node };\n    board.apply(operation);\n}\n\nexport function moveNode(board: PlaitBoard, path: Path, newPath: Path) {\n    const operation: MoveNodeOperation = { type: 'move_node', path, newPath };\n    board.apply(operation);\n}\n\nexport interface NodeTransforms {\n    insertNode: (board: PlaitBoard, node: PlaitNode, path: Path) => void;\n    setNode: (board: PlaitBoard, node: Partial<PlaitNode>, path: Path) => void;\n    removeNode: (board: PlaitBoard, path: Path) => void;\n    moveNode: (board: PlaitBoard, path: Path, newPath: Path) => void;\n}\n\nexport const NodeTransforms: NodeTransforms = {\n    insertNode,\n    setNode,\n    removeNode,\n    moveNode\n};\n", "import { Path, PlaitElement } from '../interfaces';\nimport { PlaitBoard } from '../interfaces/board';\nimport { NodeTransforms } from '../transforms/node';\nimport { sortElements } from './position';\n\nconst BOARD_TO_RAF = new WeakMap<PlaitBoard, { [key: string]: number | null }>();\n\nexport interface MoveNodeOption {\n    element: PlaitElement;\n    newPath: Path;\n}\n\nconst getTimerId = (board: PlaitBoard, key: string) => {\n    const state = getRAFState(board);\n    return state[key] || null;\n};\n\nconst getRAFState = (board: PlaitBoard) => {\n    return BOARD_TO_RAF.get(board) || {};\n};\n\nexport const throttleRAF = (board: PlaitBoard, key: string, fn: () => void) => {\n    const scheduleFunc = () => {\n        let timerId = requestAnimationFrame(() => {\n            const value = BOARD_TO_RAF.get(board) || {};\n            value[key] = null;\n            BOARD_TO_RAF.set(board, value);\n            PlaitBoard.isAlive(board) && fn();\n        });\n        const state = getRAFState(board);\n        state[key] = timerId;\n        BOARD_TO_RAF.set(board, state);\n    };\n    let timerId = getTimerId(board, key);\n    if (timerId !== null) {\n        cancelAnimationFrame(timerId);\n    }\n    scheduleFunc();\n};\n\nexport const debounce = <T>(func: (args?: T) => void, wait: number, options?: { leading: boolean }) => {\n    let timeoutId: any = null;\n    return (args?: T) => {\n        if (timeoutId !== null) {\n            clearTimeout(timeoutId);\n            timeoutId = setTimeout(() => {\n                func(args);\n                timeoutId = null;\n            }, wait);\n        } else {\n            if (options?.leading) {\n                func(args);\n            }\n            timeoutId = setTimeout(() => {\n                timeoutId = null;\n                if (!options?.leading) {\n                    func(args);\n                }\n            }, wait);\n        }\n    };\n};\n\nexport const getElementsIndices = (board: PlaitBoard, elements: PlaitElement[]): number[] => {\n    sortElements(board, elements);\n    return elements\n        .map(item => {\n            return board.children.map(item => item.id).indexOf(item.id);\n        })\n        .filter(item => item >= 0);\n};\n\nexport const getHighestIndexOfElement = (board: PlaitBoard, elements: PlaitElement[]) => {\n    const indices = getElementsIndices(board, elements);\n    return indices[indices.length - 1];\n};\n\nexport const moveElementsToNewPath = (board: PlaitBoard, moveOptions: MoveNodeOption[]) => {\n    moveOptions\n        .map(item => {\n            const path = PlaitBoard.findPath(board, item.element);\n            const ref = board.pathRef(path);\n            return () => {\n                ref.current && NodeTransforms.moveNode(board, ref.current, item.newPath);\n                ref.unref();\n            };\n        })\n        .forEach(action => {\n            action();\n        });\n};\n", "import { PlaitBoard } from \"../interfaces/board\";\n\nexport const IS_DRAGGING = new WeakMap<PlaitBoard, boolean>();\n\n\nexport const isDragging = (board: PlaitBoard) => {\n    return !!IS_DRAGGING.get(board);\n};\n\nexport const setDragging = (board: PlaitBoard, state: boolean) => {\n    IS_DRAGGING.set(board, state);\n}", "import { PlaitBoard, PlaitElement } from '../interfaces';\nimport { setDragging } from './dnd';\nimport { BOARD_TO_MOVING_ELEMENT } from './weak-maps';\n\nexport const getMovingElements = (board: PlaitBoard) => {\n    return BOARD_TO_MOVING_ELEMENT.get(board) || [];\n};\n\nexport const isMovingElements = (board: PlaitBoard) => {\n    return (BOARD_TO_MOVING_ELEMENT.get(board) || []).length > 0;\n};\n\nexport const removeMovingElements = (board: PlaitBoard) => {\n    BOARD_TO_MOVING_ELEMENT.delete(board);\n    setDragging(board, false);\n};\n\nexport const cacheMovingElements = (board: PlaitBoard, elements: PlaitElement[]) => {\n    BOARD_TO_MOVING_ELEMENT.set(board, elements);\n    setDragging(board, true);\n};\n", "import { PlaitBoard, PlaitElement, RectangleClient } from '../interfaces';\nimport { findElements, getRectangleByElements } from './element';\n\nconst FOREIGN_OBJECT_EXPRESSION = `foreignObject[class^='foreign-object']`;\n\nexport interface ToImageOptions {\n    elements?: PlaitElement[];\n    name?: string;\n    ratio?: number;\n    padding?: number;\n    fillStyle?: string;\n    // List of class names. The list must be in the form class1,class2,...\n    inlineStyleClassNames?: string;\n}\n\n/**\n * Is element node\n * @param node\n * @returns\n */\nfunction isElementNode(node: Node): node is HTMLElement {\n    return node.nodeType === Node.ELEMENT_NODE;\n}\n\n/**\n * load image resources\n * @param url image url\n * @returns image element\n */\nfunction loadImage(src: string): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n        const img = new Image();\n        img.crossOrigin = 'Anonymous';\n        img.onload = () => resolve(img);\n        img.onerror = () => reject(new Error('Failed to load image'));\n        img.src = src;\n    });\n}\n\n/**\n * create and return canvas and context\n * @param width canvas width\n * @param height canvas height\n * @param fillStyle fill style\n * @returns canvas and context\n */\nfunction createCanvas(width: number, height: number, fillStyle = 'transparent') {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d')!;\n\n    canvas.width = width;\n    canvas.height = height;\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n    ctx.strokeStyle = '#ffffff';\n    ctx.fillStyle = fillStyle;\n    ctx.fillRect(0, 0, width, height);\n\n    return {\n        canvas,\n        ctx\n    };\n}\n\n/**\n * convert image to base64\n * @param url image url\n * @returns image base64\n */\nasync function convertImageToBase64(url: string): Promise<string> {\n    const response = await fetch(url);\n    const blob = await response.blob();\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onloadend = () => resolve(reader.result as string);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    });\n}\n\n/**\n * clone node style\n * @param nativeNode source node\n * @param clonedNode clone node\n */\nfunction cloneCSSStyle<T extends HTMLElement>(nativeNode: T, clonedNode: T) {\n    const targetStyle = clonedNode?.style;\n    if (!targetStyle) {\n        return;\n    }\n\n    const sourceStyle = window.getComputedStyle(nativeNode);\n    if (sourceStyle.cssText) {\n        targetStyle.cssText = sourceStyle.cssText;\n        targetStyle.transformOrigin = sourceStyle.transformOrigin;\n    } else {\n        Array.from(sourceStyle).forEach(name => {\n            let value = sourceStyle.getPropertyValue(name);\n            targetStyle.setProperty(name, value, sourceStyle.getPropertyPriority(name));\n        });\n    }\n}\n\n/**\n * batch clone target styles\n * @param sourceNode\n * @param cloneNode\n * @param inlineStyleClassNames\n */\nfunction batchCloneCSSStyle(sourceNode: SVGGElement, cloneNode: SVGGElement, inlineStyleClassNames: string) {\n    if (inlineStyleClassNames) {\n        const classNames = inlineStyleClassNames + `, ${FOREIGN_OBJECT_EXPRESSION}`;\n        const sourceNodes = Array.from(sourceNode.querySelectorAll(classNames));\n        const cloneNodes = Array.from(cloneNode.querySelectorAll(classNames));\n\n        sourceNodes.forEach((node, index) => {\n            const childElements = Array.from(node.querySelectorAll('*')).filter(isElementNode) as HTMLElement[];\n            const cloneChildElements = Array.from(cloneNodes[index].querySelectorAll('*')).filter(isElementNode) as HTMLElement[];\n            sourceNodes.push(...childElements);\n            cloneNodes.push(...cloneChildElements);\n        });\n\n        // processing styles\n        sourceNodes.map((node, index) => {\n            cloneCSSStyle(node as HTMLElement, cloneNodes[index] as HTMLElement);\n        });\n    }\n}\n\n/**\n * convert images in target nodes in batches\n * @param sourceNode\n * @param cloneNode\n */\nasync function batchConvertImage(sourceNode: SVGGElement, cloneNode: SVGGElement) {\n    const sourceImageNodes = Array.from(sourceNode.querySelectorAll(`${FOREIGN_OBJECT_EXPRESSION}`));\n    const cloneImageNodes = Array.from(cloneNode.querySelectorAll(`${FOREIGN_OBJECT_EXPRESSION}`));\n    await Promise.all(\n        sourceImageNodes.map((_, index) => {\n            return new Promise(resolve => {\n                const cloneImageNode = cloneImageNodes[index];\n                // processing image\n                const image = (cloneImageNode as HTMLElement).querySelector('img');\n                const url = image?.getAttribute('src');\n                if (!url) {\n                    return resolve(true);\n                }\n                convertImageToBase64(url).then(base64Image => {\n                    image?.setAttribute('src', base64Image);\n                    resolve(true);\n                });\n            });\n        })\n    );\n}\n\n/**\n * clone svg element\n * @param board board\n * @param options parameter configuration\n * @returns clone svg element\n */\nasync function cloneSvg(board: PlaitBoard, elements: PlaitElement[], rectangle: RectangleClient, options: ToImageOptions) {\n    const { width, height, x, y } = rectangle;\n    const { padding = 4, inlineStyleClassNames } = options;\n    const sourceSvg = PlaitBoard.getHost(board);\n    const selectedGElements = elements.map(value => PlaitElement.getElementG(value));\n    const cloneSvgElement = sourceSvg.cloneNode() as SVGElement;\n    const newHostElement = PlaitBoard.getElementHost(board).cloneNode() as SVGGElement;\n\n    cloneSvgElement.style.width = `${width}px`;\n    cloneSvgElement.style.height = `${height}px`;\n    cloneSvgElement.style.backgroundColor = '';\n    cloneSvgElement.setAttribute('width', `${width}`);\n    cloneSvgElement.setAttribute('height', `${height}`);\n    cloneSvgElement.setAttribute('viewBox', [x - padding, y - padding, width + 2 * padding, height + 2 * padding].join(','));\n\n    const promiseArray = new Array(selectedGElements.length);\n    await Promise.all(\n        selectedGElements.map(async (child, i) => {\n            const cloneChild = child.cloneNode(true) as SVGGElement;\n            batchCloneCSSStyle(child, cloneChild, inlineStyleClassNames as string);\n            await batchConvertImage(child, cloneChild);\n            promiseArray[i] = cloneChild;\n        })\n    );\n    newHostElement.append(...promiseArray);\n    cloneSvgElement.appendChild(newHostElement);\n    return cloneSvgElement;\n}\n\n/**\n * current board transfer pictures\n * @param board board\n * @param options parameter configuration\n * @returns images in the specified format base64\n */\nexport async function toImage(board: PlaitBoard, options: ToImageOptions) {\n    if (!board) {\n        return undefined;\n    }\n    const elements = options.elements || findElements(board, { match: () => true, recursion: () => true, isReverse: false });\n    const targetRectangle = getRectangleByElements(board, elements, false);\n    const { ratio = 2, fillStyle = 'transparent' } = options;\n    const { width, height } = targetRectangle;\n    const ratioWidth = width * ratio;\n    const ratioHeight = height * ratio;\n\n    const cloneSvgElement = await cloneSvg(board, elements, targetRectangle, options);\n    const { canvas, ctx } = createCanvas(ratioWidth, ratioHeight, fillStyle);\n\n    const svgStr = new XMLSerializer().serializeToString(cloneSvgElement);\n    const imgSrc = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svgStr)}`;\n\n    try {\n        const img = await loadImage(imgSrc);\n        ctx.drawImage(img, 0, 0, ratioWidth, ratioHeight);\n        return canvas.toDataURL('image/png');\n    } catch (error) {\n        console.error('Error converting SVG to image:', error);\n        return undefined;\n    }\n}\n\n/**\n * download the file with the specified name\n * @param url download url\n * @param name file name\n */\nexport function downloadImage(url: string, name: string) {\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = name;\n    a.click();\n    a.remove();\n}\n", "import { PlaitElement } from '../../interfaces';\n\nexport enum WritableClipboardType {\n    'medias' = 'medias',\n    'elements' = 'elements'\n}\n\nexport enum WritableClipboardOperationType {\n    'copy' = 'copy',\n    'cut' = 'cut',\n    'duplicate' = 'duplicate',\n    'paste' = 'paste'\n}\n\nexport type WritableClipboardData = PlaitElement[] | any[];\n\nexport interface WritableClipboardContext {\n    text: string;\n    type: WritableClipboardType;\n    elements: WritableClipboardData;\n}\n\nexport interface ClipboardData {\n    files?: File[];\n    elements?: PlaitElement[];\n    medias?: any[];\n    text?: string;\n    operationType?: WritableClipboardOperationType;\n}\n", "import { ClipboardData, WritableClipboardContext, WritableClipboardData, WritableClipboardType } from './types';\n\nexport const buildPlaitHtml = (type: WritableClipboardType, data: WritableClipboardData) => {\n    const stringifiedClipboard = replaceAngleBrackets(\n        JSON.stringify({\n            type,\n            data\n        })\n    );\n    return `<plait>${stringifiedClipboard}</plait>`;\n};\n\nexport const getClipboardFromHtml = (html: string): ClipboardData | null => {\n    let plaitString = html?.match(/<plait[^>]*>(.*)<\\/plait>/)?.[1];\n    if (plaitString) {\n        plaitString = reverseReplaceAngleBrackets(plaitString);\n        try {\n            const plaitJson = JSON.parse(plaitString);\n            if (plaitJson) {\n                if (plaitJson.type === WritableClipboardType.elements) {\n                    return {\n                        elements: plaitJson.data\n                    };\n                } else if (plaitJson.type === WritableClipboardType.medias) {\n                    return {\n                        medias: plaitJson.data\n                    };\n                }\n            }\n        } catch (error) {\n            console.error(error);\n            return null;\n        }\n    }\n    return null;\n};\n\nexport const stripHtml = (html: string) => {\n    // See <https://github.com/developit/preact-markup/blob/4788b8d61b4e24f83688710746ee36e7464f7bbc/src/parse-markup.js#L60-L69>\n    const doc = document.implementation.createHTMLDocument('');\n    doc.documentElement.innerHTML = html.trim();\n    return doc.body.textContent || doc.body.innerText || '';\n};\n\nexport const getProbablySupportsClipboardWrite = () => {\n    return 'clipboard' in navigator && 'write' in navigator.clipboard;\n};\n\nexport const getProbablySupportsClipboardWriteText = () => {\n    return 'clipboard' in navigator && 'writeText' in navigator.clipboard;\n};\n\nexport const getProbablySupportsClipboardRead = () => {\n    return 'clipboard' in navigator && 'read' in navigator.clipboard;\n};\n\nexport const createClipboardContext = (\n    type: WritableClipboardType,\n    elements: WritableClipboardData,\n    text: string\n): WritableClipboardContext => {\n    return {\n        type,\n        elements,\n        text\n    };\n};\n\nexport const addClipboardContext = (\n    clipboardContext: WritableClipboardContext,\n    addition: WritableClipboardContext\n): WritableClipboardContext => {\n    const { type, elements, text } = clipboardContext;\n    if (type === addition.type) {\n        return {\n            type,\n            elements: elements.concat(addition.elements),\n            text: text + ' ' + addition.text\n        };\n    }\n    return clipboardContext;\n};\n\nexport const addOrCreateClipboardContext = (clipboardContext: WritableClipboardContext | null, addition: WritableClipboardContext) => {\n    if (!clipboardContext) {\n        return addition;\n    } else {\n        return addClipboardContext(clipboardContext, addition);\n    }\n};\n\nexport const replaceAngleBrackets = (str: string) => {\n    return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');\n};\n\nexport const reverseReplaceAngleBrackets = (str: string) => {\n    return str.replace(/&lt;/g, '<').replace(/&gt;/g, '>');\n};\n", "import { buildPlaitHtml, getClipboardFromHtml } from './common';\nimport { ClipboardData, WritableClipboardData, WritableClipboardType } from './types';\n\nexport const setDataTransferClipboard = (dataTransfer: DataTransfer | null, type: WritableClipboardType, data: WritableClipboardData) => {\n    dataTransfer?.setData(`text/html`, buildPlaitHtml(type, data));\n};\n\nexport const setDataTransferClipboardText = (data: DataTransfer | null, text: string) => {\n    data?.setData(`text/plain`, text);\n};\n\nexport const getDataTransferClipboard = (data: DataTransfer | null): ClipboardData => {\n    const html = data?.getData(`text/html`);\n    if (html) {\n        const htmlClipboardData = getClipboardFromHtml(html);\n        if (htmlClipboardData) {\n            return htmlClipboardData;\n        }\n    }\n\n    return {};\n};\n\nexport const getDataTransferClipboardText = (data: DataTransfer | null) => {\n    if (!data) {\n        return {};\n    }\n    const text = data?.getData(`text/plain`);\n    if (text) {\n        const htmlClipboardData = getClipboardFromHtml(text);\n        if (htmlClipboardData) {\n            return htmlClipboardData;\n        }\n    }\n    return {\n        text\n    };\n};\n", "import {\n    buildPlaitHtml,\n    getClipboardFromHtml,\n    getProbablySupportsClipboardRead,\n    getProbablySupportsClipboardWrite,\n    stripHtml\n} from './common';\nimport { ClipboardData, WritableClipboardData, WritableClipboardType } from './types';\n\nexport const setNavigatorClipboard = async (type: WritableClipboardType, data: WritableClipboardData, text: string = '') => {\n    let textClipboard = text;\n    if (getProbablySupportsClipboardWrite()) {\n        await navigator.clipboard.write([\n            new ClipboardItem({\n                'text/html': new Blob([buildPlaitHtml(type, data)], {\n                    type: 'text/html'\n                }),\n                'text/plain': new Blob([textClipboard ?? JSON.stringify(data)], { type: 'text/plain' })\n            })\n        ]);\n    }\n};\n\nexport const getNavigatorClipboard = async (): Promise<ClipboardData> => {\n    if (!getProbablySupportsClipboardRead()) {\n        return {};\n    }\n    const clipboardItems = await navigator.clipboard.read();\n    let clipboardData: ClipboardData = {};\n\n    if (Array.isArray(clipboardItems) && clipboardItems[0] instanceof ClipboardItem) {\n        for (const item of clipboardItems) {\n            if (isFile(item)) {\n                const clipboardFiles = item.types.filter(type => type.match(/^image\\//));\n                const fileBlobs = await Promise.all(clipboardFiles.map(type => item.getType(type)!));\n                const urls = (fileBlobs.filter(Boolean) as (File | Blob)[]).map(blob => URL.createObjectURL(blob));\n                const files = await Promise.all(\n                    urls.map(async url => {\n                        const blob = await (await fetch(url)).blob();\n                        return new File([blob], 'plait-file', { type: blob.type });\n                    })\n                );\n                return {\n                    files\n                };\n            }\n            if (item.types.includes('text/html')) {\n                const htmlContent = await blobAsString(await item.getType('text/html'));\n                const htmlClipboardData = getClipboardFromHtml(htmlContent);\n                if (htmlClipboardData) {\n                    return htmlClipboardData;\n                }\n                if (htmlContent && htmlContent.trim()) {\n                    clipboardData = { text: stripHtml(htmlContent) };\n                }\n            }\n            if (item.types.includes('text/plain')) {\n                const textContent = await blobAsString(await item.getType('text/plain'));\n                clipboardData = {\n                    text: stripHtml(textContent)\n                };\n            }\n        }\n    }\n    return clipboardData;\n};\n\nconst isFile = (item: ClipboardItem) => {\n    return item.types.find(i => i.match(/^image\\//));\n};\n\nconst blobAsString = (blob: Blob) => {\n    return new Promise<string>((resolve, reject) => {\n        const reader = new FileReader();\n        reader.addEventListener('loadend', () => {\n            const text = reader.result;\n            resolve(text as string);\n        });\n        reader.addEventListener('error', () => {\n            reject(reader.error);\n        });\n        reader.readAsText(blob);\n    });\n};\n", "import {\n    buildPlaitHtml,\n    getProbablySupportsClipboardRead,\n    getProbablySupportsClipboardWrite,\n    getProbablySupportsClipboardWriteText\n} from './common';\nimport {\n    getDataTransferClipboard,\n    getDataTransferClipboardText,\n    setDataTransferClipboard,\n    setDataTransferClipboardText\n} from './data-transfer';\nimport { getNavigatorClipboard, setNavigatorClipboard } from './navigator-clipboard';\nimport { ClipboardData, WritableClipboardContext } from './types';\n\nexport const getClipboardData = async (dataTransfer: DataTransfer | null): Promise<ClipboardData> => {\n    let clipboardData = {};\n    if (dataTransfer) {\n        if (dataTransfer.files.length) {\n            return { files: Array.from(dataTransfer.files) };\n        }\n        clipboardData = getDataTransferClipboard(dataTransfer);\n        if (Object.keys(clipboardData).length === 0) {\n            clipboardData = getDataTransferClipboardText(dataTransfer);\n        }\n        return clipboardData;\n    }\n    if (getProbablySupportsClipboardRead()) {\n        return await getNavigatorClipboard();\n    }\n    return clipboardData;\n};\n\nexport const setClipboardData = async (dataTransfer: DataTransfer | null, clipboardContext: WritableClipboardContext | null) => {\n    if (!clipboardContext) {\n        return;\n    }\n    const { type, elements, text } = clipboardContext;\n\n    if (getProbablySupportsClipboardWrite()) {\n        return await setNavigatorClipboard(type, elements, text);\n    }\n\n    if (dataTransfer) {\n        setDataTransferClipboard(dataTransfer, type, elements);\n        setDataTransferClipboardText(dataTransfer, text);\n        return;\n    }\n\n    // Compatible with situations where navigator.clipboard.write is not supported and dataTransfer is empty\n    // Such as contextmenu copy in Firefox.\n    if (getProbablySupportsClipboardWriteText()) {\n        return await navigator.clipboard.writeText(buildPlaitHtml(type, elements));\n    }\n};\n", "import { ACTIVE_STROKE_WIDTH, SELECTION_RECTANGLE_BOUNDING_CLASS_NAME, SELECTION_RECTANGLE_CLASS_NAME } from '../constants';\nimport {\n    PlaitBoard,\n    PlaitElement,\n    PlaitGroup,\n    PlaitOperation,\n    PlaitPluginKey,\n    PlaitPointerType,\n    RectangleClient,\n    SELECTION_BORDER_COLOR,\n    WithSelectionPluginOptions\n} from '../interfaces';\nimport { setDragging } from './dnd';\nimport { getRectangleByElements } from './element';\nimport { BOARD_TO_IS_SELECTION_MOVING, BOARD_TO_TEMPORARY_ELEMENTS } from './weak-maps';\nimport { drawRectangle } from './drawing/rectangle';\nimport { cacheSelectedElements, getSelectedElements } from './selected-element';\nimport { getSelectionAngle, setAngleForG } from './angle';\nimport { filterSelectedGroups, getAllElementsInGroup, getElementsInGroup, getElementsInGroupByElement, getGroupByElement } from './group';\nimport { uniqueById } from './helper';\nimport { Selection } from '../interfaces/selection';\nimport { PlaitOptionsBoard } from '../plugins/with-options';\nimport { toActiveRectangleFromViewBoxRectangle } from './to-point';\n\nexport function isSelectionMoving(board: PlaitBoard) {\n    return !!BOARD_TO_IS_SELECTION_MOVING.get(board);\n}\n\nexport function setSelectionMoving(board: PlaitBoard) {\n    PlaitBoard.getBoardContainer(board).classList.add('selection-moving');\n    BOARD_TO_IS_SELECTION_MOVING.set(board, true);\n    setDragging(board, true);\n}\n\nexport function clearSelectionMoving(board: PlaitBoard) {\n    PlaitBoard.getBoardContainer(board).classList.remove('selection-moving');\n    BOARD_TO_IS_SELECTION_MOVING.delete(board);\n    setDragging(board, false);\n}\n\nexport function isHandleSelection(board: PlaitBoard) {\n    const options = getSelectionOptions(board);\n    return board.pointer !== PlaitPointerType.hand && !options.isDisabledSelection && !PlaitBoard.isReadonly(board);\n}\n\nexport function hasSetSelectionOperation(board: PlaitBoard) {\n    return !!board.operations.find((op) => PlaitOperation.isSetSelectionOperation(op));\n}\n\nexport function getTemporaryElements(board: PlaitBoard) {\n    const ref = BOARD_TO_TEMPORARY_ELEMENTS.get(board);\n    if (ref) {\n        return ref.elements;\n    } else {\n        return undefined;\n    }\n}\n\nexport function getTemporaryRef(board: PlaitBoard) {\n    return BOARD_TO_TEMPORARY_ELEMENTS.get(board);\n}\n\nexport function deleteTemporaryElements(board: PlaitBoard) {\n    BOARD_TO_TEMPORARY_ELEMENTS.delete(board);\n}\n\nexport function drawSelectionRectangleG(board: PlaitBoard) {\n    const elements = getSelectedElements(board);\n    const rectangle = getRectangleByElements(board, elements, false);\n    const activeRectangle = toActiveRectangleFromViewBoxRectangle(board, rectangle);\n    if (activeRectangle.width > 0 && activeRectangle.height > 0 && elements.length > 1) {\n        const selectionRectangleG = drawRectangle(board, RectangleClient.inflate(activeRectangle, ACTIVE_STROKE_WIDTH), {\n            stroke: SELECTION_BORDER_COLOR,\n            strokeWidth: ACTIVE_STROKE_WIDTH,\n            fillStyle: 'solid'\n        });\n        selectionRectangleG.classList.add(SELECTION_RECTANGLE_CLASS_NAME, SELECTION_RECTANGLE_BOUNDING_CLASS_NAME);\n        const angle = getSelectionAngle(elements);\n        if (angle) {\n            setAngleForG(selectionRectangleG, RectangleClient.getCenterPoint(activeRectangle), angle);\n        }\n        return selectionRectangleG;\n    }\n    return null;\n}\n\nexport function setSelectedElementsWithGroup(board: PlaitBoard, elements: PlaitElement[], isShift: boolean) {\n    if (!board.selection) {\n        return;\n    }\n    const selectedElements = getSelectedElements(board);\n    if (!Selection.isCollapsed(board.selection)) {\n        let newElements = [...selectedElements];\n        elements.forEach((item) => {\n            if (!item.groupId) {\n                newElements.push(item);\n            } else {\n                newElements.push(...getElementsInGroupByElement(board, item));\n            }\n        });\n        cacheSelectedElements(board, uniqueById(newElements));\n        return;\n    }\n    if (Selection.isCollapsed(board.selection)) {\n        const hitElement = elements[0];\n        const hitElementGroups = getGroupByElement(board, hitElement, true) as PlaitGroup[];\n        if (hitElementGroups.length > 0) {\n            const elementsInHighestGroup = getElementsInGroup(board, hitElementGroups[hitElementGroups.length - 1], true) || [];\n            const isSelectGroupElement = selectedElements.some((element) =>\n                elementsInHighestGroup.map((item) => item.id).includes(element.id)\n            );\n            if (isShift) {\n                cacheSelectedElementsWithGroupOnShift(board, elements, isSelectGroupElement, elementsInHighestGroup);\n            } else {\n                cacheSelectedElementsWithGroup(board, elements, isSelectGroupElement, hitElementGroups);\n            }\n        }\n    }\n}\n\nexport function cacheSelectedElementsWithGroupOnShift(\n    board: PlaitBoard,\n    elements: PlaitElement[],\n    isSelectGroupElement: boolean,\n    elementsInHighestGroup: PlaitElement[]\n) {\n    const selectedElements = getSelectedElements(board);\n    let newElements = [...selectedElements];\n    const hitElement = elements[0];\n    let pendingElements: PlaitElement[] = [];\n    if (!isSelectGroupElement) {\n        pendingElements = elementsInHighestGroup;\n    } else {\n        const isHitSelectedElement = selectedElements.some((item) => item.id === hitElement.id);\n        const selectedElementsInGroup = elementsInHighestGroup.filter((item) => selectedElements.includes(item));\n        if (isHitSelectedElement) {\n            pendingElements = selectedElementsInGroup.filter((item) => item.id !== hitElement.id);\n        } else {\n            pendingElements.push(...selectedElementsInGroup, ...elements);\n        }\n    }\n    elementsInHighestGroup.forEach((element) => {\n        if (newElements.includes(element)) {\n            newElements.splice(newElements.indexOf(element), 1);\n        }\n    });\n    if (pendingElements.length) {\n        newElements.push(...pendingElements);\n    }\n    cacheSelectedElements(board, uniqueById(newElements));\n}\n\nexport function cacheSelectedElementsWithGroup(\n    board: PlaitBoard,\n    elements: PlaitElement[],\n    isSelectGroupElement: boolean,\n    hitElementGroups: PlaitGroup[]\n) {\n    let newElements = [...elements];\n    const selectedGroups = filterSelectedGroups(board, hitElementGroups);\n    if (selectedGroups.length > 0) {\n        if (selectedGroups.length > 1) {\n            newElements = getAllElementsInGroup(board, selectedGroups[selectedGroups.length - 2], true);\n        } else {\n            const element = board.getOneHitElement(elements);\n            if (element) {\n                newElements = [element];\n            }\n        }\n    } else {\n        const elementsInGroup = getAllElementsInGroup(board, hitElementGroups[hitElementGroups.length - 1], true);\n        if (!isSelectGroupElement) {\n            newElements = elementsInGroup;\n        } else {\n            const element = board.getOneHitElement(elements);\n            if (element) {\n                newElements = [element];\n            }\n        }\n    }\n    cacheSelectedElements(board, uniqueById(newElements));\n}\n\nexport const getSelectionOptions = (board: PlaitBoard) => {\n    const options = (board as PlaitOptionsBoard).getPluginOptions<WithSelectionPluginOptions>(PlaitPluginKey.withSelection);\n    return options;\n};\n\nexport const setSelectionOptions = (board: PlaitBoard, options: Partial<WithSelectionPluginOptions>) => {\n    (board as PlaitOptionsBoard).setPluginOptions<WithSelectionPluginOptions>(PlaitPluginKey.withSelection, options);\n};\n", "import { ACTIVE_STROKE_WIDTH } from '../constants';\nimport { Path, PlaitBoard, PlaitElement, PlaitGroup, PlaitGroupElement, RectangleClient, SELECTION_BORDER_COLOR } from '../interfaces';\nimport { getSelectionAngle, setAngleForG } from './angle';\nimport { createG } from './dom';\nimport { drawRectangle } from './drawing/rectangle';\nimport { getRectangleByElements } from './element';\nimport { idCreator } from './id-creator';\nimport { getSelectedElements } from './selected-element';\nimport { isSelectionMoving } from './selection';\nimport { depthFirstRecursion } from './tree';\nimport { moveElementsToNewPath } from './common';\nimport { sortElements } from './position';\n\nexport const getElementsInGroup = (board: PlaitBoard, group: PlaitGroup, recursion?: boolean, includeGroup?: boolean) => {\n    let result: PlaitElement[] = [];\n    const elements = board.children.filter(value => (value as PlaitElement).groupId === group.id) as PlaitElement[];\n    if (recursion) {\n        elements.forEach(item => {\n            if (PlaitGroupElement.isGroup(item)) {\n                if (includeGroup) {\n                    result.push(item);\n                }\n                result.push(...getElementsInGroup(board, item, recursion, includeGroup));\n            } else {\n                result.push(item);\n            }\n        });\n    } else {\n        result = includeGroup ? elements : (elements.filter(item => !PlaitGroupElement.isGroup(item)) as PlaitElement[]);\n    }\n    return result;\n};\n\nexport const getAllElementsInGroup = (board: PlaitBoard, group: PlaitGroup, recursion?: boolean, includeGroup?: boolean) => {\n    const elementsInGroup = getElementsInGroup(board, group, recursion, includeGroup);\n    const result: PlaitElement[] = [];\n    elementsInGroup.forEach(element => {\n        depthFirstRecursion(\n            element,\n            node => {\n                result.push(node);\n            },\n            () => true\n        );\n    });\n    return result;\n};\n\nexport const getRectangleByGroup = (board: PlaitBoard, group: PlaitGroup, recursion?: boolean) => {\n    const elementsInGroup = getAllElementsInGroup(board, group, recursion) as PlaitElement[];\n    return getRectangleByElements(board, elementsInGroup, false);\n};\n\nexport const getGroupByElement = (\n    board: PlaitBoard,\n    element: PlaitElement,\n    recursion?: boolean,\n    originElements?: PlaitElement[]\n): PlaitGroup | PlaitGroup[] | null => {\n    const group = (originElements || board.children).find(item => item.id === element?.groupId);\n    if (!group) {\n        return recursion ? [] : null;\n    }\n    if (recursion) {\n        const groups = [group];\n        const grandGroups = getGroupByElement(board, group, recursion, originElements) as PlaitGroup[];\n        if (grandGroups.length) {\n            groups.push(...grandGroups);\n        }\n        return groups as PlaitGroup[];\n    } else {\n        return group as PlaitGroup;\n    }\n};\n\nexport const getHighestGroup = (board: PlaitBoard, element: PlaitElement) => {\n    const hitElementGroups = getGroupByElement(board, element, true) as PlaitGroup[];\n    if (hitElementGroups.length) {\n        return hitElementGroups[hitElementGroups.length - 1];\n    }\n    return null;\n};\n\nexport const getElementsInGroupByElement = (board: PlaitBoard, element: PlaitElement) => {\n    const highestGroup = getHighestGroup(board, element);\n    if (highestGroup) {\n        return getAllElementsInGroup(board, highestGroup, true) as PlaitGroup[];\n    } else {\n        return [element];\n    }\n};\n\nexport const isSelectedElementOrGroup = (board: PlaitBoard, element: PlaitElement, elements?: PlaitElement[]) => {\n    const selectedElements = elements?.length ? elements : getSelectedElements(board);\n    if (PlaitGroupElement.isGroup(element)) {\n        return isSelectedAllElementsInGroup(board, element, elements);\n    }\n    return selectedElements.map(item => item.id).includes(element.id);\n};\n\nexport const isSelectedAllElementsInGroup = (board: PlaitBoard, group: PlaitGroup, elements?: PlaitElement[]) => {\n    const selectedElements = elements?.length ? elements : getSelectedElements(board);\n    const elementsInGroup = getElementsInGroup(board, group, true);\n    return elementsInGroup.every(item => selectedElements.map(element => element.id).includes(item.id));\n};\n\nexport const filterSelectedGroups = (board: PlaitBoard, groups: PlaitGroup[], elements?: PlaitElement[]): PlaitGroup[] => {\n    const selectedGroups: PlaitGroup[] = [];\n    groups.forEach(item => {\n        if (isSelectedElementOrGroup(board, item, elements)) {\n            selectedGroups.push(item);\n        }\n    });\n    return selectedGroups;\n};\n\nexport const getSelectedGroups = (board: PlaitBoard, elements?: PlaitElement[], originElements?: PlaitElement[]): PlaitGroup[] => {\n    const highestSelectedGroups = getHighestSelectedGroups(board, elements, originElements);\n    const groups: PlaitGroup[] = [];\n    highestSelectedGroups.forEach(item => {\n        groups.push(item);\n        const elementsInGroup = getElementsInGroup(board, item, true, true);\n        groups.push(...(elementsInGroup.filter(item => PlaitGroupElement.isGroup(item)) as PlaitGroup[]));\n    });\n    return groups;\n};\n\nexport const getHighestSelectedGroup = (\n    board: PlaitBoard,\n    element: PlaitElement,\n    elements?: PlaitElement[],\n    originElements?: PlaitElement[]\n): PlaitGroup | null => {\n    const hitElementGroups = getGroupByElement(board, element, true, originElements) as PlaitGroup[];\n    const selectedGroups = filterSelectedGroups(board, hitElementGroups, elements);\n    if (selectedGroups.length) {\n        return selectedGroups[selectedGroups.length - 1];\n    }\n    return null;\n};\n\nexport const getHighestSelectedGroups = (board: PlaitBoard, elements?: PlaitElement[], originElements?: PlaitElement[]): PlaitGroup[] => {\n    let result: PlaitGroup[] = [];\n    const selectedElements = elements?.length ? elements : getSelectedElements(board);\n    selectedElements.forEach(item => {\n        if (item.groupId) {\n            const group = getHighestSelectedGroup(board, item, elements, originElements);\n            if (group && !result.includes(group)) {\n                result.push(group);\n            }\n        }\n    });\n    return result;\n};\n\nexport const getSelectedIsolatedElements = (board: PlaitBoard, elements?: PlaitElement[]) => {\n    let result: PlaitElement[] = [];\n    const selectedElements = elements?.length ? elements : getSelectedElements(board);\n    selectedElements\n        .filter(item => !PlaitGroupElement.isGroup(item))\n        .forEach(item => {\n            if (!item.groupId) {\n                result.push(item);\n            } else {\n                const group = getHighestSelectedGroup(board, item, elements);\n                if (!group) {\n                    result.push(item);\n                }\n            }\n        });\n    return result;\n};\n\nexport const getSelectedIsolatedElementsCanAddToGroup = (board: PlaitBoard, elements?: PlaitElement[]) => {\n    const selectedIsolatedElements = getSelectedIsolatedElements(board, elements);\n    return selectedIsolatedElements.filter(item => board.canAddToGroup(item));\n};\n\nexport const getHighestSelectedElements = (board: PlaitBoard, elements?: PlaitElement[]) => {\n    return [...getHighestSelectedGroups(board, elements), ...getSelectedIsolatedElements(board, elements)];\n};\n\nexport const createGroupRectangleG = (board: PlaitBoard, elements: PlaitElement[]): SVGGElement | null => {\n    const selectedElementIds = getSelectedElements(board).map(item => item.id);\n    let groupRectangleG: SVGGElement | null = null;\n    const isMoving = isSelectionMoving(board);\n\n    elements.forEach(item => {\n        const isRender = (!selectedElementIds.includes(item.id) && !isMoving) || isMoving;\n        if (item.groupId && isRender) {\n            if (!groupRectangleG) {\n                groupRectangleG = createG();\n            }\n            const elements = getElementsInGroupByElement(board, item);\n            const rectangle = getRectangleByElements(board, elements, false);\n            const rectangleG = drawRectangle(board, rectangle, {\n                stroke: SELECTION_BORDER_COLOR,\n                strokeWidth: ACTIVE_STROKE_WIDTH,\n                strokeLineDash: [5]\n            });\n            const angle = getSelectionAngle(elements);\n            if (angle) {\n                setAngleForG(rectangleG, RectangleClient.getCenterPoint(rectangle), angle);\n            }\n            groupRectangleG.append(rectangleG);\n        }\n    });\n    return groupRectangleG;\n};\n\nexport const createGroup = (groupId?: string): PlaitGroup => {\n    return groupId\n        ? {\n              id: idCreator(),\n              type: 'group',\n              groupId\n          }\n        : {\n              id: idCreator(),\n              type: 'group'\n          };\n};\n\nexport const nonGroupInHighestSelectedElements = (elements: PlaitElement[]) => {\n    return elements.every(item => !item.groupId);\n};\n\nexport const hasSelectedElementsInSameGroup = (elements: PlaitElement[]) => {\n    return elements.every(item => item.groupId && item.groupId === elements[0].groupId);\n};\n\nexport const canAddGroup = (board: PlaitBoard, elements?: PlaitElement[]) => {\n    const highestSelectedElements = getHighestSelectedElements(board, elements);\n    const rootElements = highestSelectedElements.filter(item => board.canAddToGroup(item));\n    if (rootElements.length > 1) {\n        return nonGroupInHighestSelectedElements(rootElements) || hasSelectedElementsInSameGroup(rootElements);\n    }\n    return false;\n};\n\nexport const canRemoveGroup = (board: PlaitBoard, elements?: PlaitElement[], originElements?: PlaitElement[]) => {\n    const selectedGroups = getHighestSelectedGroups(board, elements, originElements);\n    const selectedElements = elements?.length ? elements : getSelectedElements(board);\n    return selectedElements.length > 0 && selectedGroups.length > 0;\n};\n\nexport const getEditingGroup = (board: PlaitBoard, element: PlaitElement) => {\n    const groups = getGroupByElement(board, element, true) as PlaitGroup[];\n    let editingGroup = null;\n    if (groups?.length) {\n        for (let i = 0; i < groups?.length; i++) {\n            if (!isSelectedAllElementsInGroup(board, groups[i])) {\n                editingGroup = groups[i];\n                break;\n            }\n        }\n    }\n    return editingGroup;\n};\n\nexport const moveElementsToNewPathAfterAddGroup = (board: PlaitBoard, selectedElements: PlaitElement[], newPath: Path) => {\n    const moveElements = [...selectedElements];\n    sortElements(board, moveElements);\n    moveElements.pop();\n    moveElementsToNewPath(\n        board,\n        moveElements.map(element => {\n            return {\n                element,\n                newPath\n            };\n        })\n    );\n};\n", "import { PlaitBoard, PlaitElement, Point } from '../interfaces';\nimport { WritableClipboardOperationType } from './clipboard';\nimport { setClipboardData } from './clipboard/clipboard';\nimport { getRectangleByElements } from './element';\nimport { getSelectedElements } from './selected-element';\n\nexport const deleteFragment = (board: PlaitBoard) => {\n    const elements = board.getDeletedFragment([]);\n    board.deleteFragment(elements);\n};\n\nexport const setFragment = (board: PlaitBoard, operationType: WritableClipboardOperationType, clipboardData: DataTransfer | null) => {\n    const selectedElements = getSelectedElements(board);\n    const rectangle = getRectangleByElements(board, selectedElements, false);\n    const clipboardContext = board.buildFragment(null, rectangle, operationType);\n    clipboardContext && setClipboardData(clipboardData, clipboardContext);\n};\n\nexport const duplicateElements = (board: PlaitBoard, elements?: PlaitElement[], point?: Point) => {\n    const targetElements = elements?.length ? elements : getSelectedElements(board);\n    const targetRectangle = getRectangleByElements(board, targetElements, false);\n    const clipboardContext = board.buildFragment(null, targetRectangle, WritableClipboardOperationType.duplicate, targetElements);\n    const stringifiedContext = clipboardContext && JSON.stringify(clipboardContext);\n    const clonedContext = stringifiedContext && JSON.parse(stringifiedContext);\n    clonedContext &&\n        board.insertFragment(\n            {\n                ...clonedContext,\n                text: undefined\n            },\n            point || [targetRectangle.x + targetRectangle.width / 2, targetRectangle.y + targetRectangle.height / 2],\n            WritableClipboardOperationType.duplicate\n        );\n};\n", "import { PlaitBoard, PlaitElement, Point, RectangleClient, SELECTION_BORDER_COLOR } from '../../interfaces';\nimport { getRectangleByAngle } from '../angle';\nimport { createG } from '../dom';\nimport { findElements } from '../element';\n\nexport interface SnapDelta {\n    deltaX: number;\n    deltaY: number;\n}\n\nexport interface SnapRef extends SnapDelta {\n    snapG: SVGGElement;\n}\n\nexport interface GapSnapRef {\n    before: { distance: number; index: number }[];\n    after: { distance: number; index: number }[];\n}\n\ntype PointSnapLineRef = {\n    axis: number;\n    isHorizontal: boolean;\n    pointRectangles: RectangleClient[];\n};\n\ntype TripleSnapAxis = [number, number, number];\n\nexport const SNAP_TOLERANCE = 2;\n\nconst SNAP_SPACING = 24;\n\nexport function getSnapRectangles(board: PlaitBoard, activeElements: PlaitElement[]) {\n    const elements = findElements(board, {\n        match: element => board.isAlign(element) && !activeElements.some(item => item.id === element.id),\n        recursion: () => true,\n        isReverse: false\n    });\n    return elements.map(item => {\n        const rectangle = board.getRectangle(item)!;\n        return getRectangleByAngle(rectangle, item.angle || 0);\n    });\n}\n\nexport function getBarPoint(point: Point, isHorizontal: boolean) {\n    return isHorizontal\n        ? [\n              [point[0], point[1] - 4],\n              [point[0], point[1] + 4]\n          ]\n        : [\n              [point[0] - 4, point[1]],\n              [point[0] + 4, point[1]]\n          ];\n}\n\nexport function getMinPointDelta(pointRectangles: RectangleClient[], axis: number, isHorizontal: boolean) {\n    let delta = SNAP_TOLERANCE;\n    pointRectangles.forEach(item => {\n        const distance = getNearestDelta(axis, item, isHorizontal);\n        if (Math.abs(distance) < Math.abs(delta)) {\n            delta = distance;\n        }\n    });\n    return delta;\n}\n\nexport const getNearestDelta = (axis: number, rectangle: RectangleClient, isHorizontal: boolean) => {\n    const pointAxis = getTripleAxis(rectangle, isHorizontal);\n    const deltas = pointAxis.map(item => item - axis);\n    const absDeltas = deltas.map(item => Math.abs(item));\n    const index = absDeltas.indexOf(Math.min(...absDeltas));\n    return deltas[index];\n};\n\nexport const getTripleAxis = (rectangle: RectangleClient, isHorizontal: boolean): TripleSnapAxis => {\n    const axis = isHorizontal ? 'x' : 'y';\n    const side = isHorizontal ? 'width' : 'height';\n    return [rectangle[axis], rectangle[axis] + rectangle[side] / 2, rectangle[axis] + rectangle[side]];\n};\n\nexport function getNearestPointRectangle(snapRectangles: RectangleClient[], activeRectangle: RectangleClient) {\n    let minDistance = Infinity;\n    let nearestRectangle = snapRectangles[0];\n\n    snapRectangles.forEach(item => {\n        const distance = Math.sqrt(Math.pow(activeRectangle.x - item.x, 2) + Math.pow(activeRectangle.y - item.y, 2));\n        if (distance < minDistance) {\n            minDistance = distance;\n            nearestRectangle = item;\n        }\n    });\n    return nearestRectangle;\n}\n\nexport const isSnapPoint = (axis: number, rectangle: RectangleClient, isHorizontal: boolean) => {\n    const pointAxis = getTripleAxis(rectangle, isHorizontal);\n    return pointAxis.includes(axis);\n};\n\nexport function drawPointSnapLines(\n    board: PlaitBoard,\n    activeRectangle: RectangleClient,\n    snapRectangles: RectangleClient[],\n    drawHorizontal = true,\n    drawVertical = true,\n    snapMiddle = false\n) {\n    let pointLinePoints: [Point, Point][] = [];\n    const pointAxisX = getTripleAxis(activeRectangle, true);\n    const pointAxisY = getTripleAxis(activeRectangle, false);\n    const pointLineRefs: PointSnapLineRef[] = [\n        {\n            axis: pointAxisX[0],\n            isHorizontal: true,\n            pointRectangles: []\n        },\n        {\n            axis: pointAxisX[1],\n            isHorizontal: true,\n            pointRectangles: []\n        },\n        {\n            axis: pointAxisX[2],\n            isHorizontal: true,\n            pointRectangles: []\n        },\n        {\n            axis: pointAxisY[0],\n            isHorizontal: false,\n            pointRectangles: []\n        },\n        {\n            axis: pointAxisY[1],\n            isHorizontal: false,\n            pointRectangles: []\n        },\n        {\n            axis: pointAxisY[2],\n            isHorizontal: false,\n            pointRectangles: []\n        }\n    ];\n    for (let index = 0; index < snapRectangles.length; index++) {\n        const element = snapRectangles[index];\n        if (isSnapPoint(pointLineRefs[0].axis, element, pointLineRefs[0].isHorizontal)) {\n            pointLineRefs[0].pointRectangles.push(element);\n        }\n        if (isSnapPoint(pointLineRefs[1].axis, element, pointLineRefs[1].isHorizontal)) {\n            pointLineRefs[1].pointRectangles.push(element);\n        }\n        if (isSnapPoint(pointLineRefs[2].axis, element, pointLineRefs[2].isHorizontal)) {\n            pointLineRefs[2].pointRectangles.push(element);\n        }\n        if (isSnapPoint(pointLineRefs[3].axis, element, pointLineRefs[3].isHorizontal)) {\n            pointLineRefs[3].pointRectangles.push(element);\n        }\n        if (isSnapPoint(pointLineRefs[4].axis, element, pointLineRefs[4].isHorizontal)) {\n            pointLineRefs[4].pointRectangles.push(element);\n        }\n        if (isSnapPoint(pointLineRefs[5].axis, element, pointLineRefs[5].isHorizontal)) {\n            pointLineRefs[5].pointRectangles.push(element);\n        }\n    }\n\n    const setResizePointSnapLine = (axis: number, pointRectangle: RectangleClient, isHorizontal: boolean) => {\n        const boundingRectangle = RectangleClient.inflate(\n            RectangleClient.getBoundingRectangle([activeRectangle, pointRectangle]),\n            SNAP_SPACING\n        );\n        if (isHorizontal) {\n            const pointStart = [axis, boundingRectangle.y] as Point;\n            const pointEnd = [axis, boundingRectangle.y + boundingRectangle.height] as Point;\n            pointLinePoints.push([pointStart, pointEnd]);\n        } else {\n            const pointStart = [boundingRectangle.x, axis] as Point;\n            const pointEnd = [boundingRectangle.x + boundingRectangle.width, axis] as Point;\n            pointLinePoints.push([pointStart, pointEnd]);\n        }\n    };\n    if (drawHorizontal && pointLineRefs[0].pointRectangles.length) {\n        const leftRectangle =\n            pointLineRefs[0].pointRectangles.length === 1\n                ? pointLineRefs[0].pointRectangles[0]\n                : getNearestPointRectangle(pointLineRefs[0].pointRectangles, activeRectangle);\n        setResizePointSnapLine(pointLineRefs[0].axis, leftRectangle, pointLineRefs[0].isHorizontal);\n    }\n    if (drawHorizontal && snapMiddle && pointLineRefs[1].pointRectangles.length) {\n        const middleRectangle =\n            pointLineRefs[1].pointRectangles.length === 1\n                ? pointLineRefs[1].pointRectangles[0]\n                : getNearestPointRectangle(pointLineRefs[1].pointRectangles, activeRectangle);\n        setResizePointSnapLine(pointLineRefs[1].axis, middleRectangle, pointLineRefs[1].isHorizontal);\n    }\n\n    if (drawHorizontal && pointLineRefs[2].pointRectangles.length) {\n        const rightRectangle =\n            pointLineRefs[2].pointRectangles.length === 1\n                ? pointLineRefs[2].pointRectangles[0]\n                : getNearestPointRectangle(pointLineRefs[2].pointRectangles, activeRectangle);\n        setResizePointSnapLine(pointLineRefs[2].axis, rightRectangle, pointLineRefs[2].isHorizontal);\n    }\n\n    if (drawVertical && pointLineRefs[3].pointRectangles.length) {\n        const topRectangle =\n            pointLineRefs[3].pointRectangles.length === 1\n                ? pointLineRefs[3].pointRectangles[0]\n                : getNearestPointRectangle(pointLineRefs[3].pointRectangles, activeRectangle);\n        setResizePointSnapLine(pointLineRefs[3].axis, topRectangle, pointLineRefs[3].isHorizontal);\n    }\n\n    if (drawVertical && snapMiddle && pointLineRefs[4].pointRectangles.length) {\n        const middleRectangle =\n            pointLineRefs[4].pointRectangles.length === 1\n                ? pointLineRefs[4].pointRectangles[0]\n                : getNearestPointRectangle(pointLineRefs[4].pointRectangles, activeRectangle);\n        setResizePointSnapLine(pointLineRefs[4].axis, middleRectangle, pointLineRefs[4].isHorizontal);\n    }\n\n    if (drawVertical && pointLineRefs[5].pointRectangles.length) {\n        const rightRectangle =\n            pointLineRefs[5].pointRectangles.length === 1\n                ? pointLineRefs[5].pointRectangles[0]\n                : getNearestPointRectangle(pointLineRefs[5].pointRectangles, activeRectangle);\n        setResizePointSnapLine(pointLineRefs[5].axis, rightRectangle, pointLineRefs[5].isHorizontal);\n    }\n\n    return drawDashedLines(board, pointLinePoints);\n}\n\nexport function drawDashedLines(board: PlaitBoard, lines: [Point, Point][]) {\n    const g = createG();\n    lines.forEach(points => {\n        if (!points.length) return;\n        const line = PlaitBoard.getRoughSVG(board).line(points[0][0], points[0][1], points[1][0], points[1][1], {\n            stroke: SELECTION_BORDER_COLOR,\n            strokeWidth: 1,\n            strokeLineDash: [4, 4]\n        });\n        g.appendChild(line);\n    });\n    return g;\n}\n\nexport function drawSolidLines(board: PlaitBoard, lines: Point[][]) {\n    const g = createG();\n    lines.forEach(points => {\n        if (!points.length) return;\n        let isHorizontal = points[0][1] === points[1][1];\n        const line = PlaitBoard.getRoughSVG(board).line(points[0][0], points[0][1], points[1][0], points[1][1], {\n            stroke: SELECTION_BORDER_COLOR,\n            strokeWidth: 1\n        });\n        g.appendChild(line);\n\n        points.forEach(point => {\n            const barPoint = getBarPoint(point, isHorizontal);\n            const bar = PlaitBoard.getRoughSVG(board).line(barPoint[0][0], barPoint[0][1], barPoint[1][0], barPoint[1][1], {\n                stroke: SELECTION_BORDER_COLOR,\n                strokeWidth: 1\n            });\n            g.appendChild(bar);\n        });\n    });\n    return g;\n}\n", "import { PlaitBoard, PlaitElement, PlaitGroupElement, PlaitGroup } from '../interfaces';\nimport { MoveNodeOption, getElementsIndices } from './common';\nimport { getEditingGroup, getElementsInGroup, getGroupByElement, getHighestGroup, isSelectedAllElementsInGroup } from './group';\nimport { findIndex, findLastIndex } from './helper';\nimport { sortElements } from './position';\nimport { getSelectedElements } from './selected-element';\n\nexport const getOneMoveOptions = (board: PlaitBoard, direction: 'down' | 'up'): MoveNodeOption[] => {\n    const indicesToMove = getElementsIndices(board, getSelectedElements(board));\n    let groupedIndices = toContiguousGroups(board, indicesToMove);\n    if (direction === 'up') {\n        groupedIndices = groupedIndices.reverse();\n    }\n    let moveContents: MoveNodeOption[] = [];\n    groupedIndices.forEach((indices, i) => {\n        const leadingIndex = indices[0];\n        const trailingIndex = indices[indices.length - 1];\n        const boundaryIndex = direction === 'down' ? leadingIndex : trailingIndex;\n        const targetIndex = getTargetIndex(board, boundaryIndex, direction);\n        if (targetIndex === -1 || boundaryIndex === targetIndex) {\n            return;\n        }\n        if (direction === 'down') {\n            indices = indices.reverse();\n        }\n        moveContents.push(\n            ...indices.map(path => {\n                return {\n                    element: board.children[path],\n                    newPath: [targetIndex]\n                };\n            })\n        );\n    });\n\n    return moveContents;\n};\n\nexport const getAllMoveOptions = (board: PlaitBoard, direction: 'down' | 'up'): MoveNodeOption[] => {\n    const indicesToMove = getElementsIndices(board, getSelectedElements(board));\n    let groupedIndices = toContiguousGroups(board, indicesToMove);\n    let moveContents: MoveNodeOption[] = [];\n    if (direction === 'down') {\n        groupedIndices = groupedIndices.reverse();\n    }\n    groupedIndices.forEach(indices => {\n        const leadingIndex = indices[0];\n        const trailingIndex = indices[indices.length - 1];\n        const boundaryIndex = direction === 'down' ? leadingIndex : trailingIndex;\n        const sourceElement = board.children[boundaryIndex];\n        const editingGroup = getEditingGroup(board, sourceElement);\n        let targetIndex = direction === 'down' ? 0 : board.children.length - 1;\n        if (editingGroup) {\n            const elementsInGroup = sortElements(board, getElementsInGroup(board, editingGroup, true, true));\n            targetIndex =\n                direction === 'down'\n                    ? board.children.indexOf(elementsInGroup[0])\n                    : board.children.indexOf(elementsInGroup[elementsInGroup.length - 1]);\n        }\n        if (direction === 'down') {\n            indices = indices.reverse();\n        }\n        moveContents.push(\n            ...indices.map(path => {\n                return {\n                    element: board.children[path],\n                    newPath: [targetIndex]\n                };\n            })\n        );\n    });\n\n    return moveContents;\n};\n\nexport const canSetZIndex = (board: PlaitBoard) => {\n    const selectedElements = getSelectedElements(board).filter(item => board.canSetZIndex(item));\n    return selectedElements.length > 0;\n};\n\nconst toContiguousGroups = (board: PlaitBoard, array: number[]) => {\n    let cursor = 0;\n    return array.reduce((acc, value, index) => {\n        if (index > 0) {\n            const currentElement = board.children[value];\n            const previousElement = board.children[array[index - 1]];\n            const isContiguous =\n                value - 1 === array[index - 1]\n                    ? true\n                    : board.children.every((item, childIndex) => {\n                          if (childIndex > array[index - 1] && childIndex <= value - 1) {\n                              return PlaitGroupElement.isGroup(item);\n                          }\n                          return true;\n                      });\n            let isPartialSelectGroupElement = false;\n            if (previousElement?.groupId || (currentElement?.groupId && previousElement?.groupId !== currentElement?.groupId)) {\n                let isPartialSelectPreviousGroup = false;\n                let isPartialSelectCurrentElement = false;\n                if (previousElement.groupId) {\n                    const highestGroup = getHighestGroup(board, previousElement);\n                    isPartialSelectPreviousGroup = !isSelectedAllElementsInGroup(board, highestGroup!);\n                }\n                if (currentElement.groupId) {\n                    const highestGroup = getHighestGroup(board, currentElement);\n                    isPartialSelectCurrentElement = !isSelectedAllElementsInGroup(board, highestGroup!);\n                }\n                isPartialSelectGroupElement = isPartialSelectPreviousGroup || isPartialSelectCurrentElement;\n            }\n            if (!isContiguous || isPartialSelectGroupElement) {\n                cursor = ++cursor;\n            }\n        }\n        (acc[cursor] || (acc[cursor] = [])).push(value);\n        return acc;\n    }, [] as number[][]);\n};\n\n/**\n * Returns next candidate index that's available to be moved to. Currently that\n *  is a non-deleted element, and not inside a group (unless we're editing it).\n */\nconst getTargetIndex = (board: PlaitBoard, boundaryIndex: number, direction: 'down' | 'up') => {\n    if ((boundaryIndex === 0 && direction === 'down') || (boundaryIndex === board.children.length - 1 && direction === 'up')) {\n        return -1;\n    }\n    const indexFilter = (element: PlaitElement) => {\n        if (element.isDeleted || PlaitGroupElement.isGroup(element)) {\n            return false;\n        }\n        return true;\n    };\n    const candidateIndex =\n        direction === 'down'\n            ? findLastIndex(board.children, el => indexFilter(el), Math.max(0, boundaryIndex - 1))\n            : findIndex(board.children, el => indexFilter(el), boundaryIndex + 1);\n\n    const nextElement = board.children[candidateIndex];\n    if (!nextElement) {\n        return -1;\n    }\n\n    const elements = [...board.children];\n    const sourceElement = elements[boundaryIndex];\n    const editingGroup = getEditingGroup(board, sourceElement);\n    const nextElementGroups = (getGroupByElement(board, nextElement, true) || []) as PlaitGroup[];\n    // candidate element is a sibling in current editing group  return\n    if (editingGroup && sourceElement?.groupId !== nextElement?.groupId) {\n        // candidate element is outside current editing group  prevent\n        if (!(nextElementGroups as PlaitGroup[]).find(item => item.id === editingGroup.id)) {\n            return -1;\n        }\n    }\n\n    if (!nextElement.groupId) {\n        return candidateIndex;\n    }\n\n    let siblingGroup: PlaitGroup;\n    if (editingGroup) {\n        siblingGroup = nextElementGroups[nextElementGroups.indexOf(editingGroup) - 1];\n    } else {\n        siblingGroup = nextElementGroups[nextElementGroups.length - 1];\n    }\n    if (siblingGroup) {\n        let elementsInSiblingGroup = getElementsInGroup(board, siblingGroup, true, false);\n        if (elementsInSiblingGroup.length) {\n            elementsInSiblingGroup.sort((a, b) => {\n                const indexA = board.children.findIndex(child => child.id === a.id);\n                const indexB = board.children.findIndex(child => child.id === b.id);\n                return indexA - indexB;\n            });\n            // assumes getElementsInGroup() returned elements are sorted\n            // by zIndex (ascending)\n            return direction === 'down'\n                ? elements.indexOf(elementsInSiblingGroup[0])\n                : elements.indexOf(elementsInSiblingGroup[elementsInSiblingGroup.length - 1]);\n        }\n    }\n\n    return candidateIndex;\n};\n", "export const isMobileDeviceEvent = (event: PointerEvent) => {\n    return isPencilEvent(event) || isTouchEvent(event);\n};\n\nexport const isPencilEvent = (event: PointerEvent) => {\n    return event.pointerType === 'pen';\n};\n\nexport const isTouchEvent = (event: PointerEvent) => {\n    return event.pointerType === 'touch';\n};\n\nexport const isMouseEvent = (event: PointerEvent) => {\n    return event.pointerType === 'mouse';\n};\n", "import { PlaitBoard, PlaitElement } from '../interfaces';\nimport {\n    getHighestSelectedGroups,\n    getSelectedIsolatedElementsCanAddToGroup,\n    createGroup,\n    canAddGroup,\n    hasSelectedElementsInSameGroup,\n    canRemoveGroup,\n    findElements,\n    getElementsIndices,\n    isIndicesContinuous,\n    getSelectedElements,\n    getHighestIndexOfElement,\n    moveElementsToNewPathAfterAddGroup\n} from '../utils';\nimport { NodeTransforms } from './node';\n\nexport const addGroup = (board: PlaitBoard, elements?: PlaitElement[]) => {\n    const selectedGroups = getHighestSelectedGroups(board, elements);\n    const selectedIsolatedElements = getSelectedIsolatedElementsCanAddToGroup(board);\n    const highestSelectedElements = [...selectedGroups, ...selectedIsolatedElements];\n    const group = createGroup();\n    if (canAddGroup(board)) {\n        highestSelectedElements.forEach(item => {\n            const path = PlaitBoard.findPath(board, item);\n            NodeTransforms.setNode(board, { groupId: group.id }, path);\n        });\n        const selectedElements = getSelectedElements(board);\n        const highestIndexOfSelectedElement = getHighestIndexOfElement(board, selectedElements);\n        const indices = getElementsIndices(board, highestSelectedElements);\n        const isContinuous = isIndicesContinuous(indices);\n        if (!isContinuous) {\n            moveElementsToNewPathAfterAddGroup(board, selectedElements, [highestIndexOfSelectedElement - 1]);\n        }\n        if (hasSelectedElementsInSameGroup(highestSelectedElements)) {\n            const newGroupId = selectedIsolatedElements[0].groupId;\n            NodeTransforms.insertNode(\n                board,\n                {\n                    ...group,\n                    groupId: newGroupId\n                },\n                [board.children.length]\n            );\n        } else {\n            NodeTransforms.insertNode(board, group, [board.children.length]);\n        }\n    }\n};\n\nexport const removeGroup = (board: PlaitBoard, elements?: PlaitElement[]) => {\n    const selectedGroups = getHighestSelectedGroups(board, elements);\n    if (canRemoveGroup(board)) {\n        selectedGroups.forEach(group => {\n            const elementsInGroup = findElements(board, {\n                match: item => item.groupId === group.id,\n                recursion: () => false\n            });\n            elementsInGroup.forEach(element => {\n                const path = PlaitBoard.findPath(board, element);\n                NodeTransforms.setNode(board, { groupId: group.groupId || undefined }, path);\n            });\n        });\n        selectedGroups\n            .map(group => {\n                const groupPath = PlaitBoard.findPath(board, group);\n                const groupRef = board.pathRef(groupPath);\n                return () => {\n                    groupRef.current && NodeTransforms.removeNode(board, groupRef.current);\n                    groupRef.unref();\n                };\n            })\n            .forEach(action => {\n                action();\n            });\n    }\n};\n\nexport interface GroupTransforms {\n    addGroup: (board: PlaitBoard, elements?: PlaitElement[]) => void;\n    removeGroup: (board: PlaitBoard, elements?: PlaitElement[]) => void;\n}\n\nexport const GroupTransforms = {\n    addGroup,\n    removeGroup\n};\n", "import { SetSelectionOperation } from '../interfaces/operation';\nimport { PlaitBoard } from '../interfaces/board';\nimport { Selection } from '../interfaces/selection';\nimport { BOARD_TO_TEMPORARY_ELEMENTS } from '../utils/weak-maps';\nimport { PlaitElement } from '../interfaces/element';\nimport { getTemporaryRef } from '../utils';\n\nexport function setSelection(board: PlaitBoard, selection: Selection | null) {\n    const operation: SetSelectionOperation = { type: 'set_selection', properties: board.selection, newProperties: selection };\n    board.apply(operation);\n}\n\nexport interface SelectionTransforms {\n    setSelection: (board: PlaitBoard, selection: Selection | null) => void;\n    addSelectionWithTemporaryElements: (board: PlaitBoard, elements: PlaitElement[]) => void;\n}\n\nexport const SelectionTransforms: SelectionTransforms = {\n    setSelection,\n    addSelectionWithTemporaryElements\n};\n\nexport function addSelectionWithTemporaryElements(board: PlaitBoard, elements: PlaitElement[]) {\n    const timeoutId = setTimeout(() => {\n        setSelection(board, { anchor: [0, 0], focus: [0, 0] });\n    }, 0);\n    let ref = getTemporaryRef(board);\n    if (ref) {\n        clearTimeout(ref.timeoutId);\n        const currentElements = ref.elements;\n        ref.elements.push(...elements.filter(element => !currentElements.includes(element)));\n        ref.timeoutId = timeoutId;\n    } else {\n        BOARD_TO_TEMPORARY_ELEMENTS.set(board, { timeoutId, elements });\n    }\n}\n", "import { PlaitBoard } from '../interfaces';\nimport { moveElementsToNewPath } from '../utils';\nimport { getAllMoveOptions, getOneMoveOptions } from '../utils/z-index';\n\nconst moveToTop = (board: PlaitBoard) => {\n    const moveOptions = getAllMoveOptions(board, 'up');\n    moveElementsToNewPath(board, moveOptions);\n};\n\nconst moveToBottom = (board: PlaitBoard) => {\n    const moveOptions = getAllMoveOptions(board, 'down');\n    moveElementsToNewPath(board, moveOptions);\n};\n\nconst moveUp = (board: PlaitBoard) => {\n    const moveOptions = getOneMoveOptions(board, 'up');\n    moveElementsToNewPath(board, moveOptions);\n};\n\nconst moveDown = (board: PlaitBoard) => {\n    const moveOptions = getOneMoveOptions(board, 'down');\n    moveElementsToNewPath(board, moveOptions);\n};\n\nexport interface ZIndexTransforms {\n    moveUp: (board: PlaitBoard) => void;\n    moveDown: (board: PlaitBoard) => void;\n    moveToTop: (board: PlaitBoard) => void;\n    moveToBottom: (board: PlaitBoard) => void;\n}\n\nexport const ZIndexTransforms = { moveUp, moveDown, moveToTop, moveToBottom };\n", "import { PlaitBoard } from '../interfaces/board';\nimport { PlaitElement } from '../interfaces/element';\nimport { removeSelectedElement } from '../utils/selected-element';\nimport { removeNode } from './node';\n\nexport const removeElements = (board: PlaitBoard, elements: PlaitElement[]) => {\n    elements\n        .map(element => {\n            const path = PlaitBoard.findPath(board, element);\n            const ref = board.pathRef(path);\n            return () => {\n                ref.current && removeNode(board, ref.current);\n                ref.unref();\n                removeSelectedElement(board, element, true);\n            };\n        })\n        .forEach(action => {\n            action();\n        });\n};\n\nexport const CoreTransforms = {\n    removeElements\n};\n", "import { GeneralTransforms } from './general';\nimport { GroupTransforms } from './group';\nimport { NodeTransforms } from './node';\nimport { SelectionTransforms } from './selection';\nimport { ViewportTransforms } from './viewport';\nimport { ZIndexTransforms } from './z-index';\n\nexport { BoardTransforms } from './board';\nexport { CoreTransforms } from './element';\n\nexport const Transforms: GeneralTransforms &\n    ViewportTransforms &\n    SelectionTransforms &\n    NodeTransforms &\n    GroupTransforms &\n    ZIndexTransforms = {\n    ...GeneralTransforms,\n    ...ViewportTransforms,\n    ...SelectionTransforms,\n    ...NodeTransforms,\n    ...GroupTransforms,\n    ...ZIndexTransforms\n};\n", "import { PlaitBoard, PlaitElement, Point, RectangleClient } from '../interfaces';\nimport { Transforms } from '../transforms';\nimport { getRectangleByElements } from './element';\nimport { approximately, rotate } from './math';\nimport { toActiveRectangleFromViewBoxRectangle } from './to-point';\n\nexport const rotatePoints = <T>(points: T, centerPoint: Point, angle?: number): T => {\n    if (!angle) {\n        angle = 0;\n    }\n    if (Array.isArray(points) && typeof points[0] === 'number') {\n        return rotate(points[0], points[1], centerPoint[0], centerPoint[1], angle) as T;\n    } else {\n        return (points as Point[]).map((point) => {\n            return rotate(point[0], point[1], centerPoint[0], centerPoint[1], angle || 0);\n        }) as T;\n    }\n};\n\nexport const getSelectionAngle = (elements: PlaitElement[]) => {\n    let angle = elements[0]?.angle || 0;\n    elements.forEach((item) => {\n        if (item.angle !== angle && !approximately(((item.angle || 0) % (Math.PI / 2)) - (angle % (Math.PI / 2)), 0)) {\n            angle = 0;\n        }\n    });\n    return angle;\n};\n\nexport const hasSameAngle = (elements: PlaitElement[]) => {\n    if (!elements.length) {\n        return false;\n    }\n\n    const angle = elements[0].angle;\n    if (angle === undefined) {\n        return false;\n    }\n\n    return !elements.some((item) => item.angle !== angle);\n};\n\nexport const getRotatedBoundingRectangle = (rectanglesCornerPoints: [Point, Point, Point, Point][], angle: number) => {\n    let rectanglesFromOrigin: RectangleClient[] = [];\n    for (let i = 0; i < rectanglesCornerPoints.length; i++) {\n        const cornerPoints = rectanglesCornerPoints[i];\n        const invertCornerPointsFromOrigin = rotatePoints(cornerPoints, [0, 0], -angle);\n        rectanglesFromOrigin.push(RectangleClient.getRectangleByPoints(invertCornerPointsFromOrigin));\n    }\n\n    const selectionRectangleFromOrigin = RectangleClient.getBoundingRectangle(rectanglesFromOrigin);\n    const selectionCornerPoints = RectangleClient.getCornerPoints(selectionRectangleFromOrigin);\n    const cornerPointsFromOrigin = rotatePoints(selectionCornerPoints, [0, 0], angle);\n    const centerPoint = RectangleClient.getCenterPoint(RectangleClient.getRectangleByPoints(cornerPointsFromOrigin));\n    return RectangleClient.getRectangleByPoints(rotatePoints(cornerPointsFromOrigin, centerPoint, -angle));\n};\n\nexport const getOffsetAfterRotate = (rectangle: RectangleClient, rotateCenterPoint: Point, angle: number) => {\n    const targetCenterPoint = RectangleClient.getCenterPoint(rectangle);\n    const [rotatedCenterPoint] = rotatePoints([targetCenterPoint], rotateCenterPoint, angle);\n    const offsetX = rotatedCenterPoint[0] - targetCenterPoint[0];\n    const offsetY = rotatedCenterPoint[1] - targetCenterPoint[1];\n    return { offsetX, offsetY };\n};\n\nexport const rotatedDataPoints = (points: Point[], rotateCenterPoint: Point, angle: number): Point[] => {\n    const { offsetX, offsetY } = getOffsetAfterRotate(RectangleClient.getRectangleByPoints(points), rotateCenterPoint, angle);\n    return points.map((p) => [p[0] + offsetX, p[1] + offsetY]) as Point[];\n};\n\nexport const hasValidAngle = (node: PlaitElement) => {\n    return isValidAngle(node.angle);\n};\n\nexport const isValidAngle = (angle: undefined | number) => {\n    return angle && angle !== 0;\n};\n\nexport const rotatePointsByElement = <T>(points: T, element: PlaitElement): T | null => {\n    if (hasValidAngle(element)) {\n        let rectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const centerPoint = RectangleClient.getCenterPoint(rectangle);\n        return rotatePoints(points, centerPoint, element.angle);\n    } else {\n        return null;\n    }\n};\n\nexport const rotatePointsByAngle = (points: Point[], angle: number | undefined): Point[] | null => {\n    if (isValidAngle(angle)) {\n        let rectangle = RectangleClient.getRectangleByPoints(points);\n        const centerPoint = RectangleClient.getCenterPoint(rectangle);\n        return rotatePoints(points, centerPoint, angle);\n    } else {\n        return null;\n    }\n};\n\nexport const rotateAntiPointsByElement = <T>(\n    board: PlaitBoard,\n    points: T,\n    element: PlaitElement,\n    isToActive: boolean = false\n): T | null => {\n    if (hasValidAngle(element)) {\n        let rectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const activeRectangle = isToActive ? toActiveRectangleFromViewBoxRectangle(board, rectangle) : rectangle;\n        const centerPoint = RectangleClient.getCenterPoint(activeRectangle);\n        return rotatePoints(points, centerPoint, element.angle ? -element.angle : 0);\n    } else {\n        return null;\n    }\n};\n\nexport const getRectangleByAngle = (rectangle: RectangleClient, angle: number) => {\n    if (angle) {\n        const cornerPoints = RectangleClient.getCornerPoints(rectangle);\n        const centerPoint = RectangleClient.getCenterPoint(rectangle);\n        return RectangleClient.getRectangleByPoints(rotatePoints(cornerPoints, centerPoint, angle));\n    }\n    return rectangle;\n};\n\nexport const isAxisChangedByAngle = (angle: number) => {\n    const unitAngle = Math.abs(angle) % Math.PI;\n    return unitAngle >= (1 / 4) * Math.PI && unitAngle <= (3 / 4) * Math.PI;\n};\n\nexport function degreesToRadians(d: number): number {\n    return (d / 180) * Math.PI;\n}\n\nexport function radiansToDegrees(r: number): number {\n    return (r / Math.PI) * 180;\n}\n\nexport function rotateElements(board: PlaitBoard, elements: PlaitElement[], angle: number) {\n    const selectionRectangle = getRectangleByElements(board, elements, false);\n    const selectionCenterPoint = RectangleClient.getCenterPoint(selectionRectangle);\n    elements.forEach((item) => {\n        const originAngle = item.angle;\n        const points = rotatedDataPoints(item.points!, selectionCenterPoint, normalizeAngle(angle));\n        const path = PlaitBoard.findPath(board, item);\n        Transforms.setNode(board, { points, angle: normalizeAngle((originAngle || 0) + angle) }, path);\n    });\n}\n\nexport const normalizeAngle = (angle: number): number => {\n    if (angle < 0) {\n        return angle + 2 * Math.PI;\n    }\n    if (angle >= 2 * Math.PI) {\n        return angle - 2 * Math.PI;\n    }\n    return angle;\n};\n\nexport const getAngleBetweenPoints = (startPoint: Point, endPoint: Point, centerPoint: Point): number => {\n    const startAngle = (5 * Math.PI) / 2 + Math.atan2(startPoint[1] - centerPoint[1], startPoint[0] - centerPoint[0]);\n    const endAngle = (5 * Math.PI) / 2 + Math.atan2(endPoint[1] - centerPoint[1], endPoint[0] - centerPoint[0]);\n    return normalizeAngle(endAngle - startAngle);\n};\n\nexport const getAngleByElement = (element: PlaitElement): number | undefined => {\n    return element?.angle;\n};\n\nexport const setAngleForG = (g: SVGGElement, centerPoint: Point, angle: number) => {\n    if (angle === 0) {\n        g.removeAttribute('transform');\n        return;\n    }\n    var centerX = centerPoint[0];\n    var centerY = centerPoint[1];\n\n    let cosTheta = Math.cos(angle);\n    let sinTheta = Math.sin(angle);\n\n    let transformMatrix = [\n        cosTheta,\n        sinTheta,\n        -sinTheta,\n        cosTheta,\n        centerX * (1 - cosTheta) + centerY * sinTheta,\n        centerY * (1 - cosTheta) - centerX * sinTheta\n    ];\n\n    let matrix = 'matrix(' + transformMatrix.join(',') + ')';\n    g.setAttribute('transform', `${matrix}`);\n};\n", "import { Ancestor, PlaitBoard, PlaitElement, Point, RectangleClient } from '../interfaces';\nimport { getSelectionAngle, hasSameAngle, getRotatedBoundingRectangle, rotatePointsByElement, getRectangleByAngle } from './angle';\nimport { depthFirstRecursion, getIsRecursionFunc } from './tree';\nimport { KEY_TO_ELEMENT_MAP } from './weak-maps';\n\nexport function getRectangleByElements(board: PlaitBoard, elements: PlaitElement[], recursion: boolean): RectangleClient {\n    const rectanglesCornerPoints: [Point, Point, Point, Point][] = [];\n    const callback = (node: PlaitElement) => {\n        const nodeRectangle = board.getRectangle(node);\n        if (nodeRectangle) {\n            const cornerPoints = RectangleClient.getCornerPoints(nodeRectangle);\n            const rotatedCornerPoints = rotatePointsByElement(cornerPoints, node) || cornerPoints;\n            rectanglesCornerPoints.push(rotatedCornerPoints);\n        } else {\n            console.error(`can not get rectangle of element:`, node);\n        }\n    };\n    elements.forEach(element => {\n        if (recursion) {\n            depthFirstRecursion(\n                element,\n                node => callback(node),\n                node => board.isRecursion(node)\n            );\n        } else {\n            callback(element);\n        }\n    });\n    if (rectanglesCornerPoints.length > 0) {\n        if (hasSameAngle(elements)) {\n            const angle = getSelectionAngle(elements);\n            return getRotatedBoundingRectangle(rectanglesCornerPoints, angle);\n        } else {\n            const flatCornerPoints: Point[] = rectanglesCornerPoints.reduce((acc: Point[], val) => {\n                return acc.concat(val);\n            }, []);\n            return RectangleClient.getRectangleByPoints(flatCornerPoints);\n        }\n    } else {\n        return {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        };\n    }\n}\n\nexport function getBoundingRectangleByElements(board: PlaitBoard, elements: PlaitElement[], recursion: boolean): RectangleClient {\n    const rectangle = getRectangleByElements(board, elements, recursion)!;\n    const angle = getSelectionAngle(elements);\n    return getRectangleByAngle(rectangle, angle);\n}\n\nexport function getBoardRectangle(board: PlaitBoard): RectangleClient {\n    return getRectangleByElements(board, board.children, true);\n}\n\nexport function getElementById<T extends PlaitElement = PlaitElement>(\n    board: PlaitBoard,\n    id: string,\n    dataSource?: PlaitElement[]\n): T | undefined {\n    const cachedElement = !dataSource && getElementMap(board).get(id);\n    if (cachedElement) {\n        return cachedElement as T;\n    }\n    if (!dataSource) {\n        dataSource = findElements(board, { match: element => true, recursion: element => true });\n    }\n    let element = dataSource.find(element => element.id === id) as T;\n    return element;\n}\n\nexport function getElementMap(board: PlaitBoard) {\n    const elementMap = KEY_TO_ELEMENT_MAP.get(board);\n    if (!elementMap) {\n        throw new Error('can not resolve element map');\n    }\n    return elementMap;\n}\n\nexport function findElements<T extends PlaitElement = PlaitElement>(\n    board: PlaitBoard,\n    options: {\n        match: (element: PlaitElement) => boolean;\n        recursion: (element: PlaitElement) => boolean;\n        isReverse?: boolean;\n    }\n): T[] {\n    let elements: T[] = [];\n    const isReverse = options.isReverse ?? true;\n    depthFirstRecursion<Ancestor>(\n        board,\n        node => {\n            if (!PlaitBoard.isBoard(node) && options.match(node)) {\n                elements.push(node as T);\n            }\n        },\n        (value: Ancestor) => {\n            if (PlaitBoard.isBoard(value)) {\n                return true;\n            } else {\n                return getIsRecursionFunc(board)(value) && options.recursion(value);\n            }\n        },\n        isReverse\n    );\n    return elements;\n}\n", "export interface PlaitTheme {\n    themeColorMode: ThemeColorMode;\n}\n\nexport interface ThemeColor {\n    mode: ThemeColorMode | string;\n    boardBackground?: string;\n    textColor: string;\n}\n\nexport enum ThemeColorMode {\n    'default' = 'default',\n    'colorful' = 'colorful',\n    'soft' = 'soft',\n    'retro' = 'retro',\n    'dark' = 'dark',\n    'starry' = 'starry'\n}\n\nexport const DEFAULT_COLOR = '#333333';\n\nexport const DefaultThemeColor: ThemeColor = {\n    mode: ThemeColorMode.default,\n    boardBackground: '#ffffff',\n    textColor: DEFAULT_COLOR\n};\n\nexport const ColorfulThemeColor: ThemeColor = {\n    mode: ThemeColorMode.colorful,\n    boardBackground: '#ffffff',\n    textColor: DEFAULT_COLOR\n};\n\nexport const SoftThemeColor: ThemeColor = {\n    mode: ThemeColorMode.soft,\n    boardBackground: '#f5f5f5',\n    textColor: DEFAULT_COLOR\n};\n\nexport const RetroThemeColor: ThemeColor = {\n    mode: ThemeColorMode.retro,\n    boardBackground: '#f9f8ed',\n    textColor: DEFAULT_COLOR\n};\n\nexport const DarkThemeColor: ThemeColor = {\n    mode: ThemeColorMode.dark,\n    boardBackground: '#141414',\n    textColor: '#FFFFFF'\n};\n\nexport const StarryThemeColor: ThemeColor = {\n    mode: ThemeColorMode.starry,\n    boardBackground: '#0d2537',\n    textColor: '#FFFFFF'\n};\n\nexport const ThemeColors: ThemeColor[] = [\n    DefaultThemeColor,\n    ColorfulThemeColor,\n    SoftThemeColor,\n    RetroThemeColor,\n    DarkThemeColor,\n    StarryThemeColor\n];\n", "import { PlaitPointerType } from './pointer';\nimport { ComponentType, PlaitElement } from './element';\nimport { PlaitPluginElementContext } from '../core/element/context';\nimport { PlaitHistory } from './history';\nimport { PlaitOperation } from './operation';\nimport { Selection } from './selection';\nimport { Viewport } from './viewport';\nimport {\n    BOARD_TO_CONTEXT,\n    BOARD_TO_ELEMENT_HOST,\n    BOARD_TO_HOST,\n    BOARD_TO_MOVING_POINT,\n    BOARD_TO_MOVING_POINT_IN_BOARD,\n    BOARD_TO_ROUGH_SVG,\n    IS_BOARD_ALIVE,\n    IS_BOARD_CACHE,\n    IS_TEXT_EDITABLE,\n    NODE_TO_INDEX,\n    NODE_TO_PARENT\n} from '../utils/weak-maps';\nimport { RoughSVG } from 'roughjs/bin/svg';\nimport { Point } from './point';\nimport { RectangleClient } from './rectangle-client';\nimport { getRectangleByElements } from '../utils/element';\nimport { PathRef, PathRefOptions } from './path-ref';\nimport { Ancestor, PlaitNode } from './node';\nimport { Path } from './path';\nimport { PlaitTheme, ThemeColor, ThemeColors } from './theme';\nimport { distanceBetweenPointAndRectangle } from '../utils/math';\nimport { ClipboardData, WritableClipboardContext, WritableClipboardOperationType } from '../utils';\nimport { ElementFlavour } from '../core/element/element-flavour';\nimport { PlaitBoardContext } from '../context';\n\nexport interface PlaitBoard {\n    viewport: Viewport;\n    children: PlaitElement[];\n    theme: PlaitTheme;\n    operations: PlaitOperation[];\n    // record pointer selection or drag selection\n    // it will be dirty when board viewport change\n    selection: Selection | null;\n    pointer: PlaitPointerType | string;\n    history: PlaitHistory;\n    options: PlaitBoardOptions;\n    undo: () => void;\n    redo: () => void;\n    apply: (operation: PlaitOperation) => void;\n    onChange: () => void;\n    afterChange: () => void;\n    drawSelectionRectangle: () => SVGGElement | null;\n    mousedown: (event: MouseEvent) => void;\n    mousemove: (event: MouseEvent) => void;\n    mouseleave: (event: MouseEvent) => void;\n    mouseup: (event: MouseEvent) => void;\n    globalMousemove: (event: MouseEvent) => void;\n    globalMouseup: (event: MouseEvent) => void;\n    keyDown: (event: KeyboardEvent) => void;\n    globalKeyDown: (event: KeyboardEvent) => void;\n    keyUp: (event: KeyboardEvent) => void;\n    buildFragment: (\n        clipboardContext: WritableClipboardContext | null,\n        rectangle: RectangleClient | null,\n        operationType: WritableClipboardOperationType,\n        originData?: PlaitElement[]\n    ) => WritableClipboardContext | null;\n    insertFragment: (clipboardData: ClipboardData | null, targetPoint: Point, operationType?: WritableClipboardOperationType) => void;\n    deleteFragment: (data: PlaitElement[]) => void;\n    getDeletedFragment: (data: PlaitElement[]) => PlaitElement[];\n    getRelatedFragment: (data: PlaitElement[], originData?: PlaitElement[]) => PlaitElement[];\n    dblClick: (event: MouseEvent) => void;\n    normalizeElement: (context: PlaitPluginElementContext) => void;\n    drawElement: (context: PlaitPluginElementContext) => ComponentType<ElementFlavour>;\n    isRectangleHit: (element: PlaitElement, range: Selection) => boolean;\n    // When the element has no fill color, it is considered a hit only if it hits the border.\n    isHit: (element: PlaitElement, point: Point, isStrict?: boolean) => boolean;\n    isInsidePoint: (element: PlaitElement, point: Point) => boolean;\n    // the hit element is determined by the plugin\n    getOneHitElement: (hitElements: PlaitElement[]) => PlaitElement;\n    isRecursion: (element: PlaitElement) => boolean;\n    isMovable: (element: PlaitElement) => boolean;\n    getRectangle: (element: PlaitElement) => RectangleClient | null;\n    isWithinSelection: (element: PlaitElement) => boolean;\n    pathRef: (path: Path, options?: PathRefOptions) => PathRef;\n    pathRefs: () => Set<PathRef>;\n    applyTheme: (element: PlaitElement) => void;\n    isAlign: (element: PlaitElement) => boolean;\n    isImageBindingAllowed: (element: PlaitElement) => boolean;\n    canAddToGroup: (element: PlaitElement) => boolean;\n    canSetZIndex: (element: PlaitElement) => boolean;\n    isExpanded: (element: PlaitElement) => boolean;\n    // pointer hook\n    pointerDown: (pointer: PointerEvent) => void;\n    pointerMove: (pointer: PointerEvent) => void;\n    pointerUp: (pointer: PointerEvent) => void;\n    pointerCancel: (pointer: PointerEvent) => void;\n    pointerOut: (pointer: PointerEvent) => void;\n    pointerLeave: (pointer: PointerEvent) => void;\n    globalPointerMove: (pointer: PointerEvent) => void;\n    globalPointerUp: (pointer: PointerEvent) => void;\n    drop: (event: DragEvent) => boolean;\n}\n\nexport interface PlaitBoardOptions {\n    readonly?: boolean;\n    hideScrollbar?: boolean;\n    disabledScrollOnNonFocus?: boolean;\n    themeColors?: ThemeColor[];\n}\n\nexport interface PlaitBoardMove {\n    x: number;\n    y: number;\n}\n\nexport const PlaitBoard = {\n    isBoard(value: any): value is PlaitBoard {\n        const cachedIsBoard = IS_BOARD_CACHE.get(value);\n        if (cachedIsBoard !== undefined) {\n            return cachedIsBoard;\n        }\n        const isBoard = typeof value.onChange === 'function' && typeof value.apply === 'function';\n        IS_BOARD_CACHE.set(value, isBoard);\n        return isBoard;\n    },\n    isAlive(board: PlaitBoard) {\n        const isAlive = IS_BOARD_ALIVE.get(board);\n        return !!isAlive;\n    },\n    findPath(board: PlaitBoard, node: PlaitNode): Path {\n        const path: Path = [];\n        let child: Ancestor = node;\n        while (true) {\n            const parent = NODE_TO_PARENT.get(child as PlaitElement);\n            if (parent == null) {\n                if (PlaitBoard.isBoard(child)) {\n                    return path;\n                } else {\n                    break;\n                }\n            }\n            const i = NODE_TO_INDEX.get(child as PlaitElement);\n            if (i == null) {\n                break;\n            }\n            path.unshift(i);\n            child = parent;\n        }\n        throw new Error(`Unable to find the path for Plait node: ${JSON.stringify(node)}`);\n    },\n    getHost(board: PlaitBoard) {\n        return BOARD_TO_HOST.get(board) as SVGSVGElement;\n    },\n    getElementLowerHost(board: PlaitBoard) {\n        return BOARD_TO_ELEMENT_HOST.get(board)?.lowerHost as SVGSVGElement;\n    },\n    getElementHost(board: PlaitBoard) {\n        return BOARD_TO_ELEMENT_HOST.get(board)?.host as SVGSVGElement;\n    },\n    getElementUpperHost(board: PlaitBoard) {\n        return BOARD_TO_ELEMENT_HOST.get(board)?.upperHost as SVGSVGElement;\n    },\n    getElementTopHost(board: PlaitBoard) {\n        return BOARD_TO_ELEMENT_HOST.get(board)?.topHost as SVGSVGElement;\n    },\n    getActiveHost(board: PlaitBoard) {\n        return BOARD_TO_ELEMENT_HOST.get(board)?.activeHost as SVGSVGElement;\n    },\n    getRoughSVG(board: PlaitBoard) {\n        return BOARD_TO_ROUGH_SVG.get(board) as RoughSVG;\n    },\n    getBoardContainer(board: PlaitBoard) {\n        return BOARD_TO_ELEMENT_HOST.get(board)?.container as HTMLElement;\n    },\n    getBoardContext(board: PlaitBoard) {\n        return BOARD_TO_CONTEXT.get(board) as PlaitBoardContext;\n    },\n    getRectangle(board: PlaitBoard) {\n        return getRectangleByElements(board, board.children, true);\n    },\n    getViewportContainer(board: PlaitBoard) {\n        return BOARD_TO_ELEMENT_HOST.get(board)?.viewportContainer as HTMLElement;\n    },\n    isFocus(board: PlaitBoard) {\n        return !!board.selection;\n    },\n    isReadonly(board: PlaitBoard) {\n        return board.options.readonly;\n    },\n    hasBeenTextEditing(board: PlaitBoard) {\n        return !!IS_TEXT_EDITABLE.get(board);\n    },\n    getPointer<T = PlaitPointerType>(board: PlaitBoard) {\n        return board.pointer as T;\n    },\n    isPointer<T = PlaitPointerType>(board: PlaitBoard, pointer: T) {\n        return board.pointer === pointer;\n    },\n    isInPointer<T = PlaitPointerType>(board: PlaitBoard, pointers: T[]) {\n        const point = board.pointer as T;\n        return pointers.includes(point);\n    },\n    getMovingPointInBoard(board: PlaitBoard) {\n        return BOARD_TO_MOVING_POINT_IN_BOARD.get(board);\n    },\n    isMovingPointInBoard(board: PlaitBoard) {\n        const point = BOARD_TO_MOVING_POINT.get(board);\n        const rect = PlaitBoard.getBoardContainer(board).getBoundingClientRect();\n        if (point && distanceBetweenPointAndRectangle(point[0], point[1], rect) === 0) {\n            return true;\n        }\n        return false;\n    },\n    getThemeColors<T extends ThemeColor = ThemeColor>(board: PlaitBoard) {\n        return (board.options.themeColors || ThemeColors) as T[];\n    }\n};\n", "export enum PlaitPointerType {\n    'hand' = 'hand',\n    'selection' = 'selection'\n}\n", "/**\n * Extendable Custom Types Interface\n */\n\ntype ExtendableTypes = 'Viewport' | 'SetViewportOperation' | 'SetSelectionOperation';\n\nexport interface CustomTypes {\n    [key: string]: unknown;\n}\n\nexport type ExtendedType<K extends ExtendableTypes, B> = unknown extends CustomTypes[K] ? B : CustomTypes[K];\n", "import { PlaitNode } from './node';\nimport { Path } from './path';\nimport { Selection } from './selection';\nimport { PlaitTheme } from './theme';\nimport { Viewport } from './viewport';\n\nexport type InsertNodeOperation = {\n    type: 'insert_node';\n    path: Path;\n    node: PlaitNode;\n};\n\nexport type RemoveNodeOperation = {\n    type: 'remove_node';\n    path: Path;\n    node: PlaitNode;\n};\n\nexport type MoveNodeOperation = {\n    type: 'move_node';\n    path: Path;\n    newPath: Path;\n};\n\nexport type SetThemeOperation = {\n    type: 'set_theme';\n    properties: Partial<PlaitTheme>;\n    newProperties: Partial<PlaitTheme>;\n};\n\nexport type SetViewportOperation = {\n    type: 'set_viewport';\n    properties: Partial<Viewport>;\n    newProperties: Partial<Viewport>;\n};\n\nexport type SetSelectionOperation = {\n    type: 'set_selection';\n    properties: Selection | null;\n    newProperties: Selection | null;\n};\n\nexport type SetNodeOperation = {\n    type: 'set_node';\n    path: Path;\n    properties: Partial<PlaitNode>;\n    newProperties: Partial<PlaitNode>;\n};\n\nexport type PlaitOperation =\n    | InsertNodeOperation\n    | SetViewportOperation\n    | SetSelectionOperation\n    | SetNodeOperation\n    | RemoveNodeOperation\n    | MoveNodeOperation\n    | SetThemeOperation;\n\nexport interface PlaitOperationInterface {\n    inverse: (op: PlaitOperation) => PlaitOperation;\n    isSetViewportOperation: (value: PlaitOperation) => boolean;\n    isSetSelectionOperation: (value: PlaitOperation) => boolean;\n    isSetThemeOperation: (value: PlaitOperation) => boolean;\n}\n\nexport const isSetViewportOperation = (value: any): value is SetViewportOperation => {\n    return value.type === 'set_viewport';\n};\n\nexport const isSetSelectionOperation = (value: any): value is SetSelectionOperation => {\n    return value.type === 'set_selection';\n};\n\nexport const isSetThemeOperation = (value: any): value is SetThemeOperation => {\n    return value.type === 'set_theme';\n};\n\nexport const inverse = (op: PlaitOperation): PlaitOperation => {\n    switch (op.type) {\n        case 'insert_node': {\n            return { ...op, type: 'remove_node' };\n        }\n\n        case 'remove_node': {\n            return { ...op, type: 'insert_node' };\n        }\n\n        case 'move_node': {\n            const { newPath, path } = op;\n\n            // PERF: in this case the move operation is a no-op anyways.\n            if (Path.equals(newPath, path)) {\n                return op;\n            }\n\n            // when operation path is [0,0] -> [0,2], should exec Path.transform to get [0,1] -> [0,0]\n            // shoud not return [0,2] -> [0,0] #WIK-8981\n            // if (Path.isSibling(path, newPath)) {\n            //     return { ...op, path: newPath, newPath: path };\n            // }\n\n            // If the move does not happen within a single parent it is possible\n            // for the move to impact the true path to the location where the node\n            // was removed from and where it was inserted. We have to adjust for this\n            // and find the original path. We can accomplish this (only in non-sibling)\n            // moves by looking at the impact of the move operation on the node\n            // after the original move path.\n            const inversePath = Path.transform(path, op)!;\n            const inverseNewPath = Path.transform(Path.next(path), op)!;\n            return { ...op, path: inversePath, newPath: inverseNewPath };\n        }\n\n        case 'set_node': {\n            const { properties, newProperties } = op;\n            return { ...op, properties: newProperties, newProperties: properties };\n        }\n\n        case 'set_selection': {\n            const { properties, newProperties } = op;\n\n            if (properties == null) {\n                return {\n                    ...op,\n                    properties: newProperties,\n                    newProperties: null\n                };\n            } else if (newProperties == null) {\n                return {\n                    ...op,\n                    properties: null,\n                    newProperties: properties\n                };\n            } else {\n                return { ...op, properties: newProperties, newProperties: properties };\n            }\n        }\n\n        case 'set_viewport': {\n            const { properties, newProperties } = op;\n            if (properties == null) {\n                return {\n                    ...op,\n                    properties: newProperties,\n                    newProperties: newProperties\n                };\n            } else if (newProperties == null) {\n                return {\n                    ...op,\n                    properties: properties,\n                    newProperties: properties\n                };\n            } else {\n                return { ...op, properties: newProperties, newProperties: properties };\n            }\n        }\n\n        case 'set_theme': {\n            const { properties, newProperties } = op;\n            return { ...op, properties: newProperties, newProperties: properties };\n        }\n    }\n};\n\nexport const PlaitOperation: PlaitOperationInterface = {\n    isSetViewportOperation,\n    isSetSelectionOperation,\n    isSetThemeOperation,\n    inverse\n};\n", "export type Point = [number, number];\n\nexport interface XYPosition {\n    x: number;\n    y: number;\n}\n\nexport const Point = {\n    isEquals(point?: Point, otherPoint?: Point) {\n        return point && otherPoint && point[0] === otherPoint[0] && point[1] === otherPoint[1];\n    },\n    isHorizontal(point?: Point, otherPoint?: Point, tolerance = 0) {\n        return point && otherPoint && Point.isOverHorizontal([point, otherPoint], tolerance);\n    },\n    isOverHorizontal(points: Point[], tolerance: number = 0) {\n        return points.every(point => Math.abs(point[1] - points[0][1]) <= tolerance);\n    },\n    isVertical(point?: Point, otherPoint?: Point, tolerance = 0) {\n        return point && otherPoint && Point.isOverVertical([point, otherPoint], tolerance);\n    },\n    isOverVertical(points: Point[], tolerance: number = 0) {\n        return points.every(point => Math.abs(point[0] - points[0][0]) <= tolerance);\n    },\n    isAlign(points: Point[], tolerance: number = 0) {\n        return Point.isOverHorizontal(points, tolerance) || Point.isOverVertical(points, tolerance);\n    },\n    getOffsetX(point1: Point, point2: Point) {\n        return point2[0] - point1[0];\n    },\n    getOffsetY(point1: Point, point2: Point) {\n        return point2[1] - point1[1];\n    }\n};\n", "import { PlaitBoard } from './board';\nimport { PlaitOperation } from './operation';\n\nexport interface PlaitHistory {\n    redos: PlaitOperation[][];\n    undos: PlaitOperation[][];\n}\n\nexport const SAVING = new WeakMap<PlaitBoard, boolean | undefined>();\nexport const MERGING = new WeakMap<PlaitBoard, boolean | undefined>();\nexport const HISTORY = new WeakMap<PlaitBoard, History>();\nexport const SPLITTING_ONCE = new WeakMap<PlaitBoard, boolean | undefined>();\n", "export enum Direction {\n    left = 'left',\n    top = 'top',\n    right = 'right',\n    bottom = 'bottom'\n}\n\nexport const isHorizontalDirection = (direction: Direction) => {\n    return direction === Direction.left || direction === Direction.right;\n};\n\nexport const isVerticalDirection = (direction: Direction) => {\n    return !isHorizontalDirection(direction);\n};\n\nexport type Vector = [number, number];\n\nexport type DirectionFactor = -1 | 0 | 1;\n\nexport type DirectionFactors = [DirectionFactor, DirectionFactor];\n", "import { PlaitElement } from \"./element\";\n\nexport interface PlaitGroup extends PlaitElement {\n    type: 'group';\n}\n\nexport const PlaitGroupElement = {\n    isGroup: (value: any): value is PlaitGroup => {\n        return value.type === 'group';\n    }\n}", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport function isListLikeIterable(obj: any): boolean {\n    if (!isJsObject(obj)) return false;\n    return (\n        Array.isArray(obj) ||\n        (!(obj instanceof Map) && // JS Map are iterables but return entries as [k, v]\n            Symbol.iterator in obj)\n    ); // JS Iterable have a Symbol.iterator prop\n}\n\nexport function isJsObject(o: any): boolean {\n    return o !== null && (typeof o === 'function' || typeof o === 'object');\n}\n\nexport function iterateListLike<T>(obj: Iterable<T>, fn: (p: T) => void) {\n    if (Array.isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n            fn(obj[i]);\n        }\n    } else {\n        const iterator = obj[Symbol.iterator]();\n        let item: IteratorResult<T, any>;\n        while (!(item = iterator.next()).done) {\n            fn(item.value);\n        }\n    }\n}\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {isListLikeIterable, iterateListLike} from '../utils/iterable';\n\nimport {IterableChangeRecord, IterableChanges, IterableDiffer, CustomIterable, TrackByFunction} from './iterable_differs';\n\n\nconst trackByIdentity = (index: number, item: any) => item;\n\nexport type Writable<T> = {\n  -readonly[K in keyof T]: T[K];\n};\n\nexport class DefaultIterableDiffer<V> implements IterableDiffer<V>, IterableChanges<V> {\n  public readonly length: number = 0;\n  public readonly collection!: V[]|Iterable<V>|null;\n  // Keeps track of the used records at any point in time (during & across `_check()` calls)\n  private _linkedRecords: _DuplicateMap<V>|null = null;\n  // Keeps track of the removed records at any point in time during `_check()` calls.\n  private _unlinkedRecords: _DuplicateMap<V>|null = null;\n  private _previousItHead: IterableChangeRecord_<V>|null = null;\n  private _itHead: IterableChangeRecord_<V>|null = null;\n  private _itTail: IterableChangeRecord_<V>|null = null;\n  private _additionsHead: IterableChangeRecord_<V>|null = null;\n  private _additionsTail: IterableChangeRecord_<V>|null = null;\n  private _movesHead: IterableChangeRecord_<V>|null = null;\n  private _movesTail: IterableChangeRecord_<V>|null = null;\n  private _removalsHead: IterableChangeRecord_<V>|null = null;\n  private _removalsTail: IterableChangeRecord_<V>|null = null;\n  // Keeps track of records where custom track by is the same, but item identity has changed\n  private _identityChangesHead: IterableChangeRecord_<V>|null = null;\n  private _identityChangesTail: IterableChangeRecord_<V>|null = null;\n  private _trackByFn: TrackByFunction<V>;\n\n  constructor(trackByFn?: TrackByFunction<V>) {\n    this._trackByFn = trackByFn || trackByIdentity;\n  }\n\n  forEachItem(fn: (record: IterableChangeRecord_<V>) => void) {\n    let record: IterableChangeRecord_<V>|null;\n    for (record = this._itHead; record !== null; record = record._next) {\n      fn(record);\n    }\n  }\n\n  forEachOperation(\n      fn: (item: IterableChangeRecord<V>, previousIndex: number|null, currentIndex: number|null) =>\n          void) {\n    let nextIt = this._itHead;\n    let nextRemove = this._removalsHead;\n    let addRemoveOffset = 0;\n    let moveOffsets: number[]|null = null;\n    while (nextIt || nextRemove) {\n      // Figure out which is the next record to process\n      // Order: remove, add, move\n      const record: IterableChangeRecord<V> = !nextRemove ||\n              nextIt &&\n                  nextIt.currentIndex! <\n                      getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ?\n          nextIt! :\n          nextRemove;\n      const adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);\n      const currentIndex = record.currentIndex;\n\n      // consume the item, and adjust the addRemoveOffset and update moveDistance if necessary\n      if (record === nextRemove) {\n        addRemoveOffset--;\n        nextRemove = nextRemove._nextRemoved;\n      } else {\n        nextIt = nextIt!._next;\n        if (record.previousIndex == null) {\n          addRemoveOffset++;\n        } else {\n          // INVARIANT:  currentIndex < previousIndex\n          if (!moveOffsets) moveOffsets = [];\n          const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;\n          const localCurrentIndex = currentIndex! - addRemoveOffset;\n          if (localMovePreviousIndex != localCurrentIndex) {\n            for (let i = 0; i < localMovePreviousIndex; i++) {\n              const offset = i < moveOffsets.length ? moveOffsets[i] : (moveOffsets[i] = 0);\n              const index = offset + i;\n              if (localCurrentIndex <= index && index < localMovePreviousIndex) {\n                moveOffsets[i] = offset + 1;\n              }\n            }\n            const previousIndex = record.previousIndex;\n            moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;\n          }\n        }\n      }\n\n      if (adjPreviousIndex !== currentIndex) {\n        fn(record, adjPreviousIndex, currentIndex);\n      }\n    }\n  }\n\n  forEachPreviousItem(fn: (record: IterableChangeRecord_<V>) => void) {\n    let record: IterableChangeRecord_<V>|null;\n    for (record = this._previousItHead; record !== null; record = record._nextPrevious) {\n      fn(record);\n    }\n  }\n\n  forEachAddedItem(fn: (record: IterableChangeRecord_<V>) => void) {\n    let record: IterableChangeRecord_<V>|null;\n    for (record = this._additionsHead; record !== null; record = record._nextAdded) {\n      fn(record);\n    }\n  }\n\n  forEachMovedItem(fn: (record: IterableChangeRecord_<V>) => void) {\n    let record: IterableChangeRecord_<V>|null;\n    for (record = this._movesHead; record !== null; record = record._nextMoved) {\n      fn(record);\n    }\n  }\n\n  forEachRemovedItem(fn: (record: IterableChangeRecord_<V>) => void) {\n    let record: IterableChangeRecord_<V>|null;\n    for (record = this._removalsHead; record !== null; record = record._nextRemoved) {\n      fn(record);\n    }\n  }\n\n  forEachIdentityChange(fn: (record: IterableChangeRecord_<V>) => void) {\n    let record: IterableChangeRecord_<V>|null;\n    for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {\n      fn(record);\n    }\n  }\n\n  diff(collection: CustomIterable<V>|null|undefined): DefaultIterableDiffer<V>|null {\n    if (collection == null) collection = [];\n    if (!isListLikeIterable(collection)) {\n      throw new Error('Exception: Error trying to diff. Only arrays and iterables are allowed');\n    }\n\n    if (this.check(collection)) {\n      return this;\n    } else {\n      return null;\n    }\n  }\n\n  onDestroy() {}\n\n  check(collection: CustomIterable<V>): boolean {\n    this._reset();\n\n    let record: IterableChangeRecord_<V>|null = this._itHead;\n    let mayBeDirty: boolean = false;\n    let index: number;\n    let item: V;\n    let itemTrackBy: any;\n    if (Array.isArray(collection)) {\n      (this as Writable<this>).length = collection.length;\n\n      for (let index = 0; index < this.length; index++) {\n        item = collection[index];\n        itemTrackBy = this._trackByFn(index, item);\n        if (record === null || !Object.is(record.trackById, itemTrackBy)) {\n          record = this._mismatch(record, item, itemTrackBy, index);\n          mayBeDirty = true;\n        } else {\n          if (mayBeDirty) {\n            record = this._verifyReinsertion(record, item, itemTrackBy, index);\n          }\n          if (!Object.is(record.item, item)) this._addIdentityChange(record, item);\n        }\n\n        record = record._next;\n      }\n    } else {\n      index = 0;\n      iterateListLike(collection, (item: V) => {\n        itemTrackBy = this._trackByFn(index, item);\n        if (record === null || !Object.is(record.trackById, itemTrackBy)) {\n          record = this._mismatch(record, item, itemTrackBy, index);\n          mayBeDirty = true;\n        } else {\n          if (mayBeDirty) {\n            record = this._verifyReinsertion(record, item, itemTrackBy, index);\n          }\n          if (!Object.is(record.item, item)) this._addIdentityChange(record, item);\n        }\n        record = record._next;\n        index++;\n      });\n      (this as Writable<this>).length = index;\n    }\n\n    this._truncate(record);\n    (this as Writable<this>).collection = collection;\n    return this.isDirty;\n  }\n\n  /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity\n   * changes.\n   */\n  get isDirty(): boolean {\n    return this._additionsHead !== null || this._movesHead !== null ||\n        this._removalsHead !== null || this._identityChangesHead !== null;\n  }\n\n  /**\n   * Reset the state of the change objects to show no changes. This means set previousKey to\n   * currentKey, and clear all of the queues (additions, moves, removals).\n   * Set the previousIndexes of moved and added items to their currentIndexes\n   * Reset the list of additions, moves and removals\n   *\n   * @internal\n   */\n  _reset() {\n    if (this.isDirty) {\n      let record: IterableChangeRecord_<V>|null;\n\n      for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {\n        record._nextPrevious = record._next;\n      }\n\n      for (record = this._additionsHead; record !== null; record = record._nextAdded) {\n        record.previousIndex = record.currentIndex;\n      }\n      this._additionsHead = this._additionsTail = null;\n\n      for (record = this._movesHead; record !== null; record = record._nextMoved) {\n        record.previousIndex = record.currentIndex;\n      }\n      this._movesHead = this._movesTail = null;\n      this._removalsHead = this._removalsTail = null;\n      this._identityChangesHead = this._identityChangesTail = null;\n    }\n  }\n\n  /**\n   * This is the core function which handles differences between collections.\n   *\n   * - `record` is the record which we saw at this position last time. If null then it is a new\n   *   item.\n   * - `item` is the current item in the collection\n   * - `index` is the position of the item in the collection\n   *\n   * @internal\n   */\n  _mismatch(record: IterableChangeRecord_<V>|null, item: V, itemTrackBy: any, index: number):\n      IterableChangeRecord_<V> {\n    // The previous record after which we will append the current one.\n    let previousRecord: IterableChangeRecord_<V>|null;\n\n    if (record === null) {\n      previousRecord = this._itTail;\n    } else {\n      previousRecord = record._prev;\n      // Remove the record from the collection since we know it does not match the item.\n      this._remove(record);\n    }\n\n    // See if we have evicted the item, which used to be at some anterior position of _itHead list.\n    record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);\n    if (record !== null) {\n      // It is an item which we have evicted earlier: reinsert it back into the list.\n      // But first we need to check if identity changed, so we can update in view if necessary.\n      if (!Object.is(record.item, item)) this._addIdentityChange(record, item);\n\n      this._reinsertAfter(record, previousRecord, index);\n    } else {\n      // Attempt to see if the item is at some posterior position of _itHead list.\n      record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);\n      if (record !== null) {\n        // We have the item in _itHead at/after `index` position. We need to move it forward in the\n        // collection.\n        // But first we need to check if identity changed, so we can update in view if necessary.\n        if (!Object.is(record.item, item)) this._addIdentityChange(record, item);\n\n        this._moveAfter(record, previousRecord, index);\n      } else {\n        // It is a new item: add it.\n        record =\n            this._addAfter(new IterableChangeRecord_<V>(item, itemTrackBy), previousRecord, index);\n      }\n    }\n    return record;\n  }\n\n  /**\n   * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)\n   *\n   * Use case: `[a, a]` => `[b, a, a]`\n   *\n   * If we did not have this check then the insertion of `b` would:\n   *   1) evict first `a`\n   *   2) insert `b` at `0` index.\n   *   3) leave `a` at index `1` as is. <-- this is wrong!\n   *   3) reinsert `a` at index 2. <-- this is wrong!\n   *\n   * The correct behavior is:\n   *   1) evict first `a`\n   *   2) insert `b` at `0` index.\n   *   3) reinsert `a` at index 1.\n   *   3) move `a` at from `1` to `2`.\n   *\n   *\n   * Double check that we have not evicted a duplicate item. We need to check if the item type may\n   * have already been removed:\n   * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted\n   * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a\n   * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'\n   * at the end.\n   *\n   * @internal\n   */\n  _verifyReinsertion(record: IterableChangeRecord_<V>, item: V, itemTrackBy: any, index: number):\n      IterableChangeRecord_<V> {\n    let reinsertRecord: IterableChangeRecord_<V>|null =\n        this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);\n    if (reinsertRecord !== null) {\n      record = this._reinsertAfter(reinsertRecord, record._prev!, index);\n    } else if (record.currentIndex != index) {\n      record.currentIndex = index;\n      this._addToMoves(record, index);\n    }\n    return record;\n  }\n\n  /**\n   * Get rid of any excess {@link IterableChangeRecord_}s from the previous collection\n   *\n   * - `record` The first excess {@link IterableChangeRecord_}.\n   *\n   * @internal\n   */\n  _truncate(record: IterableChangeRecord_<V>|null) {\n    // Anything after that needs to be removed;\n    while (record !== null) {\n      const nextRecord: IterableChangeRecord_<V>|null = record._next;\n      this._addToRemovals(this._unlink(record));\n      record = nextRecord;\n    }\n    if (this._unlinkedRecords !== null) {\n      this._unlinkedRecords.clear();\n    }\n\n    if (this._additionsTail !== null) {\n      this._additionsTail._nextAdded = null;\n    }\n    if (this._movesTail !== null) {\n      this._movesTail._nextMoved = null;\n    }\n    if (this._itTail !== null) {\n      this._itTail._next = null;\n    }\n    if (this._removalsTail !== null) {\n      this._removalsTail._nextRemoved = null;\n    }\n    if (this._identityChangesTail !== null) {\n      this._identityChangesTail._nextIdentityChange = null;\n    }\n  }\n\n  /** @internal */\n  _reinsertAfter(\n      record: IterableChangeRecord_<V>, prevRecord: IterableChangeRecord_<V>|null,\n      index: number): IterableChangeRecord_<V> {\n    if (this._unlinkedRecords !== null) {\n      this._unlinkedRecords.remove(record);\n    }\n    const prev = record._prevRemoved;\n    const next = record._nextRemoved;\n\n    if (prev === null) {\n      this._removalsHead = next;\n    } else {\n      prev._nextRemoved = next;\n    }\n    if (next === null) {\n      this._removalsTail = prev;\n    } else {\n      next._prevRemoved = prev;\n    }\n\n    this._insertAfter(record, prevRecord, index);\n    this._addToMoves(record, index);\n    return record;\n  }\n\n  /** @internal */\n  _moveAfter(\n      record: IterableChangeRecord_<V>, prevRecord: IterableChangeRecord_<V>|null,\n      index: number): IterableChangeRecord_<V> {\n    this._unlink(record);\n    this._insertAfter(record, prevRecord, index);\n    this._addToMoves(record, index);\n    return record;\n  }\n\n  /** @internal */\n  _addAfter(\n      record: IterableChangeRecord_<V>, prevRecord: IterableChangeRecord_<V>|null,\n      index: number): IterableChangeRecord_<V> {\n    this._insertAfter(record, prevRecord, index);\n\n    if (this._additionsTail === null) {\n      // assert(this._additionsHead === null);\n      this._additionsTail = this._additionsHead = record;\n    } else {\n      // assert(_additionsTail._nextAdded === null);\n      // assert(record._nextAdded === null);\n      this._additionsTail = this._additionsTail._nextAdded = record;\n    }\n    return record;\n  }\n\n  /** @internal */\n  _insertAfter(\n      record: IterableChangeRecord_<V>, prevRecord: IterableChangeRecord_<V>|null,\n      index: number): IterableChangeRecord_<V> {\n\n    const next: IterableChangeRecord_<V>|null =\n        prevRecord === null ? this._itHead : prevRecord._next;\n    record._next = next;\n    record._prev = prevRecord;\n    if (next === null) {\n      this._itTail = record;\n    } else {\n      next._prev = record;\n    }\n    if (prevRecord === null) {\n      this._itHead = record;\n    } else {\n      prevRecord._next = record;\n    }\n\n    if (this._linkedRecords === null) {\n      this._linkedRecords = new _DuplicateMap<V>();\n    }\n    this._linkedRecords.put(record);\n\n    record.currentIndex = index;\n    return record;\n  }\n\n  /** @internal */\n  _remove(record: IterableChangeRecord_<V>): IterableChangeRecord_<V> {\n    return this._addToRemovals(this._unlink(record));\n  }\n\n  /** @internal */\n  _unlink(record: IterableChangeRecord_<V>): IterableChangeRecord_<V> {\n    if (this._linkedRecords !== null) {\n      this._linkedRecords.remove(record);\n    }\n\n    const prev = record._prev;\n    const next = record._next;\n\n    if (prev === null) {\n      this._itHead = next;\n    } else {\n      prev._next = next;\n    }\n    if (next === null) {\n      this._itTail = prev;\n    } else {\n      next._prev = prev;\n    }\n\n    return record;\n  }\n\n  /** @internal */\n  _addToMoves(record: IterableChangeRecord_<V>, toIndex: number): IterableChangeRecord_<V> {\n    if (record.previousIndex === toIndex) {\n      return record;\n    }\n\n    if (this._movesTail === null) {\n      this._movesTail = this._movesHead = record;\n    } else {\n      this._movesTail = this._movesTail._nextMoved = record;\n    }\n\n    return record;\n  }\n\n  private _addToRemovals(record: IterableChangeRecord_<V>): IterableChangeRecord_<V> {\n    if (this._unlinkedRecords === null) {\n      this._unlinkedRecords = new _DuplicateMap<V>();\n    }\n    this._unlinkedRecords.put(record);\n    record.currentIndex = null;\n    record._nextRemoved = null;\n\n    if (this._removalsTail === null) {\n      this._removalsTail = this._removalsHead = record;\n      record._prevRemoved = null;\n    } else {\n      record._prevRemoved = this._removalsTail;\n      this._removalsTail = this._removalsTail._nextRemoved = record;\n    }\n    return record;\n  }\n\n  /** @internal */\n  _addIdentityChange(record: IterableChangeRecord_<V>, item: V) {\n    record.item = item;\n    if (this._identityChangesTail === null) {\n      this._identityChangesTail = this._identityChangesHead = record;\n    } else {\n      this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;\n    }\n    return record;\n  }\n}\n\nexport class IterableChangeRecord_<V> implements IterableChangeRecord<V> {\n  currentIndex: number|null = null;\n  previousIndex: number|null = null;\n\n  /** @internal */\n  _nextPrevious: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _prev: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _next: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _prevDup: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _nextDup: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _prevRemoved: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _nextRemoved: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _nextAdded: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _nextMoved: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _nextIdentityChange: IterableChangeRecord_<V>|null = null;\n\n\n  constructor(public item: V, public trackById: any) {}\n}\n\n// A linked list of IterableChangeRecords with the same IterableChangeRecord_.item\nclass _DuplicateItemRecordList<V> {\n  /** @internal */\n  _head: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _tail: IterableChangeRecord_<V>|null = null;\n\n  /**\n   * Append the record to the list of duplicates.\n   *\n   * Note: by design all records in the list of duplicates hold the same value in record.item.\n   */\n  add(record: IterableChangeRecord_<V>): void {\n    if (this._head === null) {\n      this._head = this._tail = record;\n      record._nextDup = null;\n      record._prevDup = null;\n    } else {\n      this._tail!._nextDup = record;\n      record._prevDup = this._tail;\n      record._nextDup = null;\n      this._tail = record;\n    }\n  }\n\n  // Returns a IterableChangeRecord_ having IterableChangeRecord_.trackById == trackById and\n  // IterableChangeRecord_.currentIndex >= atOrAfterIndex\n  get(trackById: any, atOrAfterIndex: number|null): IterableChangeRecord_<V>|null {\n    let record: IterableChangeRecord_<V>|null;\n    for (record = this._head; record !== null; record = record._nextDup) {\n      if ((atOrAfterIndex === null || atOrAfterIndex <= record.currentIndex!) &&\n          Object.is(record.trackById, trackById)) {\n        return record;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Remove one {@link IterableChangeRecord_} from the list of duplicates.\n   *\n   * Returns whether the list of duplicates is empty.\n   */\n  remove(record: IterableChangeRecord_<V>): boolean {\n\n    const prev: IterableChangeRecord_<V>|null = record._prevDup;\n    const next: IterableChangeRecord_<V>|null = record._nextDup;\n    if (prev === null) {\n      this._head = next;\n    } else {\n      prev._nextDup = next;\n    }\n    if (next === null) {\n      this._tail = prev;\n    } else {\n      next._prevDup = prev;\n    }\n    return this._head === null;\n  }\n}\n\nclass _DuplicateMap<V> {\n  map = new Map<any, _DuplicateItemRecordList<V>>();\n\n  put(record: IterableChangeRecord_<V>) {\n    const key = record.trackById;\n\n    let duplicates = this.map.get(key);\n    if (!duplicates) {\n      duplicates = new _DuplicateItemRecordList<V>();\n      this.map.set(key, duplicates);\n    }\n    duplicates.add(record);\n  }\n\n  /**\n   * Retrieve the `value` using key. Because the IterableChangeRecord_ value may be one which we\n   * have already iterated over, we use the `atOrAfterIndex` to pretend it is not there.\n   *\n   * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we\n   * have any more `a`s needs to return the second `a`.\n   */\n  get(trackById: any, atOrAfterIndex: number|null): IterableChangeRecord_<V>|null {\n    const key = trackById;\n    const recordList = this.map.get(key);\n    return recordList ? recordList.get(trackById, atOrAfterIndex) : null;\n  }\n\n  /**\n   * Removes a {@link IterableChangeRecord_} from the list of duplicates.\n   *\n   * The list of duplicates also is removed from the map if it gets empty.\n   */\n  remove(record: IterableChangeRecord_<V>): IterableChangeRecord_<V> {\n    const key = record.trackById;\n    const recordList: _DuplicateItemRecordList<V> = this.map.get(key)!;\n    // Remove the list of duplicates when it gets empty\n    if (recordList.remove(record)) {\n      this.map.delete(key);\n    }\n    return record;\n  }\n\n  get isEmpty(): boolean {\n    return this.map.size === 0;\n  }\n\n  clear() {\n    this.map.clear();\n  }\n}\n\nfunction getPreviousIndex(item: any, addRemoveOffset: number, moveOffsets: number[]|null): number {\n  const previousIndex = item.previousIndex;\n  if (previousIndex === null) return previousIndex;\n  let moveOffset = 0;\n  if (moveOffsets && previousIndex < moveOffsets.length) {\n    moveOffset = moveOffsets[previousIndex];\n  }\n  return previousIndex + addRemoveOffset + moveOffset;\n}\n", "import {\n    Ancestor,\n    ComponentType,\n    PlaitBoard,\n    PlaitChildrenContext,\n    PlaitElement,\n    PlaitNode,\n    PlaitPluginElementContext\n} from '../interfaces';\nimport { NODE_TO_INDEX, NODE_TO_PARENT } from '../utils/weak-maps';\nimport { isSelectedElement, replaceSelectedElement } from '../utils/selected-element';\nimport { ElementFlavour } from './element/element-flavour';\nimport { DefaultIterableDiffer } from '../differs/default_iterable_differ';\nimport { IterableChangeRecord, IterableDiffer } from '../differs/iterable_differs';\nimport { isDebug } from '../utils/debug';\n\nexport class ListRender {\n    private children: PlaitElement[] = [];\n    private instances: ElementFlavour[] = [];\n    private contexts: PlaitPluginElementContext[] = [];\n    private differ: IterableDiffer<PlaitElement> | null = null;\n    public initialized = false;\n\n    constructor(private board: PlaitBoard) {}\n\n    public initialize(children: PlaitElement[], childrenContext: PlaitChildrenContext) {\n        this.initialized = true;\n        this.children = children;\n        children.forEach((descendant, index) => {\n            NODE_TO_INDEX.set(descendant, index);\n            NODE_TO_PARENT.set(descendant, childrenContext.parent);\n            const context = getContext(this.board, descendant, index, childrenContext.parent);\n            const componentType = getComponentType(this.board, context);\n            const instance = createPluginComponent(this.board, componentType, context, childrenContext);\n            this.instances.push(instance);\n            this.contexts.push(context);\n        });\n        this.differ = new DefaultIterableDiffer<PlaitElement>(trackBy);\n        this.differ.diff(children);\n    }\n\n    public update(children: PlaitElement[], childrenContext: PlaitChildrenContext) {\n        if (!this.initialized) {\n            this.initialize(children, childrenContext);\n            return;\n        }\n        if (!this.differ) {\n            throw new Error('Exception: Can not find differ ');\n        }\n        const { board, parent } = childrenContext;\n        const diffResult = this.differ.diff(children);\n        if (diffResult) {\n            const newContexts: PlaitPluginElementContext[] = [];\n            const newInstances: ElementFlavour[] = [];\n            // for moving scene: the current index for first element before moving\n            let currentIndexForFirstElement: number | null = null;\n            diffResult.forEachItem((record: IterableChangeRecord<PlaitElement>) => {\n                NODE_TO_INDEX.set(record.item, record.currentIndex as number);\n                NODE_TO_PARENT.set(record.item, childrenContext.parent);\n                const previousContext = record.previousIndex === null ? undefined : this.contexts[record.previousIndex];\n                const context = getContext(board, record.item, record.currentIndex as number, parent, previousContext);\n                if (record.previousIndex === null) {\n                    const componentType = getComponentType(board, context);\n                    const componentRef = createPluginComponent(board, componentType, context, childrenContext);\n                    newContexts.push(context);\n                    newInstances.push(componentRef);\n                } else {\n                    const instance = this.instances[record.previousIndex];\n                    instance.context = context;\n                    newInstances.push(instance);\n                    newContexts.push(context);\n                }\n                // item might has been changed, so need to compare the id\n                if (record.item === this.children[0] || record.item.id === this.children[0]?.id) {\n                    currentIndexForFirstElement = record.currentIndex;\n                }\n            });\n            diffResult.forEachOperation(record => {\n                // removed\n                if (record.currentIndex === null) {\n                    const componentRef = this.instances[record.previousIndex as number];\n                    componentRef?.destroy();\n                }\n                // moved\n                if (record.previousIndex !== null && record.currentIndex !== null) {\n                    mountOnItemMove(record.item, record.currentIndex, childrenContext, currentIndexForFirstElement);\n                }\n            });\n            this.instances = newInstances;\n            this.contexts = newContexts;\n            this.children = children;\n        } else {\n            const newContexts: PlaitPluginElementContext[] = [];\n            this.children.forEach((element, index) => {\n                NODE_TO_INDEX.set(element, index);\n                NODE_TO_PARENT.set(element, childrenContext.parent);\n                const previousContext = this.contexts[index];\n                const previousInstance = this.instances[index];\n                const context = getContext(board, element, index, parent, previousContext);\n                previousInstance.context = context;\n                newContexts.push(context);\n            });\n            this.contexts = newContexts;\n        }\n    }\n\n    public destroy() {\n        this.children.forEach((element: PlaitElement, index: number) => {\n            if (this.instances[index]) {\n                this.instances[index].destroy();\n            }\n        });\n        this.instances = [];\n        this.children = [];\n        this.contexts = [];\n        this.initialized = false;\n        this.differ = null;\n    }\n}\n\nconst trackBy = (index: number, element: PlaitElement) => {\n    return element.id;\n};\n\nconst createPluginComponent = (\n    board: PlaitBoard,\n    componentType: ComponentType<ElementFlavour>,\n    context: PlaitPluginElementContext,\n    childrenContext: PlaitChildrenContext\n) => {\n    const instance = new componentType();\n    instance.context = context;\n    board.normalizeElement(context);\n    try {\n        instance.initialize();\n    } catch (error) {\n        if (isDebug()) {\n            console.error('list-render-initialize', error, 'context', context);\n        }\n    }\n    const g = instance.getContainerG();\n    mountElementG(context.index, g, childrenContext);\n    instance.initializeListRender();\n    return instance;\n};\n\nconst getComponentType = (board: PlaitBoard, context: PlaitPluginElementContext) => {\n    const result = board.drawElement(context);\n    return result;\n};\n\nconst getContext = (\n    board: PlaitBoard,\n    element: PlaitElement,\n    index: number,\n    parent: Ancestor,\n    previousContext?: PlaitPluginElementContext\n): PlaitPluginElementContext => {\n    let isSelected = isSelectedElement(board, element);\n    const previousElement = previousContext && previousContext.element;\n    if (previousElement && previousElement !== element && isSelectedElement(board, previousElement)) {\n        isSelected = true;\n        replaceSelectedElement(board, previousElement, element);\n    }\n    const context: PlaitPluginElementContext = {\n        element: element,\n        parent: parent,\n        board: board,\n        selected: isSelected,\n        index,\n        hasThemeChanged: !!board.operations?.find(op => op.type === 'set_theme')\n    };\n    return context;\n};\n\n// the g depth of root element[1]-[2]-[3]-[4]\n// the g depth of root element and children elementthe [2] element has children\n// [1]-\n// [2]([2-1-1][2-1-2][2-1][2-2][2-3-1][2-3-2][2-3][2])-\n// [3]-\n// [4]\nexport const mountElementG = (\n    index: number,\n    g: SVGGElement,\n    childrenContext: PlaitChildrenContext,\n    // for moving scene: the current index for first element before moving\n    currentIndexForFirstElement: number | null = null\n) => {\n    const { parent, parentG } = childrenContext;\n    if (PlaitBoard.isBoard(parent)) {\n        if (index > 0) {\n            const previousElement = parent.children[index - 1];\n            const previousContainerG = PlaitElement.getContainerG(previousElement, { suppressThrow: false });\n            previousContainerG.insertAdjacentElement('afterend', g);\n        } else {\n            if (currentIndexForFirstElement !== null) {\n                const firstElement = parent.children[currentIndexForFirstElement];\n                const firstContainerG = firstElement && PlaitElement.getContainerG(firstElement, { suppressThrow: true });\n                if (firstElement && firstContainerG) {\n                    parentG.insertBefore(g, firstContainerG);\n                } else {\n                    throw new Error('fail to mount container on moving');\n                }\n            } else {\n                parentG.append(g);\n            }\n        }\n    } else {\n        if (index > 0) {\n            const previousElement = (parent.children as PlaitElement[])[index - 1];\n            const previousElementG = PlaitElement.getElementG(previousElement);\n            previousElementG.insertAdjacentElement('afterend', g);\n        } else {\n            if (currentIndexForFirstElement) {\n                const nextElement = (parent.children as PlaitElement[])[currentIndexForFirstElement];\n                const nextPath = nextElement && PlaitBoard.findPath(childrenContext.board, nextElement);\n                const first = nextPath && PlaitNode.first(childrenContext.board, nextPath);\n                const firstContainerG = first && PlaitElement.getContainerG(first, { suppressThrow: false });\n                if (firstContainerG) {\n                    parentG.insertBefore(g, firstContainerG);\n                } else {\n                    throw new Error('fail to mount container on moving');\n                }\n            } else {\n                let parentElementG = PlaitElement.getElementG(parent);\n                parentG.insertBefore(g, parentElementG);\n            }\n        }\n    }\n};\n\nconst mountOnItemMove = (\n    element: PlaitElement,\n    index: number,\n    childrenContext: PlaitChildrenContext,\n    currentIndexForFirstElement: number | null\n) => {\n    const containerG = PlaitElement.getContainerG(element, { suppressThrow: false });\n    mountElementG(index, containerG, childrenContext, currentIndexForFirstElement);\n    if (element.children && !PlaitElement.isRootElement(element) && childrenContext.board.isExpanded(element)) {\n        element.children.forEach((child, index) => {\n            mountOnItemMove(child, index, { ...childrenContext, parent: element }, null);\n        });\n    }\n};\n", "/**\n *  element-flavour  Angular \n */\n\nimport { PlaitBoard, PlaitChildrenContext, PlaitElement, PlaitNode, PlaitPluginElementContext } from '../../interfaces';\nimport { removeSelectedElement } from '../../utils/selected-element';\nimport { createG } from '../../utils/dom/common';\nimport { hasBeforeContextChange, hasOnContextChanged } from './context-change';\nimport { ListRender } from '../list-render';\nimport { ELEMENT_TO_REF, NODE_TO_CONTAINER_G, NODE_TO_G } from '../../utils/weak-maps';\nimport { PlaitElementRef } from './element-ref';\nimport { getElementMap } from '../../utils/element';\n\nexport class ElementFlavour<\n    T extends PlaitElement = PlaitElement,\n    K extends PlaitBoard = PlaitBoard,\n    R extends PlaitElementRef = PlaitElementRef\n> {\n    private _g!: SVGGElement;\n\n    private _containerG!: SVGGElement;\n\n    // children elements's render need rootContainerG\n    // the value of rootContainerG come from the containerG of root element\n    private _rootContainerG?: SVGGElement;\n\n    initialized = false;\n\n    protected _context!: PlaitPluginElementContext<T, K>;\n\n    get hasChildren() {\n        return !!this.element.children;\n    }\n\n    set context(value: PlaitPluginElementContext<T, K>) {\n        if (hasBeforeContextChange<T, K>(this)) {\n            this.beforeContextChange(value);\n        }\n        const previousContext = this._context;\n        this._context = value;\n        if (this.initialized) {\n            const elementG = this.getElementG();\n            const containerG = this.getContainerG();\n            NODE_TO_G.set(this.element, elementG);\n            NODE_TO_CONTAINER_G.set(this.element, containerG);\n            getElementMap(this.board).set(this.element.id, this.element);\n            ELEMENT_TO_REF.set(this.element, this.ref);\n            this.updateListRender();\n            if (hasOnContextChanged<T>(this)) {\n                this.onContextChanged(value, previousContext);\n            }\n        } else {\n            if (PlaitElement.isRootElement(this.element) && this.hasChildren) {\n                this._g = createG();\n                this._containerG = createG();\n                this._containerG.append(this._g);\n            } else {\n                this._g = createG();\n                this._containerG = this._g;\n            }\n            NODE_TO_G.set(this.element, this._g);\n            NODE_TO_CONTAINER_G.set(this.element, this._containerG);\n            ELEMENT_TO_REF.set(this.element, this.ref);\n            getElementMap(this.board).set(this.element.id, this.element);\n        }\n    }\n\n    get context() {\n        return this._context;\n    }\n\n    get element() {\n        return this.context && this.context.element;\n    }\n\n    get board() {\n        return this.context && this.context.board;\n    }\n\n    get selected() {\n        return this.context && this.context.selected;\n    }\n\n    listRender?: ListRender;\n\n    getContainerG() {\n        return this._containerG;\n    }\n\n    getElementG() {\n        return this._g;\n    }\n\n    constructor(private ref: R) {}\n\n    initialize() {\n        if (this.element.type) {\n            this.getContainerG().setAttribute(`plait-${this.element.type}`, 'true');\n        }\n        if (this.hasChildren) {\n            if (PlaitElement.isRootElement(this.element)) {\n                this._rootContainerG = this._containerG;\n            } else {\n                const path = PlaitBoard.findPath(this.board, this.element);\n                const rootNode = PlaitNode.get(this.board, path.slice(0, 1));\n                this._rootContainerG = PlaitElement.getContainerG(rootNode, { suppressThrow: false });\n            }\n        }\n        this.getContainerG().setAttribute('plait-data-id', this.element.id);\n        this.initialized = true;\n    }\n\n    public initializeListRender() {\n        if (this.hasChildren) {\n            this.listRender = new ListRender(this.board);\n            if (this.board.isExpanded(this.element)) {\n                this.listRender.initialize(this.element.children!, this.initializeChildrenContext());\n            }\n        }\n    }\n\n    public getRef() {\n        return this.ref;\n    }\n\n    private updateListRender() {\n        if (this.hasChildren) {\n            if (!this.listRender) {\n                throw new Error('incorrectly initialize list render');\n            }\n            if (this.board.isExpanded(this.element)) {\n                this.listRender.update(this.element.children!, this.initializeChildrenContext());\n            } else {\n                if (this.listRender.initialized) {\n                    this.listRender.destroy();\n                }\n            }\n        }\n    }\n\n    private initializeChildrenContext(): PlaitChildrenContext {\n        if (!this._rootContainerG) {\n            throw new Error('can not resolve root container g');\n        }\n        return {\n            board: this.board,\n            parent: this.element,\n            parentG: this._rootContainerG\n        };\n    }\n\n    destroy() {\n        if (NODE_TO_G.get(this.element) === this._g) {\n            NODE_TO_G.delete(this.element);\n        }\n        getElementMap(this.board).delete(this.element.id);\n        if (NODE_TO_CONTAINER_G.get(this.element) === this._containerG) {\n            NODE_TO_CONTAINER_G.delete(this.element);\n        }\n        if (ELEMENT_TO_REF.get(this.element) === this.ref) {\n            ELEMENT_TO_REF.set(this.element, this.ref);\n        }\n        removeSelectedElement(this.board, this.element);\n        this.getContainerG().remove();\n        this.listRender?.destroy();\n    }\n}\n", "import { Subject } from 'rxjs';\nimport { ImageEntry } from './interfaces/element';\n\nexport class PlaitBoardContext {\n    private _stable = new Subject();\n\n    private uploadingFiles: ImageEntry[] = [];\n\n    getUploadingFile(url: string) {\n        return this.uploadingFiles.find(file => file.url === url);\n    }\n\n    setUploadingFile(file: ImageEntry) {\n        return this.uploadingFiles.push(file);\n    }\n\n    removeUploadingFile(fileEntry: ImageEntry) {\n        this.uploadingFiles = this.uploadingFiles.filter(file => file.url !== fileEntry.url);\n    }\n\n    onStable() {\n        return this._stable.asObservable();\n    }\n\n    nextStable() {\n        this._stable.next('');\n    }\n}\n", "import { PlaitOperation } from './operation';\nimport { Path } from './path';\n\nexport interface PathRef {\n    current: Path | null;\n    affinity: 'forward' | 'backward' | null;\n    unref(): Path | null;\n}\n\nexport interface PathRefOptions {\n    affinity?: 'forward' | 'backward' | null;\n}\n\nexport const PathRef = {\n    transform(ref: PathRef, op: PlaitOperation): void {\n        const { current } = ref;\n\n        if (current == null) {\n            return;\n        }\n\n        const path = Path.transform(current, op);\n        ref.current = path;\n\n        if (path == null) {\n            ref.unref();\n        }\n    }\n};\n", "import { PlaitBoard, PlaitBoardOptions } from '../interfaces/board';\nimport { PlaitPointerType } from '../interfaces/pointer';\nimport { PlaitElement } from '../interfaces/element';\nimport { PlaitPluginElementContext } from '../core/element/context';\nimport { PlaitOperation } from '../interfaces/operation';\nimport { Transforms } from '../transforms';\nimport { FLUSHING, PATH_REFS } from '../utils/weak-maps';\nimport { PathRef, PathRefOptions } from '../interfaces/path-ref';\nimport { Path } from '../interfaces/path';\nimport { ThemeColorMode } from '../interfaces/theme';\nimport { CoreTransforms } from '../transforms/element';\nimport { ClipboardData, WritableClipboardContext, WritableClipboardOperationType, drawSelectionRectangleG } from '../utils';\nimport { Point, RectangleClient } from '../interfaces';\n\nexport function createBoard(children: PlaitElement[], options?: PlaitBoardOptions): PlaitBoard {\n    const board: PlaitBoard = {\n        viewport: {\n            zoom: 1\n        },\n        children,\n        theme: { themeColorMode: ThemeColorMode.default },\n        operations: [],\n        history: {\n            redos: [],\n            undos: []\n        },\n        selection: null,\n        options: options || {\n            readonly: false,\n            hideScrollbar: false,\n            disabledScrollOnNonFocus: false\n        },\n        pointer: options?.readonly ? PlaitPointerType.hand : PlaitPointerType.selection,\n        undo: () => {},\n        redo: () => {},\n        apply: (operation: PlaitOperation) => {\n            for (const ref of board.pathRefs()) {\n                PathRef.transform(ref, operation);\n            }\n\n            board.operations.push(operation);\n\n            Transforms.transform(board, operation);\n\n            if (!FLUSHING.get(board)) {\n                FLUSHING.set(board, true);\n\n                Promise.resolve().then(() => {\n                    FLUSHING.set(board, false);\n                    board.onChange();\n                    board.afterChange();\n                    board.operations = [];\n                });\n            }\n        },\n        pathRef: (path: Path, options?: PathRefOptions) => {\n            const affinity = options?.affinity || 'forward';\n            const ref: PathRef = {\n                current: path,\n                affinity,\n                unref() {\n                    const { current } = ref;\n                    const pathRefs = board.pathRefs();\n                    pathRefs.delete(ref);\n                    ref.current = null;\n                    return current;\n                }\n            };\n\n            const refs = board.pathRefs();\n            refs.add(ref);\n            return ref;\n        },\n        pathRefs: () => {\n            let refs = PATH_REFS.get(board);\n\n            if (!refs) {\n                refs = new Set();\n                PATH_REFS.set(board, refs);\n            }\n\n            return refs;\n        },\n        onChange: () => {},\n        afterChange: () => {},\n        drawSelectionRectangle: () => {\n            return drawSelectionRectangleG(board);\n        },\n        mousedown: (event: MouseEvent) => {},\n        mousemove: (event: MouseEvent) => {},\n        mouseleave: (event: MouseEvent) => {},\n        globalMousemove: (event: MouseEvent) => {},\n        mouseup: (event: MouseEvent) => {},\n        globalMouseup: (event: MouseEvent) => {},\n        keyDown: (event: KeyboardEvent) => {},\n        globalKeyDown: (event: KeyboardEvent) => {},\n        keyUp: (event: KeyboardEvent) => {},\n        dblClick: (event: MouseEvent) => {},\n        buildFragment: (\n            clipboardContext: WritableClipboardContext | null,\n            rectangle: RectangleClient | null,\n            operationType: WritableClipboardOperationType,\n            originData?: PlaitElement[]\n        ) => clipboardContext,\n        insertFragment: (clipboardData: ClipboardData | null, targetPoint: Point, operationType?: WritableClipboardOperationType) => {},\n        deleteFragment: (elements: PlaitElement[]) => {\n            CoreTransforms.removeElements(board, elements);\n        },\n        getDeletedFragment: (data: PlaitElement[]) => data,\n        getRelatedFragment: (data: PlaitElement[], originData?: PlaitElement[]) => data,\n        normalizeElement: (context: PlaitPluginElementContext) => {},\n        drawElement: (context: PlaitPluginElementContext) => {\n            throw new Error(`can not resolve plugin element component type: ${context.element.type}`);\n        },\n        isWithinSelection: (element) => false,\n        isRectangleHit: (element) => false,\n        isHit: (element) => false,\n        isInsidePoint: (element) => false,\n        getOneHitElement: (data: PlaitElement[]) => data[0],\n        isRecursion: (element) => true,\n        isMovable: (element) => false,\n        getRectangle: (element) => null,\n        applyTheme: (element: PlaitElement) => {},\n        isAlign: (element) => false,\n        pointerDown: (pointer) => {},\n        pointerMove: (pointer) => {},\n        pointerUp: (pointer) => {},\n        pointerCancel: (pointer) => {},\n        pointerOut: (pointer) => {},\n        pointerLeave: (pointer) => {},\n        globalPointerMove: (pointer) => {},\n        globalPointerUp: (pointer) => {},\n        drop: (event: DragEvent) => {\n            return false;\n        },\n        isImageBindingAllowed: (element: PlaitElement) => false,\n        canAddToGroup: (element: PlaitElement) => true,\n        canSetZIndex: (element: PlaitElement) => true,\n        isExpanded: (element: PlaitElement) => true\n    };\n    return board;\n}\n", "import { BOARD_TO_ON_CHANGE, BOARD_TO_AFTER_CHANGE } from '../utils/weak-maps';\nimport { PlaitBoard } from '../interfaces/board';\n\nexport function withBoard(board: PlaitBoard) {\n    const { onChange, afterChange } = board;\n\n    board.onChange = () => {\n        const onContextChange = BOARD_TO_ON_CHANGE.get(board);\n        if (onContextChange) {\n            onContextChange();\n        }\n        onChange();\n    };\n\n    board.afterChange = () => {\n        const afterContextChange = BOARD_TO_AFTER_CHANGE.get(board);\n        if (afterContextChange) {\n            afterContextChange();\n        }\n        afterChange();\n    }\n\n    return board;\n}\n", "import { PlaitBoard, PlaitPointerType } from '../interfaces';\nimport { isMobileDeviceEvent } from './pointer';\n\nexport const isSmartHand = (board: PlaitBoard, event: PointerEvent) => {\n    return PlaitBoard.isPointer(board, PlaitPointerType.selection) && isMobileDeviceEvent(event);\n};\n", "import { DRAG_SELECTION_PRESS_AND_MOVE_BUFFER } from '../constants';\nimport { PlaitPointerType, PlaitBoard, PlaitBoardMove, WithHandPluginOptions, PlaitPluginKey } from '../interfaces';\nimport {\n    distanceBetweenPointAndPoint,\n    isHitElement,\n    isMovingElements,\n    isSelectionMoving,\n    setSelectionOptions,\n    toHostPoint,\n    toViewBoxPoint\n} from '../utils';\nimport { isMainPointer, isWheelPointer } from '../utils/dom/common';\nimport { isSmartHand } from '../utils/mobile';\nimport { updateViewportContainerScroll } from '../utils/viewport';\nimport { PlaitOptionsBoard } from './with-options';\n\nconst ShortcutKey = 'Space';\n\nexport function withHandPointer<T extends PlaitBoard>(board: T) {\n    const { pointerDown, pointerMove, globalPointerUp, keyDown, keyUp, pointerUp } = board;\n    let isHandMoving: boolean = false;\n    let movingPoint: PlaitBoardMove | null = null;\n    let pointerDownEvent: PointerEvent | null = null;\n    let hasWheelPressed = false;\n    let beingPressedShortcutKey = false;\n\n    board.pointerDown = (event: PointerEvent) => {\n        const options = (board as unknown as PlaitOptionsBoard).getPluginOptions<WithHandPluginOptions>(PlaitPluginKey.withHand);\n        const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n        const isHitTarget = isHitElement(board, point);\n        const canEnterHandMode =\n            options?.isHandMode(board, event) ||\n            PlaitBoard.isPointer(board, PlaitPointerType.hand) ||\n            (isSmartHand(board, event) && !isHitTarget) ||\n            beingPressedShortcutKey;\n        if (canEnterHandMode && isMainPointer(event)) {\n            movingPoint = {\n                x: event.x,\n                y: event.y\n            };\n            if (!PlaitBoard.isPointer(board, PlaitPointerType.hand)) {\n                PlaitBoard.getBoardContainer(board).classList.add('viewport-moving');\n            }\n        } else if (isWheelPointer(event)) {\n            hasWheelPressed = true;\n            // Prevent the browser's default behavior of scrolling the page when the mouse wheel is pressed.\n            event.preventDefault();\n            movingPoint = {\n                x: event.x,\n                y: event.y\n            };\n            isHandMoving = true;\n            PlaitBoard.getBoardContainer(board).classList.add('viewport-moving');\n        }\n        pointerDownEvent = event;\n        pointerDown(event);\n    };\n\n    board.pointerMove = (event: PointerEvent) => {\n        const options = (board as unknown as PlaitOptionsBoard).getPluginOptions<WithHandPluginOptions>(PlaitPluginKey.withHand);\n        //  withSelection  pointerMove  PRESS_AND_MOVE_BUFFER\n        // 1. \n        // 2.  withHand \n        // Must exceed the DRAG_SELECTION_PRESS_AND_MOVE_BUFFER threshold defined in withSelection's pointerMove.\n        // The system first checks for drag selection state eligibility\n        // withHand behavior is only triggered if drag selection state is not initiated.\n        const triggerDistance = DRAG_SELECTION_PRESS_AND_MOVE_BUFFER + 4;\n        if (\n            movingPoint &&\n            !isHandMoving &&\n            !isSelectionMoving(board) &&\n            pointerDownEvent &&\n            distanceBetweenPointAndPoint(pointerDownEvent.x, pointerDownEvent.y, event.x, event.y) > triggerDistance &&\n            !isMovingElements(board)\n        ) {\n            isHandMoving = true;\n            PlaitBoard.getBoardContainer(board).classList.add('viewport-moving');\n        }\n        const canEnterHandMode =\n            options?.isHandMode(board, event) ||\n            PlaitBoard.isPointer(board, PlaitPointerType.hand) ||\n            isSmartHand(board, event) ||\n            hasWheelPressed ||\n            beingPressedShortcutKey;\n        if (canEnterHandMode && isHandMoving && movingPoint && !isSelectionMoving(board) && !isMovingElements(board)) {\n            const viewportContainer = PlaitBoard.getViewportContainer(board);\n            const left = viewportContainer.scrollLeft - (event.x - movingPoint.x);\n            const top = viewportContainer.scrollTop - (event.y - movingPoint.y);\n            updateViewportContainerScroll(board, left, top, false);\n            movingPoint.x = event.x;\n            movingPoint.y = event.y;\n        }\n        pointerMove(event);\n    };\n\n    board.pointerUp = (event: PointerEvent) => {\n        if (isHandMoving) {\n            return;\n        }\n        pointerUp(event);\n    };\n\n    board.globalPointerUp = (event: PointerEvent) => {\n        if (movingPoint) {\n            movingPoint = null;\n        }\n        isHandMoving = false;\n        PlaitBoard.getBoardContainer(board).classList.remove('viewport-moving');\n        hasWheelPressed = false;\n        globalPointerUp(event);\n    };\n\n    board.keyDown = (event: KeyboardEvent) => {\n        if (event.code === ShortcutKey) {\n            if (!board.options.readonly && !PlaitBoard.isPointer(board, PlaitPointerType.hand)) {\n                beingPressedShortcutKey = true;\n                setSelectionOptions(board, { isDisabledSelection: true });\n                PlaitBoard.getBoardContainer(board).classList.add('viewport-moving');\n            }\n            event.preventDefault();\n        }\n        keyDown(event);\n    };\n\n    board.keyUp = (event: KeyboardEvent) => {\n        if (!board.options.readonly && event.code === ShortcutKey) {\n            beingPressedShortcutKey = false;\n            setSelectionOptions(board, { isDisabledSelection: false });\n            PlaitBoard.getBoardContainer(board).classList.remove('viewport-moving');\n        }\n        keyUp(event);\n    };\n\n    return board;\n}\n", "import { PlaitBoard, PlaitOperation } from '../interfaces';\nimport { isHotkey } from 'is-hotkey';\nimport { PlaitHistoryBoard, shouldClear, shouldMerge, shouldSave } from '../utils';\n\nexport function withHistory<T extends PlaitBoard>(board: T) {\n    const { apply, keyDown } = board;\n    board.history = { undos: [], redos: [] };\n\n    board.redo = () => {\n        const { history } = board;\n        const { redos } = history;\n\n        if (redos.length > 0) {\n            const batch = redos[redos.length - 1];\n\n            PlaitHistoryBoard.withoutSaving(board, () => {\n                for (const op of batch) {\n                    board.apply(op);\n                }\n            });\n\n            history.redos.pop();\n            history.undos.push(batch);\n        }\n    };\n\n    board.undo = () => {\n        const { history } = board;\n        const { undos } = history;\n\n        if (undos.length > 0) {\n            const batch = undos[undos.length - 1];\n\n            PlaitHistoryBoard.withoutSaving(board, () => {\n                const inverseOps = batch.map(PlaitOperation.inverse).reverse();\n                for (const op of inverseOps) {\n                    board.apply(op);\n                }\n            });\n\n            history.redos.push(batch);\n            history.undos.pop();\n        }\n    };\n\n    board.apply = (op: PlaitOperation) => {\n        const { operations, history } = board;\n        const { undos } = history;\n        const lastBatch = undos[undos.length - 1];\n        const lastOp = lastBatch && lastBatch[lastBatch.length - 1];\n        let save = PlaitHistoryBoard.isSaving(board);\n        let merge = PlaitHistoryBoard.isMerging(board);\n\n        if (save == null) {\n            save = shouldSave(op, lastOp);\n        }\n\n        if (save) {\n            if (!merge) {\n                if (lastBatch == null) {\n                    merge = false;\n                } else if (operations.length !== 0) {\n                    merge = true;\n                } else {\n                    merge = shouldMerge(op, lastOp);\n                }\n            }\n\n            if (PlaitHistoryBoard.isSplittingOnce(board)) {\n                merge = false;\n                PlaitHistoryBoard.setSplittingOnce(board, undefined);\n            }\n\n            if (lastBatch && merge) {\n                lastBatch.push(op);\n            } else {\n                const batch = [op];\n                undos.push(batch);\n            }\n\n            while (undos.length > 100) {\n                undos.shift();\n            }\n\n            if (shouldClear(op)) {\n                history.redos = [];\n            }\n        }\n        apply(op);\n    };\n\n    board.keyDown = (event: KeyboardEvent) => {\n        if (isHotkey('mod+z', event)) {\n            board.undo();\n            return;\n        }\n        if (isHotkey('mod+shift+z', event)) {\n            board.redo();\n            return;\n        }\n        keyDown(event);\n    };\n\n    return board;\n}\n", "import { isHotkey, isKeyHotkey } from 'is-hotkey';\nimport { Ancestor, PlaitBoard, PlaitElement, PlaitPluginKey, WithSelectionPluginOptions } from '../interfaces';\nimport { BoardTransforms, Transforms } from '../transforms';\nimport { deleteFragment, depthFirstRecursion, duplicateElements, getSelectedElements, hotkeys } from '../utils';\nimport { PlaitOptionsBoard } from './with-options';\n\nexport const withHotkey = (board: PlaitBoard) => {\n    const { keyDown, keyUp, globalKeyDown } = board;\n\n    board.keyDown = (event: KeyboardEvent) => {\n        const options = (board as PlaitOptionsBoard).getPluginOptions<WithSelectionPluginOptions>(PlaitPluginKey.withSelection);\n        if (!PlaitBoard.isReadonly(board) && options.isMultipleSelection && isHotkey('mod+a', event)) {\n            event.preventDefault();\n            let elements: PlaitElement[] = [];\n            depthFirstRecursion<Ancestor>(\n                board,\n                node => {\n                    if (PlaitBoard.isBoard(node)) {\n                        return;\n                    }\n                    elements.push(node as PlaitElement);\n                },\n                node => {\n                    if (PlaitBoard.isBoard(node) || board.isRecursion(node)) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                },\n                true\n            );\n            Transforms.addSelectionWithTemporaryElements(board, elements);\n            return;\n        }\n        if (!PlaitBoard.isReadonly(board)) {\n            if (isKeyHotkey('mod+]', event)) {\n                event.preventDefault();\n                Transforms.moveUp(board);\n                return;\n            }\n            if (isKeyHotkey('mod+[', event)) {\n                event.preventDefault();\n                Transforms.moveDown(board);\n                return;\n            }\n            if (isKeyHotkey('mod+option+', event)) {\n                event.preventDefault();\n                Transforms.moveToTop(board);\n                return;\n            }\n            if (isKeyHotkey('mod+option+', event)) {\n                event.preventDefault();\n                Transforms.moveToBottom(board);\n                return;\n            }\n        }\n\n        const selectedElements = getSelectedElements(board);\n        if (!PlaitBoard.isReadonly(board) && selectedElements.length > 0) {\n            if (isKeyHotkey('mod+d', event)) {\n                event.preventDefault();\n                duplicateElements(board);\n                return;\n            }\n        }\n        if (\n            !PlaitBoard.isReadonly(board) &&\n            selectedElements.length > 0 &&\n            (hotkeys.isDeleteBackward(event) || hotkeys.isDeleteForward(event))\n        ) {\n            event.preventDefault();\n            deleteFragment(board);\n        }\n\n        keyDown(event);\n    };\n\n    board.keyUp = (event: KeyboardEvent) => {\n        keyUp(event);\n    };\n\n    board.globalKeyDown = (event: KeyboardEvent) => {\n        if (PlaitBoard.getMovingPointInBoard(board) || PlaitBoard.isMovingPointInBoard(board)) {\n            if (isHotkey(['mod+=', 'mod++'], { byKey: true })(event)) {\n                event.preventDefault();\n                BoardTransforms.updateZoom(board, board.viewport.zoom + 0.1);\n                return;\n            }\n            if (isHotkey(['mod+shift+=', 'mod+shift++'], { byKey: true })(event)) {\n                event.preventDefault();\n                BoardTransforms.fitViewport(board);\n                return;\n            }\n            if (isHotkey(['mod+-', 'mod+shift+-'])(event)) {\n                event.preventDefault();\n                BoardTransforms.updateZoom(board, board.viewport.zoom - 0.1);\n                return;\n            }\n            if (isHotkey(['mod+0', 'mod+shift+0'], { byKey: true })(event)) {\n                event.preventDefault();\n                BoardTransforms.updateZoom(board, 1);\n                return;\n            }\n        }\n        globalKeyDown(event);\n    };\n\n    return board;\n};\n", "import { PlaitBoard } from '../../interfaces/board';\nimport { createG } from '../dom/common';\nimport { PlaitElement } from '../../interfaces/element';\nimport { Point, RectangleClient } from '../../interfaces';\nimport {\n    drawPointSnapLines,\n    drawSolidLines,\n    GapSnapRef,\n    getMinPointDelta,\n    getSnapRectangles,\n    getTripleAxis,\n    SNAP_TOLERANCE,\n    SnapDelta,\n    SnapRef\n} from './snap';\n\nexport function getSnapMovingRef(board: PlaitBoard, activeRectangle: RectangleClient, activeElements: PlaitElement[]): SnapRef {\n    const snapRectangles = getSnapRectangles(board, activeElements);\n    const snapG = createG();\n    let snapDelta = getPointLineDelta(activeRectangle, snapRectangles);\n    const pointLinesG = drawMovingPointSnapLines(board, snapDelta, activeRectangle, snapRectangles);\n    snapG.append(pointLinesG);\n    const result = getGapSnapLinesAndDelta(board, snapDelta, activeRectangle, snapRectangles);\n    snapDelta = result.snapDelta;\n    snapG.append(result.snapG);\n    return { ...snapDelta, snapG };\n}\n\nfunction getPointLineDeltas(activeRectangle: RectangleClient, snapRectangles: RectangleClient[], isHorizontal: boolean) {\n    const axis = getTripleAxis(activeRectangle, isHorizontal);\n    const deltaStart = getMinPointDelta(snapRectangles, axis[0], isHorizontal);\n    const deltaMiddle = getMinPointDelta(snapRectangles, axis[1], isHorizontal);\n    const deltaEnd = getMinPointDelta(snapRectangles, axis[2], isHorizontal);\n    return [deltaStart, deltaMiddle, deltaEnd];\n}\n\nfunction getPointLineDelta(activeRectangle: RectangleClient, snapRectangles: RectangleClient[]) {\n    let snapDelta: SnapDelta = {\n        deltaX: 0,\n        deltaY: 0\n    };\n    function getDelta(isHorizontal: boolean) {\n        let delta = 0;\n        const deltas = getPointLineDeltas(activeRectangle, snapRectangles, isHorizontal);\n        for (let i = 0; i < deltas.length; i++) {\n            if (Math.abs(deltas[i]) < SNAP_TOLERANCE) {\n                delta = deltas[i];\n                break;\n            }\n        }\n        return delta;\n    }\n    snapDelta.deltaX = getDelta(true);\n    snapDelta.deltaY = getDelta(false);\n    return snapDelta;\n}\n\nfunction updateActiveRectangle(snapDelta: SnapDelta, activeRectangle: RectangleClient) {\n    const { deltaX, deltaY } = snapDelta;\n    const { x, y, width, height } = activeRectangle;\n    return {\n        x: x + deltaX,\n        y: y + deltaY,\n        width,\n        height\n    };\n}\n\nfunction drawMovingPointSnapLines(\n    board: PlaitBoard,\n    snapDelta: SnapDelta,\n    activeRectangle: RectangleClient,\n    snapRectangles: RectangleClient[]\n) {\n    const newActiveRectangle = updateActiveRectangle(snapDelta, activeRectangle);\n    return drawPointSnapLines(board, newActiveRectangle, snapRectangles, true, true, true);\n}\n\nfunction getGapSnapLinesAndDelta(\n    board: PlaitBoard,\n    snapDelta: SnapDelta,\n    activeRectangle: RectangleClient,\n    snapRectangles: RectangleClient[]\n) {\n    let deltaX = snapDelta.deltaX;\n    let deltaY = snapDelta.deltaY;\n    const gapHorizontalResult = getGapLinesAndDelta(activeRectangle, snapRectangles, true);\n    const gapVerticalResult = getGapLinesAndDelta(activeRectangle, snapRectangles, false);\n    const gapSnapLines: Point[][] = [...gapHorizontalResult.lines, ...gapVerticalResult.lines];\n    if (gapHorizontalResult.delta) {\n        deltaX = gapHorizontalResult.delta;\n    }\n    if (gapVerticalResult.delta) {\n        deltaY = gapVerticalResult.delta;\n    }\n    return {\n        snapDelta: { deltaX, deltaY },\n        snapG: drawSolidLines(board, gapSnapLines)\n    };\n}\n\nfunction getGapLinesAndDelta(activeRectangle: RectangleClient, snapRectangles: RectangleClient[], isHorizontal: boolean) {\n    let lines: any[] = [];\n    let delta = 0;\n    let rectangles: RectangleClient[] = [];\n    const axis = isHorizontal ? 'x' : 'y';\n    const side = isHorizontal ? 'width' : 'height';\n\n    const activeRectangleCenter = activeRectangle[axis] + activeRectangle[side] / 2;\n    snapRectangles.forEach(rec => {\n        const isCross = isHorizontal ? isHorizontalCross(rec, activeRectangle) : isVerticalCross(rec, activeRectangle);\n        if (isCross && !RectangleClient.isHit(rec, activeRectangle)) {\n            rectangles.push(rec);\n        }\n    });\n    rectangles = [...rectangles, activeRectangle].sort((a, b) => a[axis] - b[axis]);\n\n    const refArray: GapSnapRef[] = [];\n    let gapDistance = 0;\n    let beforeIndex = undefined;\n    let afterIndex = undefined;\n\n    for (let i = 0; i < rectangles.length; i++) {\n        for (let j = i + 1; j < rectangles.length; j++) {\n            const before = rectangles[i];\n            const after = rectangles[j];\n            const distance = after[axis] - (before[axis] + before[side]);\n            let dif = Infinity;\n            if (refArray[i]?.after) {\n                refArray[i].after.push({ distance, index: j });\n            } else {\n                refArray[i] = { ...refArray[i], after: [{ distance, index: j }] };\n            }\n\n            if (refArray[j]?.before) {\n                refArray[j].before.push({ distance, index: i });\n            } else {\n                refArray[j] = { ...refArray[j], before: [{ distance, index: i }] };\n            }\n\n            //middle\n            let _center = (before[axis] + before[side] + after[axis]) / 2;\n            dif = Math.abs(_center - activeRectangleCenter);\n            if (dif < SNAP_TOLERANCE) {\n                gapDistance = (after[axis] - (before[axis] + before[side]) - activeRectangle[side]) / 2;\n                delta = _center - activeRectangleCenter;\n                beforeIndex = i;\n                afterIndex = j;\n            }\n\n            //after\n            const distanceRight = after[axis] - (before[axis] + before[side]);\n            _center = after[axis] + after[side] + distanceRight + activeRectangle[side] / 2;\n            dif = Math.abs(_center - activeRectangleCenter);\n            if ((!gapDistance || gapDistance !== distanceRight) && dif < SNAP_TOLERANCE) {\n                gapDistance = distanceRight;\n                beforeIndex = j;\n                delta = _center - activeRectangleCenter;\n            }\n\n            //before\n            const distanceBefore = after[axis] - (before[axis] + before[side]);\n            _center = before[axis] - distanceBefore - activeRectangle[side] / 2;\n            dif = Math.abs(_center - activeRectangleCenter);\n\n            if (!gapDistance && dif < SNAP_TOLERANCE) {\n                gapDistance = distanceBefore;\n                afterIndex = i;\n                delta = _center - activeRectangleCenter;\n            }\n        }\n    }\n\n    const activeIndex = rectangles.indexOf(activeRectangle);\n    let beforeIndexes: number[] = [];\n    let afterIndexes: number[] = [];\n    if (beforeIndex !== undefined) {\n        beforeIndexes.push(beforeIndex);\n        findRectangle(gapDistance, refArray[beforeIndex], 'before', beforeIndexes);\n    }\n\n    if (afterIndex !== undefined) {\n        afterIndexes.push(afterIndex);\n        findRectangle(gapDistance, refArray[afterIndex], 'after', afterIndexes);\n    }\n\n    if (beforeIndexes.length || afterIndexes.length) {\n        const indexArr = [...beforeIndexes.reverse(), activeIndex, ...afterIndexes];\n        activeRectangle[axis] += delta;\n        for (let i = 1; i < indexArr.length; i++) {\n            lines.push(getLinePoints(rectangles[indexArr[i - 1]], rectangles[indexArr[i]]));\n        }\n    }\n\n    function findRectangle(distance: number, ref: GapSnapRef, direction: string, rectangleIndexes: number[]) {\n        const arr = ref[direction as keyof GapSnapRef];\n        const index = refArray.indexOf(ref);\n        if ((index === 0 && direction === 'before') || (index === refArray.length - 1 && direction === 'after')) return;\n        for (let i = 0; i < arr.length; i++) {\n            if (Math.abs(arr[i].distance - distance) < 0.1) {\n                rectangleIndexes.push(arr[i].index);\n                findRectangle(distance, refArray[arr[i].index], direction, rectangleIndexes);\n                return;\n            }\n        }\n    }\n\n    function getLinePoints(beforeRectangle: RectangleClient, afterRectangle: RectangleClient) {\n        const oppositeAxis = axis === 'x' ? 'y' : 'x';\n        const oppositeSide = side === 'width' ? 'height' : 'width';\n        const snap = [\n            beforeRectangle[oppositeAxis],\n            beforeRectangle[oppositeAxis] + beforeRectangle[oppositeSide],\n            afterRectangle[oppositeAxis],\n            afterRectangle[oppositeAxis] + afterRectangle[oppositeSide]\n        ];\n        const sortArr = snap.sort((a, b) => a - b);\n        const average = (sortArr[1] + sortArr[2]) / 2;\n        const offset = 3;\n        return isHorizontal\n            ? [\n                  [beforeRectangle.x + beforeRectangle.width + offset, average],\n                  [afterRectangle.x - offset, average]\n              ]\n            : [\n                  [average, beforeRectangle.y + beforeRectangle.height + offset],\n                  [average, afterRectangle.y - offset]\n              ];\n    }\n    return { delta, lines };\n}\n\nfunction isHorizontalCross(rectangle: RectangleClient, other: RectangleClient) {\n    return !(rectangle.y + rectangle.height < other.y || rectangle.y > other.y + other.height);\n}\n\nfunction isVerticalCross(rectangle: RectangleClient, other: RectangleClient) {\n    return !(rectangle.x + rectangle.width < other.x || rectangle.x > other.x + other.width);\n}\n", "import { PlaitBoard } from '../interfaces/board';\nimport { isInPlaitBoard } from '../utils/board';\nimport { createG, isMainPointer } from '../utils/dom/common';\nimport { Point } from '../interfaces/point';\nimport { Transforms } from '../transforms';\nimport { PlaitElement } from '../interfaces/element';\nimport { getHitElementByPoint, getSelectedElements } from '../utils/selected-element';\nimport { PlaitNode } from '../interfaces/node';\nimport { throttleRAF } from '../utils/common';\nimport { cacheMovingElements, getMovingElements, isMovingElements, removeMovingElements } from '../utils/moving-element';\nimport { MERGING } from '../interfaces/history';\nimport {\n    getRectangleByElements,\n    distanceBetweenPointAndPoint,\n    toHostPoint,\n    toViewBoxPoint,\n    hotkeys,\n    getElementsInGroupByElement,\n    getRectangleByAngle,\n    getSelectionAngle,\n    duplicateElements,\n    drawRectangle,\n    depthFirstRecursion,\n    getAngleByElement,\n    setAngleForG,\n    NODE_TO_INDEX\n} from '../utils';\nimport { getSnapMovingRef } from '../utils/snap/snap-moving';\nimport { PlaitGroupElement, PlaitPointerType, RectangleClient, SELECTION_BORDER_COLOR, SELECTION_FILL_COLOR } from '../interfaces';\nimport { ACTIVE_MOVING_CLASS_NAME, PRESS_AND_MOVE_BUFFER } from '../constants';\nimport { addSelectionWithTemporaryElements } from '../transforms/selection';\nimport { isKeyHotkey } from 'is-hotkey';\n\nexport function withMoving(board: PlaitBoard) {\n    const { pointerDown, pointerMove, globalPointerUp, globalPointerMove, globalKeyDown, keyUp } = board;\n\n    let offsetX = 0;\n    let offsetY = 0;\n    let isPreventDefault = false;\n    let startPoint: Point | null;\n    let activeElements: PlaitElement[] = [];\n    let snapG: SVGGElement | null = null;\n    let activeElementsRectangle: RectangleClient | null = null;\n    let selectedTargetElements: PlaitElement[] | null = null;\n    let hitTargetElement: PlaitElement | undefined = undefined;\n    let isHitSelectedTarget: boolean | undefined = undefined;\n    let pendingNodesG: SVGGElement | null = null;\n\n    board.globalKeyDown = (event: KeyboardEvent) => {\n        if (!PlaitBoard.isReadonly(board)) {\n            if (isKeyHotkey('option', event)) {\n                event.preventDefault();\n                if (startPoint && activeElements.length && !PlaitBoard.hasBeenTextEditing(board)) {\n                    pendingNodesG = drawPendingNodesG(board, activeElements, offsetX, offsetY);\n                    pendingNodesG && PlaitBoard.getElementTopHost(board).append(pendingNodesG);\n                }\n            }\n        }\n        globalKeyDown(event);\n    };\n\n    board.keyUp = (event: KeyboardEvent) => {\n        if (!PlaitBoard.isReadonly(board)) {\n            if (pendingNodesG && startPoint && activeElements.length && !PlaitBoard.hasBeenTextEditing(board)) {\n                event.preventDefault();\n                const currentElements = updatePoints(board, activeElements, offsetX, offsetY);\n                PlaitBoard.getBoardContainer(board).classList.add('element-moving');\n                cacheMovingElements(board, currentElements as PlaitElement[]);\n            }\n        }\n        pendingNodesG?.remove();\n        keyUp(event);\n    };\n\n    board.pointerDown = (event: PointerEvent) => {\n        if (PlaitBoard.isReadonly(board) || !PlaitBoard.isPointer(board, PlaitPointerType.selection) || !isMainPointer(event)) {\n            pointerDown(event);\n            return;\n        }\n        const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n        hitTargetElement = getHitElementByPoint(board, point, el => board.isMovable(el));\n        selectedTargetElements = getSelectedTargetElements(board);\n        isHitSelectedTarget = hitTargetElement && selectedTargetElements.includes(hitTargetElement);\n        if (hitTargetElement && isHitSelectedTarget) {\n            startPoint = point;\n            activeElements = selectedTargetElements;\n            activeElementsRectangle = getRectangleByElements(board, activeElements, true);\n        } else if (hitTargetElement) {\n            startPoint = point;\n            const relatedElements = board.getRelatedFragment([], [hitTargetElement]);\n            activeElements = [...getElementsInGroupByElement(board, hitTargetElement), ...relatedElements];\n            activeElementsRectangle = getRectangleByElements(board, activeElements, true);\n        } else {\n            // \n            // Only after it is determined that the user has not hit the element can it be verified whether the user hit the blank area where the selected element is located.\n            const targetRectangle = selectedTargetElements.length > 0 && getRectangleByElements(board, selectedTargetElements, false);\n            const isHitInTargetRectangle = targetRectangle && RectangleClient.isPointInRectangle(targetRectangle, point);\n            if (isHitInTargetRectangle) {\n                startPoint = point;\n                activeElements = selectedTargetElements;\n                activeElementsRectangle = targetRectangle;\n            }\n        }\n        pointerDown(event);\n    };\n\n    board.pointerMove = (event: PointerEvent) => {\n        if (startPoint && activeElements.length && !PlaitBoard.hasBeenTextEditing(board)) {\n            if (!isPreventDefault) {\n                isPreventDefault = true;\n            }\n            snapG?.remove();\n            pendingNodesG?.remove();\n            const endPoint = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n            offsetX = endPoint[0] - startPoint[0];\n            offsetY = endPoint[1] - startPoint[1];\n            const distance = distanceBetweenPointAndPoint(...endPoint, ...startPoint);\n            if (distance > PRESS_AND_MOVE_BUFFER || getMovingElements(board).length > 0) {\n                if (hitTargetElement && !isHitSelectedTarget && selectedTargetElements && selectedTargetElements.length > 0) {\n                    addSelectionWithTemporaryElements(board, []);\n                    hitTargetElement = undefined;\n                    selectedTargetElements = null;\n                    isHitSelectedTarget = undefined;\n                }\n                throttleRAF(board, 'with-moving', () => {\n                    if (!activeElementsRectangle) {\n                        return;\n                    }\n                    const newRectangle = {\n                        ...activeElementsRectangle,\n                        x: activeElementsRectangle.x + offsetX,\n                        y: activeElementsRectangle.y + offsetY\n                    };\n                    const activeRectangle = getRectangleByAngle(newRectangle, getSelectionAngle(activeElements));\n                    const ref = getSnapMovingRef(board, activeRectangle, activeElements);\n                    offsetX += ref.deltaX;\n                    offsetY += ref.deltaY;\n                    snapG = ref.snapG;\n                    snapG.classList.add(ACTIVE_MOVING_CLASS_NAME);\n                    PlaitBoard.getElementTopHost(board).append(snapG);\n                    if (event.altKey) {\n                        pendingNodesG = drawPendingNodesG(board, activeElements, offsetX, offsetY);\n                        pendingNodesG && PlaitBoard.getElementTopHost(board).append(pendingNodesG);\n                    } else {\n                        const currentElements = updatePoints(board, activeElements, offsetX, offsetY);\n                        PlaitBoard.getBoardContainer(board).classList.add('element-moving');\n                        cacheMovingElements(board, currentElements as PlaitElement[]);\n                    }\n                });\n            }\n        }\n        if (isPreventDefault) {\n            // Prevent canvas scrolling behavior from being triggered during move\n            event.preventDefault();\n        }\n        pointerMove(event);\n    };\n\n    board.globalPointerMove = (event: PointerEvent) => {\n        if (startPoint) {\n            const inPlaitBoardElement = isInPlaitBoard(board, event.x, event.y);\n            if (!inPlaitBoardElement) {\n                cancelMove(board);\n            }\n        }\n        globalPointerMove(event);\n    };\n\n    board.globalPointerUp = event => {\n        if (event.altKey && activeElements.length) {\n            const validElements = getValidElements(board, activeElements);\n            const rectangle = getRectangleByElements(board, validElements, false);\n            duplicateElements(board, validElements, [rectangle.x + offsetX, rectangle.y + offsetY]);\n        }\n        isPreventDefault = false;\n        hitTargetElement = undefined;\n        selectedTargetElements = null;\n        isHitSelectedTarget = undefined;\n        if (startPoint) {\n            cancelMove(board);\n        }\n        globalPointerUp(event);\n    };\n\n    function cancelMove(board: PlaitBoard) {\n        snapG?.remove();\n        pendingNodesG?.remove();\n        startPoint = null;\n        activeElementsRectangle = null;\n        offsetX = 0;\n        offsetY = 0;\n        activeElements = [];\n        if (isMovingElements(board)) {\n            removeMovingElements(board);\n        }\n        MERGING.set(board, false);\n        PlaitBoard.getBoardContainer(board).classList.remove('element-moving');\n    }\n\n    return withArrowMoving(board);\n}\n\nexport function withArrowMoving(board: PlaitBoard) {\n    const { keyDown, keyUp } = board;\n    board.keyDown = (event: KeyboardEvent) => {\n        const selectedElements = getSelectedElements(board);\n        if (!PlaitBoard.isReadonly(board) && selectedElements.length > 0 && (hotkeys.isArrow(event) || hotkeys.isExtendArrow(event))) {\n            event.preventDefault();\n            const isShift = event.shiftKey ? true : false;\n            const offset = [0, 0];\n            const buffer = isShift ? 10 : 1;\n            switch (true) {\n                case hotkeys.isMoveUp(event) || hotkeys.isExtendUp(event): {\n                    offset[1] = -buffer;\n                    break;\n                }\n                case hotkeys.isMoveDown(event) || hotkeys.isExtendDown(event): {\n                    offset[1] = buffer;\n                    break;\n                }\n                case hotkeys.isMoveBackward(event) || hotkeys.isExtendBackward(event): {\n                    offset[0] = -buffer;\n                    break;\n                }\n                case hotkeys.isMoveForward(event) || hotkeys.isExtendForward(event): {\n                    offset[0] = buffer;\n                    break;\n                }\n            }\n            const targetElements = getSelectedTargetElements(board);\n            throttleRAF(board, 'with-arrow-moving', () => {\n                updatePoints(board, targetElements, offset[0], offset[1]);\n            });\n        }\n        keyDown(event);\n    };\n\n    board.keyUp = (event: KeyboardEvent) => {\n        MERGING.set(board, false);\n        keyUp(event);\n    };\n    return board;\n}\n\nexport function getSelectedTargetElements(board: PlaitBoard) {\n    const selectedElements = getSelectedElements(board);\n    const movableElements = board.children.filter(item => board.isMovable(item));\n    const targetElements = selectedElements.filter(element => {\n        return movableElements.includes(element);\n    });\n    const relatedElements = board.getRelatedFragment([]);\n    targetElements.push(...relatedElements);\n    return targetElements;\n}\n\nexport function getValidElements(board: PlaitBoard, activeElements: PlaitElement[]) {\n    const validElements = [...activeElements].filter(element => !PlaitGroupElement.isGroup(element) && PlaitElement.isRootElement(element));\n    return validElements;\n}\n\nexport function updatePoints(board: PlaitBoard, activeElements: PlaitElement[], offsetX: number, offsetY: number) {\n    const validElements = getValidElements(board, activeElements);\n    const currentElements = validElements.map(element => {\n        const points = element.points || [];\n        const newPoints = points.map(p => [p[0] + offsetX, p[1] + offsetY]) as Point[];\n        const index = NODE_TO_INDEX.get(element as PlaitElement) as number;\n        Transforms.setNode(\n            board,\n            {\n                points: newPoints\n            },\n            [index]\n        );\n        MERGING.set(board, true);\n        return PlaitNode.get(board, [index]);\n    });\n    return currentElements;\n}\n\nexport function drawPendingNodesG(board: PlaitBoard, activeElements: PlaitElement[], offsetX: number, offsetY: number) {\n    let pendingNodesG: SVGElement | null = null;\n    const elements: PlaitElement[] = [];\n    const validElements = getValidElements(board, activeElements);\n    validElements.forEach(element => {\n        depthFirstRecursion(\n            element,\n            node => {\n                elements.push(node);\n            },\n            () => true\n        );\n    });\n    elements.forEach(item => {\n        let rectangle = board.getRectangle(item);\n        if (rectangle) {\n            rectangle = {\n                x: rectangle.x + offsetX,\n                y: rectangle.y + offsetY,\n                width: rectangle.width,\n                height: rectangle.height\n            };\n            const movingG = drawRectangle(board, rectangle!, {\n                stroke: SELECTION_BORDER_COLOR,\n                strokeWidth: 1,\n                fill: SELECTION_FILL_COLOR,\n                fillStyle: 'solid'\n            });\n            if (!pendingNodesG) {\n                pendingNodesG = createG();\n                pendingNodesG.classList.add(ACTIVE_MOVING_CLASS_NAME);\n            }\n            const angle = getAngleByElement(item);\n            angle && setAngleForG(movingG, RectangleClient.getCenterPoint(rectangle), angle);\n            pendingNodesG.append(movingG);\n        }\n    });\n    return pendingNodesG;\n}\n", "import { PlaitBoard } from '../interfaces/board';\nimport { WithPluginOptions } from '../interfaces/plugin';\n\nexport interface PlaitOptionsBoard extends PlaitBoard {\n    getPluginOptions: <K = WithPluginOptions>(key: string) => K;\n    setPluginOptions: <K = WithPluginOptions>(key: string, value: Partial<K>) => void;\n}\n\nexport const withOptions = (board: PlaitBoard) => {\n    const pluginOptions = new Map<string, any>();\n    const newBoard = board as PlaitOptionsBoard;\n\n    newBoard.getPluginOptions = key => {\n        return pluginOptions.get(key);\n    };\n\n    newBoard.setPluginOptions = (key, options) => {\n        const oldOptions = newBoard.getPluginOptions(key) || {};\n        pluginOptions.set(key, { ...oldOptions, ...options });\n    };\n\n    return newBoard;\n};\n", "import { PlaitBoard, PlaitElement, RectangleClient } from '../interfaces';\nimport { WritableClipboardContext, WritableClipboardType, WritableClipboardOperationType, addOrCreateClipboardContext } from '../utils';\n\nexport function withRelatedFragment(board: PlaitBoard) {\n    const { buildFragment } = board;\n\n    board.buildFragment = (\n        clipboardContext: WritableClipboardContext | null,\n        rectangle: RectangleClient | null,\n        operationType: WritableClipboardOperationType,\n        originData?: PlaitElement[]\n    ) => {\n        let relatedFragment = board.getRelatedFragment(originData || []);\n        if (relatedFragment) {\n            if (originData?.length) {\n                relatedFragment = relatedFragment.filter(item => !originData.map(element => element.id).includes(item.id));\n            }\n            if (relatedFragment.length) {\n                const addition: WritableClipboardContext = {\n                    text: '',\n                    type: WritableClipboardType.elements,\n                    elements: relatedFragment\n                };\n                clipboardContext = addOrCreateClipboardContext(clipboardContext, addition);\n            }\n        }\n        return buildFragment(clipboardContext, rectangle, operationType, originData);\n    };\n\n    return board;\n}\n", "import { PlaitBoard } from '../interfaces/board';\nimport { Point } from '../interfaces/point';\nimport { Transforms } from '../transforms';\nimport { isMainPointer } from '../utils/dom/common';\nimport { RectangleClient } from '../interfaces/rectangle-client';\nimport {\n    cacheSelectedElements,\n    clearSelectedElement,\n    getHitElementsBySelection,\n    getSelectedElements,\n    isHitElement,\n    removeSelectedElement\n} from '../utils/selected-element';\nimport { PlaitPointerType, SELECTION_BORDER_COLOR, SELECTION_FILL_COLOR } from '../interfaces';\nimport { ATTACHED_ELEMENT_CLASS_NAME } from '../constants/selection';\nimport {\n    clearSelectionMoving,\n    deleteTemporaryElements,\n    drawRectangle,\n    getTemporaryElements,\n    isDragging,\n    isHandleSelection,\n    isSelectionMoving,\n    setSelectionMoving,\n    throttleRAF,\n    toHostPoint,\n    toViewBoxPoint,\n    setSelectedElementsWithGroup,\n    hasSetSelectionOperation,\n    getSelectionOptions,\n    setSelectionOptions,\n    distanceBetweenPointAndPoint,\n    isMobileDeviceEvent,\n    toActivePoint\n} from '../utils';\nimport { Selection } from '../interfaces/selection';\nimport { DRAG_SELECTION_PRESS_AND_MOVE_BUFFER } from '../constants';\n\nexport function withSelection(board: PlaitBoard) {\n    const { pointerDown, pointerUp, pointerMove, globalPointerUp, onChange, afterChange, drawSelectionRectangle } = board;\n    let screenStart: Point | null = null;\n    let screenEnd: Point | null = null;\n    let selectionMovingG: SVGGElement;\n    let selectionRectangleG: SVGGElement | null;\n    let isShift = false;\n    let timerId: ReturnType<typeof setTimeout> | null = null;\n    let pointerDownEvent: PointerEvent | null = null;\n\n    board.pointerDown = (event: PointerEvent) => {\n        if (!isShift && event.shiftKey) {\n            isShift = true;\n        }\n        if (isShift && !event.shiftKey) {\n            isShift = false;\n        }\n        const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n        const isHitTarget = isHitElement(board, point);\n        const options = getSelectionOptions(board);\n        if (\n            PlaitBoard.isPointer(board, PlaitPointerType.selection) &&\n            isMainPointer(event) &&\n            !isHitTarget &&\n            options.isMultipleSelection &&\n            !options.isDisabledSelection\n        ) {\n            if (isMobileDeviceEvent(event)) {\n                timerId = setTimeout(() => {\n                    screenStart = [event.x, event.y];\n                    timerId = null;\n                }, 120);\n            } else {\n                screenStart = [event.x, event.y];\n            }\n        }\n        pointerDownEvent = event;\n        pointerDown(event);\n    };\n\n    board.pointerMove = (event: PointerEvent) => {\n        if (\n            timerId &&\n            pointerDownEvent &&\n            distanceBetweenPointAndPoint(pointerDownEvent.x, pointerDownEvent.y, event.x, event.y) > DRAG_SELECTION_PRESS_AND_MOVE_BUFFER\n        ) {\n            clearTimeout(timerId);\n            timerId = null;\n        }\n        if (PlaitBoard.isPointer(board, PlaitPointerType.selection) && screenStart) {\n            event.preventDefault();\n            screenEnd = [event.x, event.y];\n            const rectangle = RectangleClient.getRectangleByPoints([\n                toActivePoint(board, ...screenStart),\n                toActivePoint(board, ...screenEnd)\n            ]);\n            selectionMovingG?.remove();\n            throttleRAF(board, 'with-selection', () => {\n                if (screenStart && screenEnd) {\n                    Transforms.setSelection(board, {\n                        anchor: toViewBoxPoint(board, toHostPoint(board, screenStart[0], screenStart[1])),\n                        focus: toViewBoxPoint(board, toHostPoint(board, screenEnd[0], screenEnd[1]))\n                    });\n                }\n            });\n            setSelectionMoving(board);\n            selectionMovingG = drawRectangle(board, rectangle, {\n                stroke: SELECTION_BORDER_COLOR,\n                strokeWidth: 1,\n                fill: SELECTION_FILL_COLOR,\n                fillStyle: 'solid'\n            });\n            PlaitBoard.getActiveHost(board).append(selectionMovingG);\n        }\n        pointerMove(event);\n    };\n\n    // handle the end of click select\n    board.pointerUp = (event: PointerEvent) => {\n        const isSetSelectionPointer =\n            PlaitBoard.isPointer(board, PlaitPointerType.selection) || PlaitBoard.isPointer(board, PlaitPointerType.hand);\n        const isSkip = !isMainPointer(event) || isDragging(board) || !isSetSelectionPointer;\n        if (isSkip) {\n            pointerUp(event);\n            return;\n        }\n        const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n        const selection = { anchor: point, focus: point };\n        Transforms.setSelection(board, selection);\n        pointerUp(event);\n    };\n\n    board.globalPointerUp = (event: PointerEvent) => {\n        if (screenStart && screenEnd) {\n            selectionMovingG?.remove();\n            clearSelectionMoving(board);\n            Transforms.setSelection(board, {\n                anchor: toViewBoxPoint(board, toHostPoint(board, screenStart[0], screenStart[1])),\n                focus: toViewBoxPoint(board, toHostPoint(board, screenEnd[0], screenEnd[1]))\n            });\n        }\n        const options = getSelectionOptions(board);\n        if (PlaitBoard.isFocus(board) && !options.isPreventClearSelection) {\n            const isInBoard = event.target instanceof Node && PlaitBoard.getBoardContainer(board).contains(event.target);\n            const isInDocument = event.target instanceof Node && document.contains(event.target);\n            const isAttachedElement = event.target instanceof Element && event.target.closest(`.${ATTACHED_ELEMENT_CLASS_NAME}`);\n            // Clear selection when mouse board outside area\n            // The framework needs to determine whether the board is focused through selection\n            if (!isInBoard && !screenStart && !isAttachedElement && isInDocument) {\n                Transforms.setSelection(board, null);\n            }\n        }\n        screenStart = null;\n        screenEnd = null;\n        if (timerId) {\n            clearTimeout(timerId);\n            timerId = null;\n        }\n        pointerDownEvent = null;\n        globalPointerUp(event);\n    };\n\n    board.onChange = () => {\n        const options = getSelectionOptions(board);\n        if (options.isDisabledSelection) {\n            clearSelectedElement(board);\n        }\n        // remove selected element if include\n        board.operations.forEach((op) => {\n            if (op.type === 'remove_node') {\n                removeSelectedElement(board, op.node, true);\n            }\n        });\n        if (isHandleSelection(board) && hasSetSelectionOperation(board)) {\n            try {\n                if (!isShift) {\n                    selectionRectangleG?.remove();\n                }\n                const temporaryElements = getTemporaryElements(board);\n                if (temporaryElements) {\n                    cacheSelectedElements(board, [...temporaryElements]);\n                } else {\n                    let elements = getHitElementsBySelection(board);\n                    if (!options.isMultipleSelection && elements.length > 1) {\n                        elements = [elements[0]];\n                    }\n                    const isHitElementWithGroup = elements.some((item) => item.groupId);\n                    const selectedElements = getSelectedElements(board);\n                    if (isHitElementWithGroup) {\n                        setSelectedElementsWithGroup(board, elements, isShift);\n                    } else {\n                        if (board.selection && Selection.isCollapsed(board.selection)) {\n                            const element = board.getOneHitElement(elements);\n                            if (element) {\n                                elements = [element];\n                            }\n                        }\n                        if (isShift) {\n                            const newElements = [...selectedElements];\n                            if (board.selection && Selection.isCollapsed(board.selection)) {\n                                elements.forEach((element) => {\n                                    if (newElements.includes(element)) {\n                                        newElements.splice(newElements.indexOf(element), 1);\n                                    } else {\n                                        newElements.push(element);\n                                    }\n                                });\n                                cacheSelectedElements(board, newElements);\n                            } else {\n                                elements.forEach((element) => {\n                                    if (!newElements.includes(element)) {\n                                        newElements.push(element);\n                                    }\n                                });\n                                cacheSelectedElements(board, [...newElements]);\n                            }\n                        } else {\n                            cacheSelectedElements(board, [...elements]);\n                        }\n                    }\n                }\n                const newElements = getSelectedElements(board);\n                deleteTemporaryElements(board);\n                if (!isSelectionMoving(board)) {\n                    selectionRectangleG?.remove();\n                    if (newElements.length > 1) {\n                        selectionRectangleG = board.drawSelectionRectangle();\n                        PlaitBoard.getActiveHost(board).append(selectionRectangleG!);\n                    }\n                }\n            } catch (error) {\n                console.error(error);\n            }\n        }\n        onChange();\n    };\n\n    board.afterChange = () => {\n        if (isHandleSelection(board) && !hasSetSelectionOperation(board)) {\n            try {\n                const currentSelectedElements = getSelectedElements(board);\n                if (currentSelectedElements.length && currentSelectedElements.length > 1) {\n                    selectionRectangleG?.remove();\n                    selectionRectangleG = board.drawSelectionRectangle();\n                    PlaitBoard.getActiveHost(board).append(selectionRectangleG!);\n                } else {\n                    selectionRectangleG?.remove();\n                }\n            } catch (error) {\n                console.error(error);\n            }\n        }\n        afterChange();\n    };\n\n    setSelectionOptions(board, {\n        isMultipleSelection: true,\n        isDisabledSelection: false,\n        isPreventClearSelection: false\n    });\n\n    return board;\n}\n", "import { PlaitBoard } from '../interfaces/board';\n\nexport interface PlaitI18nBoard extends PlaitBoard {\n    getI18nValue: (key: string) => string | null;\n}\n\nexport const withI18n = (board: PlaitBoard) => {\n    const newBoard = board as PlaitI18nBoard;\n\n    newBoard.getI18nValue = (key) => {\n        console.warn(`I18n key \"${key}\" is not found.`);\n        return null;\n    };\n\n    return newBoard;\n};\n\nexport const getI18nValue = (board: PlaitBoard, key: string, defaultValue = '') => {\n    const i18nBoard = board as PlaitI18nBoard;\n    return i18nBoard.getI18nValue(key) || defaultValue;\n};\n", "import { PlaitBoardOptions, PlaitElement, PlaitPlugin } from '../../interfaces';\nimport { createBoard } from '../../plugins/create-board';\nimport { KEY_TO_ELEMENT_MAP } from '../../utils';\n\n/**\n * 1.create board instance\n * 2.build fake node weak map\n */\nexport const createTestingBoard = (\n    plugins: PlaitPlugin[],\n    children: PlaitElement[],\n    options: PlaitBoardOptions = { readonly: false, hideScrollbar: true, disabledScrollOnNonFocus: false }\n) => {\n    let board = createBoard(children, options);\n    plugins.forEach(plugin => {\n        board = plugin(board);\n    });\n    KEY_TO_ELEMENT_MAP.set(board, new Map());\n    return board;\n};\n", "import { PlaitBoard } from '../../interfaces/board';\nimport { PlaitNode } from '../../interfaces/node';\nimport { NODE_TO_INDEX, NODE_TO_PARENT } from '../../utils/weak-maps';\n\nexport const fakeNodeWeakMap = (object: PlaitNode | PlaitBoard) => {\n    const children = object.children || [];\n    children.forEach((value, index: number) => {\n        NODE_TO_PARENT.set(value, object);\n        NODE_TO_INDEX.set(value, index);\n        fakeNodeWeakMap(value);\n    });\n};\n\nexport const clearNodeWeakMap = (object: PlaitNode | PlaitBoard) => {\n    const children = object.children || [];\n    children.forEach(value => {\n        NODE_TO_PARENT.delete(value);\n        NODE_TO_INDEX.delete(value);\n        clearNodeWeakMap(value);\n    });\n};\n", "/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport { IS_MAC } from '../../utils/dom/environment';\nimport { ModifierKeys } from '../test-element';\n\n/** Used to generate unique IDs for events. */\nlet uniqueIds = 0;\n\n/**\n * Creates a browser MouseEvent with the specified options.\n * @docs-private\n */\nexport function createMouseEvent(\n    type: string,\n    clientX = 0,\n    clientY = 0,\n    offsetX = 1,\n    offsetY = 1,\n    button = 0,\n    modifiers: ModifierKeys = {}\n) {\n    // Note: We cannot determine the position of the mouse event based on the screen\n    // because the dimensions and position of the browser window are not available\n    // To provide reasonable `screenX` and `screenY` coordinates, we simply use the\n    // client coordinates as if the browser is opened in fullscreen.\n    const screenX = clientX;\n    const screenY = clientY;\n\n    const event = new MouseEvent(type, {\n        bubbles: true,\n        cancelable: true,\n        composed: true, // Required for shadow DOM events.\n        view: window,\n        detail: 0,\n        relatedTarget: null,\n        screenX,\n        screenY,\n        clientX,\n        clientY,\n        ctrlKey: modifiers.control,\n        altKey: modifiers.alt,\n        shiftKey: modifiers.shift,\n        metaKey: modifiers.meta,\n        button: button,\n        buttons: 1\n    });\n\n    // The `MouseEvent` constructor doesn't allow us to pass these properties into the constructor.\n    // Override them to `1`, because they're used for fake screen reader event detection.\n    if (offsetX != null) {\n        defineReadonlyEventProperty(event, 'offsetX', offsetX);\n    }\n\n    if (offsetY != null) {\n        defineReadonlyEventProperty(event, 'offsetY', offsetY);\n    }\n\n    return event;\n}\n\n/**\n * Creates a browser `PointerEvent` with the specified options. Pointer events\n * by default will appear as if they are the primary pointer of their type.\n * https://www.w3.org/TR/pointerevents2/#dom-pointerevent-isprimary.\n *\n * For example, if pointer events for a multi-touch interaction are created, the non-primary\n * pointer touches would need to be represented by non-primary pointer events.\n *\n * @docs-private\n */\nexport function createPointerEvent(\n    type: string,\n    clientX = 0,\n    clientY = 0,\n    offsetX?: number,\n    offsetY?: number,\n    options: PointerEventInit = { isPrimary: true }\n) {\n    const event = new PointerEvent(type, {\n        bubbles: true,\n        cancelable: true,\n        composed: true, // Required for shadow DOM events.\n        view: window,\n        clientX,\n        clientY,\n        ...options\n    });\n\n    if (offsetX != null) {\n        defineReadonlyEventProperty(event, 'offsetX', offsetX);\n    }\n\n    if (offsetY != null) {\n        defineReadonlyEventProperty(event, 'offsetY', offsetY);\n    }\n\n    return event;\n}\n\n/**\n * Creates a browser TouchEvent with the specified pointer coordinates.\n * @docs-private\n */\nexport function createTouchEvent(type: string, pageX = 0, pageY = 0, clientX = 0, clientY = 0) {\n    // We cannot use the `TouchEvent` or `Touch` because Firefox and Safari lack support.\n    const event = document.createEvent('UIEvent');\n    const touchDetails = { pageX, pageY, clientX, clientY, identifier: uniqueIds++ };\n\n    // TS3.6 removes the initUIEvent method and suggests porting to \"new UIEvent()\".\n    (event as any).initUIEvent(type, true, true, window, 0);\n\n    // Most of the browsers don't have a \"initTouchEvent\" method that can be used to define\n    // the touch details.\n    defineReadonlyEventProperty(event, 'touches', [touchDetails]);\n    defineReadonlyEventProperty(event, 'targetTouches', [touchDetails]);\n    defineReadonlyEventProperty(event, 'changedTouches', [touchDetails]);\n\n    return event;\n}\n\n/**\n * Creates a keyboard event with the specified key and modifiers.\n * @docs-private\n */\nexport function createKeyboardEvent(type: string, keyCode: number = 0, key: string = '', modifiers: ModifierKeys = {}) {\n    return new KeyboardEvent(type, {\n        bubbles: true,\n        cancelable: true,\n        composed: true, // Required for shadow DOM events.\n        view: window,\n        keyCode: keyCode,\n        key: key,\n        shiftKey: modifiers.shift,\n        metaKey: modifiers.meta,\n        altKey: modifiers.alt,\n        ctrlKey: modifiers.control\n    });\n}\n\n/**\n * Creates a fake event object with any desired event type.\n * @docs-private\n */\nexport function createFakeEvent(type: string, bubbles = false, cancelable = true, composed = true) {\n    return new Event(type, { bubbles, cancelable, composed });\n}\n\n/**\n * Defines a readonly property on the given event object. Readonly properties on an event object\n * are always set as configurable as that matches default readonly properties for DOM event objects.\n */\nfunction defineReadonlyEventProperty(event: Event, propertyName: string, value: any) {\n    Object.defineProperty(event, propertyName, { get: () => value, configurable: true });\n}\n\nexport function createModModifierKeys() {\n    const modifiers = IS_MAC ? { meta: true } : { control: true };\n    return modifiers;\n}\n", "/*\n * Public API Surface of plait\n */\nexport * from './constants';\nexport * from './core/element/context-change';\nexport * from './core/element/element-flavour';\nexport * from './core/element/element-ref';\nexport * from './core/list-render';\nexport * from './interfaces';\nexport * from './transforms';\nexport * from './utils';\nexport * from './context';\nexport * from './plugins';\nexport * from './testing';\nexport * from './utils/debug';\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],
  "mappings": "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",
  "names": ["Subscription", "empty", "timeout", "Subscriber", "ConsumerObserver", "SafeSubscriber", "Observable", "observable", "OperatorSubscriber", "err", "ConnectableObservable", "timestamp", "timestamp", "Subject", "observable", "AnonymousSubject", "BehaviorSubject", "ReplaySubject", "last", "AsyncSubject", "Action", "delay", "timeout", "AsyncAction", "delay", "AsapAction", "delay", "Scheduler", "delay", "AsyncScheduler", "AsapScheduler", "QueueAction", "delay", "QueueScheduler", "AnimationFrameAction", "delay", "AnimationFrameScheduler", "VirtualTimeScheduler", "VirtualAction", "delay", "delay", "repeat", "delay", "delay", "iterator", "iterator", "NotificationKind", "Notification", "isArray", "expand", "buffer", "isArray", "ResizeCursorClass", "CursorClass", "findIndex", "last", "min", "A", "B", "C", "D", "rx", "ry", "N", "M", "a", "PlaitPluginKey", "radius", "ViewportTransforms", "isFromViewportChange", "timerId", "debounce", "item", "WritableClipboardType", "WritableClipboardOperationType", "elements", "findIndex", "ViewportTransforms", "element", "ThemeColorMode", "PlaitPointerType", "Direction", "iterator", "index", "context", "first", "options", "merge", "board", "buffer", "newElements"]
}
