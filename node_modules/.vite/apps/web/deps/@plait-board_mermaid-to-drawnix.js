import {
  mermaid,
  require_dist
} from "./chunk-JFQG3RRO.js";
import {
  require_dayjs_min
} from "./chunk-LVOXEQME.js";
import {
  ArrowLineMarkerType,
  ArrowLineShape,
  BasicShapes,
  DefaultLineStyle,
  FlowchartSymbols,
  ShapeDefaultSpace,
  createArrowLineElement,
  createGeometryElement,
  getTextShapeProperty
} from "./chunk-ZENJNSGT.js";
import "./chunk-4TU3NFLN.js";
import {
  DEFAULT_FONT_SIZE
} from "./chunk-6RPCEARB.js";
import {
  DEFAULT_FONT_FAMILY,
  StrokeStyle,
  buildText,
  measureElement
} from "./chunk-NNVG7YTJ.js";
import {
  Node
} from "./chunk-OBPCNI2P.js";
import {
  PlaitGroupElement,
  RectangleClient,
  createGroup,
  idCreator
} from "./chunk-6V4XCDNF.js";
import "./chunk-LYPQCHSP.js";
import "./chunk-YHVPT5BK.js";
import "./chunk-R23N5LB2.js";
import {
  __toESM
} from "./chunk-2TUXWMP5.js";

// ../../node_modules/@plait-board/mermaid-to-drawnix/dist/constants.js
var DEFAULT_FONT_SIZE2 = 20;
var SVG_TO_SHAPE_MAPPER = {
  rect: "rectangle",
  circle: "ellipse"
};
var MERMAID_CONFIG = {
  startOnLoad: false,
  flowchart: { curve: "linear" },
  themeVariables: {
    fontSize: `${DEFAULT_FONT_SIZE2}px`
  },
  maxEdges: 500,
  maxTextSize: 5e4
};

// ../../node_modules/@plait-board/mermaid-to-drawnix/dist/converter/GraphConverter.js
var GraphConverter = class {
  constructor({ converter }) {
    this.convert = (graph, config) => {
      return this.converter(graph, {
        ...config,
        fontSize: config.fontSize || DEFAULT_FONT_SIZE2
      });
    };
    this.converter = converter;
  }
};

// ../../node_modules/@plait-board/mermaid-to-drawnix/dist/interfaces.js
var VERTEX_TYPE;
(function(VERTEX_TYPE2) {
  VERTEX_TYPE2["ROUND"] = "round";
  VERTEX_TYPE2["STADIUM"] = "stadium";
  VERTEX_TYPE2["DOUBLECIRCLE"] = "doublecircle";
  VERTEX_TYPE2["CIRCLE"] = "circle";
  VERTEX_TYPE2["DIAMOND"] = "diamond";
})(VERTEX_TYPE || (VERTEX_TYPE = {}));
var LABEL_STYLE_PROPERTY;
(function(LABEL_STYLE_PROPERTY2) {
  LABEL_STYLE_PROPERTY2["COLOR"] = "color";
})(LABEL_STYLE_PROPERTY || (LABEL_STYLE_PROPERTY = {}));
var CONTAINER_STYLE_PROPERTY;
(function(CONTAINER_STYLE_PROPERTY2) {
  CONTAINER_STYLE_PROPERTY2["FILL"] = "fill";
  CONTAINER_STYLE_PROPERTY2["STROKE"] = "stroke";
  CONTAINER_STYLE_PROPERTY2["STROKE_WIDTH"] = "stroke-width";
  CONTAINER_STYLE_PROPERTY2["STROKE_DASHARRAY"] = "stroke-dasharray";
})(CONTAINER_STYLE_PROPERTY || (CONTAINER_STYLE_PROPERTY = {}));

// ../../node_modules/@plait-board/mermaid-to-drawnix/dist/markdown-to-text.js
var removeMarkdown = (markdown, options = {
  listUnicodeChar: ""
}) => {
  options = options || {};
  options.listUnicodeChar = options.hasOwnProperty("listUnicodeChar") ? options.listUnicodeChar : false;
  options.stripListLeaders = options.hasOwnProperty("stripListLeaders") ? options.stripListLeaders : true;
  options.gfm = options.hasOwnProperty("gfm") ? options.gfm : true;
  options.useImgAltText = options.hasOwnProperty("useImgAltText") ? options.useImgAltText : true;
  options.preserveLinks = options.hasOwnProperty("preserveLinks") ? options.preserveLinks : false;
  let output = markdown || "";
  output = output.replace(/^(-\s*?|\*\s*?|_\s*?){3,}\s*$/gm, "");
  try {
    if (options.stripListLeaders) {
      if (options.listUnicodeChar)
        output = output.replace(/^([\s\t]*)([\*\-\+]|\d+\.)\s+/gm, options.listUnicodeChar + " $1");
      else
        output = output.replace(/^([\s\t]*)([\*\-\+]|\d+\.)\s+/gm, "$1");
    }
    if (options.gfm) {
      output = output.replace(/\n={2,}/g, "\n").replace(/~{3}.*\n/g, "").replace(/~~/g, "").replace(/`{3}.*\n/g, "");
    }
    if (options.preserveLinks) {
      output = output.replace(/\[(.*?)\][\[\(](.*?)[\]\)]/g, "$1 ($2)");
    }
    output = output.replace(/<[^>]*>/g, "").replace(/^[=\-]{2,}\s*$/g, "").replace(/\[\^.+?\](\: .*?$)?/g, "").replace(/\s{0,2}\[.*?\]: .*?$/g, "").replace(/\!\[(.*?)\][\[\(].*?[\]\)]/g, options.useImgAltText ? "$1" : "").replace(/\[(.*?)\][\[\(].*?[\]\)]/g, "$1").replace(/^\s{0,3}>\s?/g, "").replace(/(^|\n)\s{0,3}>\s?/g, "\n\n").replace(/^\s{1,2}\[(.*?)\]: (\S+)( ".*?")?\s*$/g, "").replace(/^(\n)?\s{0,}#{1,6}\s+| {0,}(\n)?\s{0,}#{0,} {0,}(\n)?\s{0,}$/gm, "$1$2$3").replace(/([\*_]{1,3})(\S.*?\S{0,1})\1/g, "$2").replace(/([\*_]{1,3})(\S.*?\S{0,1})\1/g, "$2").replace(/(`{3,})(.*?)\1/gm, "$2").replace(/`(.+?)`/g, "$1").replace(/\n{2,}/g, "\n\n");
  } catch (e) {
    console.error(e);
    return markdown;
  }
  return output;
};

// ../../node_modules/@plait-board/mermaid-to-drawnix/dist/converter/helpers.js
var MERMAID_EDGE_TYPE_MAPPER = {
  arrow_point: {
    source: { marker: ArrowLineMarkerType.none },
    target: { marker: ArrowLineMarkerType.arrow }
  },
  arrow_circle: {
    source: { marker: ArrowLineMarkerType.none },
    target: { marker: ArrowLineMarkerType.arrow }
  },
  arrow_cross: {
    source: { marker: ArrowLineMarkerType.none },
    target: { marker: ArrowLineMarkerType.arrow }
  },
  arrow_open: {
    source: { marker: ArrowLineMarkerType.none },
    target: { marker: ArrowLineMarkerType.none }
  },
  double_arrow_circle: {
    source: { marker: ArrowLineMarkerType.arrow },
    target: { marker: ArrowLineMarkerType.arrow }
  },
  double_arrow_cross: {
    source: { marker: ArrowLineMarkerType.arrow },
    target: { marker: ArrowLineMarkerType.arrow }
  },
  double_arrow_point: {
    source: { marker: ArrowLineMarkerType.arrow },
    target: { marker: ArrowLineMarkerType.arrow }
  }
};
var computeDrawnixArrowType = (mermaidArrowType) => {
  return MERMAID_EDGE_TYPE_MAPPER[mermaidArrowType];
};
var computeDrawnixArrowStyle = (edge) => {
  const arrowStyle = {};
  if (edge.stroke === "dotted") {
    arrowStyle.strokeStyle = StrokeStyle.dotted;
  }
  return arrowStyle;
};
var getText = (element) => {
  let text = element.text;
  if (element.labelType === "markdown") {
    text = removeMarkdown(element.text);
  }
  text = text.replace(/<br\/?>/g, "\n");
  text = text.replace(/\\n/g, "\n");
  const tagsToRemove = ["sub", "small", "i"];
  tagsToRemove.forEach((tag) => {
    text = text.replace(new RegExp(`<${tag}>|</${tag}>`, "g"), "");
  });
  return removeFontAwesomeIcons(text);
};
var removeFontAwesomeIcons = (input) => {
  const fontAwesomeRegex = /\s?(fa|fab):[a-zA-Z0-9-]+/g;
  return input.replace(fontAwesomeRegex, "");
};
var computeDrawnixVertexStyle = (style) => {
  const plaitElementProperty = {};
  Object.keys(style).forEach((property) => {
    var _a;
    switch (property) {
      case CONTAINER_STYLE_PROPERTY.FILL: {
        plaitElementProperty.fill = style[property];
        break;
      }
      case CONTAINER_STYLE_PROPERTY.STROKE: {
        plaitElementProperty.strokeColor = style[property];
        break;
      }
      case CONTAINER_STYLE_PROPERTY.STROKE_WIDTH: {
        plaitElementProperty.strokeWidth = Number((_a = style[property]) == null ? void 0 : _a.split("px")[0]);
        break;
      }
      case CONTAINER_STYLE_PROPERTY.STROKE_DASHARRAY: {
        plaitElementProperty.strokeStyle = StrokeStyle.dashed;
        break;
      }
    }
  });
  return plaitElementProperty;
};
var computeDrawnixTextStyle = (style) => {
  const textProperty = {};
  Object.keys(style).forEach((property) => {
    switch (property) {
      case LABEL_STYLE_PROPERTY.COLOR: {
        textProperty.color = style[property];
        break;
      }
    }
  });
  return textProperty;
};
var getRectangleByMermaidElement = (vertex) => {
  return vertex;
};
var normalizeText = (text) => {
  return text.replace(/\\n/g, "\n");
};
var getHitConnectionFromConnectionPoint = (connectionPoint, hitElement) => {
  let rectangle = RectangleClient.getRectangleByPoints(hitElement.points);
  return [(connectionPoint[0] - rectangle.x) / rectangle.width, (connectionPoint[1] - rectangle.y) / rectangle.height];
};

// ../../node_modules/@plait-board/mermaid-to-drawnix/dist/converter/types/flowchart.js
var computeGroupIds = (graph) => {
  const tree = {};
  graph.subGraphs.map((subGraph) => {
    subGraph.nodeIds.forEach((nodeId) => {
      tree[subGraph.id] = {
        id: subGraph.id,
        parent: null,
        isLeaf: false
      };
      tree[nodeId] = {
        id: nodeId,
        parent: subGraph.id,
        isLeaf: graph.vertices[nodeId] !== void 0
      };
    });
  });
  const mapper = {};
  [...Object.keys(graph.vertices), ...graph.subGraphs.map((c) => c.id)].forEach((id) => {
    if (!tree[id]) {
      return;
    }
    let curr = tree[id];
    const groupIds = [];
    if (!curr.isLeaf) {
      groupIds.push(`subgraph_group_${curr.id}`);
    }
    while (true) {
      if (curr.parent) {
        groupIds.push(`subgraph_group_${curr.parent}`);
        curr = tree[curr.parent];
      } else {
        break;
      }
    }
    mapper[id] = groupIds;
  });
  return {
    getGroupIds: (elementId) => {
      return mapper[elementId] || [];
    },
    getParentId: (elementId) => {
      return tree[elementId] ? tree[elementId].parent : null;
    }
  };
};
var flowchartToDrawnixConverter = new GraphConverter({
  converter: (graph, config) => {
    const elements = [];
    const mermaidIdToElementMap = {};
    const mermaidGroupIdToElementMap = {};
    const { getGroupIds, getParentId } = computeGroupIds(graph);
    graph.subGraphs.reverse().forEach((subGraph) => {
      const groupIds = getGroupIds(subGraph.id);
      groupIds.forEach((groupId, index) => {
        if (!mermaidGroupIdToElementMap[groupId]) {
          const groupElement = createGroup();
          mermaidGroupIdToElementMap[groupId] = groupElement;
        }
        if (index > 0 && mermaidGroupIdToElementMap[groupId]) {
          const childGroup = mermaidGroupIdToElementMap[groupIds[index - 1]];
          childGroup.groupId = mermaidGroupIdToElementMap[groupId].id;
        }
      });
      const text = buildText(getText(subGraph), void 0);
      const textSize = getTextShapeProperty({}, text);
      const points = RectangleClient.getPoints(RectangleClient.getRectangleByCenterPoint([
        subGraph.x + subGraph.width / 2,
        subGraph.y + 4 + textSize.height / 2
      ], textSize.width, textSize.height));
      const textElement = createGeometryElement(BasicShapes.text, points, text);
      let containerElement = createGeometryElement(BasicShapes.rectangle, RectangleClient.getPoints(getRectangleByMermaidElement(subGraph)), "", { fill: "#ffffde", strokeColor: "#aaaa33", strokeWidth: 1 });
      containerElement.groupId = mermaidGroupIdToElementMap[groupIds[0]].id;
      elements.push(containerElement);
      mermaidIdToElementMap[subGraph.id] = containerElement;
      textElement.groupId = mermaidGroupIdToElementMap[groupIds[0]].id;
      elements.push(textElement);
      groupIds.forEach((groupId) => {
        const existing = elements.findIndex((searchElement) => {
          var _a;
          return searchElement.id === ((_a = mermaidGroupIdToElementMap[groupId]) == null ? void 0 : _a.id);
        }) >= 0;
        if (!existing) {
          elements.push(mermaidGroupIdToElementMap[groupId]);
        }
      });
    });
    Object.values(graph.vertices).forEach((vertex) => {
      if (!vertex) {
        return;
      }
      const groupIds = getGroupIds(vertex.id);
      const elementStyle = computeDrawnixVertexStyle(vertex.containerStyle);
      const textStyle = computeDrawnixTextStyle(vertex.labelStyle);
      const verticesText = buildText(getText(vertex), void 0, textStyle);
      const textSize = measureElement(null, verticesText, {
        fontFamily: DEFAULT_FONT_FAMILY,
        fontSize: DEFAULT_FONT_SIZE
      });
      const styleOptions = {
        fill: "#ECECFF",
        strokeColor: "#9370DB",
        strokeWidth: 1,
        ...elementStyle
      };
      let geometryElement = createGeometryElement(BasicShapes.rectangle, RectangleClient.getPoints(getRectangleByMermaidElement(vertex)), buildText(getText(vertex), void 0, textStyle), {
        ...styleOptions
      }, {
        textHeight: textSize.height
      });
      switch (vertex.type) {
        case VERTEX_TYPE.ROUND: {
          geometryElement.shape = BasicShapes.roundRectangle;
          break;
        }
        case VERTEX_TYPE.STADIUM: {
          geometryElement.shape = FlowchartSymbols.terminal;
          break;
        }
        case VERTEX_TYPE.DOUBLECIRCLE: {
          const CIRCLE_MARGIN = 5;
          const innerRectangle = RectangleClient.inflate(getRectangleByMermaidElement(vertex), -CIRCLE_MARGIN * 2);
          const innerCircle = createGeometryElement(BasicShapes.ellipse, RectangleClient.getPoints(innerRectangle), buildText(getText(vertex)), {
            ...styleOptions
          });
          geometryElement = { ...geometryElement, shape: BasicShapes.ellipse };
          geometryElement.text = buildText("");
          elements.push(geometryElement);
          elements.push(innerCircle);
          mermaidIdToElementMap[vertex.id] = geometryElement;
          const groupElement2 = groupIds[0] && mermaidGroupIdToElementMap[groupIds[0]];
          if (groupElement2) {
            geometryElement.groupId = groupElement2.id;
          }
          return;
        }
        case VERTEX_TYPE.CIRCLE: {
          geometryElement.shape = BasicShapes.ellipse;
          break;
        }
        case VERTEX_TYPE.DIAMOND: {
          geometryElement.shape = BasicShapes.diamond;
          break;
        }
      }
      elements.push(geometryElement);
      mermaidIdToElementMap[vertex.id] = geometryElement;
      const groupElement = groupIds[0] && mermaidGroupIdToElementMap[groupIds[0]];
      if (groupElement) {
        geometryElement.groupId = groupElement.id;
      }
    });
    graph.edges.forEach((edge) => {
      let groupIds = [];
      const startParentId = getParentId(edge.start);
      const endParentId = getParentId(edge.end);
      if (startParentId && startParentId === endParentId) {
        groupIds = getGroupIds(startParentId);
      }
      const { startX, startY, reflectionPoints } = edge;
      const arrowType = computeDrawnixArrowType(edge.type);
      const points = reflectionPoints.map((point) => [point.x, point.y]);
      const sourceHandle = {
        marker: arrowType.source.marker
      };
      const targetHandle = {
        marker: arrowType.target.marker
      };
      const sourceElement = mermaidIdToElementMap[edge.start];
      if (sourceElement) {
        sourceHandle.boundId = sourceElement.id;
        sourceHandle.connection = getHitConnectionFromConnectionPoint(points[0], sourceElement);
      }
      const targetElement = mermaidIdToElementMap[edge.end];
      if (targetElement) {
        targetHandle.boundId = targetElement.id;
        targetHandle.connection = getHitConnectionFromConnectionPoint(points[points.length - 1], targetElement);
      }
      const texts = [];
      if (edge.text) {
        const textValue = buildText(getText(edge));
        const { width, height } = measureElement(null, textValue, {
          fontSize: DEFAULT_FONT_SIZE,
          fontFamily: DEFAULT_FONT_FAMILY
        });
        texts.push({
          position: 0.5,
          text: buildText(getText(edge)),
          width,
          height
        });
      }
      const arrowStyle = computeDrawnixArrowStyle(edge);
      const arrowOptions = {
        strokeWidth: DefaultLineStyle.strokeWidth,
        ...arrowStyle
      };
      const arrowLineElement = createArrowLineElement(ArrowLineShape.straight, [...points], {
        ...sourceHandle
      }, {
        ...targetHandle
      }, texts, { ...arrowOptions });
      elements.push(arrowLineElement);
      const groupElement = groupIds[0] && mermaidGroupIdToElementMap[groupIds[0]];
      if (groupElement) {
        arrowLineElement.groupId = groupElement.id;
      }
    });
    return {
      elements
    };
  }
});

// ../../node_modules/@plait-board/mermaid-to-drawnix/dist/converter/transformToDrawnixElement.js
var transformToDrawnixLineElement = (element, mermaidGroupIdToElementMap, config) => {
  const points = [
    [element.startX, element.startY],
    [element.endX, element.endY]
  ];
  const arrowOptions = {
    strokeColor: element.strokeColor || "hsl(259.6261682243, 59.7765363128%, 87.9019607843%)",
    strokeWidth: element.strokeWidth || 2,
    strokeStyle: element.strokeStyle || StrokeStyle.solid
  };
  const line = createArrowLineElement(ArrowLineShape.straight, [...points], {
    marker: ArrowLineMarkerType.none
  }, {
    marker: ArrowLineMarkerType.none
  }, [], { ...arrowOptions });
  if (element.groupId) {
    let groupElement = mermaidGroupIdToElementMap[element.groupId];
    if (!groupElement) {
      groupElement = createGroup();
      mermaidGroupIdToElementMap[element.groupId] = groupElement;
    }
    line.groupId = groupElement.id;
  }
  return line;
};
var transformToDrawnixArrowElement = (element, mermaidGroupIdToElementMap, config) => {
  var _a;
  let points = [
    [element.startX, element.startY],
    [element.endX, element.endY]
  ];
  if (element.points) {
    points = element.points.map((point) => [
      element.startX + point[0],
      element.startY + point[1]
    ]);
  }
  const arrowOptions = {
    strokeColor: element.strokeColor && element.strokeColor !== "none" && element.strokeColor || "#000",
    strokeWidth: element.strokeWidth || 1,
    strokeStyle: element.strokeStyle || StrokeStyle.solid
  };
  const arrowText = buildText(normalizeText(((_a = element == null ? void 0 : element.label) == null ? void 0 : _a.text) || ""), void 0);
  const texts = [];
  if (Node.string(arrowText).trim().length > 0) {
    const textSize = measureElement(null, arrowText, {
      fontFamily: DEFAULT_FONT_FAMILY,
      fontSize: DEFAULT_FONT_SIZE
    });
    texts.push({
      position: 0.5,
      text: arrowText,
      width: textSize.width,
      height: textSize.height
    });
  }
  const arrow = createArrowLineElement(config.arrowLineShape || ArrowLineShape.curve, [...points], {
    marker: element.startArrowhead ? ArrowLineMarkerType.arrow : ArrowLineMarkerType.none
  }, {
    marker: element.endArrowhead ? ArrowLineMarkerType.arrow : ArrowLineMarkerType.none
  }, texts, { ...arrowOptions });
  if (element.groupId) {
    let groupElement = mermaidGroupIdToElementMap[element.groupId];
    if (!groupElement) {
      groupElement = createGroup();
      mermaidGroupIdToElementMap[element.groupId] = groupElement;
    }
    arrow.groupId = groupElement.id;
  }
  return arrow;
};
var transformToDrawnixRectangleElement = (element, mermaidGroupIdToElementMap, config) => {
  var _a, _b;
  let extraProps = {};
  if (element.type === "rectangle" && element.subtype === "activation") {
    extraProps = {
      fill: "#e9ecef",
      strokeStyle: StrokeStyle.solid
    };
  }
  const styleOptions = {
    strokeStyle: (element == null ? void 0 : element.strokeStyle) || StrokeStyle.solid,
    strokeWidth: (element == null ? void 0 : element.strokeWidth) || 1,
    strokeColor: (element == null ? void 0 : element.strokeColor) || "hsl(259.6261682243, 59.7765363128%, 87.9019607843%)",
    fill: (element == null ? void 0 : element.bgColor) || "#ECECFF",
    ...extraProps
  };
  const textStyle = {
    color: ((_a = element.label) == null ? void 0 : _a.color) || "#000"
  };
  const verticesText = buildText(normalizeText(((_b = element == null ? void 0 : element.label) == null ? void 0 : _b.text) || ""), void 0, textStyle);
  const textSize = measureElement(null, verticesText, {
    fontFamily: DEFAULT_FONT_FAMILY,
    fontSize: DEFAULT_FONT_SIZE
  });
  const rectangle = getRectangleByMermaidElement({
    ...element,
    width: element.width || textSize.width + ShapeDefaultSpace.rectangleAndText * 2 + styleOptions.strokeWidth * 2
  });
  const container = createGeometryElement(element.type, RectangleClient.getPoints(rectangle), verticesText, {
    ...styleOptions
  }, {
    textHeight: textSize.height
  });
  if (element.groupId) {
    let groupElement = mermaidGroupIdToElementMap[element.groupId];
    if (!groupElement) {
      groupElement = createGroup();
      mermaidGroupIdToElementMap[element.groupId] = groupElement;
    }
    container.groupId = groupElement.id;
  }
  return container;
};
var transformToDrawnixTextElement = (element, mermaidGroupIdToElementMap, config) => {
  const text = buildText(normalizeText(element.text || ""), void 0);
  const textSize = getTextShapeProperty({}, text);
  const textRectangle = RectangleClient.getRectangleByCenterPoint([element.x + textSize.width / 2, element.y], textSize.width, textSize.height);
  const textElement = createGeometryElement(BasicShapes.text, RectangleClient.getPoints(textRectangle), text, {}, {
    textHeight: textSize.height
  });
  if (element.groupId) {
    let groupElement = mermaidGroupIdToElementMap[element.groupId];
    if (!groupElement) {
      groupElement = createGroup();
      mermaidGroupIdToElementMap[element.groupId] = groupElement;
    }
    textElement.groupId = groupElement.id;
  }
  return textElement;
};
var transformToDrawnixGroupElement = (childrenElements, text, options = {}) => {
  const childrenRectangle = RectangleClient.getBoundingRectangle(childrenElements.map((ele) => RectangleClient.getRectangleByPoints(ele.points)));
  const PADDING = 60;
  const groupRectangle = RectangleClient.inflate(childrenRectangle, PADDING);
  const containerElement = createGeometryElement(BasicShapes.rectangle, [...RectangleClient.getPoints(groupRectangle)], "", { strokeWidth: 1, ...options });
  const slateTextElement = buildText(text, void 0);
  const textSize = getTextShapeProperty({}, text);
  const points = RectangleClient.getPoints(RectangleClient.getRectangleByCenterPoint([
    groupRectangle.x + groupRectangle.width / 2,
    groupRectangle.y + 4 + textSize.height / 2
  ], textSize.width, textSize.height));
  const textElement = createGeometryElement(BasicShapes.text, points, slateTextElement);
  return { textElement, containerElement };
};

// ../../node_modules/@plait-board/mermaid-to-drawnix/dist/converter/types/sequence.js
var sequenceToDrawnixConvertor = new GraphConverter({
  converter: (chart, config) => {
    const elements = [];
    const activations = [];
    const mermaidGroupIdToElementMap = {};
    Object.values(chart.nodes).forEach((node) => {
      if (!node || !node.length) {
        return;
      }
      node.forEach((element) => {
        let plaitElement;
        switch (element.type) {
          case "line":
            plaitElement = transformToDrawnixLineElement(element, mermaidGroupIdToElementMap, config);
            break;
          case "rectangle":
          case "ellipse":
            plaitElement = transformToDrawnixRectangleElement(element, mermaidGroupIdToElementMap, config);
            break;
          case "text":
            plaitElement = transformToDrawnixTextElement(element, mermaidGroupIdToElementMap, config);
            break;
          default:
            throw `unknown type ${element.type}`;
            break;
        }
        plaitElement.origin = element;
        if (element.type === "rectangle" && (element == null ? void 0 : element.subtype) === "activation") {
          activations.push(plaitElement);
        } else {
          elements.push(plaitElement);
        }
      });
    });
    Object.values(chart.lines).forEach((line) => {
      if (!line) {
        return;
      }
      elements.push(transformToDrawnixLineElement(line, mermaidGroupIdToElementMap, config));
    });
    Object.values(chart.arrows).forEach((arrow) => {
      if (!arrow) {
        return;
      }
      elements.push(transformToDrawnixArrowElement(arrow, mermaidGroupIdToElementMap, config));
      if (arrow.sequenceNumber) {
        elements.push(transformToDrawnixRectangleElement(arrow.sequenceNumber, mermaidGroupIdToElementMap, config));
      }
    });
    elements.push(...activations);
    if (chart.loops) {
      const { lines, texts, nodes } = chart.loops;
      lines.forEach((line) => {
        elements.push(transformToDrawnixLineElement(line, mermaidGroupIdToElementMap, config));
      });
      texts.forEach((text) => {
        elements.push(transformToDrawnixTextElement(text, mermaidGroupIdToElementMap, config));
      });
      nodes.forEach((node) => {
        elements.push(transformToDrawnixRectangleElement(node, mermaidGroupIdToElementMap, config));
      });
    }
    if (chart.groups) {
      chart.groups.forEach((group) => {
        const { actorKeys, name } = group;
        if (!actorKeys.length) {
          return;
        }
        const actors = elements.filter((ele) => {
          const element = ele;
          if (element.origin && element.origin.id) {
            const hyphenIndex = element.origin.id.indexOf("-");
            const id = element.origin.id.substring(0, hyphenIndex);
            return actorKeys.includes(id);
          }
          return false;
        });
        const { textElement, containerElement } = transformToDrawnixGroupElement(actors, name, { fill: group.fill });
        elements.unshift(textElement);
        elements.unshift(containerElement);
        const groupElement = createGroup();
        containerElement.groupId = groupElement.id;
        elements.forEach((ele) => {
          if (PlaitGroupElement.isGroup(ele)) {
            return;
          }
          const element = ele;
          const containerRectangle = RectangleClient.getRectangleByPoints(containerElement.points);
          const isInContainer = element.points.every((point) => {
            return RectangleClient.isPointInRectangle(containerRectangle, point);
          });
          if (isInContainer) {
            element.groupId = groupElement.id;
          }
        });
        elements.push(groupElement);
      });
    }
    elements.forEach((ele) => {
      if (ele.origin) {
        delete ele.origin;
      }
    });
    Object.values(mermaidGroupIdToElementMap).forEach((groupElement) => {
      elements.push(groupElement);
    });
    return { elements };
  }
});

// ../../node_modules/@plait-board/mermaid-to-drawnix/dist/converter/types/class.js
var classToDrawnixConvertor = new GraphConverter({
  converter: (chart, config) => {
    const elements = [];
    const mermaidIdToElementMap = {};
    const mermaidGroupIdToElementMap = {};
    Object.values(chart.nodes).forEach((node) => {
      if (!node || !node.length) {
        return;
      }
      node.forEach((element) => {
        let drawnixElement;
        switch (element.type) {
          case "line":
            drawnixElement = transformToDrawnixLineElement(element, mermaidGroupIdToElementMap, config);
            break;
          case "rectangle":
          case "ellipse":
            drawnixElement = transformToDrawnixRectangleElement(element, mermaidGroupIdToElementMap, config);
            break;
          case "text":
            drawnixElement = transformToDrawnixTextElement(element, mermaidGroupIdToElementMap, config);
            break;
          default:
            throw `unknown type ${element.type}`;
            break;
        }
        drawnixElement.origin = element;
        if (element.id) {
          mermaidIdToElementMap[element.id] = drawnixElement;
        }
        elements.push(drawnixElement);
      });
    });
    Object.values(chart.lines).forEach((line) => {
      if (!line) {
        return;
      }
      let drawnixElement = transformToDrawnixLineElement(line, mermaidGroupIdToElementMap, config);
      drawnixElement.origin = line;
      elements.push(drawnixElement);
    });
    Object.values(chart.arrows).forEach((arrow) => {
      if (!arrow) {
        return;
      }
      const drawnixElement = transformToDrawnixArrowElement(arrow, mermaidGroupIdToElementMap, {
        ...config,
        arrowLineShape: ArrowLineShape.straight
      });
      if (arrow.start && arrow.start.id && mermaidIdToElementMap[arrow.start.id]) {
        drawnixElement.source.boundId = mermaidIdToElementMap[arrow.start.id].id;
        drawnixElement.source.connection = getHitConnectionFromConnectionPoint(drawnixElement.points[0], mermaidIdToElementMap[arrow.start.id]);
      }
      if (arrow.end && arrow.end.id && mermaidIdToElementMap[arrow.end.id]) {
        drawnixElement.target.boundId = mermaidIdToElementMap[arrow.end.id].id;
        drawnixElement.target.connection = getHitConnectionFromConnectionPoint(drawnixElement.points[drawnixElement.points.length - 1], mermaidIdToElementMap[arrow.end.id]);
      }
      drawnixElement.origin = arrow;
      elements.push(drawnixElement);
    });
    Object.values(chart.text).forEach((ele) => {
      const drawnixElement = transformToDrawnixTextElement(ele, mermaidGroupIdToElementMap, config);
      drawnixElement.origin = ele;
      elements.push(drawnixElement);
    });
    Object.values(chart.namespaces).forEach((namespace) => {
      const classIds = Object.keys(namespace.classes);
      const children = [...classIds];
      const chartElements = [...chart.lines, ...chart.arrows, ...chart.text];
      classIds.forEach((classId) => {
        const childIds = chartElements.filter((ele) => ele.metadata && ele.metadata.classId === classId).map((ele) => ele.id);
        if (childIds.length) {
          children.push(...childIds);
        }
      });
      const childrenElements = elements.filter((ele) => ele.origin && ele.origin.id && children.includes(ele.origin.id));
      const { textElement, containerElement } = transformToDrawnixGroupElement(childrenElements, namespace.id);
      elements.unshift(textElement);
      elements.unshift(containerElement);
    });
    elements.forEach((ele) => {
      if (ele.origin) {
        delete ele.origin;
      }
    });
    Object.values(mermaidGroupIdToElementMap).forEach((groupElement) => {
      elements.push(groupElement);
    });
    return { elements };
  }
});

// ../../node_modules/@plait-board/mermaid-to-drawnix/dist/converter/types/graphImage.js
var createImage = (startPoint, imageItem) => {
  const { width, height, url } = imageItem;
  const points = [
    startPoint,
    [startPoint[0] + width, startPoint[1] + height]
  ];
  const imageElement = {
    id: idCreator(),
    type: "image",
    points,
    url
  };
  return imageElement;
};
var graphImageConverter = new GraphConverter({
  converter: (graph) => {
    const { width, height } = graph;
    const imageElement = createImage([0, 0], {
      width,
      height,
      url: graph.dataURL
    });
    return { elements: [imageElement] };
  }
});

// ../../node_modules/@plait-board/mermaid-to-drawnix/dist/graphToDrawnix.js
var graphToDrawnix = (graph, options = { fontSize: 20 }) => {
  switch (graph.type) {
    case "graphImage": {
      return graphImageConverter.convert(graph, options);
    }
    case "flowchart": {
      return flowchartToDrawnixConverter.convert(graph, options);
    }
    case "sequence": {
      return sequenceToDrawnixConvertor.convert(graph, options);
    }
    case "class": {
      return classToDrawnixConvertor.convert(graph, options);
    }
    default: {
      throw new Error(`graphToDrawnix: unknown graph type "${graph.type}, only flowcharts are supported!"`);
    }
  }
};

// ../../node_modules/mermaid/dist/mermaid.core.mjs
var import_dayjs = __toESM(require_dayjs_min(), 1);
var import_sanitize_url = __toESM(require_dist(), 1);

// ../../node_modules/@plait-board/mermaid-to-drawnix/dist/utils.js
var entityCodesToText = (input) => {
  input = decodeEntities(input);
  const inputWithDecimalCode = input.replace(/#(\d+);/g, "&#$1;").replace(/#([a-z]+);/g, "&$1;");
  const element = document.createElement("textarea");
  element.innerHTML = inputWithDecimalCode;
  return element.value;
};
var getTransformAttr = (el) => {
  const transformAttr = el.getAttribute("transform");
  const translateMatch = transformAttr == null ? void 0 : transformAttr.match(/translate\(([ \d.-]+),\s*([\d.-]+)\)/);
  let transformX = 0;
  let transformY = 0;
  if (translateMatch) {
    transformX = Number(translateMatch[1]);
    transformY = Number(translateMatch[2]);
  }
  return { transformX, transformY };
};
var encodeEntities = (text) => {
  let txt = text;
  txt = txt.replace(/style.*:\S*#.*;/g, (s) => {
    return s.substring(0, s.length - 1);
  });
  txt = txt.replace(/classDef.*:\S*#.*;/g, (s) => {
    return s.substring(0, s.length - 1);
  });
  txt = txt.replace(/#\w+;/g, (s) => {
    const innerTxt = s.substring(1, s.length - 1);
    const isInt = /^\+?\d+$/.test(innerTxt);
    if (isInt) {
      return `ﬂ°°${innerTxt}¶ß`;
    }
    return `ﬂ°${innerTxt}¶ß`;
  });
  return txt;
};
var decodeEntities = function(text) {
  return text.replace(/ﬂ°°/g, "#").replace(/ﬂ°/g, "&").replace(/¶ß/g, ";");
};
var computeEdgePositions = (pathElement, offset = { x: 0, y: 0 }) => {
  if (pathElement.tagName.toLowerCase() !== "path") {
    throw new Error(`Invalid input: Expected an HTMLElement of tag "path", got ${pathElement.tagName}`);
  }
  const dAttr = pathElement.getAttribute("d");
  if (!dAttr) {
    throw new Error('Path element does not contain a "d" attribute');
  }
  const commands = dAttr.split(/(?=[LM])/);
  const startPosition = commands[0].substring(1).split(",").map((coord) => parseFloat(coord));
  const endPosition = commands[commands.length - 1].substring(1).split(",").map((coord) => parseFloat(coord));
  const reflectionPoints = commands.map((command) => {
    const coords = command.substring(1).split(",").map((coord) => parseFloat(coord));
    return { x: coords[0], y: coords[1] };
  }).filter((point, index, array) => {
    if (index === 0 || index === array.length - 1) {
      return true;
    }
    if (point.x === array[index - 1].x && point.y === array[index - 1].y) {
      return false;
    }
    if (index === array.length - 2 && (array[index - 1].x === point.x || array[index - 1].y === point.y)) {
      const lastPoint = array[array.length - 1];
      const distance = Math.hypot(lastPoint.x - point.x, lastPoint.y - point.y);
      return distance > 20;
    }
    return point.x !== array[index - 1].x || point.y !== array[index - 1].y;
  }).map((p) => {
    return {
      x: p.x + offset.x,
      y: p.y + offset.y
    };
  });
  return {
    startX: startPosition[0] + offset.x,
    startY: startPosition[1] + offset.y,
    endX: endPosition[0] + offset.x,
    endY: endPosition[1] + offset.y,
    reflectionPoints
  };
};

// ../../node_modules/@plait-board/mermaid-to-drawnix/dist/parser/flowchart.js
var parseSubGraph = (data, containerEl) => {
  const nodeIds = data.nodes.map((n) => {
    if (n.startsWith("flowchart-")) {
      return n.split("-")[1];
    }
    return n;
  });
  const el = containerEl.querySelector(`[id='${data.id}']`);
  if (!el) {
    throw new Error("SubGraph element not found");
  }
  const position = computeElementPosition(el, containerEl);
  const boundingBox = el.getBBox();
  const dimension = {
    width: boundingBox.width,
    height: boundingBox.height
  };
  data.classes = void 0;
  data.dir = void 0;
  return {
    ...data,
    nodeIds,
    ...position,
    ...dimension,
    text: entityCodesToText(data.title)
  };
};
var parseVertex = (data, containerEl, classes) => {
  var _a, _b, _c, _d, _e;
  const el = containerEl.querySelector(`[id*="flowchart-${data.id}-"]`);
  if (!el) {
    return void 0;
  }
  let link;
  if (((_a = el.parentElement) == null ? void 0 : _a.tagName.toLowerCase()) === "a") {
    link = el.parentElement.getAttribute("xlink:href");
  }
  const position = computeElementPosition(link ? el.parentElement : el, containerEl);
  const boundingBox = el.getBBox();
  const dimension = {
    width: boundingBox.width,
    height: boundingBox.height
  };
  const labelContainerStyleText = (_b = el.querySelector(".label-container")) == null ? void 0 : _b.getAttribute("style");
  const labelStyleText = (_c = el.querySelector(".label")) == null ? void 0 : _c.getAttribute("style");
  const containerStyle = {};
  labelContainerStyleText == null ? void 0 : labelContainerStyleText.split(";").forEach((property) => {
    if (!property) {
      return;
    }
    const key = property.split(":")[0].trim();
    const value = property.split(":")[1].trim();
    containerStyle[key] = value;
  });
  const labelStyle = {};
  labelStyleText == null ? void 0 : labelStyleText.split(";").forEach((property) => {
    if (!property) {
      return;
    }
    const key = property.split(":")[0].trim();
    const value = property.split(":")[1].trim();
    labelStyle[key] = value;
  });
  if (data.classes) {
    const classDef = classes[data.classes];
    if (classDef) {
      (_d = classDef.styles) == null ? void 0 : _d.forEach((style) => {
        const [key, value] = style.split(":");
        containerStyle[key.trim()] = value.trim();
      });
      (_e = classDef.textStyles) == null ? void 0 : _e.forEach((style) => {
        const [key, value] = style.split(":");
        labelStyle[key.trim()] = value.trim();
      });
    }
  }
  return {
    id: data.id,
    labelType: data.labelType,
    text: entityCodesToText(data.text),
    type: data.type,
    link: link || void 0,
    ...position,
    ...dimension,
    containerStyle,
    labelStyle
  };
};
var parseEdge = (data, edgeIndex, containerEl) => {
  const edge = containerEl.querySelector(`[id*="L-${data.start}-${data.end}-${edgeIndex}"]`);
  if (!edge) {
    throw new Error("Edge element not found");
  }
  const position = computeElementPosition(edge, containerEl);
  const edgePositionData = computeEdgePositions(edge, position);
  data.length = void 0;
  return {
    ...data,
    ...edgePositionData,
    text: entityCodesToText(data.text)
  };
};
var computeElementPosition = (el, containerEl) => {
  var _a;
  if (!el) {
    throw new Error("Element not found");
  }
  let root = (_a = el.parentElement) == null ? void 0 : _a.parentElement;
  const childElement = el.childNodes[0];
  let childPosition = { x: 0, y: 0 };
  if (childElement) {
    const { transformX: transformX2, transformY: transformY2 } = getTransformAttr(childElement);
    const boundingBox = childElement.getBBox();
    childPosition = {
      x: Number(childElement.getAttribute("x")) || transformX2 + boundingBox.x || 0,
      y: Number(childElement.getAttribute("y")) || transformY2 + boundingBox.y || 0
    };
  }
  const { transformX, transformY } = getTransformAttr(el);
  const position = {
    x: transformX + childPosition.x,
    y: transformY + childPosition.y
  };
  while (root && root.id !== containerEl.id) {
    if (root.classList.value === "root" && root.hasAttribute("transform")) {
      const { transformX: transformX2, transformY: transformY2 } = getTransformAttr(root);
      position.x += transformX2;
      position.y += transformY2;
    }
    root = root.parentElement;
  }
  return position;
};
var parseMermaidFlowChartDiagram = (diagram, containerEl) => {
  diagram.parse();
  const mermaidParser = diagram.parser.yy;
  const vertices = mermaidParser.getVertices();
  const classes = mermaidParser.getClasses();
  Object.keys(vertices).forEach((id) => {
    vertices[id] = parseVertex(vertices[id], containerEl, classes);
  });
  const edgeCountMap = /* @__PURE__ */ new Map();
  const edges = mermaidParser.getEdges().filter((edge) => {
    return containerEl.querySelector(`[id*="L-${edge.start}-${edge.end}"]`);
  }).map((data) => {
    const edgeId = `${data.start}-${data.end}`;
    const count = edgeCountMap.get(edgeId) || 0;
    edgeCountMap.set(edgeId, count + 1);
    return parseEdge(data, count, containerEl);
  });
  const subGraphs = mermaidParser.getSubGraphs().map((data) => parseSubGraph(data, containerEl));
  return {
    type: "flowchart",
    subGraphs,
    vertices,
    edges
  };
};

// ../../node_modules/@plait-board/mermaid-to-drawnix/dist/elementSkeleton.js
var createArrowSkeletonFromSVG = (arrowNode, opts) => {
  const arrow = {};
  if (opts == null ? void 0 : opts.label) {
    arrow.label = { text: entityCodesToText(opts.label), fontSize: 16 };
  }
  const tagName = arrowNode.tagName;
  if (tagName === "line") {
    arrow.startX = Number(arrowNode.getAttribute("x1"));
    arrow.startY = Number(arrowNode.getAttribute("y1"));
    arrow.endX = Number(arrowNode.getAttribute("x2"));
    arrow.endY = Number(arrowNode.getAttribute("y2"));
  } else if (tagName === "path") {
    const dAttr = arrowNode.getAttribute("d");
    if (!dAttr) {
      throw new Error('Path element does not contain a "d" attribute');
    }
    const commands = dAttr.split(/(?=[LC])/);
    const startPosition = commands[0].substring(1).split(",").map((coord) => parseFloat(coord));
    const points = [];
    commands.forEach((command) => {
      const currPoints = command.substring(1).trim().split(" ").map((pos) => {
        const [x, y] = pos.split(",");
        return [
          parseFloat(x) - startPosition[0],
          parseFloat(y) - startPosition[1]
        ];
      });
      points.push(...currPoints);
    });
    const endPosition = points[points.length - 1];
    arrow.startX = startPosition[0];
    arrow.startY = startPosition[1];
    arrow.endX = endPosition[0];
    arrow.endY = endPosition[1];
    arrow.points = points;
  }
  if (opts == null ? void 0 : opts.label) {
    const offset = 10;
    arrow.startY = arrow.startY - offset;
    arrow.endY = arrow.endY - offset;
  }
  arrow.strokeColor = arrowNode.getAttribute("stroke");
  arrow.strokeWidth = Number(arrowNode.getAttribute("stroke-width"));
  arrow.type = "arrow";
  arrow.strokeStyle = (opts == null ? void 0 : opts.strokeStyle) || "solid";
  arrow.startArrowhead = (opts == null ? void 0 : opts.startArrowhead) || null;
  arrow.endArrowhead = (opts == null ? void 0 : opts.endArrowhead) || null;
  return arrow;
};
var createArrowSkeleton = (startX, startY, endX, endY, opts) => {
  const arrow = {};
  arrow.type = "arrow";
  arrow.startX = startX;
  arrow.startY = startY;
  arrow.endX = endX;
  arrow.endY = endY;
  Object.assign(arrow, { ...opts });
  return arrow;
};
var createTextSkeleton = (x, y, text, opts) => {
  const textElement = {
    type: "text",
    x,
    y,
    text,
    width: (opts == null ? void 0 : opts.width) || 20,
    height: (opts == null ? void 0 : opts.height) || 20,
    fontSize: (opts == null ? void 0 : opts.fontSize) || DEFAULT_FONT_SIZE2,
    id: opts == null ? void 0 : opts.id,
    groupId: opts == null ? void 0 : opts.groupId,
    metadata: opts == null ? void 0 : opts.metadata
  };
  return textElement;
};
var createTextSkeletonFromSVG = (textNode, text, opts) => {
  const node = {};
  const x = Number(textNode.getAttribute("x"));
  const y = Number(textNode.getAttribute("y"));
  node.type = "text";
  node.text = entityCodesToText(text);
  if (opts == null ? void 0 : opts.id) {
    node.id = opts.id;
  }
  if (opts == null ? void 0 : opts.groupId) {
    node.groupId = opts.groupId;
  }
  const boundingBox = textNode.getBBox();
  node.width = boundingBox.width;
  node.height = boundingBox.height;
  node.x = x - boundingBox.width / 2;
  node.y = y;
  const fontSize = parseInt(getComputedStyle(textNode).fontSize);
  node.fontSize = fontSize;
  return node;
};
var createContainerSkeletonFromSVG = (node, type, opts = {}) => {
  const container = {};
  container.type = type;
  const { label, subtype, id, groupId } = opts;
  container.id = id;
  if (groupId) {
    container.groupId = groupId;
  }
  if (label) {
    container.label = {
      text: entityCodesToText(label.text),
      fontSize: 16,
      verticalAlign: label == null ? void 0 : label.verticalAlign
    };
  }
  const boundingBox = node.getBBox();
  container.x = boundingBox.x;
  container.y = boundingBox.y;
  container.width = boundingBox.width;
  container.height = boundingBox.height;
  container.subtype = subtype;
  switch (subtype) {
    case "highlight":
      const bgColor = node.getAttribute("fill");
      if (bgColor) {
        container.bgColor = bgColor;
      }
      break;
    case "note":
      container.strokeStyle = "dashed";
      break;
  }
  return container;
};
var createLineSkeletonFromSVG = (lineNode, startX, startY, endX, endY, opts) => {
  const line = {};
  line.startX = startX;
  line.startY = startY;
  line.endX = endX;
  if (opts == null ? void 0 : opts.groupId) {
    line.groupId = opts.groupId;
  }
  if (opts == null ? void 0 : opts.id) {
    line.id = opts.id;
  }
  line.endY = endY;
  line.strokeColor = lineNode.getAttribute("stroke");
  line.strokeWidth = Number(lineNode.getAttribute("stroke-width"));
  line.type = "line";
  return line;
};

// ../../node_modules/@plait-board/mermaid-to-drawnix/dist/parser/sequence.js
var SEQUENCE_ARROW_TYPES = {
  0: "SOLID",
  1: "DOTTED",
  3: "SOLID_CROSS",
  4: "DOTTED_CROSS",
  5: "SOLID_OPEN",
  6: "DOTTED_OPEN",
  24: "SOLID_POINT",
  25: "DOTTED_POINT"
};
var MESSAGE_TYPE = {
  SOLID: 0,
  DOTTED: 1,
  NOTE: 2,
  SOLID_CROSS: 3,
  DOTTED_CROSS: 4,
  SOLID_OPEN: 5,
  DOTTED_OPEN: 6,
  LOOP_START: 10,
  LOOP_END: 11,
  ALT_START: 12,
  ALT_ELSE: 13,
  ALT_END: 14,
  OPT_START: 15,
  OPT_END: 16,
  ACTIVE_START: 17,
  ACTIVE_END: 18,
  PAR_START: 19,
  PAR_AND: 20,
  PAR_END: 21,
  RECT_START: 22,
  RECT_END: 23,
  SOLID_POINT: 24,
  DOTTED_POINT: 25,
  AUTONUMBER: 26,
  CRITICAL_START: 27,
  CRITICAL_OPTION: 28,
  CRITICAL_END: 29,
  BREAK_START: 30,
  BREAK_END: 31,
  PAR_OVER_START: 32
};
var getStrokeStyle = (type) => {
  let strokeStyle;
  switch (type) {
    case MESSAGE_TYPE.SOLID:
    case MESSAGE_TYPE.SOLID_CROSS:
    case MESSAGE_TYPE.SOLID_OPEN:
    case MESSAGE_TYPE.SOLID_POINT:
      strokeStyle = StrokeStyle.solid;
      break;
    case MESSAGE_TYPE.DOTTED:
    case MESSAGE_TYPE.DOTTED_CROSS:
    case MESSAGE_TYPE.DOTTED_OPEN:
    case MESSAGE_TYPE.DOTTED_POINT:
      strokeStyle = StrokeStyle.dotted;
      break;
    default:
      strokeStyle = StrokeStyle.solid;
      break;
  }
  return strokeStyle;
};
var attachSequenceNumberToArrow = (node, arrow) => {
  var _a, _b;
  const showSequenceNumber = !!((_a = node.nextElementSibling) == null ? void 0 : _a.classList.contains("sequenceNumber"));
  if (showSequenceNumber) {
    const text = (_b = node.nextElementSibling) == null ? void 0 : _b.textContent;
    if (!text) {
      throw new Error("sequence number not present");
    }
    const height = 30;
    const yOffset = height / 2;
    const xOffset = 10;
    const sequenceNumber = {
      type: "rectangle",
      x: arrow.startX - xOffset,
      y: arrow.startY - yOffset,
      label: { text, fontSize: 14 },
      bgColor: "#e9ecef",
      height,
      subtype: "sequence"
    };
    Object.assign(arrow, { sequenceNumber });
  }
};
var createActorSymbol = (rootNode, text, opts) => {
  if (!rootNode) {
    throw "root node not found";
  }
  const groupId = idCreator();
  const children = Array.from(rootNode.children);
  const nodeElements = [];
  children.forEach((child, index) => {
    const id = `${opts == null ? void 0 : opts.id}-${index}`;
    let ele;
    switch (child.tagName) {
      case "line":
        const startX = Number(child.getAttribute("x1"));
        const startY = Number(child.getAttribute("y1"));
        const endX = Number(child.getAttribute("x2"));
        const endY = Number(child.getAttribute("y2"));
        ele = createLineSkeletonFromSVG(child, startX, startY, endX, endY, { groupId, id });
        break;
      case "text":
        ele = createTextSkeletonFromSVG(child, text, {
          groupId,
          id
        });
        break;
      case "circle":
        ele = createContainerSkeletonFromSVG(child, "ellipse", {
          label: child.textContent ? { text: child.textContent } : void 0,
          groupId,
          id
        });
      default:
        ele = createContainerSkeletonFromSVG(child, SVG_TO_SHAPE_MAPPER[child.tagName], {
          label: child.textContent ? { text: child.textContent } : void 0,
          groupId,
          id
        });
    }
    nodeElements.push(ele);
  });
  return nodeElements;
};
var parseActor = (actors, containerEl) => {
  const actorTopNodes = Array.from(containerEl.querySelectorAll(".actor-top"));
  const actorBottomNodes = Array.from(containerEl.querySelectorAll(".actor-bottom"));
  const nodes = [];
  const lines = [];
  Object.values(actors).forEach((actor, index) => {
    var _a;
    const topRootNode = actorTopNodes.find((actorNode) => actorNode.getAttribute("name") === actor.name);
    const bottomRootNode = actorBottomNodes.find((actorNode) => actorNode.getAttribute("name") === actor.name);
    if (!topRootNode || !bottomRootNode) {
      throw "root not found";
    }
    const text = actor.description;
    if (actor.type === "participant") {
      const topNodeElement = createContainerSkeletonFromSVG(topRootNode, "rectangle", { id: `${actor.name}-top`, label: { text }, subtype: "actor" });
      if (!topNodeElement) {
        throw "Top Node element not found!";
      }
      nodes.push([topNodeElement]);
      const bottomNodeElement = createContainerSkeletonFromSVG(bottomRootNode, "rectangle", { id: `${actor.name}-bottom`, label: { text }, subtype: "actor" });
      nodes.push([bottomNodeElement]);
      const lineNode = (_a = topRootNode == null ? void 0 : topRootNode.parentElement) == null ? void 0 : _a.previousElementSibling;
      if ((lineNode == null ? void 0 : lineNode.tagName) !== "line") {
        throw "Line not found";
      }
      const startX = Number(lineNode.getAttribute("x1"));
      if (!topNodeElement.height) {
        throw "Top node element height is null";
      }
      const startY = topNodeElement.y + topNodeElement.height;
      const endY = bottomNodeElement.y;
      const endX = Number(lineNode.getAttribute("x2"));
      const line = createLineSkeletonFromSVG(lineNode, startX, startY, endX, endY);
      lines.push(line);
    } else if (actor.type === "actor") {
      const topNodeElement = createActorSymbol(topRootNode, text, {
        id: `${actor.name}-top`
      });
      nodes.push(topNodeElement);
      const bottomNodeElement = createActorSymbol(bottomRootNode, text, {
        id: `${actor.name}-bottom`
      });
      nodes.push(bottomNodeElement);
      const lineNode = topRootNode.previousElementSibling;
      if ((lineNode == null ? void 0 : lineNode.tagName) !== "line") {
        throw "Line not found";
      }
      const startX = Number(lineNode.getAttribute("x1"));
      const startY = Number(lineNode.getAttribute("y1"));
      const endX = Number(lineNode.getAttribute("x2"));
      const bottomEllipseNode = bottomNodeElement.find((node) => node.type === "ellipse");
      if (bottomEllipseNode) {
        const endY = bottomEllipseNode.y;
        const line = createLineSkeletonFromSVG(lineNode, startX, startY, endX, endY);
        lines.push(line);
      }
    }
  });
  return { nodes, lines };
};
var computeArrows = (messages, containerEl) => {
  const arrows = [];
  const arrowNodes = Array.from(containerEl.querySelectorAll('[class*="messageLine"]'));
  const supportedMessageTypes = Object.keys(SEQUENCE_ARROW_TYPES);
  const arrowMessages = messages.filter((message) => supportedMessageTypes.includes(message.type.toString()));
  arrowNodes.forEach((arrowNode, index) => {
    const message = arrowMessages[index];
    const messageType = SEQUENCE_ARROW_TYPES[message.type];
    const arrow = createArrowSkeletonFromSVG(arrowNode, {
      label: message == null ? void 0 : message.message,
      strokeStyle: getStrokeStyle(message.type),
      endArrowhead: messageType === "SOLID_OPEN" || messageType === "DOTTED_OPEN" ? null : "arrow"
    });
    attachSequenceNumberToArrow(arrowNode, arrow);
    arrows.push(arrow);
  });
  return arrows;
};
var computeNotes = (messages, containerEl) => {
  const noteNodes = Array.from(containerEl.querySelectorAll(".note")).map((node) => node.parentElement);
  const noteText = messages.filter((message) => message.type === MESSAGE_TYPE.NOTE);
  const notes = [];
  noteNodes.forEach((node, index) => {
    if (!node) {
      return;
    }
    const rect = node.firstChild;
    const text = noteText[index].message;
    const note = createContainerSkeletonFromSVG(rect, "rectangle", {
      label: { text },
      subtype: "note"
    });
    notes.push(note);
  });
  return notes;
};
var parseActivations = (containerEl) => {
  const activationNodes = Array.from(containerEl.querySelectorAll(`[class*=activation]`));
  const activations = [];
  activationNodes.forEach((node) => {
    const rect = createContainerSkeletonFromSVG(node, "rectangle", {
      label: { text: "" },
      subtype: "activation"
    });
    activations.push(rect);
  });
  return activations;
};
var parseLoops = (messages, containerEl) => {
  const lineNodes = Array.from(containerEl.querySelectorAll(".loopLine"));
  const lines = [];
  const texts = [];
  const nodes = [];
  lineNodes.forEach((node) => {
    const startX = Number(node.getAttribute("x1"));
    const startY = Number(node.getAttribute("y1"));
    const endX = Number(node.getAttribute("x2"));
    const endY = Number(node.getAttribute("y2"));
    const line = createLineSkeletonFromSVG(node, startX, startY, endX, endY);
    line.strokeStyle = StrokeStyle.dotted;
    line.strokeColor = "#adb5bd";
    line.strokeWidth = 2;
    lines.push(line);
  });
  const loopTextNodes = Array.from(containerEl.querySelectorAll(".loopText"));
  const criticalMessages = messages.filter((message) => message.type === MESSAGE_TYPE.CRITICAL_START).map((message) => message.message);
  loopTextNodes.forEach((node) => {
    var _a;
    const text = node.textContent || "";
    const textElement = createTextSkeletonFromSVG(node, text);
    const rawText = ((_a = text.match(/\[(.*?)\]/)) == null ? void 0 : _a[1]) || "";
    const isCritical = criticalMessages.includes(rawText);
    if (isCritical) {
      textElement.x += 16;
    }
    texts.push(textElement);
  });
  const labelBoxes = Array.from(containerEl == null ? void 0 : containerEl.querySelectorAll(".labelBox"));
  const labelTextNode = Array.from(containerEl == null ? void 0 : containerEl.querySelectorAll(".labelText"));
  labelBoxes.forEach((labelBox, index) => {
    var _a;
    const text = ((_a = labelTextNode[index]) == null ? void 0 : _a.textContent) || "";
    const container = createContainerSkeletonFromSVG(labelBox, "rectangle", {
      label: { text }
    });
    container.strokeColor = "#adb5bd";
    container.bgColor = "#e9ecef";
    container.width = void 0;
    nodes.push(container);
  });
  return { lines, texts, nodes };
};
var computeHighlights = (containerEl) => {
  const rects = Array.from(containerEl.querySelectorAll(".rect")).filter((node) => {
    var _a;
    return ((_a = node.parentElement) == null ? void 0 : _a.tagName) !== "g";
  });
  const nodes = [];
  rects.forEach((rect) => {
    const node = createContainerSkeletonFromSVG(rect, "rectangle", {
      label: { text: "" },
      subtype: "highlight"
    });
    nodes.push(node);
  });
  return nodes;
};
var parseMermaidSequenceDiagram = (diagram, containerEl) => {
  diagram.parse();
  const mermaidParser = diagram.parser.yy;
  const nodes = [];
  const groups = mermaidParser.getBoxes();
  const bgHightlights = computeHighlights(containerEl);
  const actorData = mermaidParser.getActors();
  const { nodes: actors, lines } = parseActor(actorData, containerEl);
  const messages = mermaidParser.getMessages();
  const arrows = computeArrows(messages, containerEl);
  const notes = computeNotes(messages, containerEl);
  const activations = parseActivations(containerEl);
  const loops = parseLoops(messages, containerEl);
  nodes.push(bgHightlights);
  nodes.push(...actors);
  nodes.push(notes);
  nodes.push(activations);
  return { type: "sequence", lines, arrows, nodes, loops, groups };
};

// ../../node_modules/@plait-board/mermaid-to-drawnix/dist/parser/class.js
var RELATION_TYPE = {
  AGGREGATION: 0,
  EXTENSION: 1,
  COMPOSITION: 2,
  DEPENDENCY: 3,
  LOLLIPOP: 4
};
var LINE_TYPE = {
  LINE: 0,
  DOTTED_LINE: 1
};
var MERMAID_ARROW_HEAD_OFFSET = 16;
var getStrokeStyle2 = (type) => {
  let lineType;
  switch (type) {
    case LINE_TYPE.LINE:
      lineType = StrokeStyle.solid;
      break;
    case LINE_TYPE.DOTTED_LINE:
      lineType = StrokeStyle.dotted;
      break;
    default:
      lineType = StrokeStyle.solid;
  }
  return lineType;
};
var getArrowhead = (type) => {
  let arrowhead;
  switch (type) {
    case RELATION_TYPE.AGGREGATION:
      arrowhead = "diamond_outline";
      break;
    case RELATION_TYPE.COMPOSITION:
      arrowhead = "diamond";
      break;
    case RELATION_TYPE.EXTENSION:
      arrowhead = "triangle_outline";
      break;
    case "none":
      arrowhead = null;
      break;
    case RELATION_TYPE.DEPENDENCY:
    default:
      arrowhead = "arrow";
      break;
  }
  return arrowhead;
};
var parseClasses = (classes, containerEl) => {
  const nodes = [];
  const lines = [];
  const text = [];
  Object.values(classes).forEach((classNode) => {
    var _a;
    const { domId, id: classId } = classNode;
    const groupId = idCreator();
    const domNode = containerEl.querySelector(`[data-id=${classId}]`);
    if (!domNode) {
      throw Error(`DOM Node with id ${domId} not found`);
    }
    const { transformX, transformY } = getTransformAttr(domNode);
    const container = createContainerSkeletonFromSVG(domNode.firstChild, "rectangle", { id: classId, groupId });
    container.x += transformX;
    container.y += transformY;
    container.metadata = { classId };
    nodes.push(container);
    const lineNodes = Array.from(domNode.querySelectorAll(".divider"));
    lineNodes.forEach((lineNode) => {
      const startX = Number(lineNode.getAttribute("x1"));
      const startY = Number(lineNode.getAttribute("y1"));
      const endX = Number(lineNode.getAttribute("x2"));
      const endY = Number(lineNode.getAttribute("y2"));
      const line = createLineSkeletonFromSVG(lineNode, startX, startY, endX, endY, {
        groupId,
        id: idCreator()
      });
      line.startX += transformX;
      line.startY += transformY;
      line.endX += transformX;
      line.endY += transformY;
      line.metadata = { classId };
      lines.push(line);
    });
    const labelNodes = (_a = domNode.querySelector(".label")) == null ? void 0 : _a.children;
    if (!labelNodes) {
      throw "label nodes not found";
    }
    Array.from(labelNodes).forEach((node) => {
      const label = node.textContent;
      if (!label) {
        return;
      }
      const id = idCreator();
      const { transformX: textTransformX, transformY: textTransformY } = getTransformAttr(node);
      const boundingBox = node.getBBox();
      const offsetY = 10;
      const textElement = createTextSkeleton(transformX + textTransformX, transformY + textTransformY + offsetY, label, {
        width: boundingBox.width,
        height: boundingBox.height,
        id,
        groupId,
        metadata: { classId }
      });
      text.push(textElement);
    });
  });
  return { nodes, lines, text };
};
var adjustArrowPosition = (direction, arrow) => {
  const arrowHeadShapes = ["triangle_outline", "diamond", "diamond_outline"];
  const shouldUpdateStartArrowhead = arrow.startArrowhead && arrowHeadShapes.includes(arrow.startArrowhead);
  const shouldUpdateEndArrowhead = arrow.endArrowhead && arrowHeadShapes.includes(arrow.endArrowhead);
  if (!shouldUpdateEndArrowhead && !shouldUpdateStartArrowhead) {
    return arrow;
  }
  if (shouldUpdateStartArrowhead) {
    if (direction === "LR") {
      arrow.startX -= MERMAID_ARROW_HEAD_OFFSET;
    } else if (direction === "RL") {
      arrow.startX += MERMAID_ARROW_HEAD_OFFSET;
    } else if (direction === "TB") {
      arrow.startY -= MERMAID_ARROW_HEAD_OFFSET;
    } else if (direction === "BT") {
      arrow.startY += MERMAID_ARROW_HEAD_OFFSET;
    }
  }
  if (shouldUpdateEndArrowhead) {
    if (direction === "LR") {
      arrow.endX += MERMAID_ARROW_HEAD_OFFSET;
    } else if (direction === "RL") {
      arrow.endX -= MERMAID_ARROW_HEAD_OFFSET;
    } else if (direction === "TB") {
      arrow.endY += MERMAID_ARROW_HEAD_OFFSET;
    } else if (direction === "BT") {
      arrow.endY -= MERMAID_ARROW_HEAD_OFFSET;
    }
  }
  return arrow;
};
var parseRelations = (relations, classNodes, containerEl, direction) => {
  var _a;
  const edges = (_a = containerEl.querySelector(".edgePaths")) == null ? void 0 : _a.children;
  if (!edges) {
    throw new Error("No Edges found!");
  }
  const arrows = [];
  const text = [];
  relations.forEach((relationNode, index) => {
    const { id1, id2, relation } = relationNode;
    const node1 = classNodes.find((node) => node.id === id1);
    const node2 = classNodes.find((node) => node.id === id2);
    const strokeStyle = getStrokeStyle2(relation.lineType);
    const startArrowhead = getArrowhead(relation.type1);
    const endArrowhead = getArrowhead(relation.type2);
    const edgePositionData = computeEdgePositions(edges[index]);
    const arrowSkeleton = createArrowSkeleton(edgePositionData.startX, edgePositionData.startY, edgePositionData.endX, edgePositionData.endY, {
      strokeStyle,
      startArrowhead,
      endArrowhead,
      label: relationNode.title ? { text: relationNode.title } : void 0,
      start: { type: "rectangle", id: node1.id },
      end: { type: "rectangle", id: node2.id }
    });
    const arrow = adjustArrowPosition(direction, arrowSkeleton);
    arrows.push(arrow);
    const { relationTitle1, relationTitle2 } = relationNode;
    const offsetX = 20;
    const offsetY = 15;
    const directionOffset = 15;
    let x;
    let y;
    if (relationTitle1 && relationTitle1 !== "none") {
      switch (direction) {
        case "TB":
          x = arrow.startX - offsetX;
          if (arrow.endX < arrow.startX) {
            x -= directionOffset;
          }
          y = arrow.startY + offsetY;
          break;
        case "BT":
          x = arrow.startX + offsetX;
          if (arrow.endX > arrow.startX) {
            x += directionOffset;
          }
          y = arrow.startY - offsetY;
          break;
        case "LR":
          x = arrow.startX + offsetX;
          y = arrow.startY + offsetY;
          if (arrow.endY > arrow.startY) {
            y += directionOffset;
          }
          break;
        case "RL":
          x = arrow.startX - offsetX;
          y = arrow.startY - offsetY;
          if (arrow.startY > arrow.endY) {
            y -= directionOffset;
          }
          break;
        default:
          x = arrow.startX - offsetX;
          y = arrow.startY + offsetY;
      }
      const relationTitleElement = createTextSkeleton(x, y, relationTitle1, {
        fontSize: 16
      });
      text.push(relationTitleElement);
    }
    if (relationTitle2 && relationTitle2 !== "none") {
      switch (direction) {
        case "TB":
          x = arrow.endX + offsetX;
          if (arrow.endX < arrow.startX) {
            x += directionOffset;
          }
          y = arrow.endY - offsetY;
          break;
        case "BT":
          x = arrow.endX - offsetX;
          if (arrow.endX > arrow.startX) {
            x -= directionOffset;
          }
          y = arrow.endY + offsetY;
          break;
        case "LR":
          x = arrow.endX - offsetX;
          y = arrow.endY - offsetY;
          if (arrow.endY > arrow.startY) {
            y -= directionOffset;
          }
          break;
        case "RL":
          x = arrow.endX + offsetX;
          y = arrow.endY + offsetY;
          if (arrow.startY > arrow.endY) {
            y += directionOffset;
          }
          break;
        default:
          x = arrow.endX + offsetX;
          y = arrow.endY - offsetY;
      }
      const relationTitleElement = createTextSkeleton(x, y, relationTitle2, {
        fontSize: 16
      });
      text.push(relationTitleElement);
    }
  });
  return { arrows, text };
};
var parseNotes = (notes, containerEl, classNodes) => {
  const noteContainers = [];
  const connectors = [];
  notes.forEach((note) => {
    const { id, text, class: classId } = note;
    const node = containerEl.querySelector(`#${id}`);
    if (!node) {
      throw new Error(`Node with id ${id} not found!`);
    }
    const { transformX, transformY } = getTransformAttr(node);
    const rect = node.firstChild;
    const container = createContainerSkeletonFromSVG(rect, "rectangle", {
      id,
      subtype: "note",
      label: { text }
    });
    Object.assign(container, {
      x: container.x + transformX,
      y: container.y + transformY
    });
    noteContainers.push(container);
    if (classId) {
      const classNode = classNodes.find((node2) => node2.id === classId);
      if (!classNode) {
        throw new Error(`class node with id ${classId} not found!`);
      }
      const startX = container.x + (container.width || 0) / 2;
      const startY = container.y + (container.height || 0);
      const endX = startX;
      const endY = classNode.y;
      const connector = createArrowSkeleton(startX, startY, endX, endY, {
        strokeStyle: "dotted",
        startArrowhead: null,
        endArrowhead: null,
        start: { id: container.id, type: "rectangle" },
        end: { id: classNode.id, type: "rectangle" }
      });
      connectors.push(connector);
    }
  });
  return { notes: noteContainers, connectors };
};
var parseMermaidClassDiagram = (diagram, containerEl) => {
  diagram.parse();
  const mermaidParser = diagram.parser.yy;
  const direction = mermaidParser.getDirection();
  const nodes = [];
  const lines = [];
  const text = [];
  const classNodes = [];
  const namespaces = mermaidParser.getNamespaces();
  const classes = mermaidParser.getClasses();
  if (Object.keys(classes).length) {
    const classData = parseClasses(classes, containerEl);
    nodes.push(classData.nodes);
    lines.push(...classData.lines);
    text.push(...classData.text);
    classNodes.push(...classData.nodes);
  }
  const relations = mermaidParser.getRelations();
  const { arrows, text: relationTitles } = parseRelations(relations, classNodes, containerEl, direction);
  const { notes, connectors } = parseNotes(mermaidParser.getNotes(), containerEl, classNodes);
  nodes.push(notes);
  arrows.push(...connectors);
  text.push(...relationTitles);
  return { type: "class", nodes, lines, arrows, text, namespaces };
};

// ../../node_modules/@plait-board/mermaid-to-drawnix/dist/parseMermaid.js
var convertSvgToGraphImage = (svgContainer) => {
  const svgEl = svgContainer.querySelector("svg");
  if (!svgEl) {
    throw new Error("SVG element not found");
  }
  const rect = svgEl.getBoundingClientRect();
  const width = rect.width;
  const height = rect.height;
  svgEl.setAttribute("width", `${width}`);
  svgEl.setAttribute("height", `${height}`);
  const mimeType = "image/svg+xml";
  const decoded = unescape(encodeURIComponent(svgEl.outerHTML));
  const base64 = btoa(decoded);
  const dataURL = `data:image/svg+xml;base64,${base64}`;
  const graphImage = {
    type: "graphImage",
    mimeType,
    dataURL,
    width,
    height
  };
  return graphImage;
};
var parseMermaid = async (definition, config = MERMAID_CONFIG) => {
  mermaid.initialize({ ...MERMAID_CONFIG, ...config });
  const diagram = await mermaid.mermaidAPI.getDiagramFromText(encodeEntities(definition));
  const { svg } = await mermaid.render("mermaid-to-drawnix", definition);
  const svgContainer = document.createElement("div");
  svgContainer.setAttribute("style", `opacity: 0; position: relative; z-index: -1;`);
  svgContainer.innerHTML = svg;
  svgContainer.id = "mermaid-diagram";
  document.body.appendChild(svgContainer);
  let data;
  switch (diagram.type) {
    case "flowchart-v2": {
      data = parseMermaidFlowChartDiagram(diagram, svgContainer);
      break;
    }
    case "sequence": {
      data = parseMermaidSequenceDiagram(diagram, svgContainer);
      break;
    }
    case "classDiagram": {
      data = parseMermaidClassDiagram(diagram, svgContainer);
      break;
    }
    // fallback to image if diagram type not-supported
    default: {
      data = convertSvgToGraphImage(svgContainer);
    }
  }
  svgContainer.remove();
  return data;
};

// ../../node_modules/@plait-board/mermaid-to-drawnix/dist/index.js
var parseMermaidToDrawnix = async (definition, config) => {
  var _a;
  const mermaidConfig = config || {};
  const fontSize = parseInt(((_a = mermaidConfig.themeVariables) == null ? void 0 : _a.fontSize) ?? "") || DEFAULT_FONT_SIZE2;
  const parsedMermaidData = await parseMermaid(definition, {
    ...mermaidConfig,
    themeVariables: {
      ...mermaidConfig.themeVariables,
      // Multiplying by 1.25 to increase the font size by 25% and render correctly in Drawnix
      fontSize: `${fontSize * 1.25}px`
    }
  });
  const drawnixElements = graphToDrawnix(parsedMermaidData, {
    fontSize
  });
  return drawnixElements;
};
export {
  parseMermaidToDrawnix
};
//# sourceMappingURL=@plait-board_mermaid-to-drawnix.js.map
