{
  "version": 3,
  "sources": ["../../../../packages/text-plugins/src/align/align-editor.ts", "../../../../packages/text-plugins/src/mark/types.ts", "../../../../packages/text-plugins/src/mark/constant.ts", "../../../../packages/text-plugins/src/mark/mark.editor.ts", "../../../../packages/text-plugins/src/mark/with-marks.ts", "../../../../packages/text-plugins/src/link/link-editor.ts", "../../../../packages/text-plugins/src/link/with-link.ts", "../../../../packages/text-plugins/src/constant/index.ts", "../../../../packages/text-plugins/src/utils/clipboard.ts", "../../../../packages/text-plugins/src/utils/common.ts", "../../../../packages/text-plugins/src/utils/marks.ts", "../../../../packages/text-plugins/src/text-transforms.ts", "../../../../packages/text-plugins/src/public-api.ts", "../../../../packages/text-plugins/src/plait-text-plugins.ts"],
  "sourcesContent": ["import { Alignment, ParagraphElement } from '@plait/common';\nimport { Editor, Transforms, Node } from 'slate';\n\nexport const AlignEditor = {\n    isActive(editor: Editor, alignment: Alignment) {\n        const blockElement = Node.get(editor, defaultPath) as ParagraphElement;\n        if (blockElement) {\n            const { align } = blockElement;\n            return align === alignment;\n        }\n        return false;\n    },\n    setAlign(editor: Editor, alignment: Alignment) {\n        const props: Partial<ParagraphElement> = {\n            align: alignment\n        };\n        Transforms.setNodes(editor, props, {\n            at: defaultPath\n        });\n    }\n};\n\nconst defaultPath = [0];\n", "export enum MarkTypes {\n    bold = 'bold',\n    italic = 'italic',\n    underline = 'underlined',\n    strike = 'strike',\n    color = 'color',\n    fontSize = 'font-size'\n}\n\nexport const MarkProps: MarkTypes[] = [\n    MarkTypes.bold,\n    MarkTypes.color,\n    MarkTypes.italic,\n    MarkTypes.strike,\n    MarkTypes.underline,\n    MarkTypes.fontSize\n];\n\nexport enum FontSizes {\n    'fontSize12' = '12',\n    'fontSize13' = '13',\n    'fontSize14' = '14',\n    'fontSize15' = '15',\n    'fontSize16' = '16',\n    'fontSize18' = '18',\n    'fontSize20' = '20',\n    'fontSize24' = '24',\n    'fontSize28' = '28',\n    'fontSize32' = '32',\n    'fontSize40' = '40',\n    'fontSize48' = '48'\n}\n\nexport const HOTKEYS = {\n    'mod+b': MarkTypes.bold,\n    'mod+i': MarkTypes.italic,\n    'mod+u': MarkTypes.underline,\n    'mod+shift+x': MarkTypes.strike\n};\n", "export const DEFAULT_FONT_SIZE = 14;\n", "import { Editor, Text, Node, Element, Transforms, NodeEntry, Location } from 'slate';\nimport { FontSizes, MarkProps, MarkTypes } from './types';\nimport { DEFAULT_FONT_SIZE } from './constant';\nimport { DEFAULT_COLOR } from '@plait/core';\n\nexport interface MarkEditor extends Editor {\n    removeMark: (key: string, shouldChange?: boolean) => void;\n}\n\nexport const PlaitMarkEditor = {\n    getMarks(editor: Editor) {\n        const marks: any = {};\n        let at: Location = [];\n        if (editor.selection) {\n            at = editor.selection;\n        } else if (editor.children && editor.children.length > 0) {\n            at = { anchor: Editor.start(editor, [0]), focus: Editor.end(editor, [0]) };\n        }\n        const matchResult = Editor.nodes(editor, { match: Text.isText, at });\n        for (const match of matchResult) {\n            const [node] = match as NodeEntry<Text>;\n            const { text, ...rest } = node;\n            Object.assign(marks, rest);\n        }\n        for (const key in marks) {\n            if (!MarkProps.includes(key as MarkTypes)) {\n                delete marks[key];\n            }\n        }\n        return marks;\n    },\n    getMarksByElement(element: Element) {\n        const marks: any = {};\n        const texts = Node.texts(element);\n        for (const match of texts) {\n            const [node] = match as NodeEntry<Text>;\n            const { text, ...rest } = node;\n            Object.assign(marks, rest);\n        }\n        for (const key in marks) {\n            if (!MarkProps.includes(key as MarkTypes)) {\n                delete marks[key];\n            }\n        }\n        return marks;\n    },\n    isMarkActive(editor: Editor, format: MarkTypes) {\n        if (!editor?.selection) {\n            return;\n        }\n        const node = Node.get(editor, editor?.selection?.anchor?.path);\n        if (!Text.isText(node)) {\n            return false;\n        }\n        const marks = PlaitMarkEditor.getMarks(editor);\n        return marks && marks[format] ? true : false;\n    },\n    toggleMark(editor: Editor, format: MarkTypes) {\n        setSelection(editor);\n        const isActive = PlaitMarkEditor.isMarkActive(editor, format);\n        if (isActive) {\n            Editor.removeMark(editor, format);\n        } else {\n            Editor.addMark(editor, format, true);\n        }\n    },\n    setFontSizeMark(editor: Editor, size: FontSizes, defaultSize: number = DEFAULT_FONT_SIZE) {\n        setSelection(editor);\n        // set paragraph text fontSize\n        if (Number(size) === defaultSize) {\n            Editor.removeMark(editor, MarkTypes.fontSize);\n        } else {\n            // set paragraph text fontSize\n            Editor.addMark(editor, MarkTypes.fontSize, Number(size));\n        }\n    },\n    setColorMark(editor: Editor, color: string | null, defaultTextColor: string = DEFAULT_COLOR) {\n        setSelection(editor);\n        if (color === defaultTextColor || color === null || color === undefined) {\n            Editor.removeMark(editor, 'color');\n        } else {\n            Editor.addMark(editor, 'color', color);\n        }\n    }\n};\n\nexport function setSelection(editor: Editor) {\n    if (!editor.selection) {\n        Transforms.select(editor, [0]);\n    }\n}\n", "import { isKeyHotkey } from 'is-hotkey';\nimport { MarkEditor, PlaitMarkEditor } from './mark.editor';\nimport { Editor, Range, Text, Transforms } from 'slate';\nimport { HOTKEYS } from './types';\n\nexport const withMark = <T extends Editor & MarkEditor>(editor: T): T => {\n    const e = editor;\n\n    e.removeMark = (key: string, shouldChange = true) => {\n        const { selection } = e;\n        if (selection) {\n            if (Range.isExpanded(selection)) {\n                Transforms.unsetNodes(e, key, {\n                    match: Text.isText,\n                    split: true\n                });\n            } else {\n                const marks = { ...(Editor.marks(e) || {}) };\n                delete (marks as any)[key];\n                editor.marks = marks;\n                const text = Editor.string(e, selection.anchor.path);\n                if (text !== '') {\n                    Editor.setNormalizing(editor, false);\n                    e.insertText('');\n                    editor.marks = marks;\n                    Editor.setNormalizing(editor, true);\n                } else {\n                    Transforms.unsetNodes(e, key, { at: selection.anchor.path });\n                }\n                if (shouldChange) {\n                    editor.onChange();\n                }\n            }\n        }\n    };\n\n    e.addMark = (key: string, value: any) => {\n        const { selection } = editor;\n\n        if (selection) {\n            if (Range.isExpanded(selection)) {\n                Transforms.setNodes(e, { [key]: value }, { match: Text.isText, split: true });\n            } else {\n                const marks = {\n                    ...(Editor.marks(e) || {}),\n                    [key]: value\n                };\n                editor.marks = marks;\n                const text = Editor.string(e, selection.anchor.path);\n                if (text !== '') {\n                    Editor.setNormalizing(editor, false);\n                    e.insertText('');\n                    editor.marks = marks;\n                    Editor.setNormalizing(editor, true);\n                } else {\n                    Transforms.setNodes(e, { [key]: value }, { at: selection.anchor.path });\n                }\n            }\n        }\n    };\n\n    return e;\n};\n\nexport const markShortcuts = (editor: Editor, event: KeyboardEvent) => {\n    for (const hotkey in HOTKEYS) {\n        if (isKeyHotkey(hotkey, event)) {\n            event.preventDefault();\n            const mark = (HOTKEYS as any)[hotkey];\n            PlaitMarkEditor.toggleMark(editor, mark);\n        }\n    }\n};\n", "import { CustomElement, LinkElement } from '@plait/common';\nimport { Editor, Transforms, Range, Element, BaseRange, Location, Node } from 'slate';\n\nexport const LinkEditor = {\n    wrapLink(editor: Editor, text: string, url: string) {\n        if (LinkEditor.isLinkActive(editor)) {\n            LinkEditor.unwrapLink(editor);\n        }\n        const { selection } = editor;\n        const isCollapsed = selection && Range.isCollapsed(selection);\n        const link: LinkElement = {\n            type: 'link',\n            url,\n            children: [{ text }]\n        };\n        if (isCollapsed || Node.string(editor) === '') {\n            Transforms.insertNodes(editor, link);\n        } else if (!selection) {\n            const at = { anchor: Editor.start(editor, [0]), focus: Editor.end(editor, [0]) };\n            Transforms.wrapNodes(editor, link, { split: true, at });\n        } else {\n            Transforms.wrapNodes(editor, link, { split: true });\n            Transforms.collapse(editor, { edge: 'end' });\n        }\n    },\n    unwrapLink(editor: Editor, at?: Location) {\n        if (!at) {\n            at = editor.selection as BaseRange;\n            if (!at && editor.children && editor.children.length > 0) {\n                at = { anchor: Editor.start(editor, [0]), focus: Editor.end(editor, [0]) };\n            }\n        }\n        Transforms.unwrapNodes<CustomElement>(editor, { at, match: n => Element.isElement(n) && (n as LinkElement).type === 'link' });\n    },\n    isLinkActive(editor: Editor) {\n        let at = editor.selection as BaseRange;\n        if (!at && editor.children && editor.children.length > 0) {\n            at = { anchor: Editor.start(editor, [0]), focus: Editor.end(editor, [0]) };\n        }\n        const [link] = Editor.nodes<CustomElement>(editor, { match: n => Element.isElement(n) && (n as LinkElement).type === 'link', at });\n        return !!link;\n    },\n    getLinkElement(editor: Editor) {\n        let at = editor.selection as BaseRange;\n        if (!at && editor.children && editor.children.length > 0) {\n            at = { anchor: Editor.start(editor, [0]), focus: Editor.end(editor, [0]) };\n        }\n        const [link] = Editor.nodes<CustomElement>(editor, { match: n => Element.isElement(n) && (n as LinkElement).type === 'link', at });\n        return link;\n    }\n};\n", "import { LinkElement } from '@plait/common';\nimport { Element, NodeEntry, Transforms, Node, Editor } from 'slate';\n\nexport const withLink = <T extends Editor>(editor: T): T => {\n    const { isInline, normalizeNode } = editor;\n\n    editor.isInline = (element: Element) => {\n        return (element as LinkElement).type === 'link' ? true : isInline(element);\n    };\n\n    editor.normalizeNode = (nodeEntry: NodeEntry) => {\n        const node = nodeEntry[0] as LinkElement;\n        const path = nodeEntry[1];\n        if (node.type && node.type === 'link' && Node.string(node) === '') {\n            Transforms.removeNodes(editor, { at: path });\n            return;\n        }\n\n        normalizeNode(nodeEntry);\n    };\n\n    return editor;\n};\n", "export const TEXT_DEFAULT_HEIGHT = 20;\n\nexport const CLIPBOARD_FORMAT_KEY = 'x-plait-text-fragment';\n", "import { Element, Node } from 'slate';\nimport { CLIPBOARD_FORMAT_KEY } from '../constant';\n\nexport const getTextFromClipboard = (data: DataTransfer | null) => {\n    let plaitTextData = data?.getData(`application/${CLIPBOARD_FORMAT_KEY}`);\n    const text = (data ? data.getData(`text/plain`) : '') as string;\n    if (plaitTextData) {\n        const decoded = decodeURIComponent(window.atob(plaitTextData));\n        const res = JSON.parse(decoded) as Element[];\n        if (res.length === 1 && Node.string(res[0])) {\n            return res[0];\n        }\n    }\n    return text.trim() || '';\n};\n", "// credit: https://github.com/segmentio/is-url\n// support mailto: protocol\nexport function isUrl(string: string) {\n    const protocolAndDomainRE = /^(?:\\w+:)?\\/\\/(\\S+)$/;\n    const emailProtocolRE = /^mailto:([^\\s@]+@[^\\s@]+\\.[^\\s@]+)$/;\n    const localhostDomainRE = /^localhost[\\:?\\d]*(?:[^\\:?\\d]\\S*)?$/;\n    const nonLocalhostDomainRE = /^[^\\s\\.]+\\.\\S{2,}$/;\n\n    if (typeof string !== 'string') {\n        return false;\n    }\n\n    // 检查是否是 mailto: 协议\n    const emailMatch = string.match(emailProtocolRE);\n    if (emailMatch) {\n        // 简单验证 email 地址格式\n        return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(emailMatch[1]);\n    }\n\n    // 原有的 URL 验证逻辑\n    const match = string.match(protocolAndDomainRE);\n    if (!match) {\n        return false;\n    }\n\n    const everythingAfterProtocol = match[1];\n    if (!everythingAfterProtocol) {\n        return false;\n    }\n\n    if (localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol)) {\n        return true;\n    }\n\n    return false;\n}\n", "import { CustomText, getTextEditorsByElement, getTextManages } from '@plait/common';\nimport { PlaitElement } from '@plait/core';\nimport { PlaitMarkEditor } from '../mark/mark.editor';\nimport { Element, Node } from 'slate';\nimport { ParagraphElement } from '../types';\n\nexport const getTextMarksByElement = (element: PlaitElement) => {\n    const editors = getTextEditorsByElement(element);\n    const editor = editors[0];\n    if (!editor || editor.children.length === 0) {\n        return {};\n    }\n    const currentMarks: Omit<CustomText, 'text'> = PlaitMarkEditor.getMarks(editor);\n    return currentMarks;\n};\n\nexport const getFirstTextMarks = (element: ParagraphElement) => {\n    const firstText = Node.first({ children: [element] }, [0]);\n    return firstText[0] as CustomText;\n};\n", "import { PlaitBoard, PlaitElement, getSelectedElements } from '@plait/core';\nimport { BaseEditor, BaseRange, Editor, Transforms as SlateTransforms } from 'slate';\nimport { FontSizes, MarkTypes } from './mark/types';\nimport { Alignment, findFirstTextEditor, getTextEditors, getTextEditorsByElement } from '@plait/common';\nimport { PlaitMarkEditor } from './mark/mark.editor';\nimport { AlignEditor } from './align/align-editor';\n\nconst setTextMarks = (board: PlaitBoard, mark: MarkTypes, editors?: BaseEditor[]) => {\n    let textEditors: BaseEditor[] | undefined;\n    if (editors?.length) {\n        textEditors = editors;\n    } else {\n        const selectedElements = getSelectedElements(board);\n        if (selectedElements.length) {\n            const firstEditor = findFirstTextEditor(board);\n            if (!firstEditor) {\n                return;\n            }\n            const activeMarks = PlaitMarkEditor.getMarks(firstEditor);\n            const elements = selectedElements.filter(element => {\n                const elementEditors = getTextEditorsByElement(element);\n                return elementEditors.some(editor => {\n                    const elementMarks = PlaitMarkEditor.getMarks(editor);\n                    return elementMarks[mark] === activeMarks[mark];\n                });\n            });\n            textEditors = getTextEditors(board, elements);\n        }\n    }\n    if (textEditors && textEditors.length) {\n        textEditors.forEach(editor => {\n            PlaitMarkEditor.toggleMark(editor, mark);\n        });\n    }\n};\n\nconst setFontSize = (\n    board: PlaitBoard,\n    size: FontSizes,\n    defaultFontSize: number | ((element: PlaitElement) => number | undefined),\n    editors?: BaseEditor[]\n) => {\n    const textEditors = getHandleTextEditors(board, editors);\n    if (textEditors && textEditors.length) {\n        const selectedElements = getSelectedElements(board);\n        textEditors.forEach(editor => {\n            let finalDefaultFontSize;\n            if (typeof defaultFontSize === 'function') {\n                const element = selectedElements.find(element => {\n                    const textEditors = getTextEditorsByElement(element);\n                    return textEditors.includes(editor);\n                });\n                finalDefaultFontSize = defaultFontSize(element!);\n            } else {\n                finalDefaultFontSize = defaultFontSize;\n            }\n\n            PlaitMarkEditor.setFontSizeMark(editor, size, finalDefaultFontSize);\n        });\n    }\n};\n\nconst setTextColor = (board: PlaitBoard, color: string | null, textSelection?: BaseRange, editors?: BaseEditor[]) => {\n    const textEditors = getHandleTextEditors(board, editors);\n    if (textEditors && textEditors.length) {\n        textEditors.forEach(editor => {\n            if (textSelection) {\n                SlateTransforms.select(editor, textSelection);\n            }\n            if (color === 'transparent') {\n                Editor.removeMark(editor, MarkTypes.color);\n            } else {\n                PlaitMarkEditor.setColorMark(editor, color);\n            }\n        });\n    }\n};\n\nconst setTextAlign = (board: PlaitBoard, align: Alignment, editors?: BaseEditor[]) => {\n    const textEditors = getHandleTextEditors(board, editors);\n    if (textEditors && textEditors.length) {\n        textEditors.forEach(editor => AlignEditor.setAlign(editor, align));\n    }\n};\n\nconst getHandleTextEditors = (board: PlaitBoard, editors?: BaseEditor[]) => {\n    let textEditors: BaseEditor[] | undefined;\n    if (editors?.length) {\n        textEditors = editors;\n    } else {\n        textEditors = getTextEditors(board);\n    }\n    return textEditors;\n};\n\nexport const TextTransforms = { setTextAlign, setTextColor, setFontSize, setTextMarks };\n", "/*\n * Public API Surface of utils\n */\n\nexport * from './align';\nexport * from './mark';\nexport * from './link';\nexport * from './utils';\nexport * from './constant';\nexport * from './text-transforms';\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],
  "mappings": "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",
  "names": ["MarkTypes", "FontSizes", "element", "textEditors", "SlateTransforms"]
}
