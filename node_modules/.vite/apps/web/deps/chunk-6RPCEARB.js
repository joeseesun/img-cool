import {
  findFirstTextEditor,
  getTextEditors,
  getTextEditorsByElement
} from "./chunk-NNVG7YTJ.js";
import {
  Editor,
  Element,
  Node,
  Range,
  Text,
  Transforms
} from "./chunk-OBPCNI2P.js";
import {
  DEFAULT_COLOR,
  getSelectedElements
} from "./chunk-6V4XCDNF.js";
import {
  require_lib
} from "./chunk-R23N5LB2.js";
import {
  __toESM
} from "./chunk-2TUXWMP5.js";

// ../../node_modules/@plait/text-plugins/fesm2022/plait-text-plugins.mjs
var import_is_hotkey = __toESM(require_lib(), 1);
var AlignEditor = {
  isActive(editor, alignment) {
    const blockElement = Node.get(editor, defaultPath);
    if (blockElement) {
      const { align } = blockElement;
      return align === alignment;
    }
    return false;
  },
  setAlign(editor, alignment) {
    const props = {
      align: alignment
    };
    Transforms.setNodes(editor, props, {
      at: defaultPath
    });
  }
};
var defaultPath = [0];
var MarkTypes;
(function(MarkTypes2) {
  MarkTypes2["bold"] = "bold";
  MarkTypes2["italic"] = "italic";
  MarkTypes2["underline"] = "underlined";
  MarkTypes2["strike"] = "strike";
  MarkTypes2["color"] = "color";
  MarkTypes2["fontSize"] = "font-size";
})(MarkTypes || (MarkTypes = {}));
var MarkProps = [
  MarkTypes.bold,
  MarkTypes.color,
  MarkTypes.italic,
  MarkTypes.strike,
  MarkTypes.underline,
  MarkTypes.fontSize
];
var FontSizes;
(function(FontSizes2) {
  FontSizes2["fontSize12"] = "12";
  FontSizes2["fontSize13"] = "13";
  FontSizes2["fontSize14"] = "14";
  FontSizes2["fontSize15"] = "15";
  FontSizes2["fontSize16"] = "16";
  FontSizes2["fontSize18"] = "18";
  FontSizes2["fontSize20"] = "20";
  FontSizes2["fontSize24"] = "24";
  FontSizes2["fontSize28"] = "28";
  FontSizes2["fontSize32"] = "32";
  FontSizes2["fontSize40"] = "40";
  FontSizes2["fontSize48"] = "48";
})(FontSizes || (FontSizes = {}));
var HOTKEYS = {
  "mod+b": MarkTypes.bold,
  "mod+i": MarkTypes.italic,
  "mod+u": MarkTypes.underline,
  "mod+shift+x": MarkTypes.strike
};
var DEFAULT_FONT_SIZE = 14;
var PlaitMarkEditor = {
  getMarks(editor) {
    const marks = {};
    let at = [];
    if (editor.selection) {
      at = editor.selection;
    } else if (editor.children && editor.children.length > 0) {
      at = { anchor: Editor.start(editor, [0]), focus: Editor.end(editor, [0]) };
    }
    const matchResult = Editor.nodes(editor, { match: Text.isText, at });
    for (const match of matchResult) {
      const [node] = match;
      const { text, ...rest } = node;
      Object.assign(marks, rest);
    }
    for (const key in marks) {
      if (!MarkProps.includes(key)) {
        delete marks[key];
      }
    }
    return marks;
  },
  getMarksByElement(element) {
    const marks = {};
    const texts = Node.texts(element);
    for (const match of texts) {
      const [node] = match;
      const { text, ...rest } = node;
      Object.assign(marks, rest);
    }
    for (const key in marks) {
      if (!MarkProps.includes(key)) {
        delete marks[key];
      }
    }
    return marks;
  },
  isMarkActive(editor, format) {
    var _a, _b;
    if (!(editor == null ? void 0 : editor.selection)) {
      return;
    }
    const node = Node.get(editor, (_b = (_a = editor == null ? void 0 : editor.selection) == null ? void 0 : _a.anchor) == null ? void 0 : _b.path);
    if (!Text.isText(node)) {
      return false;
    }
    const marks = PlaitMarkEditor.getMarks(editor);
    return marks && marks[format] ? true : false;
  },
  toggleMark(editor, format) {
    setSelection(editor);
    const isActive = PlaitMarkEditor.isMarkActive(editor, format);
    if (isActive) {
      Editor.removeMark(editor, format);
    } else {
      Editor.addMark(editor, format, true);
    }
  },
  setFontSizeMark(editor, size, defaultSize = DEFAULT_FONT_SIZE) {
    setSelection(editor);
    if (Number(size) === defaultSize) {
      Editor.removeMark(editor, MarkTypes.fontSize);
    } else {
      Editor.addMark(editor, MarkTypes.fontSize, Number(size));
    }
  },
  setColorMark(editor, color, defaultTextColor = DEFAULT_COLOR) {
    setSelection(editor);
    if (color === defaultTextColor || color === null || color === void 0) {
      Editor.removeMark(editor, "color");
    } else {
      Editor.addMark(editor, "color", color);
    }
  }
};
function setSelection(editor) {
  if (!editor.selection) {
    Transforms.select(editor, [0]);
  }
}
var withMark = (editor) => {
  const e = editor;
  e.removeMark = (key, shouldChange = true) => {
    const { selection } = e;
    if (selection) {
      if (Range.isExpanded(selection)) {
        Transforms.unsetNodes(e, key, {
          match: Text.isText,
          split: true
        });
      } else {
        const marks = { ...Editor.marks(e) || {} };
        delete marks[key];
        editor.marks = marks;
        const text = Editor.string(e, selection.anchor.path);
        if (text !== "") {
          Editor.setNormalizing(editor, false);
          e.insertText("");
          editor.marks = marks;
          Editor.setNormalizing(editor, true);
        } else {
          Transforms.unsetNodes(e, key, { at: selection.anchor.path });
        }
        if (shouldChange) {
          editor.onChange();
        }
      }
    }
  };
  e.addMark = (key, value) => {
    const { selection } = editor;
    if (selection) {
      if (Range.isExpanded(selection)) {
        Transforms.setNodes(e, { [key]: value }, { match: Text.isText, split: true });
      } else {
        const marks = {
          ...Editor.marks(e) || {},
          [key]: value
        };
        editor.marks = marks;
        const text = Editor.string(e, selection.anchor.path);
        if (text !== "") {
          Editor.setNormalizing(editor, false);
          e.insertText("");
          editor.marks = marks;
          Editor.setNormalizing(editor, true);
        } else {
          Transforms.setNodes(e, { [key]: value }, { at: selection.anchor.path });
        }
      }
    }
  };
  return e;
};
var markShortcuts = (editor, event) => {
  for (const hotkey in HOTKEYS) {
    if ((0, import_is_hotkey.isKeyHotkey)(hotkey, event)) {
      event.preventDefault();
      const mark = HOTKEYS[hotkey];
      PlaitMarkEditor.toggleMark(editor, mark);
    }
  }
};
var LinkEditor = {
  wrapLink(editor, text, url) {
    if (LinkEditor.isLinkActive(editor)) {
      LinkEditor.unwrapLink(editor);
    }
    const { selection } = editor;
    const isCollapsed = selection && Range.isCollapsed(selection);
    const link = {
      type: "link",
      url,
      children: [{ text }]
    };
    if (isCollapsed || Node.string(editor) === "") {
      Transforms.insertNodes(editor, link);
    } else if (!selection) {
      const at = { anchor: Editor.start(editor, [0]), focus: Editor.end(editor, [0]) };
      Transforms.wrapNodes(editor, link, { split: true, at });
    } else {
      Transforms.wrapNodes(editor, link, { split: true });
      Transforms.collapse(editor, { edge: "end" });
    }
  },
  unwrapLink(editor, at) {
    if (!at) {
      at = editor.selection;
      if (!at && editor.children && editor.children.length > 0) {
        at = { anchor: Editor.start(editor, [0]), focus: Editor.end(editor, [0]) };
      }
    }
    Transforms.unwrapNodes(editor, { at, match: (n) => Element.isElement(n) && n.type === "link" });
  },
  isLinkActive(editor) {
    let at = editor.selection;
    if (!at && editor.children && editor.children.length > 0) {
      at = { anchor: Editor.start(editor, [0]), focus: Editor.end(editor, [0]) };
    }
    const [link] = Editor.nodes(editor, { match: (n) => Element.isElement(n) && n.type === "link", at });
    return !!link;
  },
  getLinkElement(editor) {
    let at = editor.selection;
    if (!at && editor.children && editor.children.length > 0) {
      at = { anchor: Editor.start(editor, [0]), focus: Editor.end(editor, [0]) };
    }
    const [link] = Editor.nodes(editor, { match: (n) => Element.isElement(n) && n.type === "link", at });
    return link;
  }
};
var withLink = (editor) => {
  const { isInline, normalizeNode } = editor;
  editor.isInline = (element) => {
    return element.type === "link" ? true : isInline(element);
  };
  editor.normalizeNode = (nodeEntry) => {
    const node = nodeEntry[0];
    const path = nodeEntry[1];
    if (node.type && node.type === "link" && Node.string(node) === "") {
      Transforms.removeNodes(editor, { at: path });
      return;
    }
    normalizeNode(nodeEntry);
  };
  return editor;
};
var TEXT_DEFAULT_HEIGHT = 20;
var CLIPBOARD_FORMAT_KEY = "x-plait-text-fragment";
var getTextFromClipboard = (data) => {
  let plaitTextData = data == null ? void 0 : data.getData(`application/${CLIPBOARD_FORMAT_KEY}`);
  const text = data ? data.getData(`text/plain`) : "";
  if (plaitTextData) {
    const decoded = decodeURIComponent(window.atob(plaitTextData));
    const res = JSON.parse(decoded);
    if (res.length === 1 && Node.string(res[0])) {
      return res[0];
    }
  }
  return text.trim() || "";
};
function isUrl(string) {
  const protocolAndDomainRE = /^(?:\w+:)?\/\/(\S+)$/;
  const emailProtocolRE = /^mailto:([^\s@]+@[^\s@]+\.[^\s@]+)$/;
  const localhostDomainRE = /^localhost[\:?\d]*(?:[^\:?\d]\S*)?$/;
  const nonLocalhostDomainRE = /^[^\s\.]+\.\S{2,}$/;
  if (typeof string !== "string") {
    return false;
  }
  const emailMatch = string.match(emailProtocolRE);
  if (emailMatch) {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(emailMatch[1]);
  }
  const match = string.match(protocolAndDomainRE);
  if (!match) {
    return false;
  }
  const everythingAfterProtocol = match[1];
  if (!everythingAfterProtocol) {
    return false;
  }
  if (localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol)) {
    return true;
  }
  return false;
}
var getTextMarksByElement = (element) => {
  const editors = getTextEditorsByElement(element);
  const editor = editors[0];
  if (!editor || editor.children.length === 0) {
    return {};
  }
  const currentMarks = PlaitMarkEditor.getMarks(editor);
  return currentMarks;
};
var getFirstTextMarks = (element) => {
  const firstText = Node.first({ children: [element] }, [0]);
  return firstText[0];
};
var setTextMarks = (board, mark, editors) => {
  let textEditors;
  if (editors == null ? void 0 : editors.length) {
    textEditors = editors;
  } else {
    const selectedElements = getSelectedElements(board);
    if (selectedElements.length) {
      const firstEditor = findFirstTextEditor(board);
      if (!firstEditor) {
        return;
      }
      const activeMarks = PlaitMarkEditor.getMarks(firstEditor);
      const elements = selectedElements.filter((element) => {
        const elementEditors = getTextEditorsByElement(element);
        return elementEditors.some((editor) => {
          const elementMarks = PlaitMarkEditor.getMarks(editor);
          return elementMarks[mark] === activeMarks[mark];
        });
      });
      textEditors = getTextEditors(board, elements);
    }
  }
  if (textEditors && textEditors.length) {
    textEditors.forEach((editor) => {
      PlaitMarkEditor.toggleMark(editor, mark);
    });
  }
};
var setFontSize = (board, size, defaultFontSize, editors) => {
  const textEditors = getHandleTextEditors(board, editors);
  if (textEditors && textEditors.length) {
    const selectedElements = getSelectedElements(board);
    textEditors.forEach((editor) => {
      let finalDefaultFontSize;
      if (typeof defaultFontSize === "function") {
        const element = selectedElements.find((element2) => {
          const textEditors2 = getTextEditorsByElement(element2);
          return textEditors2.includes(editor);
        });
        finalDefaultFontSize = defaultFontSize(element);
      } else {
        finalDefaultFontSize = defaultFontSize;
      }
      PlaitMarkEditor.setFontSizeMark(editor, size, finalDefaultFontSize);
    });
  }
};
var setTextColor = (board, color, textSelection, editors) => {
  const textEditors = getHandleTextEditors(board, editors);
  if (textEditors && textEditors.length) {
    textEditors.forEach((editor) => {
      if (textSelection) {
        Transforms.select(editor, textSelection);
      }
      if (color === "transparent") {
        Editor.removeMark(editor, MarkTypes.color);
      } else {
        PlaitMarkEditor.setColorMark(editor, color);
      }
    });
  }
};
var setTextAlign = (board, align, editors) => {
  const textEditors = getHandleTextEditors(board, editors);
  if (textEditors && textEditors.length) {
    textEditors.forEach((editor) => AlignEditor.setAlign(editor, align));
  }
};
var getHandleTextEditors = (board, editors) => {
  let textEditors;
  if (editors == null ? void 0 : editors.length) {
    textEditors = editors;
  } else {
    textEditors = getTextEditors(board);
  }
  return textEditors;
};
var TextTransforms = { setTextAlign, setTextColor, setFontSize, setTextMarks };

export {
  AlignEditor,
  MarkTypes,
  MarkProps,
  FontSizes,
  HOTKEYS,
  DEFAULT_FONT_SIZE,
  PlaitMarkEditor,
  setSelection,
  withMark,
  markShortcuts,
  LinkEditor,
  withLink,
  TEXT_DEFAULT_HEIGHT,
  CLIPBOARD_FORMAT_KEY,
  getTextFromClipboard,
  isUrl,
  getTextMarksByElement,
  getFirstTextMarks,
  TextTransforms
};
//# sourceMappingURL=chunk-6RPCEARB.js.map
