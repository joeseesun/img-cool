import {
  Editor,
  Node,
  Operation,
  Range,
  Transforms as Transforms2
} from "./chunk-OBPCNI2P.js";
import {
  ACTIVE_STROKE_WIDTH,
  DEFAULT_COLOR,
  Direction,
  ElementFlavour,
  IS_TEXT_EDITABLE,
  MERGING,
  PRESS_AND_MOVE_BUFFER,
  PlaitBoard,
  PlaitElement,
  PlaitGroupElement,
  PlaitPointerType,
  Point,
  RESIZE_CURSORS,
  RESIZE_HANDLE_CLASS_NAME,
  RectangleClient,
  ResizeCursorClass,
  SELECTION_RECTANGLE_CLASS_NAME,
  Selection,
  Transforms,
  createDebugGenerator,
  createForeignObject,
  createG,
  createGroupRectangleG,
  distanceBetweenPointAndPoint,
  drawCircle,
  drawRectangle,
  fromEvent,
  getElementsInGroup,
  getGroupByElement,
  getHighestSelectedElements,
  getHighestSelectedGroups,
  getHitElementsBySelection,
  getRectangleByElements,
  getRectangleByGroup,
  getSelectedElements,
  getSelectedGroups,
  getSelectedIsolatedElements,
  getSelectedIsolatedElementsCanAddToGroup,
  getSelectionAngle,
  hotkeys,
  idCreator,
  isDragging,
  isMainPointer,
  isMovingElements,
  isSelectedElementOrGroup,
  isSelectionMoving,
  rotatePoints,
  setAngleForG,
  setDragging,
  setStrokeLinecap,
  throttleRAF,
  timer,
  toActiveRectangleFromViewBoxRectangle,
  toHostPoint,
  toViewBoxPoint,
  updateForeignObject,
  updateForeignObjectWidth
} from "./chunk-6V4XCDNF.js";
import {
  require_lib
} from "./chunk-R23N5LB2.js";
import {
  __toESM
} from "./chunk-2TUXWMP5.js";

// ../../node_modules/@plait/common/fesm2022/plait-common.mjs
var import_is_hotkey = __toESM(require_lib(), 1);
var BASE = 4;
var PRIMARY_COLOR = "#6698FF";
var RESIZE_HANDLE_DIAMETER = 9;
var WithTextPluginKey = "plait-text-plugin-key";
var DEFAULT_ROUTE_MARGIN = 30;
var TRANSPARENT = "transparent";
var ROTATE_HANDLE_DISTANCE_TO_ELEMENT = 20;
var ROTATE_HANDLE_SIZE = 18;
var DEFAULT_FONT_FAMILY = `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'PingFang SC', 'Noto Sans', 'Noto Sans CJK SC', 'Microsoft Yahei', 'Hiragino Sans GB', Arial, sans-serif`;
var DEFAULT_FILL = "none";
var MediaKeys;
(function(MediaKeys2) {
  MediaKeys2["image"] = "image";
})(MediaKeys || (MediaKeys = {}));
var PICTURE_ACCEPTED_UPLOAD_SIZE = 20;
var acceptImageTypes = ["png", "jpeg", "gif", "bmp"];
var WithCommonPluginKey = "plait-common-plugin-key";
var ResizeHandle;
(function(ResizeHandle2) {
  ResizeHandle2["nw"] = "0";
  ResizeHandle2["n"] = "4";
  ResizeHandle2["ne"] = "1";
  ResizeHandle2["e"] = "5";
  ResizeHandle2["se"] = "2";
  ResizeHandle2["s"] = "6";
  ResizeHandle2["sw"] = "3";
  ResizeHandle2["w"] = "7";
})(ResizeHandle || (ResizeHandle = {}));
var StrokeStyle;
(function(StrokeStyle2) {
  StrokeStyle2["solid"] = "solid";
  StrokeStyle2["dashed"] = "dashed";
  StrokeStyle2["dotted"] = "dotted";
})(StrokeStyle || (StrokeStyle = {}));
var Generator = class {
  constructor(board, options) {
    this.board = board;
    this.options = options;
  }
  processDrawing(element, parentG, data) {
    var _a, _b;
    if (this.canDraw && this.canDraw(element, data)) {
      const g = this.draw(element, data);
      if (g) {
        if (this.g && parentG.contains(this.g)) {
          this.g.replaceWith(g);
        } else {
          if (this.g) {
            this.g.remove();
          }
          if ((_a = this.options) == null ? void 0 : _a.prepend) {
            parentG.prepend(g);
          } else {
            parentG.appendChild(g);
          }
        }
        this.g = g;
        const rectangle = this.board.getRectangle(element);
        if (!rectangle) {
          return;
        }
        let centerPoint = RectangleClient.getCenterPoint(rectangle);
        if ((_b = this.options) == null ? void 0 : _b.active) {
          const activeRectangle = toActiveRectangleFromViewBoxRectangle(this.board, rectangle);
          centerPoint = RectangleClient.getCenterPoint(activeRectangle);
        }
        let angle;
        if (PlaitGroupElement.isGroup(element)) {
          angle = getSelectionAngle(getElementsInGroup(this.board, element, true));
        } else {
          angle = element.angle;
        }
        if (angle) {
          setAngleForG(g, centerPoint, angle);
        }
      } else {
        this.destroy();
      }
      if (hasAfterDraw(this)) {
        this.afterDraw(element);
      }
    } else {
      this.destroy();
    }
  }
  destroy() {
    if (this.g) {
      this.g.remove();
      this.g = void 0;
    }
  }
};
function hasAfterDraw(value) {
  if (value.afterDraw) {
    return true;
  }
  return false;
}
var drawHandle = (board, centerPoint) => {
  const options = { stroke: "#99999995", strokeWidth: 2, fill: "#FFF", fillStyle: "solid" };
  const handleG = drawCircle(PlaitBoard.getRoughSVG(board), centerPoint, RESIZE_HANDLE_DIAMETER, options);
  handleG.classList.add(RESIZE_HANDLE_CLASS_NAME);
  return handleG;
};
function drawFillPrimaryHandle(board, point) {
  return drawCircle(PlaitBoard.getRoughSVG(board), point, RESIZE_HANDLE_DIAMETER, {
    stroke: "#FFFFFF",
    strokeWidth: 1,
    fill: `${PRIMARY_COLOR}`,
    fillStyle: "solid"
  });
}
function drawPrimaryHandle(board, point) {
  return drawCircle(PlaitBoard.getRoughSVG(board), point, RESIZE_HANDLE_DIAMETER, {
    stroke: `${PRIMARY_COLOR}`,
    strokeWidth: 2,
    fill: `#FFFFFF`,
    fillStyle: "solid"
  });
}
var rotateHandleRadius = 6;
var drawRotateHandle = (board, rectangle) => {
  const options = { stroke: DEFAULT_COLOR, strokeWidth: 1, fillStyle: "solid" };
  const handleCenterPoint = [
    rectangle.x - ROTATE_HANDLE_DISTANCE_TO_ELEMENT - ROTATE_HANDLE_SIZE / 2,
    rectangle.y + rectangle.height + ROTATE_HANDLE_DISTANCE_TO_ELEMENT + ROTATE_HANDLE_SIZE / 2
  ];
  const rs = PlaitBoard.getRoughSVG(board);
  const handleG = createG();
  const line = rs.path(`M ${handleCenterPoint[0] + rotateHandleRadius} ${handleCenterPoint[1]} A ${rotateHandleRadius} ${rotateHandleRadius}, 0, 1, 0, ${handleCenterPoint[0]} ${handleCenterPoint[1] + rotateHandleRadius}`, options);
  const arrow = rs.polygon([
    [handleCenterPoint[0], handleCenterPoint[1] + rotateHandleRadius - 2],
    [handleCenterPoint[0], handleCenterPoint[1] + rotateHandleRadius + 2],
    [handleCenterPoint[0] + 4.5, handleCenterPoint[1] + rotateHandleRadius]
  ], { ...options, fill: DEFAULT_COLOR });
  setStrokeLinecap(arrow, "round");
  handleG.append(line, arrow);
  return handleG;
};
var createActiveGenerator = (board, options) => {
  return new ActiveGenerator(board, { ...options, active: true });
};
var _ActiveGenerator = class _ActiveGenerator extends Generator {
  constructor(board, options) {
    super(board, { ...options, active: true });
    this.board = board;
    this.options = options;
    this.hasResizeHandle = false;
  }
  canDraw(element, data) {
    if (data.selected) {
      return true;
    } else {
      return false;
    }
  }
  draw(element, data) {
    const activeG = createG();
    const activeRectangle = toActiveRectangleFromViewBoxRectangle(this.board, this.options.getRectangle(element));
    const delta = this.options.getStrokeWidth() * this.board.viewport.zoom;
    const activeRectangleWithDelta = RectangleClient.inflate(activeRectangle, delta);
    const strokeG = drawRectangle(this.board, activeRectangleWithDelta, {
      stroke: PRIMARY_COLOR,
      strokeWidth: ACTIVE_STROKE_WIDTH
    });
    activeG.append(strokeG);
    strokeG.classList.add(SELECTION_RECTANGLE_CLASS_NAME);
    strokeG.style.opacity = `${this.options.getStrokeOpacity()}`;
    if (this.options.hasResizeHandle()) {
      this.hasResizeHandle = true;
      RectangleClient.getCornerPoints(activeRectangleWithDelta).forEach((corner) => {
        const cornerHandleG = drawHandle(this.board, corner);
        activeG.append(cornerHandleG);
      });
    } else {
      this.hasResizeHandle = false;
    }
    return activeG;
  }
};
_ActiveGenerator.key = "active-generator";
var ActiveGenerator = _ActiveGenerator;
var getResizeHandleByIndex = (index) => {
  return `${index}`;
};
var getIndexByResizeHandle = (resizeHandle) => {
  return Number(resizeHandle);
};
var getSymmetricHandleIndex = (board, index) => {
  const originIndex = isEdgeHandle(board, getResizeHandleByIndex(index)) ? index - 4 : index;
  let originSymmetricHandleIndex = originIndex + 2;
  if (originSymmetricHandleIndex >= 4) {
    originSymmetricHandleIndex = originSymmetricHandleIndex - 4;
  }
  return isEdgeHandle(board, getResizeHandleByIndex(index)) ? originSymmetricHandleIndex + 4 : originSymmetricHandleIndex;
};
var getResizeCursorClassByIndex = (index) => {
  switch (index) {
    case 0:
    case 2:
      return ResizeCursorClass.nwse;
    case 1:
    case 3:
      return ResizeCursorClass.nesw;
    case 4:
    case 6:
      return ResizeCursorClass.ns;
    case 5:
    case 7:
      return ResizeCursorClass.ew;
    default:
      return null;
  }
};
var getRotatedResizeCursorClassByAngle = (cursor, angle) => {
  const index = RESIZE_CURSORS.indexOf(cursor);
  if (index >= 0) {
    const temp = Math.round(angle / (Math.PI / 4));
    cursor = RESIZE_CURSORS[(index + temp) % RESIZE_CURSORS.length];
  }
  return cursor;
};
var getRectangleResizeHandleRefs = (rectangle, diameter) => {
  const corners = RectangleClient.getCornerPoints(rectangle);
  const refs = corners.map((corner, index) => {
    return {
      rectangle: {
        x: corner[0] - diameter / 2,
        y: corner[1] - diameter / 2,
        width: diameter,
        height: diameter
      },
      handle: getResizeHandleByIndex(index),
      cursorClass: getResizeCursorClassByIndex(index)
    };
  });
  const rectangles = getResizeSideRectangles(corners, diameter / 2);
  refs.push(...rectangles.map((rectangle2, index) => {
    return {
      rectangle: rectangle2,
      handle: getResizeHandleByIndex(index + 4),
      cursorClass: getResizeCursorClassByIndex(index + 4)
    };
  }));
  return refs;
};
var getResizeHandlePointByIndex = (rectangle, index) => {
  if (index <= 3) {
    const corners = RectangleClient.getCornerPoints(rectangle);
    return corners[index];
  } else {
    const edgeCenterPoints = RectangleClient.getEdgeCenterPoints(rectangle);
    return edgeCenterPoints[index - 4];
  }
};
var getResizeSideRectangles = (cornerPoints, offset) => {
  const result = [];
  for (let i = 0; i < cornerPoints.length; i++) {
    let rectangle = RectangleClient.getRectangleByPoints([cornerPoints[i], cornerPoints[(i + 1) % 4]]);
    const arr = new Array(2).fill(0);
    arr[(i + 1) % 2] = offset / 2;
    rectangle = RectangleClient.expand(rectangle, arr[0], arr[1]);
    result.push(rectangle);
  }
  return result;
};
var IS_RESIZING = /* @__PURE__ */ new WeakMap();
var isResizing = (board) => {
  return !!IS_RESIZING.get(board);
};
var isResizingByCondition = (board, match) => {
  return isResizing(board) && match(IS_RESIZING.get(board));
};
var addResizing = (board, resizeRef, key) => {
  PlaitBoard.getBoardContainer(board).classList.add(`${key}-resizing`);
  IS_RESIZING.set(board, resizeRef);
  setDragging(board, true);
};
var removeResizing = (board, key) => {
  PlaitBoard.getBoardContainer(board).classList.remove(`${key}-resizing`);
  IS_RESIZING.delete(board);
  setDragging(board, false);
};
var isEdgeHandle = (board, handle) => {
  const index = getIndexByResizeHandle(handle);
  if (index >= 4) {
    return true;
  } else {
    return false;
  }
};
var isCornerHandle = (board, handle) => {
  return !isEdgeHandle(board, handle);
};
var resetPointsAfterResize = (originRectangle, currentRectangle, originSelectionCenterPoint, currentSelectionCenterPoint, angle) => {
  const correctSelectionCenterPoint = rotatePoints([currentSelectionCenterPoint], originSelectionCenterPoint, angle)[0];
  const rotatedElementCenterPoint = rotatePoints([RectangleClient.getCenterPoint(currentRectangle)], originSelectionCenterPoint, angle)[0];
  const currentPoints = RectangleClient.getPoints(currentRectangle);
  const originRectangleCenterPoint = RectangleClient.getCenterPoint(originRectangle);
  const correctElementCenterPoint = rotatePoints([rotatedElementCenterPoint], correctSelectionCenterPoint, -angle)[0];
  const rotatedPoints = rotatePoints(currentPoints, originRectangleCenterPoint, angle);
  return rotatePoints(rotatedPoints, correctElementCenterPoint, -angle);
};
var hasMoreThanOnePoint = (element) => {
  const points = element.points;
  return points && points.length > 1;
};
var hasResizeHandle = (board, element) => {
  if (PlaitBoard.hasBeenTextEditing(board) || isSelectionMoving(board)) {
    return false;
  }
  const selectedElements = getSelectedElements(board);
  return selectedElements.length === 1 && selectedElements[0] === element && hasMoreThanOnePoint(element);
};
function getUnitVectorByPointAndPoint(point1, point2) {
  const deltaX = point2[0] - point1[0];
  const deltaY = point2[1] - point1[1];
  const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
  if (distance === 0) {
    throw new Error("Points must not be the same for a unit vector calculation.");
  }
  const unitX = deltaX / distance;
  const unitY = deltaY / distance;
  return [unitX, unitY];
}
function getPointByVectorComponent(point, vector, component) {
  const distance = Math.hypot(vector[0], vector[1]);
  return [point[0] + vector[0] / distance * component, point[1] + vector[1] / distance * component];
}
function getPointByVectorDirectionComponent(point, unitVector, directionComponent, isHorizontal) {
  if (isHorizontal) {
    return [point[0] + directionComponent, point[1] + directionComponent / unitVector[0] * unitVector[1]];
  } else {
    return [point[0] + directionComponent / unitVector[1] * unitVector[0], point[1] + directionComponent];
  }
}
function rotateVectorAnti90(vector) {
  const x = vector[0];
  const y = vector[1];
  const rotatedX = y;
  const rotatedY = -x;
  return [rotatedX, rotatedY];
}
function rotateVector(vector, angle) {
  if (!angle) {
    return vector;
  }
  const x = vector[0];
  const y = vector[1];
  const rotatedX = x * Math.cos(angle) - y * Math.sin(angle);
  const rotatedY = x * Math.sin(angle) + y * Math.cos(angle);
  return [rotatedX, rotatedY];
}
function isPointOnSegment(point, startPoint, endPoint) {
  const distanceToStart = distanceBetweenPointAndPoint(point[0], point[1], startPoint[0], startPoint[1]);
  const distanceToEnd = distanceBetweenPointAndPoint(point[0], point[1], endPoint[0], endPoint[1]);
  const segmentLength = distanceBetweenPointAndPoint(startPoint[0], startPoint[1], endPoint[0], endPoint[1]);
  return Math.abs(distanceToStart + distanceToEnd - segmentLength) < 0.1;
}
var getCrossingPointsBetweenPointAndSegment = (point, startPoint, endPoint) => {
  const result = [];
  const xRange = [Math.min(startPoint[0], endPoint[0]), Math.max(startPoint[0], endPoint[0])];
  const yRange = [Math.min(startPoint[1], endPoint[1]), Math.max(startPoint[1], endPoint[1])];
  const unitVector = getUnitVectorByPointAndPoint(startPoint, endPoint);
  if (point[0] >= xRange[0] && point[0] <= xRange[1]) {
    const crossingPoint = getPointByVectorDirectionComponent(startPoint, unitVector, point[0] - startPoint[0], true);
    result.push(crossingPoint);
  } else if (point[1] >= yRange[0] && point[1] <= yRange[1]) {
    const crossingPoint = getPointByVectorDirectionComponent(startPoint, unitVector, point[1] - startPoint[1], false);
    result.push(crossingPoint);
  }
  return result;
};
function getPointOnPolyline(points, ratio) {
  const totalLength = calculatePolylineLength(points);
  const targetDistance = totalLength * ratio;
  let accumulatedDistance = 0;
  for (let i = 0; i < points.length - 1; i++) {
    const [x1, y1] = points[i];
    const [x2, y2] = points[i + 1];
    const segmentLength = distanceBetweenPointAndPoint(x1, y1, x2, y2);
    if (accumulatedDistance + segmentLength >= targetDistance) {
      const remainingDistance = targetDistance - accumulatedDistance;
      const ratioInSegment = remainingDistance / segmentLength;
      const targetX = x1 + (x2 - x1) * ratioInSegment;
      const targetY = y1 + (y2 - y1) * ratioInSegment;
      return [targetX, targetY];
    }
    accumulatedDistance += segmentLength;
  }
  return points[points.length - 1];
}
function calculatePolylineLength(points) {
  let length = 0;
  for (let i = 0; i < points.length - 1; i++) {
    const [x1, y1] = points[i];
    const [x2, y2] = points[i + 1];
    length += distanceBetweenPointAndPoint(x1, y1, x2, y2);
  }
  return length;
}
function getRatioByPoint(points, point) {
  const totalLength = calculatePolylineLength(points);
  let distance = 0;
  for (let i = 0; i < points.length - 1; i++) {
    const isOverlap = isPointOnSegment(point, points[i], points[i + 1]);
    if (isOverlap) {
      distance += distanceBetweenPointAndPoint(point[0], point[1], points[i][0], points[i][1]);
      return distance / totalLength;
    } else {
      distance += distanceBetweenPointAndPoint(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1]);
    }
  }
  throw new Error("Cannot get ratio by point");
}
var removeDuplicatePoints = (points) => {
  const newArray = [];
  points.forEach((point) => {
    const index = newArray.findIndex((otherPoint) => {
      return Point.isEquals(point, otherPoint);
    });
    if (index === -1)
      newArray.push(point);
  });
  return newArray;
};
function simplifyOrthogonalPoints(points) {
  if (points.length <= 2)
    return points;
  let simplifiedPoints = [points[0]];
  for (let i = 1; i < points.length - 1; i++) {
    const previous = points[i - 1];
    const current = points[i];
    const next = points[i + 1];
    const isTurn = !(Point.isOverHorizontal([previous, current, next]) || Point.isOverVertical([previous, current, next]));
    if (isTurn) {
      simplifiedPoints.push(current);
    }
  }
  simplifiedPoints.push(points[points.length - 1]);
  return simplifiedPoints;
}
var getExtendPoint = (source, target, extendDistance) => {
  const distance = distanceBetweenPointAndPoint(...source, ...target);
  const isEqual = Point.isEquals(source, target);
  const sin = isEqual ? 1 : (target[1] - source[1]) / distance;
  const cos = isEqual ? 1 : (target[0] - source[0]) / distance;
  return [source[0] + extendDistance * cos, source[1] + extendDistance * sin];
};
var handleDirectionFactors = {
  [Direction.left]: { x: -1, y: 0 },
  [Direction.right]: { x: 1, y: 0 },
  [Direction.top]: { x: 0, y: -1 },
  [Direction.bottom]: { x: 0, y: 1 }
};
function getOppositeDirection(direction) {
  switch (direction) {
    case Direction.left:
      return Direction.right;
    case Direction.right:
      return Direction.left;
    case Direction.top:
      return Direction.bottom;
    case Direction.bottom:
      return Direction.top;
  }
}
function getDirectionByPointOfRectangle(point) {
  if (point[0] === 0) {
    return Direction.left;
  }
  if (point[0] === 1) {
    return Direction.right;
  }
  if (point[1] === 0) {
    return Direction.top;
  }
  if (point[1] === 1) {
    return Direction.bottom;
  }
  return void 0;
}
function getDirectionByVector(vector) {
  const x = vector[0];
  const y = vector[1];
  if (x === 0 && y === 0) {
    return null;
  }
  if (x === 0) {
    return y > 0 ? Direction.bottom : Direction.top;
  }
  if (y === 0) {
    return x > 0 ? Direction.right : Direction.left;
  }
  const angle = Math.atan2(y, x);
  if (angle > -Math.PI / 4 && angle <= Math.PI / 4) {
    return Direction.right;
  } else if (angle > Math.PI / 4 && angle <= 3 * Math.PI / 4) {
    return Direction.bottom;
  } else if (angle > -3 * Math.PI / 4 && angle <= -Math.PI / 4) {
    return Direction.top;
  } else {
    return Direction.left;
  }
}
function getDirectionBetweenPointAndPoint(source, target) {
  if (source[0] === target[0]) {
    if (source[1] >= target[1]) {
      return Direction.top;
    } else {
      return Direction.bottom;
    }
  }
  if (source[1] === target[1]) {
    if (source[0] >= target[0]) {
      return Direction.left;
    } else {
      return Direction.right;
    }
  }
  throw new Error("can not match direction");
}
function getDirectionFactor(direction) {
  return handleDirectionFactors[direction];
}
function getDirectionFactorByDirectionComponent(directionComponent) {
  const directionFactor = directionComponent === 0 ? directionComponent : directionComponent / Math.abs(directionComponent);
  return directionFactor;
}
var getPoints = (source, sourcePosition, target, targetPosition, offset) => {
  const sourceDirectionFactors = getDirectionFactor(sourcePosition);
  const targetDFs = getDirectionFactor(targetPosition);
  const sourceGapped = [source[0] + sourceDirectionFactors.x * offset, source[1] + sourceDirectionFactors.y * offset];
  const targetGapped = [target[0] + targetDFs.x * offset, target[1] + targetDFs.y * offset];
  const dir = getDirection(sourceGapped, sourcePosition, targetGapped);
  const dirAccessor = dir.x !== 0 ? "x" : "y";
  const currDir = dir[dirAccessor];
  let points = [];
  let centerX, centerY;
  const [defaultCenterX, defaultCenterY] = getEdgeCenter({
    sourceX: source[0],
    sourceY: source[1],
    targetX: target[0],
    targetY: target[1]
  });
  if (sourceDirectionFactors[dirAccessor] * targetDFs[dirAccessor] === -1) {
    centerX = defaultCenterX;
    centerY = defaultCenterY;
    const verticalSplit = [
      [centerX, sourceGapped[1]],
      [centerX, targetGapped[1]]
    ];
    const horizontalSplit = [
      [sourceGapped[0], centerY],
      [targetGapped[0], centerY]
    ];
    if (sourceDirectionFactors[dirAccessor] === currDir) {
      points = dirAccessor === "x" ? verticalSplit : horizontalSplit;
    } else {
      points = dirAccessor === "x" ? horizontalSplit : verticalSplit;
    }
  } else {
    const sourceTarget = [[sourceGapped[0], targetGapped[1]]];
    const targetSource = [[targetGapped[0], sourceGapped[1]]];
    if (dirAccessor === "x") {
      points = sourceDirectionFactors.x === currDir ? targetSource : sourceTarget;
    } else {
      points = sourceDirectionFactors.y === currDir ? sourceTarget : targetSource;
    }
    let flipSourceTarget;
    if (sourcePosition !== targetPosition) {
      const dirAccessorOpposite = dirAccessor === "x" ? 1 : 0;
      const isSameDir = sourceDirectionFactors[dirAccessor] === targetDFs[dirAccessor === "x" ? "y" : "x"];
      const sourceGtTarget = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite];
      const sourceLtTarget = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];
      flipSourceTarget = sourceDirectionFactors[dirAccessor] === 1 && (!isSameDir && sourceGtTarget || isSameDir && sourceLtTarget) || sourceDirectionFactors[dirAccessor] !== 1 && (!isSameDir && sourceLtTarget || isSameDir && sourceGtTarget);
      if (flipSourceTarget) {
        points = dirAccessor === "x" ? sourceTarget : targetSource;
      }
    }
  }
  return [source, sourceGapped, ...points, targetGapped, target];
};
var getDirection = (source, sourcePosition = Direction.bottom, target) => {
  if (sourcePosition === Direction.left || sourcePosition === Direction.right) {
    return source[0] < target[0] ? { x: 1, y: 0 } : { x: -1, y: 0 };
  }
  return source[1] < target[1] ? { x: 0, y: 1 } : { x: 0, y: -1 };
};
function getEdgeCenter({ sourceX, sourceY, targetX, targetY }) {
  const xOffset = Math.abs(targetX - sourceX) / 2;
  const centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;
  const yOffset = Math.abs(targetY - sourceY) / 2;
  const centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;
  return [centerX, centerY, xOffset, yOffset];
}
function isVirtualKey(e) {
  const isMod = e.ctrlKey || e.metaKey;
  const isAlt = (0, import_is_hotkey.isKeyHotkey)("alt", e);
  const isShift = (0, import_is_hotkey.isKeyHotkey)("shift", e);
  const isCapsLock = e.key.includes("CapsLock");
  const isTab = e.key.includes("Tab");
  const isEsc = e.key.includes("Escape");
  const isF = e.key.startsWith("F");
  const isArrow = e.key.includes("Arrow") ? true : false;
  return isCapsLock || isMod || isAlt || isArrow || isShift || isTab || isEsc || isF;
}
var isExpandHotkey = (event) => {
  return (0, import_is_hotkey.isKeyHotkey)("mod+/", event);
};
var isTabHotkey = (event) => {
  return event.key === "Tab";
};
var isEnterHotkey = (event) => {
  return event.key === "Enter";
};
var isSpaceHotkey = (event) => {
  return event.code === "Space";
};
var isDelete = (event) => {
  return hotkeys.isDeleteBackward(event) || hotkeys.isDeleteForward(event);
};
var BoardCreationMode;
(function(BoardCreationMode2) {
  BoardCreationMode2["dnd"] = "dnd";
  BoardCreationMode2["drawing"] = "drawing";
})(BoardCreationMode || (BoardCreationMode = {}));
var BOARD_TO_CREATION_MODE = /* @__PURE__ */ new WeakMap();
var getCreationMode = (board) => {
  return BOARD_TO_CREATION_MODE.get(board);
};
var setCreationMode = (board, mode) => {
  BOARD_TO_CREATION_MODE.set(board, mode);
};
var isDndMode = (board) => {
  return getCreationMode(board) === BoardCreationMode.dnd;
};
var isDrawingMode = (board) => {
  return getCreationMode(board) === BoardCreationMode.drawing;
};
var getTextManages = (element) => {
  const ref = PlaitElement.getElementRef(element);
  return (ref == null ? void 0 : ref.getTextManages()) || [];
};
var getFirstTextManage = (element) => {
  const textManage = getTextManages(element)[0];
  if (!textManage) {
    console.warn("can not find textManage");
  }
  return textManage;
};
var getTextEditorsByElement = (element) => {
  return getTextManages(element).map((manage) => {
    return manage.editor;
  });
};
var getFirstTextEditor = (element) => {
  const textEditor = getTextEditorsByElement(element)[0];
  if (!textEditor) {
    console.warn("can not find textManage");
  }
  return textEditor;
};
var findFirstTextEditor = (board) => {
  const selectedElements = getSelectedElements(board);
  let firstEditor = null;
  selectedElements.forEach((element) => {
    const editors = getTextEditorsByElement(element);
    if (!firstEditor && editors && editors.length > 0) {
      firstEditor = editors[0];
    }
  });
  return firstEditor;
};
var getElementsText = (elements) => {
  return elements.map((item) => {
    try {
      const editors = getTextEditorsByElement(item);
      if (editors.length) {
        return editors.map((editor) => {
          const textsEntry = Node.texts(editor);
          return Array.from(textsEntry).reduce((total, text) => total += text[0].text, "");
        }).join(" ");
      }
      return "";
    } catch (error) {
      return "";
    }
  }).filter((item) => item).join(" ");
};
var getTextEditors = (board, elements) => {
  const selectedElements = elements || getSelectedElements(board);
  if (selectedElements.length) {
    const textManages = [];
    selectedElements.forEach((item) => {
      textManages.push(...getTextManages(item));
    });
    const editingTextManage = textManages.find((textManage) => textManage.isEditing);
    if (editingTextManage) {
      return [editingTextManage.editor];
    }
    return textManages.map((item) => {
      return item.editor;
    });
  }
  return void 0;
};
var getEditingTextEditor = (board, elements) => {
  const selectedElements = elements || getSelectedElements(board);
  const textManages = [];
  selectedElements.forEach((item) => {
    textManages.push(...getTextManages(item));
  });
  const editingTextManage = textManages.find((textManage) => textManage.isEditing);
  if (editingTextManage) {
    return editingTextManage.editor;
  }
  return void 0;
};
var buildText = (text, align, properties) => {
  properties = properties || {};
  const plaitText = typeof text === "string" ? { children: [{ text, ...properties }], type: "paragraph" } : text;
  if (align) {
    plaitText.align = align;
  }
  return plaitText;
};
var getLineHeightByFontSize = (fontSize) => {
  if (fontSize === 14) {
    return 20;
  }
  if (fontSize === 18) {
    return 25;
  }
  return fontSize * 1.5;
};
var selectImage = (board, defaultImageWidth, handle, acceptImageTypes2 = ["png", "jpeg", "gif", "bmp"]) => {
  const inputFile = document.createElement("input");
  inputFile.setAttribute("type", "file");
  const acceptImageTypesString = "." + acceptImageTypes2.join(",.");
  inputFile.setAttribute("accept", acceptImageTypesString);
  inputFile.onchange = (event) => {
    buildImage(board, event.target.files[0], defaultImageWidth, handle);
  };
  inputFile.click();
};
var buildImage = async (board, imageFile, defaultImageWidth, handle) => {
  let width = 0, height = 0;
  await getImageSize(imageFile, defaultImageWidth).then((value) => {
    width = value.width;
    height = value.height;
  });
  let imageItem = null;
  const url = URL.createObjectURL(imageFile);
  const context = PlaitBoard.getBoardContext(board);
  context.setUploadingFile({ url, file: imageFile });
  imageItem = {
    url,
    width,
    height
  };
  handle(imageItem);
};
function getImageSize(file, defaultImageWidth) {
  return new Promise((resolve, reject) => {
    const image = new Image();
    image.src = URL.createObjectURL(file);
    image.onload = function() {
      const width = defaultImageWidth;
      const height = defaultImageWidth * image.naturalHeight / image.naturalWidth;
      resolve(image.naturalWidth > defaultImageWidth ? { width, height } : { width: image.naturalWidth, height: image.naturalHeight });
    };
  });
}
var BOARD_TO_ELEMENT_OF_FOCUSED_IMAGE = /* @__PURE__ */ new WeakMap();
var getElementOfFocusedImage = (board) => {
  return BOARD_TO_ELEMENT_OF_FOCUSED_IMAGE.get(board);
};
var addElementOfFocusedImage = (board, element) => {
  BOARD_TO_ELEMENT_OF_FOCUSED_IMAGE.set(board, element);
};
var removeElementOfFocusedImage = (board) => {
  BOARD_TO_ELEMENT_OF_FOCUSED_IMAGE.delete(board);
};
var PriorityQueue = class {
  constructor() {
    this.list = [];
  }
  enqueue(item) {
    this.list.push(item);
    this.list = this.list.sort((item1, item2) => item1.priority - item2.priority);
  }
  dequeue() {
    return this.list.shift();
  }
};
var AStar = class {
  constructor(graph) {
    this.graph = graph;
    this.cameFrom = /* @__PURE__ */ new Map();
  }
  heuristic(a, b) {
    return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]);
  }
  search(start, end, previousStart) {
    const frontier = new PriorityQueue();
    const startNode = this.graph.get(start);
    this.cameFrom = /* @__PURE__ */ new Map();
    const costSoFar = /* @__PURE__ */ new Map();
    costSoFar.set(startNode, 0);
    frontier.enqueue({ node: startNode, priority: 0 });
    while (frontier.list.length > 0) {
      var current = frontier.dequeue();
      if (!current) {
        throw new Error(`can't find current`);
      }
      const currentPoint = current.node.data;
      if (currentPoint[0] === end[0] && currentPoint[1] === end[1]) {
        break;
      }
      current.node.adjacentNodes.forEach((next) => {
        let newCost = costSoFar.get(current.node) + this.heuristic(next.data, current.node.data);
        const previousNode = this.cameFrom.get(current.node);
        const previousPoint = previousNode ? previousNode.data : previousStart;
        const x = previousPoint[0] === (current == null ? void 0 : current.node.data[0]) && previousPoint[0] === next.data[0];
        const y = previousPoint[1] === (current == null ? void 0 : current.node.data[1]) && previousPoint[1] === next.data[1];
        if (!x && !y) {
          newCost = newCost + 1;
        }
        if (!costSoFar.has(next) || costSoFar.get(next) && newCost < costSoFar.get(next)) {
          costSoFar.set(next, newCost);
          const priority = newCost + this.heuristic(next.data, end);
          frontier.enqueue({ node: next, priority });
          this.cameFrom.set(next, current.node);
        }
      });
    }
  }
  getRoute(start, end) {
    const result = [];
    let temp = end;
    while (temp[0] !== start[0] || temp[1] !== start[1]) {
      const node = this.graph.get(temp);
      const preNode = this.cameFrom.get(node);
      result.unshift(preNode.data);
      temp = preNode.data;
    }
    return result;
  }
};
var PointNode = class {
  constructor(data) {
    this.data = data;
    this.distance = Number.MAX_SAFE_INTEGER;
    this.adjacentNodes = [];
  }
};
var PointGraph = class {
  constructor() {
    this.index = {};
  }
  add(p) {
    const x = p[0];
    const y = p[1];
    const xs = x.toString(), ys = y.toString();
    if (!(xs in this.index)) {
      this.index[xs] = {};
    }
    if (!(ys in this.index[xs])) {
      this.index[xs][ys] = new PointNode(p);
    }
  }
  connect(a, b) {
    const nodeA = this.get(a);
    const nodeB = this.get(b);
    if (!nodeA || !nodeB) {
      throw new Error(`A point was not found`);
    }
    nodeA.adjacentNodes.push(nodeB);
  }
  has(p) {
    const x = p[0];
    const y = p[1];
    const xs = x.toString(), ys = y.toString();
    return xs in this.index && ys in this.index[xs];
  }
  get(p) {
    const x = p[0];
    const y = p[1];
    const xs = x.toString(), ys = y.toString();
    if (xs in this.index && ys in this.index[xs]) {
      return this.index[xs][ys];
    }
    return null;
  }
};
var debugGenerator = createDebugGenerator("debug:plait:elbow-line-routing");
var generateElbowLineRoute = (options, board) => {
  const { nextSourcePoint, nextTargetPoint } = options;
  const points = getGraphPoints(options);
  const graph = createGraph(points);
  const aStar = new AStar(graph);
  aStar.search(nextSourcePoint, nextTargetPoint, options.sourcePoint);
  let route = aStar.getRoute(nextSourcePoint, nextTargetPoint);
  route = [options.sourcePoint, ...route, nextTargetPoint, options.targetPoint];
  const isHitX = RectangleClient.isHitX(options.sourceOuterRectangle, options.targetOuterRectangle);
  const isHitY = RectangleClient.isHitY(options.sourceOuterRectangle, options.targetOuterRectangle);
  const centerX = isHitX ? void 0 : RectangleClient.getGapCenter(options.sourceOuterRectangle, options.targetOuterRectangle, true);
  const centerY = isHitY ? void 0 : RectangleClient.getGapCenter(options.sourceOuterRectangle, options.targetOuterRectangle, false);
  route = routeAdjust(route, { centerX, centerY, sourceRectangle: options.sourceRectangle, targetRectangle: options.targetRectangle }, board);
  return route;
};
var routeAdjust = (path, options, board) => {
  const { sourceRectangle, targetRectangle, centerX, centerY } = options;
  if (board) {
    debugGenerator.clear();
  }
  if (centerX !== void 0) {
    const optionsX = getAdjustOptions(path, centerX, true);
    const resultX = optionsX.pointOfHit && adjust(path, { parallelPaths: optionsX.parallelPaths, pointOfHit: optionsX.pointOfHit, sourceRectangle, targetRectangle }, board);
    if (resultX) {
      path = resultX;
    }
  }
  if (centerY !== void 0) {
    const optionsY = getAdjustOptions(path, centerY, false);
    const resultY = optionsY.pointOfHit && adjust(path, { parallelPaths: optionsY.parallelPaths, pointOfHit: optionsY.pointOfHit, sourceRectangle, targetRectangle }, board);
    if (resultY) {
      path = resultY;
    }
  }
  return path;
};
var adjust = (route, options, board) => {
  const { parallelPaths, pointOfHit, sourceRectangle, targetRectangle } = options;
  let result = null;
  parallelPaths.forEach((parallelPath) => {
    const tempRectPoints = [pointOfHit, parallelPath[0], parallelPath[1]];
    const tempRect = RectangleClient.getRectangleByPoints(tempRectPoints);
    if (!RectangleClient.isHit(tempRect, sourceRectangle) && !RectangleClient.isHit(tempRect, targetRectangle)) {
      const tempCorners = RectangleClient.getCornerPointsByPoints(tempRectPoints);
      if (board) {
        debugGenerator.drawRectangle(board, tempRect);
      }
      const indexRangeInPath = [];
      const indexRangeInCorner = [];
      route.forEach((point, index) => {
        const cornerResult = tempCorners.findIndex((corner) => Point.isEquals(point, corner));
        if (cornerResult !== -1) {
          indexRangeInPath.push(index);
          indexRangeInCorner.push(cornerResult);
        }
      });
      const newPath = [...route];
      const missCorner = tempCorners.find((c, index) => !indexRangeInCorner.includes(index));
      const removeLength = Math.abs(indexRangeInPath[0] - indexRangeInPath[indexRangeInPath.length - 1]) + 1;
      newPath.splice(indexRangeInPath[0] + 1, removeLength - 2, missCorner);
      const turnCount = simplifyOrthogonalPoints([...route]).length - 1;
      const simplifyPoints = simplifyOrthogonalPoints([...newPath]);
      const newTurnCount = simplifyPoints.length - 1;
      if (newTurnCount <= turnCount) {
        result = newPath;
      }
    }
    return null;
  });
  return result;
};
var getAdjustOptions = (path, centerOfAxis, isHorizontal) => {
  const parallelPaths = [];
  let start = null;
  let pointOfHit = null;
  const axis = isHorizontal ? 0 : 1;
  for (let index = 0; index < path.length; index++) {
    const previous = path[index - 1];
    const current = path[index];
    if (start === null && previous && previous[axis] === current[axis]) {
      start = previous;
    }
    if (start !== null) {
      if (previous[axis] !== current[axis]) {
        parallelPaths.push([start, previous]);
        start = null;
      }
    }
    if (current[axis] === centerOfAxis) {
      pointOfHit = current;
    }
  }
  if (start) {
    parallelPaths.push([start, path[path.length - 1]]);
  }
  return { pointOfHit, parallelPaths };
};
var getGraphPoints = (options) => {
  const { nextSourcePoint, nextTargetPoint, sourceOuterRectangle, targetOuterRectangle } = options;
  const x = [];
  const y = [];
  let result = [];
  [sourceOuterRectangle, targetOuterRectangle].forEach((rectangle) => {
    x.push(rectangle.x, rectangle.x + rectangle.width / 2, rectangle.x + rectangle.width);
    y.push(rectangle.y, rectangle.y + rectangle.height / 2, rectangle.y + rectangle.height);
  });
  const rectanglesX = [
    sourceOuterRectangle.x,
    sourceOuterRectangle.x + sourceOuterRectangle.width,
    targetOuterRectangle.x,
    targetOuterRectangle.x + targetOuterRectangle.width
  ].sort((a, b) => a - b);
  x.push((rectanglesX[1] + rectanglesX[2]) / 2, nextSourcePoint[0], nextTargetPoint[0]);
  const rectanglesY = [
    sourceOuterRectangle.y,
    sourceOuterRectangle.y + sourceOuterRectangle.height,
    targetOuterRectangle.y,
    targetOuterRectangle.y + targetOuterRectangle.height
  ].sort((a, b) => a - b);
  y.push((rectanglesY[1] + rectanglesY[2]) / 2, nextSourcePoint[1], nextTargetPoint[1]);
  for (let i = 0; i < x.length; i++) {
    for (let j = 0; j < y.length; j++) {
      const point = [x[i], y[j]];
      const isInSource = RectangleClient.isPointInRectangle(sourceOuterRectangle, point);
      const isInTarget = RectangleClient.isPointInRectangle(targetOuterRectangle, point);
      if (!isInSource && !isInTarget) {
        result.push(point);
      }
    }
  }
  result = removeDuplicatePoints(result).filter((point) => {
    const isInSource = RectangleClient.isPointInRectangle(sourceOuterRectangle, point);
    const isInTarget = RectangleClient.isPointInRectangle(targetOuterRectangle, point);
    return !isInSource && !isInTarget;
  });
  return result;
};
var createGraph = (points) => {
  const graph = new PointGraph();
  const Xs = [];
  const Ys = [];
  points.forEach((p) => {
    const x = p[0], y = p[1];
    if (Xs.indexOf(x) < 0)
      Xs.push(x);
    if (Ys.indexOf(y) < 0)
      Ys.push(y);
    graph.add(p);
  });
  Xs.sort((a, b) => a - b);
  Ys.sort((a, b) => a - b);
  const inHotIndex = (p) => graph.has(p);
  for (let i = 0; i < Xs.length; i++) {
    for (let j = 0; j < Ys.length; j++) {
      const point = [Xs[i], Ys[j]];
      if (!inHotIndex(point))
        continue;
      if (i > 0) {
        const otherPoint = [Xs[i - 1], Ys[j]];
        if (inHotIndex(otherPoint)) {
          graph.connect(otherPoint, point);
          graph.connect(point, otherPoint);
        }
      }
      if (j > 0) {
        const otherPoint = [Xs[i], Ys[j - 1]];
        if (inHotIndex(otherPoint)) {
          graph.connect(otherPoint, point);
          graph.connect(point, otherPoint);
        }
      }
    }
  }
  return graph;
};
var reduceRouteMargin = (sourceRectangle, targetRectangle) => {
  const defaultOffset = DEFAULT_ROUTE_MARGIN;
  let sourceOffset = new Array(4).fill(defaultOffset);
  let targetOffset = new Array(4).fill(defaultOffset);
  const leftToRight = sourceRectangle.x - (targetRectangle.x + targetRectangle.width);
  const rightToLeft = targetRectangle.x - (sourceRectangle.x + sourceRectangle.width);
  if (leftToRight > 0 && leftToRight < defaultOffset * 2) {
    const offset = leftToRight / 2;
    sourceOffset[3] = offset;
    targetOffset[1] = offset;
  }
  if (rightToLeft > 0 && rightToLeft < defaultOffset * 2) {
    const offset = rightToLeft / 2;
    targetOffset[3] = offset;
    sourceOffset[1] = offset;
  }
  const topToBottom = sourceRectangle.y - (targetRectangle.y + targetRectangle.height);
  const bottomToTop = targetRectangle.y - (sourceRectangle.y + sourceRectangle.height);
  if (topToBottom > 0 && topToBottom < defaultOffset * 2) {
    const offset = topToBottom / 2;
    sourceOffset[0] = offset;
    targetOffset[2] = offset;
  }
  if (bottomToTop > 0 && bottomToTop < defaultOffset * 2) {
    const offset = bottomToTop / 2;
    sourceOffset[2] = offset;
    targetOffset[0] = offset;
  }
  return { sourceOffset, targetOffset };
};
var getNextPoint = (point, outerRectangle, direction) => {
  switch (direction) {
    case Direction.top: {
      return [point[0], outerRectangle.y];
    }
    case Direction.bottom: {
      return [point[0], outerRectangle.y + outerRectangle.height];
    }
    case Direction.right: {
      return [outerRectangle.x + outerRectangle.width, point[1]];
    }
    default: {
      return [outerRectangle.x, point[1]];
    }
  }
};
var getSourceAndTargetOuterRectangle = (sourceRectangle, targetRectangle) => {
  const { sourceOffset, targetOffset } = reduceRouteMargin(sourceRectangle, targetRectangle);
  const sourceOuterRectangle = RectangleClient.expand(sourceRectangle, sourceOffset[3], sourceOffset[0], sourceOffset[1], sourceOffset[2]);
  const targetOuterRectangle = RectangleClient.expand(targetRectangle, targetOffset[3], targetOffset[0], targetOffset[1], targetOffset[2]);
  return {
    sourceOuterRectangle,
    targetOuterRectangle
  };
};
var isSourceAndTargetIntersect = (options) => {
  const { sourcePoint, nextSourcePoint, sourceRectangle, sourceOuterRectangle, targetPoint, nextTargetPoint, targetRectangle, targetOuterRectangle } = options;
  return RectangleClient.isPointInRectangle(targetRectangle, sourcePoint) || RectangleClient.isPointInRectangle(targetOuterRectangle, nextSourcePoint) || RectangleClient.isPointInRectangle(sourceOuterRectangle, nextTargetPoint) || RectangleClient.isPointInRectangle(sourceRectangle, targetPoint);
};
var map = /* @__PURE__ */ new Map();
var memorizeLatest = (memorizedKey, propertyKey, propertyValue) => {
  let obj = map.has(memorizedKey) ? map.get(memorizedKey) : {};
  obj[propertyKey] = propertyValue;
  map.set(memorizedKey, obj);
};
var getMemorizedLatest = (memorizedKey) => {
  return map.get(memorizedKey);
};
var IS_ROTATING = /* @__PURE__ */ new WeakMap();
var isRotating = (board) => {
  return !!IS_ROTATING.get(board);
};
var addRotating = (board, rotateRef) => {
  PlaitBoard.getBoardContainer(board).classList.add(`draw-elements-rotating`);
  IS_ROTATING.set(board, rotateRef);
  setDragging(board, true);
};
var removeRotating = (board) => {
  PlaitBoard.getBoardContainer(board).classList.remove(`draw-elements-rotating`);
  IS_ROTATING.delete(board);
  setDragging(board, false);
};
var getElementArea = (board, element) => {
  const rectangle = board.getRectangle(element);
  if (rectangle) {
    return rectangle.width * rectangle.height;
  }
  return 0;
};
var sortElementsByArea = (board, elements, direction = "asc") => {
  return elements.sort((a, b) => {
    const areaA = getElementArea(board, a);
    const areaB = getElementArea(board, b);
    return direction === "asc" ? areaA - areaB : areaB - areaA;
  });
};
var isFilled = (fill) => {
  return fill && fill !== DEFAULT_FILL && fill !== TRANSPARENT;
};
function animate(tween, duration, ease, callback) {
  const start = getTimestamp();
  let stopAnimation = false;
  function tick(now) {
    if (stopAnimation) {
      return;
    }
    const elapsed = now - start;
    const t = Math.min(elapsed / duration, 1);
    tween(ease(t));
    if (t < 1) {
      requestAnimationFrame(tick);
    } else if (callback) {
      callback();
    }
  }
  requestAnimationFrame(tick);
  return {
    stop: () => stopAnimation = true,
    start: () => {
      stopAnimation = false;
      requestAnimationFrame(tick);
    }
  };
}
function getTimestamp() {
  if (window.performance && window.performance.now) {
    return window.performance.now();
  } else {
    return Date.now();
  }
}
function linear(t) {
  return t;
}
var getStrokeLineDash = (strokeStyle, strokeWidth) => {
  switch (strokeStyle) {
    case StrokeStyle.dashed:
      return [8, 8 + strokeWidth];
    case StrokeStyle.dotted:
      return [2, 4 + strokeWidth];
    default:
      return void 0;
  }
};
var buildClipboardData = (board, elements, startPoint, elementBuilder) => {
  return elements.map((element) => {
    const newElement = elementBuilder && elementBuilder(element);
    if (newElement) {
      return newElement;
    }
    if (element.points) {
      const points = element.points.map((point) => [point[0] - startPoint[0], point[1] - startPoint[1]]);
      return { ...element, points };
    }
    return element;
  });
};
var insertClipboardData = (board, elements, startPoint, elementHandler) => {
  const idsMap = {};
  elements.forEach((element) => {
    idsMap[element.id] = idCreator();
  });
  elements.forEach((element) => {
    element.id = idsMap[element.id];
    elementHandler && elementHandler(element, idsMap);
    if (element.points) {
      element.points = element.points.map((point) => [startPoint[0] + point[0], startPoint[1] + point[1]]);
    }
    Transforms.insertNode(board, element, [board.children.length]);
  });
  Transforms.addSelectionWithTemporaryElements(board, elements);
};
var moveXOfPoint = (point, distance, direction = Direction.right) => {
  if (direction === Direction.left) {
    return [point[0] - distance, point[1]];
  }
  if (direction === Direction.bottom) {
    return [point[0], point[1] + distance];
  }
  if (direction === Direction.top) {
    return [point[0], point[1] - distance];
  }
  return [point[0] + distance, point[1]];
};
var moveYOfPoint = (point, distance, direction = Direction.right) => {
  if (direction === Direction.bottom) {
    return [point[0] + distance, point[1]];
  }
  if (direction === Direction.top) {
    return [point[0] + distance, point[1]];
  }
  return [point[0], point[1] + distance];
};
var getDirectionByIndex = (index) => {
  if (index === 0) {
    return Direction.top;
  }
  if (index === 1) {
    return Direction.right;
  }
  if (index === 2) {
    return Direction.bottom;
  }
  if (index === 3) {
    return Direction.left;
  }
  return Direction.right;
};
var getXDistanceBetweenPoint = (point1, point2, isHorizontal) => {
  if (isHorizontal) {
    return Math.abs(point1[0] - point2[0]);
  } else {
    return Math.abs(point1[1] - point2[1]);
  }
};
var FOREIGN_OBJECT_IMAGE_CLASS_NAME = "foreign-object-image";
var _ImageGenerator = class _ImageGenerator extends Generator {
  constructor(board, options) {
    super(board, options);
    this.board = board;
    this.options = options;
    this.isFocus = false;
  }
  canDraw(element) {
    return !!this.options.getImageItem(element);
  }
  draw(element) {
    this.element = element;
    const g = createG();
    const foreignRectangle = this.options.getRectangle(element);
    this.foreignObject = createForeignObject(foreignRectangle.x, foreignRectangle.y, foreignRectangle.width, foreignRectangle.height);
    this.foreignObject.classList.add(FOREIGN_OBJECT_IMAGE_CLASS_NAME);
    g.append(this.foreignObject);
    const props = {
      board: this.board,
      imageItem: this.options.getImageItem(element),
      element,
      getRectangle: () => {
        return this.options.getRectangle(element);
      }
    };
    this.imageComponentRef = this.board.renderImage(this.foreignObject, props);
    this.activeGenerator = createActiveGenerator(this.board, {
      getStrokeWidth: () => {
        const selectedElements = getSelectedElements(this.board);
        if (!(selectedElements.length === 1 && !isSelectionMoving(this.board))) {
          return ACTIVE_STROKE_WIDTH;
        } else {
          return ACTIVE_STROKE_WIDTH;
        }
      },
      getStrokeOpacity: () => {
        const selectedElements = getSelectedElements(this.board);
        if (selectedElements.length === 1 && !isSelectionMoving(this.board) || !selectedElements.length) {
          return 1;
        } else {
          return 0.5;
        }
      },
      getRectangle: () => {
        return this.options.getRectangle(this.element);
      },
      hasResizeHandle: () => {
        const isSelectedImageElement = hasResizeHandle(this.board, this.element);
        const isSelectedImage = !!getElementOfFocusedImage(this.board);
        return isSelectedImage || isSelectedImageElement;
      }
    });
    return g;
  }
  updateImage(nodeG, previous, current) {
    this.element = current;
    if (previous !== current && this.imageComponentRef) {
      const props = {
        imageItem: this.options.getImageItem(current),
        element: current,
        getRectangle: () => {
          return this.options.getRectangle(current);
        }
      };
      this.imageComponentRef.update(props);
    }
    const currentForeignObject = this.options.getRectangle(current);
    updateForeignObject(this.g, currentForeignObject.width, currentForeignObject.height, currentForeignObject.x, currentForeignObject.y);
    if (currentForeignObject && current.angle !== void 0) {
      setAngleForG(this.g, RectangleClient.getCenterPoint(currentForeignObject), current.angle);
    }
    const activeG = PlaitBoard.getActiveHost(this.board);
    this.activeGenerator.processDrawing(current, activeG, { selected: this.isFocus });
  }
  setFocus(element, isFocus) {
    this.isFocus = isFocus;
    const activeG = PlaitBoard.getActiveHost(this.board);
    this.activeGenerator.processDrawing(element, activeG, { selected: isFocus });
    const props = {
      isFocus
    };
    this.imageComponentRef.update(props);
  }
  destroy() {
    var _a, _b;
    super.destroy();
    (_a = this.imageComponentRef) == null ? void 0 : _a.destroy();
    (_b = this.activeGenerator) == null ? void 0 : _b.destroy();
  }
};
_ImageGenerator.key = "image-generator";
var ImageGenerator = _ImageGenerator;
var setProperty = (board, properties, options) => {
  const selectedElements = getSelectedElements(board);
  selectedElements.forEach((element) => {
    if ((options == null ? void 0 : options.match) && !(options == null ? void 0 : options.match(element)))
      return;
    const path = PlaitBoard.findPath(board, element);
    const memorizeKey = (options == null ? void 0 : options.getMemorizeKey) ? options == null ? void 0 : options.getMemorizeKey(element) : "";
    for (let key in properties) {
      memorizeKey && memorizeLatest(memorizeKey, key, properties[key]);
    }
    if (options == null ? void 0 : options.callback) {
      options.callback(element, path);
    } else {
      Transforms.setNode(board, properties, path);
    }
  });
};
var setStrokeStyle = (board, strokeStyle, options) => {
  setProperty(board, { strokeStyle }, options);
};
var setFillColor = (board, fill, options) => {
  setProperty(board, { fill }, options);
};
var setStrokeColor = (board, strokeColor, options) => {
  setProperty(board, { strokeColor }, options);
};
var setStrokeWidth = (board, strokeWidth, options) => {
  setProperty(board, { strokeWidth }, options);
};
var PropertyTransforms = {
  setFillColor,
  setStrokeStyle,
  setProperty,
  setStrokeWidth,
  setStrokeColor
};
var alignTop = (board) => {
  function getOffset(outerRectangle, rectangle) {
    return [0, outerRectangle.y - rectangle.y];
  }
  setOffset(board, getOffset);
};
var alignBottom = (board) => {
  function getOffset(outerRectangle, rectangle) {
    return [0, outerRectangle.y + outerRectangle.height - (rectangle.y + rectangle.height)];
  }
  setOffset(board, getOffset);
};
var alignLeft = (board) => {
  function getOffset(outerRectangle, rectangle) {
    return [outerRectangle.x - rectangle.x, 0];
  }
  setOffset(board, getOffset);
};
var alignHorizontalCenter = (board) => {
  function getOffset(outerRectangle, rectangle) {
    const outerCenter = outerRectangle.x + outerRectangle.width / 2;
    const elementCenter = rectangle.x + rectangle.width / 2;
    return [outerCenter - elementCenter, 0];
  }
  setOffset(board, getOffset);
};
var alignVerticalCenter = (board) => {
  function getOffset(outerRectangle, rectangle) {
    const outerCenter = outerRectangle.y + outerRectangle.height / 2;
    const elementCenter = rectangle.y + rectangle.height / 2;
    return [0, outerCenter - elementCenter];
  }
  setOffset(board, getOffset);
};
var alignRight = (board) => {
  function getOffset(outerRectangle, rectangle) {
    return [outerRectangle.x + outerRectangle.width - (rectangle.x + rectangle.width), 0];
  }
  setOffset(board, getOffset);
};
function setOffset(board, getOffset) {
  const elements = getHighestSelectedElements(board);
  const outerRectangle = getRectangleByElements(board, elements, false);
  elements.forEach((element) => {
    if (!element.points && !PlaitGroupElement.isGroup(element))
      return;
    const rectangle = board.getRectangle(element);
    const offset = getOffset(outerRectangle, rectangle);
    let updateElements = [];
    if (PlaitGroupElement.isGroup(element)) {
      updateElements = getElementsInGroup(board, element, true, false);
    } else if (element.points) {
      updateElements = [element];
    }
    updateElements.forEach((item) => {
      const newPoints = item.points.map((p) => [p[0] + offset[0], p[1] + offset[1]]);
      const path = PlaitBoard.findPath(board, item);
      Transforms.setNode(board, {
        points: newPoints
      }, path);
    });
    MERGING.set(board, true);
  });
  MERGING.set(board, false);
}
var distributeHorizontal = (board) => {
  distribute(board, true);
};
var distributeVertical = (board) => {
  distribute(board, false);
};
var distribute = (board, isHorizontal) => {
  const axis = isHorizontal ? "x" : "y";
  const side = isHorizontal ? "width" : "height";
  const highestSelectedElements = getHighestSelectedElements(board);
  const refs = highestSelectedElements.map((element) => {
    return { element, rectangle: board.getRectangle(element) };
  });
  const outerRectangle = getRectangleByElements(board, highestSelectedElements, false);
  const minRectangleRef = refs.sort((a, b) => a.rectangle[axis] - b.rectangle[axis])[0];
  const maxRectangleRef = refs.sort((a, b) => b.rectangle[axis] + b.rectangle[side] - (a.rectangle[axis] + a.rectangle[side]))[0];
  const minIndex = refs.findIndex((ref) => ref === minRectangleRef);
  const maxIndex = refs.findIndex((ref) => ref === maxRectangleRef);
  let distributeRefs = refs.filter((element, index) => index !== minIndex && index !== maxIndex);
  const sum = distributeRefs.reduce((accumulator, current) => current.rectangle[side] + accumulator, 0);
  const offset = (outerRectangle[side] - minRectangleRef.rectangle[side] - maxRectangleRef.rectangle[side] - sum) / (distributeRefs.length + 1);
  distributeRefs = distributeRefs.sort((a, b) => a.rectangle[axis] - b.rectangle[axis]);
  let position = minRectangleRef.rectangle[axis] + minRectangleRef.rectangle[side] + offset;
  for (let i = 0; i < distributeRefs.length; i++) {
    const rectangle = distributeRefs[i].rectangle;
    const moveOffset = [0, 0];
    const moveAxis = isHorizontal ? 0 : 1;
    moveOffset[moveAxis] = position - rectangle[axis];
    const path = PlaitBoard.findPath(board, distributeRefs[i].element);
    const newPoints = distributeRefs[i].element.points.map((p) => [p[0] + moveOffset[0], p[1] + moveOffset[1]]);
    Transforms.setNode(board, {
      points: newPoints
    }, path);
    MERGING.set(board, true);
    position = position + rectangle[side] + offset;
  }
  MERGING.set(board, false);
};
var AlignTransform = {
  alignTop,
  alignHorizontalCenter,
  alignBottom,
  alignLeft,
  alignVerticalCenter,
  alignRight,
  distributeHorizontal,
  distributeVertical
};
var normalizeShapePoints = (points, shift = false) => {
  let start = points[0];
  let end = points[1];
  if (shift) {
    const width = Math.abs(start[0] - end[0]);
    const height = Math.abs(start[1] - end[1]);
    const edge = Math.max(height, width);
    end = [start[0] + (end[0] > start[0] ? edge : -edge), start[1] + (end[1] > start[1] ? edge : -edge)];
  }
  const leftTopPoint = [Math.min(start[0], end[0]), Math.min(start[1], end[1])];
  let rightBottomPoint = [Math.max(start[0], end[0]), Math.max(start[1], end[1])];
  return [leftTopPoint, rightBottomPoint];
};
var generalCanResize = (board, event) => {
  return !PlaitBoard.isReadonly(board) && !PlaitBoard.hasBeenTextEditing(board) && PlaitBoard.isPointer(board, PlaitPointerType.selection);
};
var withResize = (board, options) => {
  const { pointerDown, pointerMove, globalPointerUp } = board;
  let resizeHitTestRef = null;
  let resizeRef = null;
  let startPoint = null;
  let hoverHitTestRef = null;
  board.pointerDown = (event) => {
    if (!options.canResize() || !generalCanResize(board, event) || !isMainPointer(event)) {
      pointerDown(event);
      return;
    }
    const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
    resizeHitTestRef = options.hitTest(point);
    if (resizeHitTestRef) {
      if (resizeHitTestRef.cursorClass) {
        PlaitBoard.getBoardContainer(board).classList.add(`${resizeHitTestRef.cursorClass}`);
      }
      startPoint = [event.x, event.y];
      const path = Array.isArray(resizeHitTestRef.element) ? resizeHitTestRef.element.map((el) => PlaitBoard.findPath(board, el)) : PlaitBoard.findPath(board, resizeHitTestRef.element);
      resizeRef = {
        path,
        element: resizeHitTestRef.element,
        handle: resizeHitTestRef.handle,
        handleIndex: resizeHitTestRef.handleIndex,
        rectangle: resizeHitTestRef.rectangle,
        options: resizeHitTestRef.options
      };
      return;
    }
    pointerDown(event);
  };
  board.pointerMove = (event) => {
    if (!options.canResize() || !generalCanResize(board, event)) {
      clearHoverHitTestRef();
      pointerMove(event);
      return;
    }
    if (startPoint && resizeHitTestRef && !isResizing(board)) {
      const endPoint = [event.x, event.y];
      const distance = distanceBetweenPointAndPoint(startPoint[0], startPoint[1], endPoint[0], endPoint[1]);
      if (distance > PRESS_AND_MOVE_BUFFER) {
        addResizing(board, resizeRef, options.key);
        MERGING.set(board, true);
        options.beforeResize && options.beforeResize(resizeRef);
      }
    }
    if (!isResizing(board) && !isDragging(board)) {
      const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
      throttleRAF(board, options.key + "-common-resize-hit-test", () => {
        const hitTestRef = options.hitTest(point);
        if (hitTestRef) {
          if (hoverHitTestRef && hitTestRef.cursorClass !== hoverHitTestRef.cursorClass) {
            PlaitBoard.getBoardContainer(board).classList.remove(`${hoverHitTestRef.cursorClass}`);
          }
          hoverHitTestRef = hitTestRef;
          if (hoverHitTestRef.cursorClass) {
            PlaitBoard.getBoardContainer(board).classList.add(`${hoverHitTestRef.cursorClass}`);
          }
        } else {
          clearHoverHitTestRef();
        }
      });
    } else {
      if (startPoint && isResizing(board)) {
        event.preventDefault();
        const endPoint = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
        throttleRAF(board, "with-common-resize", () => {
          if (startPoint && resizeRef) {
            options.onResize(resizeRef, {
              startPoint: toViewBoxPoint(board, toHostPoint(board, startPoint[0], startPoint[1])),
              endPoint,
              isShift: !!event.shiftKey
            });
          }
        });
        return;
      }
    }
    pointerMove(event);
  };
  board.globalPointerUp = (event) => {
    globalPointerUp(event);
    if (isResizing(board) || resizeHitTestRef) {
      options.afterResize && options.afterResize(resizeRef);
      removeResizing(board, options.key);
      startPoint = null;
      resizeHitTestRef = null;
      resizeRef = null;
      MERGING.set(board, false);
    }
  };
  const clearHoverHitTestRef = () => {
    if (hoverHitTestRef) {
      if (hoverHitTestRef.cursorClass) {
        PlaitBoard.getBoardContainer(board).classList.remove(`${hoverHitTestRef.cursorClass}`);
      }
      hoverHitTestRef = null;
    }
  };
  return board;
};
var GroupGenerator = class extends Generator {
  canDraw(element) {
    return true;
  }
  draw(element, partialSelected) {
    const options = {
      stroke: "",
      strokeWidth: ACTIVE_STROKE_WIDTH,
      strokeLineDash: [5]
    };
    let rectangle = { x: 0, y: 0, width: 0, height: 0 };
    if (partialSelected) {
      options.stroke = "#999";
      rectangle = getRectangleByGroup(this.board, element, true);
    }
    return drawRectangle(this.board, rectangle, options);
  }
};
var PlaitCommonElementRef = class {
  constructor() {
    this.textManages = [];
    this.generatorMap = /* @__PURE__ */ new Map();
    this.updateActiveSection = () => {
    };
  }
  addGenerator(key, generator) {
    this.generatorMap.set(key, generator);
  }
  getGenerator(key) {
    return this.generatorMap.get(key);
  }
  initializeTextManage(textManage) {
    this.textManages = [];
    if (Array.isArray(textManage)) {
      this.textManages.push(...textManage);
    } else {
      this.textManages.push(textManage);
    }
  }
  getTextManages() {
    return this.textManages;
  }
  destroyTextManage() {
    this.textManages.forEach((textManage) => {
      textManage.destroy();
    });
    this.textManages = [];
  }
};
var CommonElementFlavour = class extends ElementFlavour {
  constructor(elementRef = new PlaitCommonElementRef()) {
    super(elementRef);
  }
};
var GroupComponent = class extends CommonElementFlavour {
  constructor() {
    super();
  }
  initializeGenerator() {
    this.activeGenerator = createActiveGenerator(this.board, {
      getRectangle: (element) => {
        return getRectangleByGroup(this.board, element);
      },
      getStrokeWidth: () => 0,
      getStrokeOpacity: () => 0,
      hasResizeHandle: () => {
        return !isSelectionMoving(this.board);
      }
    });
    this.groupGenerator = new GroupGenerator(this.board);
  }
  initialize() {
    super.initialize();
    this.initializeGenerator();
    const contextService = PlaitBoard.getBoardContext(this.board);
    this.onStableSubscription = contextService.onStable().subscribe(() => {
      const elementsInGroup = getElementsInGroup(this.board, this.element, false, true);
      const isPartialSelectGroup = elementsInGroup.some((item) => isSelectedElementOrGroup(this.board, item)) && !elementsInGroup.every((item) => isSelectedElementOrGroup(this.board, item));
      this.groupGenerator.processDrawing(this.element, this.getElementG(), isPartialSelectGroup);
    });
  }
  onContextChanged(value, previous) {
  }
  destroy() {
    var _a;
    super.destroy();
    (_a = this.onStableSubscription) == null ? void 0 : _a.unsubscribe();
  }
};
function withGroup(board) {
  let groupRectangleG;
  let removeGroups;
  const { drawElement, pointerMove, globalPointerUp, insertFragment, getDeletedFragment, deleteFragment, getRelatedFragment, getRectangle, keyDown } = board;
  board.drawElement = (context) => {
    if (PlaitGroupElement.isGroup(context.element)) {
      return GroupComponent;
    }
    return drawElement(context);
  };
  board.pointerMove = (event) => {
    throttleRAF(board, "with-group", () => {
      groupRectangleG == null ? void 0 : groupRectangleG.remove();
      const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
      let selection = { anchor: point, focus: point };
      if (board.selection && !Selection.isCollapsed(board.selection)) {
        selection = board.selection;
      }
      const pointer = PlaitBoard.getPointer(board);
      if (!isResizing(board) && !isMovingElements(board) && pointer === PlaitPointerType.selection) {
        const hitElements = getHitElementsBySelection(board, selection);
        if (hitElements.length) {
          groupRectangleG = createGroupRectangleG(board, hitElements);
          groupRectangleG && PlaitBoard.getElementTopHost(board).append(groupRectangleG);
        }
      }
    });
    pointerMove(event);
  };
  board.globalPointerUp = (event) => {
    groupRectangleG == null ? void 0 : groupRectangleG.remove();
    groupRectangleG = null;
    globalPointerUp(event);
  };
  board.getRelatedFragment = (elements, originData) => {
    const groups = getSelectedGroups(board, elements, originData);
    return getRelatedFragment([...elements, ...groups], originData);
  };
  board.insertFragment = (clipboardData, targetPoint, operationType) => {
    var _a, _b;
    let elements = [];
    if ((_a = clipboardData == null ? void 0 : clipboardData.elements) == null ? void 0 : _a.length) {
      elements = new Array((_b = clipboardData == null ? void 0 : clipboardData.elements) == null ? void 0 : _b.length);
      const groups = getHighestSelectedGroups(board, clipboardData == null ? void 0 : clipboardData.elements);
      const selectedIsolatedElements = getSelectedIsolatedElements(board, clipboardData == null ? void 0 : clipboardData.elements);
      selectedIsolatedElements.forEach((item) => {
        const index = clipboardData.elements.map((element) => element.id).indexOf(item.id);
        elements.splice(index, 1, !item.groupId ? item : updateGroupId(item, void 0));
      });
      if (groups.length) {
        groups.forEach((item) => {
          const index = clipboardData.elements.map((element) => element.id).indexOf(item.id);
          const newGroup = { ...updateGroupId(item, void 0), id: idCreator() };
          elements.splice(index, 1, newGroup);
          updateElementsGroupId(item, clipboardData.elements, newGroup.id, elements);
        });
      }
      clipboardData.elements = elements;
    }
    insertFragment(clipboardData, targetPoint, operationType);
    const groupElements = elements == null ? void 0 : elements.filter((value) => PlaitGroupElement.isGroup(value));
    groupElements.forEach((element) => {
      Transforms.insertNode(board, element, [board.children.length]);
    });
  };
  board.getDeletedFragment = (data) => {
    removeGroups = getRemoveGroups(board);
    if (removeGroups && removeGroups.length) {
      data.push(...removeGroups);
    }
    return getDeletedFragment(data);
  };
  board.deleteFragment = (elements) => {
    if (removeGroups == null ? void 0 : removeGroups.length) {
      updateSiblingElementGroupId(board, removeGroups);
    }
    deleteFragment(elements);
    removeGroups = null;
  };
  board.getRectangle = (element) => {
    if (PlaitGroupElement.isGroup(element)) {
      return getRectangleByGroup(board, element, true);
    }
    return getRectangle(element);
  };
  board.keyDown = (event) => {
    if (!PlaitBoard.isReadonly(board)) {
      if ((0, import_is_hotkey.isKeyHotkey)("mod+g", event)) {
        event.preventDefault();
        Transforms.addGroup(board);
        return;
      }
      if ((0, import_is_hotkey.isKeyHotkey)("mod+shift+g", event)) {
        event.preventDefault();
        Transforms.removeGroup(board);
        return;
      }
    }
    keyDown(event);
  };
  return board;
}
var updateGroupId = (element, groupId) => {
  return {
    ...element,
    groupId
  };
};
var updateElementsGroupId = (group, clipboardDataElements, newGroupId, elements) => {
  const elementsInGroup = clipboardDataElements.filter((item) => item.groupId === group.id);
  if (elementsInGroup.length) {
    elementsInGroup.forEach((item) => {
      const index = clipboardDataElements.map((item2) => item2.id).indexOf(item.id);
      if (PlaitGroupElement.isGroup(item)) {
        const newGroup = { ...updateGroupId(item, newGroupId), id: idCreator() };
        elements.splice(index, 1, newGroup);
        updateElementsGroupId(item, clipboardDataElements, newGroup.id, elements);
      } else {
        elements.splice(index, 1, updateGroupId(item, newGroupId));
      }
    });
  }
  return elements;
};
var getRemoveGroups = (board) => {
  const selectedGroups = board.getRelatedFragment([]);
  const removeGroups = [...selectedGroups];
  const highestSelectedGroups = getHighestSelectedGroups(board);
  const selectedIsolatedElements = getSelectedIsolatedElementsCanAddToGroup(board);
  const removeNodes = [...highestSelectedGroups, ...selectedIsolatedElements];
  removeNodes.forEach((item) => {
    const hitElementGroups = getGroupByElement(board, item, true);
    if (hitElementGroups.length) {
      const elementsInGroup = getElementsInGroup(board, hitElementGroups[0], false, true);
      const siblingElements = elementsInGroup.filter((element) => ![...removeNodes, ...removeGroups].map((item2) => item2.id).includes(element.id));
      if (siblingElements.length === 1 || siblingElements.length === 0) {
        if (!removeGroups.includes(hitElementGroups[0])) {
          removeGroups.push(hitElementGroups[0]);
        }
        if (siblingElements.length === 1) {
          if (hitElementGroups.length > 1) {
            const aboveGroup = findAboveGroupWithAnotherElement(board, hitElementGroups.slice(1, hitElementGroups.length), [
              ...removeNodes,
              ...removeGroups
            ]);
            let index = hitElementGroups.length;
            if (aboveGroup) {
              index = hitElementGroups.findIndex((item2) => item2.id === aboveGroup.id);
            }
            [...hitElementGroups.slice(1, index)].forEach((item2) => {
              if (!removeGroups.includes(item2)) {
                removeGroups.push(item2);
              }
            });
          }
        }
      }
    }
  });
  return removeGroups;
};
var findAboveGroupWithAnotherElement = (board, groups, excludeNodes) => {
  let group = null;
  for (let i = 0; i < groups.length; i++) {
    const elementsInGroup = getElementsInGroup(board, groups[i], false, true);
    const siblingElements = elementsInGroup.filter((element) => !excludeNodes.map((item) => item.id).includes(element.id));
    if (siblingElements.length > 0) {
      group = groups[i];
      break;
    }
  }
  return group;
};
var updateSiblingElementGroupId = (board, removeGroups) => {
  const selectedIsolatedElements = getSelectedIsolatedElementsCanAddToGroup(board);
  const highestSelectedGroups = getHighestSelectedGroups(board);
  const isolatedElementsInGroup = selectedIsolatedElements.filter((item) => item.groupId);
  [...highestSelectedGroups, ...isolatedElementsInGroup].forEach((item) => {
    const hitElementGroups = getGroupByElement(board, item, true);
    if (hitElementGroups.length) {
      const elementsInGroup = getElementsInGroup(board, hitElementGroups[0], false, true);
      const siblingElements = elementsInGroup.filter((element) => element.id !== item.id);
      if (siblingElements.length === 1) {
        const removeGroupIds = removeGroups.map((item2) => item2.id);
        if (hitElementGroups.some((group) => removeGroupIds.includes(group.id))) {
          const group = hitElementGroups.find((group2) => !removeGroupIds.includes(group2.id));
          const path = PlaitBoard.findPath(board, siblingElements[0]);
          Transforms.setNode(board, { groupId: (group == null ? void 0 : group.id) || void 0 }, path);
        }
      }
    }
  });
};
var ImageBaseComponent = class {
  set isFocus(value) {
    this._isFocus = value;
  }
  get isFocus() {
    return this._isFocus;
  }
};
var BOARD_TO_CANVAS_MAP = /* @__PURE__ */ new WeakMap();
var ELEMENT_TO_SIZE_MAP = /* @__PURE__ */ new WeakMap();
var getCanvasForBoard = (board) => {
  if (board) {
    if (!BOARD_TO_CANVAS_MAP.get(board)) {
      const canvas = document.createElement("canvas");
      BOARD_TO_CANVAS_MAP.set(board, canvas);
      return canvas;
    }
    return BOARD_TO_CANVAS_MAP.get(board);
  }
  return document.createElement("canvas");
};
var getElementSize = (board, element, options, containerMaxWidth = 1e4) => {
  let size = ELEMENT_TO_SIZE_MAP.get(element);
  if (size) {
    return size;
  }
  size = measureElement(board, element, options, containerMaxWidth);
  ELEMENT_TO_SIZE_MAP.set(element, size);
  return size;
};
var updateElementSizeCache = (board, element, size) => {
  ELEMENT_TO_SIZE_MAP.set(element, size);
};
var clearElementSizeCache = (board, element) => {
  ELEMENT_TO_SIZE_MAP.delete(element);
};
function measureElement(board, element, options, containerMaxWidth = 1e4) {
  const canvas = getCanvasForBoard(board);
  const ctx = canvas.getContext("2d");
  const textEntries = Node.texts(element);
  const lines = [[]];
  for (const textEntry of textEntries) {
    const [text] = textEntry;
    const textString = Node.string(text);
    const textArray = textString.split("\n");
    textArray.forEach((segmentTextString, index) => {
      const segmentText = { ...text, text: segmentTextString };
      if (index === 0) {
        const currentLine = lines[lines.length - 1];
        currentLine.push(segmentText);
      } else {
        const newLine = [];
        newLine.push(segmentText);
        lines.push(newLine);
      }
    });
  }
  let width = 0;
  let height = 0;
  lines.forEach((lineTexts, index) => {
    let lineWidth = 0;
    let maxLineHeight = getLineHeightByFontSize(options.fontSize);
    lineTexts.forEach((text, index2) => {
      const font = getFont(text, { fontFamily: options.fontFamily, fontSize: options.fontSize });
      ctx.font = font;
      lineWidth += ctx.measureText(text.text).width;
      const isLast = index2 === lineTexts.length - 1;
      if (text["font-size"] && (isLast || text.text !== "")) {
        const lineHeight = getLineHeightByFontSize(parseFloat(text["font-size"]));
        if (lineHeight > maxLineHeight) {
          maxLineHeight = lineHeight;
        }
      }
    });
    if (lineWidth <= containerMaxWidth) {
      if (lineWidth > width) {
        width = lineWidth;
      }
      height += maxLineHeight;
    } else {
      width = containerMaxWidth;
      const lineWrapNumber = Math.ceil(lineWidth / containerMaxWidth);
      height += maxLineHeight * lineWrapNumber;
    }
  });
  return { width, height };
}
var getFont = (text, options) => {
  return `${text.italic ? "italic " : ""} ${text.bold ? "bold " : ""} ${text["font-size"] || options.fontSize}px ${options.fontFamily} `;
};
var TextManage = class {
  constructor(board, options) {
    this.board = board;
    this.options = options;
    this.isEditing = false;
    this.getSize = (element, maxWidth) => {
      const computedStyle = window.getComputedStyle(this.foreignObject.children[0]);
      const fontFamily = computedStyle.fontFamily;
      const fontSize = parseFloat(computedStyle.fontSize);
      const target = element || this.editor.children[0];
      return measureElement(this.board, target, {
        fontSize,
        fontFamily
      }, maxWidth || this.options.getMaxWidth());
    };
    this.getText = () => {
      return this.editor.children[0];
    };
    if (!this.options.getMaxWidth) {
      this.options.getMaxWidth = () => 999;
    }
  }
  draw(text) {
    const _rectangle = this.options.getRectangle();
    this.g = createG();
    this.foreignObject = createForeignObject(_rectangle.x, _rectangle.y, _rectangle.width, _rectangle.height);
    this.g.append(this.foreignObject);
    this.g.classList.add("text");
    const props = {
      board: this.board,
      text,
      textPlugins: this.options.textPlugins,
      onChange: (data) => {
        if (data.operations.some((op) => !Operation.isSelectionOperation(op))) {
          const { width: newWidth, height: newHeight } = this.getSize();
          this.options.onChange && this.options.onChange({ ...data, width: newWidth, height: newHeight });
          MERGING.set(this.board, true);
        }
      },
      afterInit: (editor) => {
        this.editor = editor;
      },
      onComposition: (event) => {
        if (event.type === "compositionend") {
          clearElementSizeCache(this.board, this.editor.children[0]);
          return;
        }
        const fakeRoot = buildCompositionData(this.editor, event.data);
        if (fakeRoot) {
          const sizeData = this.getSize(fakeRoot.children[0]);
          updateElementSizeCache(this.board, this.editor.children[0], sizeData);
          this.options.onChange && this.options.onChange({ ...sizeData });
          MERGING.set(this.board, true);
        }
      }
    };
    this.textComponentRef = this.board.renderText(this.foreignObject, props);
  }
  updateRectangleWidth(width) {
    updateForeignObjectWidth(this.g, width);
  }
  updateAngle(centerPoint, angle = 0) {
    setAngleForG(this.g, centerPoint, angle);
  }
  updateRectangle(rectangle) {
    const { x, y, width, height } = rectangle || this.options.getRectangle();
    updateForeignObject(this.g, width, height, x, y);
  }
  updateText(newText) {
    const props = {
      text: newText
    };
    this.textComponentRef.update(props);
  }
  edit(callback, exitEdit) {
    this.isEditing = true;
    IS_TEXT_EDITABLE.set(this.board, true);
    const props = {
      readonly: false
    };
    this.textComponentRef.update(props);
    Transforms2.select(this.editor, [0]);
    const mousedown$ = fromEvent(document, "mousedown").subscribe((event) => {
      const point = toViewBoxPoint(this.board, toHostPoint(this.board, event.x, event.y));
      const textRec = this.options.getRenderRectangle ? this.options.getRenderRectangle() : this.options.getRectangle();
      const clickInText = RectangleClient.isHit(RectangleClient.getRectangleByPoints([point, point]), textRec);
      const isAttached = event.target.closest(".plait-board-attached");
      if (!clickInText && !isAttached) {
        timer(0).subscribe(() => {
          exitCallback();
        });
      }
    });
    const keydown$ = fromEvent(document, "keydown").subscribe((event) => {
      if (event.isComposing) {
        return;
      }
      if (event.key === "Escape" || event.key === "Tab" || (exitEdit ? exitEdit(event) : false)) {
        event.preventDefault();
        event.stopPropagation();
        exitCallback();
        return;
      }
    });
    const exitCallback = () => {
      if (this.isEditing) {
        this.updateRectangle();
        mousedown$.unsubscribe();
        keydown$.unsubscribe();
        IS_TEXT_EDITABLE.set(this.board, false);
        MERGING.set(this.board, false);
        callback && callback();
        const props2 = {
          readonly: true
        };
        this.textComponentRef.update(props2);
        this.isEditing = false;
        this.exitCallback = void 0;
      }
    };
    this.exitCallback = exitCallback;
    return exitCallback;
  }
  destroy() {
    var _a, _b;
    (_a = this.g) == null ? void 0 : _a.remove();
    (_b = this.textComponentRef) == null ? void 0 : _b.destroy();
    this.exitCallback && this.exitCallback();
  }
};
var buildCompositionData = (editor, data) => {
  if (editor.selection && Range.isCollapsed(editor.selection)) {
    const [textNode, textPath] = Editor.node(editor, editor.selection);
    const offset = editor.selection.anchor.offset;
    const clonedElement = JSON.parse(JSON.stringify(editor.children[0]));
    const root = { children: [clonedElement] };
    const newTextString = textNode.text.slice(0, offset + 1) + data + textNode.text.slice(offset + 1);
    const clonedTextNode = Node.get(root, textPath);
    clonedTextNode.text = newTextString;
    return root;
  }
  return null;
};
var withText = (board) => {
  const newBoard = board;
  newBoard.renderText = (container, props) => {
    throw new Error("No implementation for renderText method.");
  };
  return newBoard;
};
var Alignment;
(function(Alignment2) {
  Alignment2["left"] = "left";
  Alignment2["center"] = "center";
  Alignment2["right"] = "right";
})(Alignment || (Alignment = {}));
var withImage = (board) => {
  const newBoard = board;
  newBoard.renderImage = (container, props) => {
    throw new Error("No implementation for renderImage method.");
  };
  return newBoard;
};

export {
  BASE,
  PRIMARY_COLOR,
  RESIZE_HANDLE_DIAMETER,
  WithTextPluginKey,
  DEFAULT_ROUTE_MARGIN,
  TRANSPARENT,
  ROTATE_HANDLE_DISTANCE_TO_ELEMENT,
  ROTATE_HANDLE_SIZE,
  DEFAULT_FONT_FAMILY,
  DEFAULT_FILL,
  MediaKeys,
  PICTURE_ACCEPTED_UPLOAD_SIZE,
  acceptImageTypes,
  WithCommonPluginKey,
  ResizeHandle,
  StrokeStyle,
  Generator,
  hasAfterDraw,
  drawHandle,
  drawFillPrimaryHandle,
  drawPrimaryHandle,
  drawRotateHandle,
  createActiveGenerator,
  ActiveGenerator,
  getResizeHandleByIndex,
  getIndexByResizeHandle,
  getSymmetricHandleIndex,
  getRotatedResizeCursorClassByAngle,
  getRectangleResizeHandleRefs,
  getResizeHandlePointByIndex,
  IS_RESIZING,
  isResizing,
  isResizingByCondition,
  addResizing,
  removeResizing,
  isEdgeHandle,
  isCornerHandle,
  resetPointsAfterResize,
  hasMoreThanOnePoint,
  hasResizeHandle,
  getUnitVectorByPointAndPoint,
  getPointByVectorComponent,
  getPointByVectorDirectionComponent,
  rotateVectorAnti90,
  rotateVector,
  isPointOnSegment,
  getCrossingPointsBetweenPointAndSegment,
  getPointOnPolyline,
  calculatePolylineLength,
  getRatioByPoint,
  removeDuplicatePoints,
  simplifyOrthogonalPoints,
  getExtendPoint,
  getOppositeDirection,
  getDirectionByPointOfRectangle,
  getDirectionByVector,
  getDirectionBetweenPointAndPoint,
  getDirectionFactor,
  getDirectionFactorByDirectionComponent,
  getPoints,
  isVirtualKey,
  isExpandHotkey,
  isTabHotkey,
  isEnterHotkey,
  isSpaceHotkey,
  isDelete,
  BoardCreationMode,
  getCreationMode,
  setCreationMode,
  isDndMode,
  isDrawingMode,
  getTextManages,
  getFirstTextManage,
  getTextEditorsByElement,
  getFirstTextEditor,
  findFirstTextEditor,
  getElementsText,
  getTextEditors,
  getEditingTextEditor,
  buildText,
  getLineHeightByFontSize,
  selectImage,
  buildImage,
  getElementOfFocusedImage,
  addElementOfFocusedImage,
  removeElementOfFocusedImage,
  PriorityQueue,
  AStar,
  PointNode,
  PointGraph,
  generateElbowLineRoute,
  routeAdjust,
  getGraphPoints,
  createGraph,
  reduceRouteMargin,
  getNextPoint,
  getSourceAndTargetOuterRectangle,
  isSourceAndTargetIntersect,
  memorizeLatest,
  getMemorizedLatest,
  IS_ROTATING,
  isRotating,
  addRotating,
  removeRotating,
  getElementArea,
  sortElementsByArea,
  isFilled,
  animate,
  getTimestamp,
  linear,
  getStrokeLineDash,
  buildClipboardData,
  insertClipboardData,
  moveXOfPoint,
  moveYOfPoint,
  getDirectionByIndex,
  getXDistanceBetweenPoint,
  FOREIGN_OBJECT_IMAGE_CLASS_NAME,
  ImageGenerator,
  setProperty,
  PropertyTransforms,
  alignTop,
  alignBottom,
  alignLeft,
  alignHorizontalCenter,
  alignVerticalCenter,
  alignRight,
  distributeHorizontal,
  distributeVertical,
  AlignTransform,
  normalizeShapePoints,
  withResize,
  PlaitCommonElementRef,
  CommonElementFlavour,
  GroupComponent,
  withGroup,
  ImageBaseComponent,
  getElementSize,
  updateElementSizeCache,
  clearElementSizeCache,
  measureElement,
  TextManage,
  buildCompositionData,
  withText,
  Alignment,
  withImage
};
//# sourceMappingURL=chunk-NNVG7YTJ.js.map
