{
  "version": 3,
  "sources": ["../../../../@plait-board/mermaid-to-drawnix/dist/constants.js", "../../../../@plait-board/mermaid-to-drawnix/dist/converter/GraphConverter.js", "../../../../@plait-board/mermaid-to-drawnix/dist/interfaces.js", "../../../../@plait-board/mermaid-to-drawnix/dist/markdown-to-text.js", "../../../../@plait-board/mermaid-to-drawnix/dist/converter/helpers.js", "../../../../@plait-board/mermaid-to-drawnix/dist/converter/types/flowchart.js", "../../../../@plait-board/mermaid-to-drawnix/dist/converter/transformToDrawnixElement.js", "../../../../@plait-board/mermaid-to-drawnix/dist/converter/types/sequence.js", "../../../../@plait-board/mermaid-to-drawnix/dist/converter/types/class.js", "../../../../@plait-board/mermaid-to-drawnix/dist/converter/types/graphImage.js", "../../../../@plait-board/mermaid-to-drawnix/dist/graphToDrawnix.js", "../../../../mermaid/dist/mermaid.core.mjs", "../../../../@plait-board/mermaid-to-drawnix/dist/utils.js", "../../../../@plait-board/mermaid-to-drawnix/dist/parser/flowchart.js", "../../../../@plait-board/mermaid-to-drawnix/dist/elementSkeleton.js", "../../../../@plait-board/mermaid-to-drawnix/dist/parser/sequence.js", "../../../../@plait-board/mermaid-to-drawnix/dist/parser/class.js", "../../../../@plait-board/mermaid-to-drawnix/dist/parseMermaid.js", "../../../../@plait-board/mermaid-to-drawnix/dist/index.js"],
  "sourcesContent": ["export const DEFAULT_FONT_SIZE = 20;\nexport const SVG_TO_SHAPE_MAPPER = {\n    rect: \"rectangle\",\n    circle: \"ellipse\",\n};\n// visit https://mermaid.js.org/schemas/config.schema.json for default schema\nexport const MERMAID_CONFIG = {\n    startOnLoad: false,\n    flowchart: { curve: \"linear\" },\n    themeVariables: {\n        fontSize: `${DEFAULT_FONT_SIZE}px`,\n    },\n    maxEdges: 500,\n    maxTextSize: 50000,\n};\n", "import { DEFAULT_FONT_SIZE } from \"../constants.js\";\nexport class GraphConverter {\n    constructor({ converter, }) {\n        this.convert = (graph, config) => {\n            return this.converter(graph, {\n                ...config,\n                fontSize: config.fontSize || DEFAULT_FONT_SIZE,\n            });\n        };\n        this.converter = converter;\n    }\n}\n", "export var VERTEX_TYPE;\n(function (VERTEX_TYPE) {\n    VERTEX_TYPE[\"ROUND\"] = \"round\";\n    VERTEX_TYPE[\"STADIUM\"] = \"stadium\";\n    VERTEX_TYPE[\"DOUBLECIRCLE\"] = \"doublecircle\";\n    VERTEX_TYPE[\"CIRCLE\"] = \"circle\";\n    VERTEX_TYPE[\"DIAMOND\"] = \"diamond\";\n})(VERTEX_TYPE || (VERTEX_TYPE = {}));\nexport var LABEL_STYLE_PROPERTY;\n(function (LABEL_STYLE_PROPERTY) {\n    LABEL_STYLE_PROPERTY[\"COLOR\"] = \"color\";\n})(LABEL_STYLE_PROPERTY || (LABEL_STYLE_PROPERTY = {}));\nexport var CONTAINER_STYLE_PROPERTY;\n(function (CONTAINER_STYLE_PROPERTY) {\n    CONTAINER_STYLE_PROPERTY[\"FILL\"] = \"fill\";\n    CONTAINER_STYLE_PROPERTY[\"STROKE\"] = \"stroke\";\n    CONTAINER_STYLE_PROPERTY[\"STROKE_WIDTH\"] = \"stroke-width\";\n    CONTAINER_STYLE_PROPERTY[\"STROKE_DASHARRAY\"] = \"stroke-dasharray\";\n})(CONTAINER_STYLE_PROPERTY || (CONTAINER_STYLE_PROPERTY = {}));\n", "/**\n * @function removeMarkdown\n *\n * @description\n * Parse the markdown and returns a string\n *\n * @param markdown - The markdown string to parse\n * @param options - The options for the function\n *\n * @returns The parsed plain text\n */\nexport const removeMarkdown = (markdown, options = {\n    listUnicodeChar: \"\",\n}) => {\n    options = options || {};\n    options.listUnicodeChar = options.hasOwnProperty(\"listUnicodeChar\")\n        ? options.listUnicodeChar\n        : false;\n    options.stripListLeaders = options.hasOwnProperty(\"stripListLeaders\")\n        ? options.stripListLeaders\n        : true;\n    options.gfm = options.hasOwnProperty(\"gfm\") ? options.gfm : true;\n    options.useImgAltText = options.hasOwnProperty(\"useImgAltText\")\n        ? options.useImgAltText\n        : true;\n    options.preserveLinks = options.hasOwnProperty(\"preserveLinks\")\n        ? options.preserveLinks\n        : false;\n    let output = markdown || \"\";\n    // Remove horizontal rules (stripListHeaders conflict with this rule, which is why it has been moved to the top)\n    output = output.replace(/^(-\\s*?|\\*\\s*?|_\\s*?){3,}\\s*$/gm, \"\");\n    try {\n        if (options.stripListLeaders) {\n            if (options.listUnicodeChar)\n                output = output.replace(/^([\\s\\t]*)([\\*\\-\\+]|\\d+\\.)\\s+/gm, options.listUnicodeChar + \" $1\");\n            else\n                output = output.replace(/^([\\s\\t]*)([\\*\\-\\+]|\\d+\\.)\\s+/gm, \"$1\");\n        }\n        if (options.gfm) {\n            output = output\n                // Header\n                .replace(/\\n={2,}/g, \"\\n\")\n                // Fenced codeblocks\n                .replace(/~{3}.*\\n/g, \"\")\n                // Strikethrough\n                .replace(/~~/g, \"\")\n                // Fenced codeblocks\n                .replace(/`{3}.*\\n/g, \"\");\n        }\n        if (options.preserveLinks) {\n            // Remove inline links while preserving the links\n            output = output.replace(/\\[(.*?)\\][\\[\\(](.*?)[\\]\\)]/g, \"$1 ($2)\");\n        }\n        output = output\n            // Remove HTML tags\n            .replace(/<[^>]*>/g, \"\")\n            // Remove setext-style headers\n            .replace(/^[=\\-]{2,}\\s*$/g, \"\")\n            // Remove footnotes?\n            .replace(/\\[\\^.+?\\](\\: .*?$)?/g, \"\")\n            .replace(/\\s{0,2}\\[.*?\\]: .*?$/g, \"\")\n            // Remove images\n            .replace(/\\!\\[(.*?)\\][\\[\\(].*?[\\]\\)]/g, options.useImgAltText ? \"$1\" : \"\")\n            // Remove inline links\n            .replace(/\\[(.*?)\\][\\[\\(].*?[\\]\\)]/g, \"$1\")\n            // Remove blockquotes\n            .replace(/^\\s{0,3}>\\s?/g, \"\")\n            .replace(/(^|\\n)\\s{0,3}>\\s?/g, \"\\n\\n\")\n            // Remove reference-style links?\n            .replace(/^\\s{1,2}\\[(.*?)\\]: (\\S+)( \".*?\")?\\s*$/g, \"\")\n            // Remove atx-style headers\n            .replace(/^(\\n)?\\s{0,}#{1,6}\\s+| {0,}(\\n)?\\s{0,}#{0,} {0,}(\\n)?\\s{0,}$/gm, \"$1$2$3\")\n            // Remove emphasis (repeat the line to remove double emphasis)\n            .replace(/([\\*_]{1,3})(\\S.*?\\S{0,1})\\1/g, \"$2\")\n            .replace(/([\\*_]{1,3})(\\S.*?\\S{0,1})\\1/g, \"$2\")\n            // Remove code blocks\n            .replace(/(`{3,})(.*?)\\1/gm, \"$2\")\n            // Remove inline code\n            .replace(/`(.+?)`/g, \"$1\")\n            // Replace two or more newlines with exactly two? Not entirely sure this belongs here...\n            .replace(/\\n{2,}/g, \"\\n\\n\");\n    }\n    catch (e) {\n        console.error(e);\n        return markdown;\n    }\n    return output;\n};\n", "import { CONTAINER_STYLE_PROPERTY, LABEL_STYLE_PROPERTY, } from \"../interfaces.js\";\nimport { RectangleClient } from \"@plait/core\";\nimport { ArrowLineMarkerType, } from \"@plait/draw\";\nimport { StrokeStyle } from \"@plait/common\";\nimport { removeMarkdown } from \"../markdown-to-text.js\";\n/**\n * Convert mermaid edge type to Drawnix arrow type\n */\nconst MERMAID_EDGE_TYPE_MAPPER = {\n    arrow_point: {\n        source: { marker: ArrowLineMarkerType.none },\n        target: { marker: ArrowLineMarkerType.arrow },\n    },\n    arrow_circle: {\n        source: { marker: ArrowLineMarkerType.none },\n        target: { marker: ArrowLineMarkerType.arrow },\n    },\n    arrow_cross: {\n        source: { marker: ArrowLineMarkerType.none },\n        target: { marker: ArrowLineMarkerType.arrow },\n    },\n    arrow_open: {\n        source: { marker: ArrowLineMarkerType.none },\n        target: { marker: ArrowLineMarkerType.none },\n    },\n    double_arrow_circle: {\n        source: { marker: ArrowLineMarkerType.arrow },\n        target: { marker: ArrowLineMarkerType.arrow },\n    },\n    double_arrow_cross: {\n        source: { marker: ArrowLineMarkerType.arrow },\n        target: { marker: ArrowLineMarkerType.arrow },\n    },\n    double_arrow_point: {\n        source: { marker: ArrowLineMarkerType.arrow },\n        target: { marker: ArrowLineMarkerType.arrow },\n    },\n};\nexport const computeDrawnixArrowType = (mermaidArrowType) => {\n    return MERMAID_EDGE_TYPE_MAPPER[mermaidArrowType];\n};\nexport const computeDrawnixArrowStyle = (edge) => {\n    const arrowStyle = {};\n    if (edge.stroke === \"dotted\") {\n        arrowStyle.strokeStyle = StrokeStyle.dotted;\n    }\n    return arrowStyle;\n};\n// Get text from graph elements, fallback markdown to text\nexport const getText = (element) => {\n    let text = element.text;\n    if (element.labelType === \"markdown\") {\n        text = removeMarkdown(element.text);\n    }\n    // 处理换行符\n    text = text.replace(/<br\\/?>/g, '\\n');\n    text = text.replace(/\\\\n/g, '\\n');\n    // 移除 Mermaid 支持的格式标签\n    const tagsToRemove = ['sub', 'small', 'i'];\n    tagsToRemove.forEach(tag => {\n        text = text.replace(new RegExp(`<${tag}>|</${tag}>`, 'g'), '');\n    });\n    return removeFontAwesomeIcons(text);\n};\n/**\n * Remove font awesome icons support from text\n */\nconst removeFontAwesomeIcons = (input) => {\n    const fontAwesomeRegex = /\\s?(fa|fab):[a-zA-Z0-9-]+/g;\n    return input.replace(fontAwesomeRegex, \"\");\n};\n/**\n * Compute style for vertex\n */\nexport const computeDrawnixVertexStyle = (style) => {\n    const plaitElementProperty = {};\n    Object.keys(style).forEach((property) => {\n        switch (property) {\n            case CONTAINER_STYLE_PROPERTY.FILL: {\n                plaitElementProperty.fill = style[property];\n                break;\n            }\n            case CONTAINER_STYLE_PROPERTY.STROKE: {\n                plaitElementProperty.strokeColor = style[property];\n                break;\n            }\n            case CONTAINER_STYLE_PROPERTY.STROKE_WIDTH: {\n                plaitElementProperty.strokeWidth = Number(style[property]?.split(\"px\")[0]);\n                break;\n            }\n            case CONTAINER_STYLE_PROPERTY.STROKE_DASHARRAY: {\n                plaitElementProperty.strokeStyle = StrokeStyle.dashed;\n                break;\n            }\n        }\n    });\n    return plaitElementProperty;\n};\n/**\n * Compute style for label\n */\nexport const computeDrawnixTextStyle = (style) => {\n    const textProperty = {};\n    Object.keys(style).forEach((property) => {\n        switch (property) {\n            case LABEL_STYLE_PROPERTY.COLOR: {\n                textProperty.color = style[property];\n                break;\n            }\n        }\n    });\n    return textProperty;\n};\nexport const getRectangleByMermaidElement = (vertex) => {\n    return vertex;\n};\nexport const normalizeText = (text) => {\n    return text.replace(/\\\\n/g, \"\\n\");\n};\nexport const getHitConnectionFromConnectionPoint = (connectionPoint, hitElement) => {\n    let rectangle = RectangleClient.getRectangleByPoints(hitElement.points);\n    return [(connectionPoint[0] - rectangle.x) / rectangle.width, (connectionPoint[1] - rectangle.y) / rectangle.height];\n};\n", "import { GraphConverter } from \"../GraphConverter.js\";\nimport { getText, computeDrawnixTextStyle, computeDrawnixArrowType, getRectangleByMermaidElement, computeDrawnixVertexStyle, computeDrawnixArrowStyle, getHitConnectionFromConnectionPoint, } from \"../helpers.js\";\nimport { VERTEX_TYPE } from \"../../interfaces.js\";\nimport { createGeometryElement, BasicShapes, createArrowLineElement, ArrowLineShape, DefaultLineStyle, getTextShapeProperty, FlowchartSymbols, } from \"@plait/draw\";\nimport { createGroup, RectangleClient } from \"@plait/core\";\nimport { buildText, DEFAULT_FONT_FAMILY, measureElement } from \"@plait/common\";\nimport { DEFAULT_FONT_SIZE as PLAIT_DEFAULT_FONT_SIZE } from \"@plait/text-plugins\";\nconst computeGroupIds = (graph) => {\n    // Parse the diagram into a tree for rendering and grouping\n    const tree = {};\n    graph.subGraphs.map((subGraph) => {\n        subGraph.nodeIds.forEach((nodeId) => {\n            tree[subGraph.id] = {\n                id: subGraph.id,\n                parent: null,\n                isLeaf: false,\n            };\n            tree[nodeId] = {\n                id: nodeId,\n                parent: subGraph.id,\n                isLeaf: graph.vertices[nodeId] !== undefined,\n            };\n        });\n    });\n    const mapper = {};\n    [...Object.keys(graph.vertices), ...graph.subGraphs.map((c) => c.id)].forEach((id) => {\n        if (!tree[id]) {\n            return;\n        }\n        let curr = tree[id];\n        const groupIds = [];\n        if (!curr.isLeaf) {\n            groupIds.push(`subgraph_group_${curr.id}`);\n        }\n        while (true) {\n            if (curr.parent) {\n                groupIds.push(`subgraph_group_${curr.parent}`);\n                curr = tree[curr.parent];\n            }\n            else {\n                break;\n            }\n        }\n        mapper[id] = groupIds;\n    });\n    return {\n        getGroupIds: (elementId) => {\n            return mapper[elementId] || [];\n        },\n        getParentId: (elementId) => {\n            return tree[elementId] ? tree[elementId].parent : null;\n        },\n    };\n};\nexport const flowchartToDrawnixConverter = new GraphConverter({\n    converter: (graph, config) => {\n        const elements = [];\n        const mermaidIdToElementMap = {};\n        const mermaidGroupIdToElementMap = {};\n        const { getGroupIds, getParentId } = computeGroupIds(graph);\n        // SubGraphs\n        graph.subGraphs.reverse().forEach((subGraph) => {\n            const groupIds = getGroupIds(subGraph.id);\n            groupIds.forEach((groupId, index) => {\n                if (!mermaidGroupIdToElementMap[groupId]) {\n                    const groupElement = createGroup();\n                    mermaidGroupIdToElementMap[groupId] = groupElement;\n                }\n                if (index > 0 && mermaidGroupIdToElementMap[groupId]) {\n                    const childGroup = mermaidGroupIdToElementMap[groupIds[index - 1]];\n                    childGroup.groupId = mermaidGroupIdToElementMap[groupId].id;\n                }\n            });\n            const text = buildText(getText(subGraph), undefined);\n            const textSize = getTextShapeProperty({}, text);\n            const points = RectangleClient.getPoints(RectangleClient.getRectangleByCenterPoint([\n                subGraph.x + subGraph.width / 2,\n                subGraph.y + 4 + textSize.height / 2,\n            ], textSize.width, textSize.height));\n            const textElement = createGeometryElement(BasicShapes.text, points, text);\n            let containerElement = createGeometryElement(BasicShapes.rectangle, RectangleClient.getPoints(getRectangleByMermaidElement(subGraph)), \"\", { fill: \"#ffffde\", strokeColor: \"#aaaa33\", strokeWidth: 1 });\n            containerElement.groupId = mermaidGroupIdToElementMap[groupIds[0]].id;\n            elements.push(containerElement);\n            mermaidIdToElementMap[subGraph.id] = containerElement;\n            textElement.groupId = mermaidGroupIdToElementMap[groupIds[0]].id;\n            elements.push(textElement);\n            groupIds.forEach((groupId) => {\n                const existing = elements.findIndex((searchElement) => {\n                    return searchElement.id === mermaidGroupIdToElementMap[groupId]?.id;\n                }) >= 0;\n                if (!existing) {\n                    elements.push(mermaidGroupIdToElementMap[groupId]);\n                }\n            });\n        });\n        // Vertices\n        Object.values(graph.vertices).forEach((vertex) => {\n            if (!vertex) {\n                return;\n            }\n            const groupIds = getGroupIds(vertex.id);\n            // Compute custom style\n            const elementStyle = computeDrawnixVertexStyle(vertex.containerStyle);\n            const textStyle = computeDrawnixTextStyle(vertex.labelStyle);\n            const verticesText = buildText(getText(vertex), undefined, textStyle);\n            const textSize = measureElement(null, verticesText, {\n                fontFamily: DEFAULT_FONT_FAMILY,\n                fontSize: PLAIT_DEFAULT_FONT_SIZE,\n            });\n            const styleOptions = {\n                fill: \"#ECECFF\",\n                strokeColor: \"#9370DB\",\n                strokeWidth: 1,\n                ...elementStyle,\n            };\n            let geometryElement = createGeometryElement(BasicShapes.rectangle, RectangleClient.getPoints(getRectangleByMermaidElement(vertex)), buildText(getText(vertex), undefined, textStyle), {\n                ...styleOptions,\n            }, {\n                textHeight: textSize.height,\n            });\n            switch (vertex.type) {\n                case VERTEX_TYPE.ROUND: {\n                    geometryElement.shape = BasicShapes.roundRectangle;\n                    break;\n                }\n                case VERTEX_TYPE.STADIUM: {\n                    geometryElement.shape = FlowchartSymbols.terminal;\n                    break;\n                }\n                case VERTEX_TYPE.DOUBLECIRCLE: {\n                    const CIRCLE_MARGIN = 5;\n                    const innerRectangle = RectangleClient.inflate(getRectangleByMermaidElement(vertex), -CIRCLE_MARGIN * 2);\n                    const innerCircle = createGeometryElement(BasicShapes.ellipse, RectangleClient.getPoints(innerRectangle), buildText(getText(vertex)), {\n                        ...styleOptions,\n                    });\n                    geometryElement = { ...geometryElement, shape: BasicShapes.ellipse };\n                    geometryElement.text = buildText(\"\");\n                    elements.push(geometryElement);\n                    elements.push(innerCircle);\n                    mermaidIdToElementMap[vertex.id] = geometryElement;\n                    const groupElement = groupIds[0] && mermaidGroupIdToElementMap[groupIds[0]];\n                    if (groupElement) {\n                        geometryElement.groupId = groupElement.id;\n                    }\n                    return;\n                }\n                case VERTEX_TYPE.CIRCLE: {\n                    geometryElement.shape = BasicShapes.ellipse;\n                    break;\n                }\n                case VERTEX_TYPE.DIAMOND: {\n                    geometryElement.shape = BasicShapes.diamond;\n                    break;\n                }\n            }\n            elements.push(geometryElement);\n            mermaidIdToElementMap[vertex.id] = geometryElement;\n            const groupElement = groupIds[0] && mermaidGroupIdToElementMap[groupIds[0]];\n            if (groupElement) {\n                geometryElement.groupId = groupElement.id;\n            }\n        });\n        // Edges\n        graph.edges.forEach((edge) => {\n            let groupIds = [];\n            const startParentId = getParentId(edge.start);\n            const endParentId = getParentId(edge.end);\n            if (startParentId && startParentId === endParentId) {\n                groupIds = getGroupIds(startParentId);\n            }\n            // Get arrow position data\n            const { startX, startY, reflectionPoints } = edge;\n            // Calculate arrow's points\n            const arrowType = computeDrawnixArrowType(edge.type);\n            const points = reflectionPoints.map((point) => [point.x, point.y]);\n            const sourceHandle = {\n                marker: arrowType.source.marker,\n            };\n            const targetHandle = {\n                marker: arrowType.target.marker,\n            };\n            const sourceElement = mermaidIdToElementMap[edge.start];\n            if (sourceElement) {\n                sourceHandle.boundId = sourceElement.id;\n                sourceHandle.connection = getHitConnectionFromConnectionPoint(points[0], sourceElement);\n            }\n            const targetElement = mermaidIdToElementMap[edge.end];\n            if (targetElement) {\n                targetHandle.boundId = targetElement.id;\n                targetHandle.connection = getHitConnectionFromConnectionPoint(points[points.length - 1], targetElement);\n            }\n            const texts = [];\n            if (edge.text) {\n                const textValue = buildText(getText(edge));\n                const { width, height } = measureElement(null, textValue, {\n                    fontSize: PLAIT_DEFAULT_FONT_SIZE,\n                    fontFamily: DEFAULT_FONT_FAMILY,\n                });\n                texts.push({\n                    position: 0.5,\n                    text: buildText(getText(edge)),\n                    width,\n                    height,\n                });\n            }\n            const arrowStyle = computeDrawnixArrowStyle(edge);\n            const arrowOptions = {\n                strokeWidth: DefaultLineStyle.strokeWidth,\n                ...arrowStyle,\n            };\n            const arrowLineElement = createArrowLineElement(ArrowLineShape.straight, [...points], {\n                ...sourceHandle,\n            }, {\n                ...targetHandle,\n            }, texts, { ...arrowOptions });\n            elements.push(arrowLineElement);\n            const groupElement = groupIds[0] && mermaidGroupIdToElementMap[groupIds[0]];\n            if (groupElement) {\n                arrowLineElement.groupId = groupElement.id;\n            }\n        });\n        return {\n            elements,\n        };\n    },\n});\n", "import { buildText, DEFAULT_FONT_FAMILY, measureElement, StrokeStyle, } from \"@plait/common\";\nimport { getRectangleByMermaidElement, normalizeText } from \"./helpers.js\";\nimport { ArrowLineMarkerType, ArrowLineShape, BasicShapes, createArrowLineElement, createGeometryElement, getTextShapeProperty, ShapeDefaultSpace, } from \"@plait/draw\";\nimport { createGroup, RectangleClient } from \"@plait/core\";\nimport { Node as SlateNode } from \"slate\";\nimport { DEFAULT_FONT_SIZE as PLAIT_DEFAULT_FONT_SIZE } from \"@plait/text-plugins\";\nexport const transformToDrawnixLineElement = (element, mermaidGroupIdToElementMap, config) => {\n    const points = [\n        [element.startX, element.startY],\n        [element.endX, element.endY],\n    ];\n    const arrowOptions = {\n        strokeColor: element.strokeColor ||\n            \"hsl(259.6261682243, 59.7765363128%, 87.9019607843%)\",\n        strokeWidth: element.strokeWidth || 2,\n        strokeStyle: (element.strokeStyle || StrokeStyle.solid),\n    };\n    const line = createArrowLineElement(ArrowLineShape.straight, [...points], {\n        marker: ArrowLineMarkerType.none,\n    }, {\n        marker: ArrowLineMarkerType.none,\n    }, [], { ...arrowOptions });\n    if (element.groupId) {\n        let groupElement = mermaidGroupIdToElementMap[element.groupId];\n        if (!groupElement) {\n            groupElement = createGroup();\n            mermaidGroupIdToElementMap[element.groupId] = groupElement;\n        }\n        line.groupId = groupElement.id;\n    }\n    return line;\n};\nexport const transformToDrawnixArrowElement = (element, mermaidGroupIdToElementMap, config) => {\n    let points = [\n        [element.startX, element.startY],\n        [element.endX, element.endY],\n    ];\n    if (element.points) {\n        points = element.points.map((point) => [\n            element.startX + point[0],\n            element.startY + point[1],\n        ]);\n    }\n    const arrowOptions = {\n        strokeColor: (element.strokeColor &&\n            element.strokeColor !== \"none\" &&\n            element.strokeColor) ||\n            \"#000\",\n        strokeWidth: element.strokeWidth || 1,\n        strokeStyle: (element.strokeStyle || StrokeStyle.solid),\n    };\n    const arrowText = buildText(normalizeText(element?.label?.text || \"\"), undefined);\n    const texts = [];\n    if (SlateNode.string(arrowText).trim().length > 0) {\n        const textSize = measureElement(null, arrowText, {\n            fontFamily: DEFAULT_FONT_FAMILY,\n            fontSize: PLAIT_DEFAULT_FONT_SIZE,\n        });\n        texts.push({\n            position: 0.5,\n            text: arrowText,\n            width: textSize.width,\n            height: textSize.height,\n        });\n    }\n    const arrow = createArrowLineElement(config.arrowLineShape || ArrowLineShape.curve, [...points], {\n        marker: element.startArrowhead\n            ? ArrowLineMarkerType.arrow\n            : ArrowLineMarkerType.none,\n    }, {\n        marker: element.endArrowhead\n            ? ArrowLineMarkerType.arrow\n            : ArrowLineMarkerType.none,\n    }, texts, { ...arrowOptions });\n    if (element.groupId) {\n        let groupElement = mermaidGroupIdToElementMap[element.groupId];\n        if (!groupElement) {\n            groupElement = createGroup();\n            mermaidGroupIdToElementMap[element.groupId] = groupElement;\n        }\n        arrow.groupId = groupElement.id;\n    }\n    return arrow;\n};\nexport const transformToDrawnixRectangleElement = (element, mermaidGroupIdToElementMap, config) => {\n    let extraProps = {};\n    if (element.type === \"rectangle\" && element.subtype === \"activation\") {\n        extraProps = {\n            fill: \"#e9ecef\",\n            strokeStyle: StrokeStyle.solid,\n        };\n    }\n    const styleOptions = {\n        strokeStyle: (element?.strokeStyle || StrokeStyle.solid),\n        strokeWidth: element?.strokeWidth || 1,\n        strokeColor: element?.strokeColor ||\n            \"hsl(259.6261682243, 59.7765363128%, 87.9019607843%)\",\n        fill: element?.bgColor || \"#ECECFF\",\n        ...extraProps,\n    };\n    const textStyle = {\n        color: element.label?.color || \"#000\",\n    };\n    const verticesText = buildText(normalizeText(element?.label?.text || \"\"), undefined, textStyle);\n    const textSize = measureElement(null, verticesText, {\n        fontFamily: DEFAULT_FONT_FAMILY,\n        fontSize: PLAIT_DEFAULT_FONT_SIZE,\n    });\n    const rectangle = getRectangleByMermaidElement({\n        ...element,\n        width: element.width ||\n            textSize.width +\n                ShapeDefaultSpace.rectangleAndText * 2 +\n                styleOptions.strokeWidth * 2,\n    });\n    const container = createGeometryElement(element.type, RectangleClient.getPoints(rectangle), verticesText, {\n        ...styleOptions,\n    }, {\n        textHeight: textSize.height,\n    });\n    if (element.groupId) {\n        let groupElement = mermaidGroupIdToElementMap[element.groupId];\n        if (!groupElement) {\n            groupElement = createGroup();\n            mermaidGroupIdToElementMap[element.groupId] = groupElement;\n        }\n        container.groupId = groupElement.id;\n    }\n    return container;\n};\nexport const transformToDrawnixTextElement = (element, mermaidGroupIdToElementMap, config) => {\n    const text = buildText(normalizeText(element.text || \"\"), undefined);\n    const textSize = getTextShapeProperty({}, text);\n    const textRectangle = RectangleClient.getRectangleByCenterPoint([element.x + textSize.width / 2, element.y], textSize.width, textSize.height);\n    const textElement = createGeometryElement(BasicShapes.text, RectangleClient.getPoints(textRectangle), text, {}, {\n        textHeight: textSize.height,\n    });\n    if (element.groupId) {\n        let groupElement = mermaidGroupIdToElementMap[element.groupId];\n        if (!groupElement) {\n            groupElement = createGroup();\n            mermaidGroupIdToElementMap[element.groupId] = groupElement;\n        }\n        textElement.groupId = groupElement.id;\n    }\n    return textElement;\n};\nexport const transformToDrawnixGroupElement = (childrenElements, text, options = {}) => {\n    const childrenRectangle = RectangleClient.getBoundingRectangle(childrenElements.map((ele) => RectangleClient.getRectangleByPoints(ele.points)));\n    const PADDING = 60;\n    const groupRectangle = RectangleClient.inflate(childrenRectangle, PADDING);\n    const containerElement = createGeometryElement(BasicShapes.rectangle, [...RectangleClient.getPoints(groupRectangle)], \"\", { strokeWidth: 1, ...options });\n    const slateTextElement = buildText(text, undefined);\n    const textSize = getTextShapeProperty({}, text);\n    const points = RectangleClient.getPoints(RectangleClient.getRectangleByCenterPoint([\n        groupRectangle.x + groupRectangle.width / 2,\n        groupRectangle.y + 4 + textSize.height / 2,\n    ], textSize.width, textSize.height));\n    const textElement = createGeometryElement(BasicShapes.text, points, slateTextElement);\n    return { textElement, containerElement };\n};\n", "import { GraphConverter } from \"../GraphConverter.js\";\nimport { createGroup, PlaitGroupElement, RectangleClient, } from \"@plait/core\";\nimport { transformToDrawnixArrowElement, transformToDrawnixRectangleElement, transformToDrawnixLineElement, transformToDrawnixTextElement, transformToDrawnixGroupElement, } from \"../transformToDrawnixElement.js\";\nexport const sequenceToDrawnixConvertor = new GraphConverter({\n    converter: (chart, config) => {\n        const elements = [];\n        const activations = [];\n        const mermaidGroupIdToElementMap = {};\n        Object.values(chart.nodes).forEach((node) => {\n            if (!node || !node.length) {\n                return;\n            }\n            node.forEach((element) => {\n                let plaitElement;\n                switch (element.type) {\n                    case \"line\":\n                        plaitElement = transformToDrawnixLineElement(element, mermaidGroupIdToElementMap, config);\n                        break;\n                    case \"rectangle\":\n                    case \"ellipse\":\n                        plaitElement = transformToDrawnixRectangleElement(element, mermaidGroupIdToElementMap, config);\n                        break;\n                    case \"text\":\n                        plaitElement = transformToDrawnixTextElement(element, mermaidGroupIdToElementMap, config);\n                        break;\n                    default:\n                        throw `unknown type ${element.type}`;\n                        break;\n                }\n                // 基于 origin.id 查询和 group 中 actorKeys 的对应关系\n                plaitElement.origin = element;\n                if (element.type === \"rectangle\" && element?.subtype === \"activation\") {\n                    activations.push(plaitElement);\n                }\n                else {\n                    elements.push(plaitElement);\n                }\n            });\n        });\n        Object.values(chart.lines).forEach((line) => {\n            if (!line) {\n                return;\n            }\n            elements.push(transformToDrawnixLineElement(line, mermaidGroupIdToElementMap, config));\n        });\n        Object.values(chart.arrows).forEach((arrow) => {\n            if (!arrow) {\n                return;\n            }\n            elements.push(transformToDrawnixArrowElement(arrow, mermaidGroupIdToElementMap, config));\n            if (arrow.sequenceNumber) {\n                elements.push(transformToDrawnixRectangleElement(arrow.sequenceNumber, mermaidGroupIdToElementMap, config));\n            }\n        });\n        elements.push(...activations);\n        // loops\n        if (chart.loops) {\n            const { lines, texts, nodes } = chart.loops;\n            lines.forEach((line) => {\n                elements.push(transformToDrawnixLineElement(line, mermaidGroupIdToElementMap, config));\n            });\n            texts.forEach((text) => {\n                elements.push(transformToDrawnixTextElement(text, mermaidGroupIdToElementMap, config));\n            });\n            nodes.forEach((node) => {\n                elements.push(transformToDrawnixRectangleElement(node, mermaidGroupIdToElementMap, config));\n            });\n        }\n        if (chart.groups) {\n            chart.groups.forEach((group) => {\n                const { actorKeys, name } = group;\n                if (!actorKeys.length) {\n                    return;\n                }\n                const actors = elements.filter((ele) => {\n                    const element = ele;\n                    if (element.origin && element.origin.id) {\n                        const hyphenIndex = element.origin.id.indexOf(\"-\");\n                        const id = element.origin.id.substring(0, hyphenIndex);\n                        return actorKeys.includes(id);\n                    }\n                    return false;\n                });\n                const { textElement, containerElement } = transformToDrawnixGroupElement(actors, name, { fill: group.fill });\n                elements.unshift(textElement);\n                elements.unshift(containerElement);\n                const groupElement = createGroup();\n                containerElement.groupId = groupElement.id;\n                elements.forEach((ele) => {\n                    if (PlaitGroupElement.isGroup(ele)) {\n                        return;\n                    }\n                    const element = ele;\n                    const containerRectangle = RectangleClient.getRectangleByPoints(containerElement.points);\n                    const isInContainer = element.points.every((point) => {\n                        return RectangleClient.isPointInRectangle(containerRectangle, point);\n                    });\n                    if (isInContainer) {\n                        element.groupId = groupElement.id;\n                    }\n                });\n                elements.push(groupElement);\n            });\n        }\n        elements.forEach((ele) => {\n            if (ele.origin) {\n                delete ele.origin;\n            }\n        });\n        Object.values(mermaidGroupIdToElementMap).forEach((groupElement) => {\n            elements.push(groupElement);\n        });\n        return { elements };\n    },\n});\n", "import { transformToDrawnixArrowElement, transformToDrawnixRectangleElement, transformToDrawnixLineElement, transformToDrawnixTextElement, transformToDrawnixGroupElement, } from \"../transformToDrawnixElement.js\";\nimport { GraphConverter } from \"../GraphConverter.js\";\nimport { ArrowLineShape, } from \"@plait/draw\";\nimport { getHitConnectionFromConnectionPoint } from \"../helpers.js\";\nexport const classToDrawnixConvertor = new GraphConverter({\n    converter: (chart, config) => {\n        const elements = [];\n        const mermaidIdToElementMap = {};\n        const mermaidGroupIdToElementMap = {};\n        Object.values(chart.nodes).forEach((node) => {\n            if (!node || !node.length) {\n                return;\n            }\n            node.forEach((element) => {\n                let drawnixElement;\n                switch (element.type) {\n                    case \"line\":\n                        drawnixElement = transformToDrawnixLineElement(element, mermaidGroupIdToElementMap, config);\n                        break;\n                    case \"rectangle\":\n                    case \"ellipse\":\n                        drawnixElement = transformToDrawnixRectangleElement(element, mermaidGroupIdToElementMap, config);\n                        break;\n                    case \"text\":\n                        drawnixElement = transformToDrawnixTextElement(element, mermaidGroupIdToElementMap, config);\n                        break;\n                    default:\n                        throw `unknown type ${element.type}`;\n                        break;\n                }\n                drawnixElement.origin = element;\n                if (element.id) {\n                    mermaidIdToElementMap[element.id] = drawnixElement;\n                }\n                elements.push(drawnixElement);\n            });\n        });\n        Object.values(chart.lines).forEach((line) => {\n            if (!line) {\n                return;\n            }\n            let drawnixElement = transformToDrawnixLineElement(line, mermaidGroupIdToElementMap, config);\n            drawnixElement.origin = line;\n            elements.push(drawnixElement);\n        });\n        Object.values(chart.arrows).forEach((arrow) => {\n            if (!arrow) {\n                return;\n            }\n            const drawnixElement = transformToDrawnixArrowElement(arrow, mermaidGroupIdToElementMap, {\n                ...config,\n                arrowLineShape: ArrowLineShape.straight,\n            });\n            if (arrow.start &&\n                arrow.start.id &&\n                mermaidIdToElementMap[arrow.start.id]) {\n                drawnixElement.source.boundId =\n                    mermaidIdToElementMap[arrow.start.id].id;\n                drawnixElement.source.connection = getHitConnectionFromConnectionPoint(drawnixElement.points[0], mermaidIdToElementMap[arrow.start.id]);\n            }\n            if (arrow.end && arrow.end.id && mermaidIdToElementMap[arrow.end.id]) {\n                drawnixElement.target.boundId = mermaidIdToElementMap[arrow.end.id].id;\n                drawnixElement.target.connection = getHitConnectionFromConnectionPoint(drawnixElement.points[drawnixElement.points.length - 1], mermaidIdToElementMap[arrow.end.id]);\n            }\n            drawnixElement.origin = arrow;\n            elements.push(drawnixElement);\n        });\n        Object.values(chart.text).forEach((ele) => {\n            const drawnixElement = transformToDrawnixTextElement(ele, mermaidGroupIdToElementMap, config);\n            drawnixElement.origin = ele;\n            elements.push(drawnixElement);\n        });\n        Object.values(chart.namespaces).forEach((namespace) => {\n            const classIds = Object.keys(namespace.classes);\n            const children = [...classIds];\n            const chartElements = [...chart.lines, ...chart.arrows, ...chart.text];\n            classIds.forEach((classId) => {\n                const childIds = chartElements\n                    .filter((ele) => ele.metadata && ele.metadata.classId === classId)\n                    .map((ele) => ele.id);\n                if (childIds.length) {\n                    children.push(...childIds);\n                }\n            });\n            const childrenElements = elements.filter((ele) => ele.origin && ele.origin.id && children.includes(ele.origin.id));\n            const { textElement, containerElement } = transformToDrawnixGroupElement(childrenElements, namespace.id);\n            elements.unshift(textElement);\n            elements.unshift(containerElement);\n        });\n        elements.forEach((ele) => {\n            if (ele.origin) {\n                delete ele.origin;\n            }\n        });\n        Object.values(mermaidGroupIdToElementMap).forEach((groupElement) => {\n            elements.push(groupElement);\n        });\n        return { elements };\n    },\n});\n", "import { GraphConverter } from \"../GraphConverter.js\";\nimport { idCreator } from \"@plait/core\";\nexport const createImage = (startPoint, imageItem) => {\n    const { width, height, url } = imageItem;\n    const points = [\n        startPoint,\n        [startPoint[0] + width, startPoint[1] + height],\n    ];\n    const imageElement = {\n        id: idCreator(),\n        type: \"image\",\n        points,\n        url,\n    };\n    return imageElement;\n};\nexport const graphImageConverter = new GraphConverter({\n    converter: (graph) => {\n        const { width, height } = graph;\n        const imageElement = createImage([0, 0], {\n            width,\n            height,\n            url: graph.dataURL,\n        });\n        return { elements: [imageElement] };\n    },\n});\n", "import { flowchartToDrawnixConverter } from \"./converter/types/flowchart.js\";\nimport { sequenceToDrawnixConvertor } from \"./converter/types/sequence.js\";\nimport { classToDrawnixConvertor } from \"./converter/types/class.js\";\nimport { graphImageConverter } from \"./converter/types/graphImage.js\";\nexport const graphToDrawnix = (graph, options = { fontSize: 20 }) => {\n    switch (graph.type) {\n        case \"graphImage\": {\n            return graphImageConverter.convert(graph, options);\n        }\n        case \"flowchart\": {\n            return flowchartToDrawnixConverter.convert(graph, options);\n        }\n        case \"sequence\": {\n            return sequenceToDrawnixConvertor.convert(graph, options);\n        }\n        case \"class\": {\n            return classToDrawnixConvertor.convert(graph, options);\n        }\n        default: {\n            throw new Error(`graphToDrawnix: unknown graph type \"${graph.type}, only flowcharts are supported!\"`);\n        }\n    }\n};\n", "import \"ts-dedent\";\nimport { N } from \"./mermaid-b5860b54.js\";\nimport \"dayjs\";\nimport \"@braintree/sanitize-url\";\nimport \"d3\";\nimport \"dompurify\";\nimport \"khroma\";\nimport \"lodash-es/memoize.js\";\nimport \"lodash-es/merge.js\";\nimport \"stylis\";\nimport \"lodash-es/isEmpty.js\";\nexport {\n  N as default\n};\n", "// Convert mermaid entity codes to text e.g. \"#9829;\" to \"♥\"\nexport const entityCodesToText = (input) => {\n    input = decodeEntities(input);\n    // Append & before the pattern #(\\d+); or #([a-z]+); to convert to decimal code\n    // so it can be rendered as html character\n    // eg #9829; => &#9829;\n    const inputWithDecimalCode = input\n        .replace(/#(\\d+);/g, \"&#$1;\")\n        .replace(/#([a-z]+);/g, \"&$1;\");\n    // Render the decimal code as html character, eg &#9829; => ♥\n    const element = document.createElement(\"textarea\");\n    element.innerHTML = inputWithDecimalCode;\n    return element.value;\n};\nexport const getTransformAttr = (el) => {\n    const transformAttr = el.getAttribute(\"transform\");\n    const translateMatch = transformAttr?.match(/translate\\(([ \\d.-]+),\\s*([\\d.-]+)\\)/);\n    let transformX = 0;\n    let transformY = 0;\n    if (translateMatch) {\n        transformX = Number(translateMatch[1]);\n        transformY = Number(translateMatch[2]);\n    }\n    return { transformX, transformY };\n};\n//TODO Once fixed in mermaid this will be removed\nexport const encodeEntities = (text) => {\n    let txt = text;\n    txt = txt.replace(/style.*:\\S*#.*;/g, (s) => {\n        return s.substring(0, s.length - 1);\n    });\n    txt = txt.replace(/classDef.*:\\S*#.*;/g, (s) => {\n        return s.substring(0, s.length - 1);\n    });\n    txt = txt.replace(/#\\w+;/g, (s) => {\n        const innerTxt = s.substring(1, s.length - 1);\n        const isInt = /^\\+?\\d+$/.test(innerTxt);\n        if (isInt) {\n            return `ﬂ°°${innerTxt}¶ß`;\n        }\n        return `ﬂ°${innerTxt}¶ß`;\n    });\n    return txt;\n};\nexport const decodeEntities = function (text) {\n    return text.replace(/ﬂ°°/g, \"#\").replace(/ﬂ°/g, \"&\").replace(/¶ß/g, \";\");\n};\n// Compute edge postion start, end and points (reflection points)\nexport const computeEdgePositions = (pathElement, offset = { x: 0, y: 0 }) => {\n    // Check if the element is a path else throw an error\n    if (pathElement.tagName.toLowerCase() !== \"path\") {\n        throw new Error(`Invalid input: Expected an HTMLElement of tag \"path\", got ${pathElement.tagName}`);\n    }\n    // Get the d attribute from the path element else throw an error\n    const dAttr = pathElement.getAttribute(\"d\");\n    if (!dAttr) {\n        throw new Error('Path element does not contain a \"d\" attribute');\n    }\n    // Split the d attribute based on M (Move To) and L (Line To) commands\n    // eg \"M29.383,38.5L29.383,63.5L29.383,83.2\" => [\"M29.383,38.5\", \"L29.383,63.5\", \"L29.383,83.2\"]\n    const commands = dAttr.split(/(?=[LM])/);\n    // Get the start position from the first commands element => [29.383,38.5]\n    const startPosition = commands[0]\n        .substring(1)\n        .split(\",\")\n        .map((coord) => parseFloat(coord));\n    // Get the last position from the last commands element => [29.383,83.2]\n    const endPosition = commands[commands.length - 1]\n        .substring(1)\n        .split(\",\")\n        .map((coord) => parseFloat(coord));\n    // compute the reflection points -> [ {x: 29.383, y: 38.5}, {x: 29.383, y: 83.2} ]\n    // These includes the start and end points and also points which are not the same as the previous points\n    const reflectionPoints = commands\n        .map((command) => {\n        const coords = command\n            .substring(1)\n            .split(\",\")\n            .map((coord) => parseFloat(coord));\n        return { x: coords[0], y: coords[1] };\n    })\n        .filter((point, index, array) => {\n        // Always include the last point\n        if (index === 0 || index === array.length - 1) {\n            return true;\n        }\n        // Exclude the points which are the same as the previous point\n        if (point.x === array[index - 1].x && point.y === array[index - 1].y) {\n            return false;\n        }\n        // The below check is exclusively for second last point\n        if (index === array.length - 2 &&\n            (array[index - 1].x === point.x || array[index - 1].y === point.y)) {\n            const lastPoint = array[array.length - 1];\n            // Get the distance between the last point and second last point using Euclidean distance formula\n            const distance = Math.hypot(lastPoint.x - point.x, lastPoint.y - point.y);\n            // Include the second last point if the distance between the\n            // last point and second last point is > 20.\n            // This is to ensure we have a distance for render the edge.\n            // 20 seems to be a good enough distance to render the edge\n            return distance > 20;\n        }\n        // Always include if the current point is not the same as the previous point\n        return point.x !== array[index - 1].x || point.y !== array[index - 1].y;\n    })\n        .map((p) => {\n        // Offset the point by the provided offset\n        return {\n            x: p.x + offset.x,\n            y: p.y + offset.y,\n        };\n    });\n    // Return the edge positions\n    return {\n        startX: startPosition[0] + offset.x,\n        startY: startPosition[1] + offset.y,\n        endX: endPosition[0] + offset.x,\n        endY: endPosition[1] + offset.y,\n        reflectionPoints,\n    };\n};\n", "import { computeEdgePositions, entityCodesToText, getTransformAttr, } from \"../utils.js\";\nconst parseSubGraph = (data, containerEl) => {\n    // Extract only node id for better reference\n    // e.g. full element id = \"flowchart-c1-205\" will map to \"c1\"\n    const nodeIds = data.nodes.map((n) => {\n        if (n.startsWith(\"flowchart-\")) {\n            return n.split(\"-\")[1];\n        }\n        return n;\n    });\n    // Get position\n    const el = containerEl.querySelector(`[id='${data.id}']`);\n    if (!el) {\n        throw new Error(\"SubGraph element not found\");\n    }\n    const position = computeElementPosition(el, containerEl);\n    // Get dimension\n    const boundingBox = el.getBBox();\n    const dimension = {\n        width: boundingBox.width,\n        height: boundingBox.height,\n    };\n    // Remove irrelevant properties\n    data.classes = undefined;\n    data.dir = undefined;\n    return {\n        ...data,\n        nodeIds,\n        ...position,\n        ...dimension,\n        text: entityCodesToText(data.title),\n    };\n};\nconst parseVertex = (data, containerEl, classes) => {\n    // Find Vertex element\n    const el = containerEl.querySelector(`[id*=\"flowchart-${data.id}-\"]`);\n    if (!el) {\n        return undefined;\n    }\n    // Check if Vertex attached with link\n    let link;\n    if (el.parentElement?.tagName.toLowerCase() === \"a\") {\n        link = el.parentElement.getAttribute(\"xlink:href\");\n    }\n    // Get position\n    const position = computeElementPosition(link ? el.parentElement : el, containerEl);\n    // Get dimension\n    const boundingBox = el.getBBox();\n    const dimension = {\n        width: boundingBox.width,\n        height: boundingBox.height,\n    };\n    // Extract style\n    const labelContainerStyleText = el\n        .querySelector(\".label-container\")\n        ?.getAttribute(\"style\");\n    const labelStyleText = el.querySelector(\".label\")?.getAttribute(\"style\");\n    const containerStyle = {};\n    labelContainerStyleText?.split(\";\").forEach((property) => {\n        if (!property) {\n            return;\n        }\n        const key = property.split(\":\")[0].trim();\n        const value = property.split(\":\")[1].trim();\n        containerStyle[key] = value;\n    });\n    const labelStyle = {};\n    labelStyleText?.split(\";\").forEach((property) => {\n        if (!property) {\n            return;\n        }\n        const key = property.split(\":\")[0].trim();\n        const value = property.split(\":\")[1].trim();\n        labelStyle[key] = value;\n    });\n    if (data.classes) {\n        const classDef = classes[data.classes];\n        if (classDef) {\n            classDef.styles?.forEach((style) => {\n                const [key, value] = style.split(\":\");\n                containerStyle[key.trim()] = value.trim();\n            });\n            classDef.textStyles?.forEach((style) => {\n                const [key, value] = style.split(\":\");\n                labelStyle[key.trim()] = value.trim();\n            });\n        }\n    }\n    return {\n        id: data.id,\n        labelType: data.labelType,\n        text: entityCodesToText(data.text),\n        type: data.type,\n        link: link || undefined,\n        ...position,\n        ...dimension,\n        containerStyle,\n        labelStyle,\n    };\n};\nconst parseEdge = (data, edgeIndex, containerEl) => {\n    // Find edge element\n    const edge = containerEl.querySelector(`[id*=\"L-${data.start}-${data.end}-${edgeIndex}\"]`);\n    if (!edge) {\n        throw new Error(\"Edge element not found\");\n    }\n    // Compute edge position data\n    const position = computeElementPosition(edge, containerEl);\n    const edgePositionData = computeEdgePositions(edge, position);\n    // Remove irrelevant properties\n    data.length = undefined;\n    return {\n        ...data,\n        ...edgePositionData,\n        text: entityCodesToText(data.text),\n    };\n};\n// Compute element position\nconst computeElementPosition = (el, containerEl) => {\n    if (!el) {\n        throw new Error(\"Element not found\");\n    }\n    let root = el.parentElement?.parentElement;\n    const childElement = el.childNodes[0];\n    let childPosition = { x: 0, y: 0 };\n    if (childElement) {\n        const { transformX, transformY } = getTransformAttr(childElement);\n        const boundingBox = childElement.getBBox();\n        childPosition = {\n            x: Number(childElement.getAttribute(\"x\")) ||\n                transformX + boundingBox.x ||\n                0,\n            y: Number(childElement.getAttribute(\"y\")) ||\n                transformY + boundingBox.y ||\n                0,\n        };\n    }\n    const { transformX, transformY } = getTransformAttr(el);\n    const position = {\n        x: transformX + childPosition.x,\n        y: transformY + childPosition.y,\n    };\n    while (root && root.id !== containerEl.id) {\n        if (root.classList.value === \"root\" && root.hasAttribute(\"transform\")) {\n            const { transformX, transformY } = getTransformAttr(root);\n            position.x += transformX;\n            position.y += transformY;\n        }\n        root = root.parentElement;\n    }\n    return position;\n};\nexport const parseMermaidFlowChartDiagram = (diagram, containerEl) => {\n    // This does some cleanup and initialization making sure\n    // diagram is parsed correctly. Useful when multiple diagrams are\n    // parsed together one after another, eg in playground\n    // https://github.com/mermaid-js/mermaid/blob/e561cbd3be2a93b8bedfa4839484966faad92ccf/packages/mermaid/src/Diagram.ts#L43\n    diagram.parse();\n    // Get mermaid parsed data from parser shared variable `yy`\n    //@ts-ignore\n    const mermaidParser = diagram.parser.yy;\n    const vertices = mermaidParser.getVertices();\n    const classes = mermaidParser.getClasses();\n    Object.keys(vertices).forEach((id) => {\n        vertices[id] = parseVertex(vertices[id], containerEl, classes);\n    });\n    // Track the count of edges based on the edge id\n    const edgeCountMap = new Map();\n    const edges = mermaidParser\n        .getEdges()\n        .filter((edge) => {\n        // Sometimes mermaid parser returns edges which are not present in the DOM hence this is a safety check to only consider edges present in the DOM, issue - https://github.com/mermaid-js/mermaid/issues/5516\n        return containerEl.querySelector(`[id*=\"L-${edge.start}-${edge.end}\"]`);\n    })\n        .map((data) => {\n        const edgeId = `${data.start}-${data.end}`;\n        const count = edgeCountMap.get(edgeId) || 0;\n        edgeCountMap.set(edgeId, count + 1);\n        return parseEdge(data, count, containerEl);\n    });\n    const subGraphs = mermaidParser\n        .getSubGraphs()\n        .map((data) => parseSubGraph(data, containerEl));\n    return {\n        type: \"flowchart\",\n        subGraphs,\n        vertices,\n        edges,\n    };\n};\n", "import { entityCodesToText } from \"./utils.js\";\nimport { DEFAULT_FONT_SIZE } from \"./constants.js\";\nexport const createArrowSkeletonFromSVG = (arrowNode, opts) => {\n    const arrow = {};\n    if (opts?.label) {\n        arrow.label = { text: entityCodesToText(opts.label), fontSize: 16 };\n    }\n    const tagName = arrowNode.tagName;\n    if (tagName === \"line\") {\n        arrow.startX = Number(arrowNode.getAttribute(\"x1\"));\n        arrow.startY = Number(arrowNode.getAttribute(\"y1\"));\n        arrow.endX = Number(arrowNode.getAttribute(\"x2\"));\n        arrow.endY = Number(arrowNode.getAttribute(\"y2\"));\n    }\n    else if (tagName === \"path\") {\n        const dAttr = arrowNode.getAttribute(\"d\");\n        if (!dAttr) {\n            throw new Error('Path element does not contain a \"d\" attribute');\n        }\n        // Split the d attribute based on M (Move To)  and C (Curve) commands\n        const commands = dAttr.split(/(?=[LC])/);\n        const startPosition = commands[0]\n            .substring(1)\n            .split(\",\")\n            .map((coord) => parseFloat(coord));\n        const points = [];\n        commands.forEach((command) => {\n            const currPoints = command\n                .substring(1)\n                .trim()\n                .split(\" \")\n                .map((pos) => {\n                const [x, y] = pos.split(\",\");\n                return [\n                    parseFloat(x) - startPosition[0],\n                    parseFloat(y) - startPosition[1],\n                ];\n            });\n            points.push(...currPoints);\n        });\n        const endPosition = points[points.length - 1];\n        arrow.startX = startPosition[0];\n        arrow.startY = startPosition[1];\n        arrow.endX = endPosition[0];\n        arrow.endY = endPosition[1];\n        arrow.points = points;\n    }\n    if (opts?.label) {\n        // In mermaid the text is positioned above arrow but in Drawnix\n        // its postioned on the arrow hence the elements below it might look cluttered so shifting the arrow by an offset of 10px\n        const offset = 10;\n        arrow.startY = arrow.startY - offset;\n        arrow.endY = arrow.endY - offset;\n    }\n    arrow.strokeColor = arrowNode.getAttribute(\"stroke\");\n    arrow.strokeWidth = Number(arrowNode.getAttribute(\"stroke-width\"));\n    arrow.type = \"arrow\";\n    arrow.strokeStyle = opts?.strokeStyle || \"solid\";\n    arrow.startArrowhead = opts?.startArrowhead || null;\n    arrow.endArrowhead = opts?.endArrowhead || null;\n    return arrow;\n};\nexport const createArrowSkeleton = (startX, startY, endX, endY, opts) => {\n    const arrow = {};\n    arrow.type = \"arrow\";\n    arrow.startX = startX;\n    arrow.startY = startY;\n    arrow.endX = endX;\n    arrow.endY = endY;\n    Object.assign(arrow, { ...opts });\n    return arrow;\n};\nexport const createTextSkeleton = (x, y, text, opts) => {\n    const textElement = {\n        type: \"text\",\n        x,\n        y,\n        text,\n        width: opts?.width || 20,\n        height: opts?.height || 20,\n        fontSize: opts?.fontSize || DEFAULT_FONT_SIZE,\n        id: opts?.id,\n        groupId: opts?.groupId,\n        metadata: opts?.metadata,\n    };\n    return textElement;\n};\nexport const createTextSkeletonFromSVG = (textNode, text, opts) => {\n    const node = {};\n    const x = Number(textNode.getAttribute(\"x\"));\n    const y = Number(textNode.getAttribute(\"y\"));\n    node.type = \"text\";\n    node.text = entityCodesToText(text);\n    if (opts?.id) {\n        node.id = opts.id;\n    }\n    if (opts?.groupId) {\n        node.groupId = opts.groupId;\n    }\n    const boundingBox = textNode.getBBox();\n    node.width = boundingBox.width;\n    node.height = boundingBox.height;\n    node.x = x - boundingBox.width / 2;\n    node.y = y;\n    const fontSize = parseInt(getComputedStyle(textNode).fontSize);\n    node.fontSize = fontSize;\n    return node;\n};\nexport const createContainerSkeletonFromSVG = (node, type, opts = {}) => {\n    const container = {};\n    container.type = type;\n    const { label, subtype, id, groupId } = opts;\n    container.id = id;\n    if (groupId) {\n        container.groupId = groupId;\n    }\n    if (label) {\n        container.label = {\n            text: entityCodesToText(label.text),\n            fontSize: 16,\n            verticalAlign: label?.verticalAlign,\n        };\n    }\n    const boundingBox = node.getBBox();\n    container.x = boundingBox.x;\n    container.y = boundingBox.y;\n    container.width = boundingBox.width;\n    container.height = boundingBox.height;\n    container.subtype = subtype;\n    switch (subtype) {\n        case \"highlight\":\n            const bgColor = node.getAttribute(\"fill\");\n            if (bgColor) {\n                container.bgColor = bgColor;\n            }\n            break;\n        case \"note\":\n            container.strokeStyle = \"dashed\";\n            break;\n    }\n    return container;\n};\nexport const createLineSkeletonFromSVG = (lineNode, startX, startY, endX, endY, opts) => {\n    const line = {};\n    line.startX = startX;\n    line.startY = startY;\n    line.endX = endX;\n    if (opts?.groupId) {\n        line.groupId = opts.groupId;\n    }\n    if (opts?.id) {\n        line.id = opts.id;\n    }\n    // Make sure lines don't overlap with the nodes, in mermaid it overlaps but isn't visible as its pushed back and containers are non transparent\n    line.endY = endY;\n    line.strokeColor = lineNode.getAttribute(\"stroke\");\n    line.strokeWidth = Number(lineNode.getAttribute(\"stroke-width\"));\n    line.type = \"line\";\n    return line;\n};\n", "import { SVG_TO_SHAPE_MAPPER } from \"../constants.js\";\nimport { createArrowSkeletonFromSVG, createContainerSkeletonFromSVG, createLineSkeletonFromSVG, createTextSkeletonFromSVG, } from \"../elementSkeleton.js\";\nimport { StrokeStyle } from \"@plait/common\";\nimport { idCreator } from \"@plait/core\";\n// Currently mermaid supported these 6 arrow types, the names are taken from mermaidParser.LINETYPE\nconst SEQUENCE_ARROW_TYPES = {\n    0: \"SOLID\",\n    1: \"DOTTED\",\n    3: \"SOLID_CROSS\",\n    4: \"DOTTED_CROSS\",\n    5: \"SOLID_OPEN\",\n    6: \"DOTTED_OPEN\",\n    24: \"SOLID_POINT\",\n    25: \"DOTTED_POINT\",\n};\nconst MESSAGE_TYPE = {\n    SOLID: 0,\n    DOTTED: 1,\n    NOTE: 2,\n    SOLID_CROSS: 3,\n    DOTTED_CROSS: 4,\n    SOLID_OPEN: 5,\n    DOTTED_OPEN: 6,\n    LOOP_START: 10,\n    LOOP_END: 11,\n    ALT_START: 12,\n    ALT_ELSE: 13,\n    ALT_END: 14,\n    OPT_START: 15,\n    OPT_END: 16,\n    ACTIVE_START: 17,\n    ACTIVE_END: 18,\n    PAR_START: 19,\n    PAR_AND: 20,\n    PAR_END: 21,\n    RECT_START: 22,\n    RECT_END: 23,\n    SOLID_POINT: 24,\n    DOTTED_POINT: 25,\n    AUTONUMBER: 26,\n    CRITICAL_START: 27,\n    CRITICAL_OPTION: 28,\n    CRITICAL_END: 29,\n    BREAK_START: 30,\n    BREAK_END: 31,\n    PAR_OVER_START: 32,\n};\nconst getStrokeStyle = (type) => {\n    let strokeStyle;\n    switch (type) {\n        case MESSAGE_TYPE.SOLID:\n        case MESSAGE_TYPE.SOLID_CROSS:\n        case MESSAGE_TYPE.SOLID_OPEN:\n        case MESSAGE_TYPE.SOLID_POINT:\n            strokeStyle = StrokeStyle.solid;\n            break;\n        case MESSAGE_TYPE.DOTTED:\n        case MESSAGE_TYPE.DOTTED_CROSS:\n        case MESSAGE_TYPE.DOTTED_OPEN:\n        case MESSAGE_TYPE.DOTTED_POINT:\n            strokeStyle = StrokeStyle.dotted;\n            break;\n        default:\n            strokeStyle = StrokeStyle.solid;\n            break;\n    }\n    return strokeStyle;\n};\nconst attachSequenceNumberToArrow = (node, arrow) => {\n    const showSequenceNumber = !!node.nextElementSibling?.classList.contains(\"sequenceNumber\");\n    if (showSequenceNumber) {\n        const text = node.nextElementSibling?.textContent;\n        if (!text) {\n            throw new Error(\"sequence number not present\");\n        }\n        const height = 30;\n        const yOffset = height / 2;\n        const xOffset = 10;\n        const sequenceNumber = {\n            type: \"rectangle\",\n            x: arrow.startX - xOffset,\n            y: arrow.startY - yOffset,\n            label: { text, fontSize: 14 },\n            bgColor: \"#e9ecef\",\n            height,\n            subtype: \"sequence\",\n        };\n        Object.assign(arrow, { sequenceNumber });\n    }\n};\nconst createActorSymbol = (rootNode, text, opts) => {\n    if (!rootNode) {\n        throw \"root node not found\";\n    }\n    const groupId = idCreator();\n    const children = Array.from(rootNode.children);\n    const nodeElements = [];\n    children.forEach((child, index) => {\n        const id = `${opts?.id}-${index}`;\n        let ele;\n        switch (child.tagName) {\n            case \"line\":\n                const startX = Number(child.getAttribute(\"x1\"));\n                const startY = Number(child.getAttribute(\"y1\"));\n                const endX = Number(child.getAttribute(\"x2\"));\n                const endY = Number(child.getAttribute(\"y2\"));\n                ele = createLineSkeletonFromSVG(child, startX, startY, endX, endY, { groupId, id });\n                break;\n            case \"text\":\n                ele = createTextSkeletonFromSVG(child, text, {\n                    groupId,\n                    id,\n                });\n                break;\n            case \"circle\":\n                ele = createContainerSkeletonFromSVG(child, \"ellipse\", {\n                    label: child.textContent ? { text: child.textContent } : undefined,\n                    groupId,\n                    id,\n                });\n            default:\n                ele = createContainerSkeletonFromSVG(child, SVG_TO_SHAPE_MAPPER[child.tagName], {\n                    label: child.textContent ? { text: child.textContent } : undefined,\n                    groupId,\n                    id,\n                });\n        }\n        nodeElements.push(ele);\n    });\n    return nodeElements;\n};\nconst parseActor = (actors, containerEl) => {\n    const actorTopNodes = Array.from(containerEl.querySelectorAll(\".actor-top\"));\n    const actorBottomNodes = Array.from(containerEl.querySelectorAll(\".actor-bottom\"));\n    const nodes = [];\n    const lines = [];\n    Object.values(actors).forEach((actor, index) => {\n        const topRootNode = actorTopNodes.find((actorNode) => actorNode.getAttribute(\"name\") === actor.name);\n        const bottomRootNode = actorBottomNodes.find((actorNode) => actorNode.getAttribute(\"name\") === actor.name);\n        if (!topRootNode || !bottomRootNode) {\n            throw \"root not found\";\n        }\n        const text = actor.description;\n        if (actor.type === \"participant\") {\n            // creating top actor node element\n            const topNodeElement = createContainerSkeletonFromSVG(topRootNode, \"rectangle\", { id: `${actor.name}-top`, label: { text }, subtype: \"actor\" });\n            if (!topNodeElement) {\n                throw \"Top Node element not found!\";\n            }\n            nodes.push([topNodeElement]);\n            // creating bottom actor node element\n            const bottomNodeElement = createContainerSkeletonFromSVG(bottomRootNode, \"rectangle\", { id: `${actor.name}-bottom`, label: { text }, subtype: \"actor\" });\n            nodes.push([bottomNodeElement]);\n            // Get the line connecting the top and bottom nodes. As per the DOM, the line is rendered as sibling parent of top root node\n            const lineNode = topRootNode?.parentElement\n                ?.previousElementSibling;\n            if (lineNode?.tagName !== \"line\") {\n                throw \"Line not found\";\n            }\n            const startX = Number(lineNode.getAttribute(\"x1\"));\n            if (!topNodeElement.height) {\n                throw \"Top node element height is null\";\n            }\n            const startY = topNodeElement.y + topNodeElement.height;\n            // Make sure lines don't overlap with the nodes, in mermaid it overlaps but isn't visible as its pushed back and containers are non transparent\n            const endY = bottomNodeElement.y;\n            const endX = Number(lineNode.getAttribute(\"x2\"));\n            const line = createLineSkeletonFromSVG(lineNode, startX, startY, endX, endY);\n            lines.push(line);\n        }\n        else if (actor.type === \"actor\") {\n            const topNodeElement = createActorSymbol(topRootNode, text, {\n                id: `${actor.name}-top`,\n            });\n            nodes.push(topNodeElement);\n            const bottomNodeElement = createActorSymbol(bottomRootNode, text, {\n                id: `${actor.name}-bottom`,\n            });\n            nodes.push(bottomNodeElement);\n            // Get the line connecting the top and bottom nodes. As per the DOM, the line is rendered as sibling of the actor root element\n            const lineNode = topRootNode.previousElementSibling;\n            if (lineNode?.tagName !== \"line\") {\n                throw \"Line not found\";\n            }\n            const startX = Number(lineNode.getAttribute(\"x1\"));\n            const startY = Number(lineNode.getAttribute(\"y1\"));\n            const endX = Number(lineNode.getAttribute(\"x2\"));\n            // Make sure lines don't overlap with the nodes, in mermaid it overlaps but isn't visible as its pushed back and containers are non transparent\n            const bottomEllipseNode = bottomNodeElement.find((node) => node.type === \"ellipse\");\n            if (bottomEllipseNode) {\n                const endY = bottomEllipseNode.y;\n                const line = createLineSkeletonFromSVG(lineNode, startX, startY, endX, endY);\n                lines.push(line);\n            }\n        }\n    });\n    return { nodes, lines };\n};\nconst computeArrows = (messages, containerEl) => {\n    const arrows = [];\n    const arrowNodes = Array.from(containerEl.querySelectorAll('[class*=\"messageLine\"]'));\n    const supportedMessageTypes = Object.keys(SEQUENCE_ARROW_TYPES);\n    const arrowMessages = messages.filter((message) => supportedMessageTypes.includes(message.type.toString()));\n    arrowNodes.forEach((arrowNode, index) => {\n        const message = arrowMessages[index];\n        const messageType = SEQUENCE_ARROW_TYPES[message.type];\n        const arrow = createArrowSkeletonFromSVG(arrowNode, {\n            label: message?.message,\n            strokeStyle: getStrokeStyle(message.type),\n            endArrowhead: messageType === \"SOLID_OPEN\" || messageType === \"DOTTED_OPEN\"\n                ? null\n                : \"arrow\",\n        });\n        attachSequenceNumberToArrow(arrowNode, arrow);\n        arrows.push(arrow);\n    });\n    return arrows;\n};\nconst computeNotes = (messages, containerEl) => {\n    const noteNodes = Array.from(containerEl.querySelectorAll(\".note\")).map((node) => node.parentElement);\n    const noteText = messages.filter((message) => message.type === MESSAGE_TYPE.NOTE);\n    const notes = [];\n    noteNodes.forEach((node, index) => {\n        if (!node) {\n            return;\n        }\n        const rect = node.firstChild;\n        const text = noteText[index].message;\n        const note = createContainerSkeletonFromSVG(rect, \"rectangle\", {\n            label: { text },\n            subtype: \"note\",\n        });\n        notes.push(note);\n    });\n    return notes;\n};\nconst parseActivations = (containerEl) => {\n    const activationNodes = Array.from(containerEl.querySelectorAll(`[class*=activation]`));\n    const activations = [];\n    activationNodes.forEach((node) => {\n        const rect = createContainerSkeletonFromSVG(node, \"rectangle\", {\n            label: { text: \"\" },\n            subtype: \"activation\",\n        });\n        activations.push(rect);\n    });\n    return activations;\n};\nconst parseLoops = (messages, containerEl) => {\n    const lineNodes = Array.from(containerEl.querySelectorAll(\".loopLine\"));\n    const lines = [];\n    const texts = [];\n    const nodes = [];\n    lineNodes.forEach((node) => {\n        const startX = Number(node.getAttribute(\"x1\"));\n        const startY = Number(node.getAttribute(\"y1\"));\n        const endX = Number(node.getAttribute(\"x2\"));\n        const endY = Number(node.getAttribute(\"y2\"));\n        const line = createLineSkeletonFromSVG(node, startX, startY, endX, endY);\n        line.strokeStyle = StrokeStyle.dotted;\n        line.strokeColor = \"#adb5bd\";\n        line.strokeWidth = 2;\n        lines.push(line);\n    });\n    const loopTextNodes = Array.from(containerEl.querySelectorAll(\".loopText\"));\n    const criticalMessages = messages\n        .filter((message) => message.type === MESSAGE_TYPE.CRITICAL_START)\n        .map((message) => message.message);\n    loopTextNodes.forEach((node) => {\n        const text = node.textContent || \"\";\n        const textElement = createTextSkeletonFromSVG(node, text);\n        // The text is rendered between [ ] in DOM hence getting the text excluding the [ ]\n        const rawText = text.match(/\\[(.*?)\\]/)?.[1] || \"\";\n        const isCritical = criticalMessages.includes(rawText);\n        // For critical label the coordinates are not accurate in mermaid as there is\n        // no padding left hence shifting the text next to critical label by 16px (font size)\n        if (isCritical) {\n            textElement.x += 16;\n        }\n        texts.push(textElement);\n    });\n    const labelBoxes = Array.from(containerEl?.querySelectorAll(\".labelBox\"));\n    const labelTextNode = Array.from(containerEl?.querySelectorAll(\".labelText\"));\n    labelBoxes.forEach((labelBox, index) => {\n        const text = labelTextNode[index]?.textContent || \"\";\n        const container = createContainerSkeletonFromSVG(labelBox, \"rectangle\", {\n            label: { text },\n        });\n        container.strokeColor = \"#adb5bd\";\n        container.bgColor = \"#e9ecef\";\n        // So width is calculated based on label\n        container.width = undefined;\n        nodes.push(container);\n    });\n    return { lines, texts, nodes };\n};\nconst computeHighlights = (containerEl) => {\n    const rects = Array.from(containerEl.querySelectorAll(\".rect\"))\n        // Only drawing specifically for highlights as the same selector is for grouping as well. For grouping we\n        // draw it ourselves\n        .filter((node) => node.parentElement?.tagName !== \"g\");\n    const nodes = [];\n    rects.forEach((rect) => {\n        const node = createContainerSkeletonFromSVG(rect, \"rectangle\", {\n            label: { text: \"\" },\n            subtype: \"highlight\",\n        });\n        nodes.push(node);\n    });\n    return nodes;\n};\nexport const parseMermaidSequenceDiagram = (diagram, containerEl) => {\n    diagram.parse();\n    // Get mermaid parsed data from parser shared variable `yy`\n    //@ts-ignore\n    const mermaidParser = diagram.parser.yy;\n    const nodes = [];\n    const groups = mermaidParser.getBoxes();\n    const bgHightlights = computeHighlights(containerEl);\n    const actorData = mermaidParser.getActors();\n    const { nodes: actors, lines } = parseActor(actorData, containerEl);\n    const messages = mermaidParser.getMessages();\n    const arrows = computeArrows(messages, containerEl);\n    const notes = computeNotes(messages, containerEl);\n    const activations = parseActivations(containerEl);\n    const loops = parseLoops(messages, containerEl);\n    nodes.push(bgHightlights);\n    nodes.push(...actors);\n    nodes.push(notes);\n    nodes.push(activations);\n    return { type: \"sequence\", lines, arrows, nodes, loops, groups };\n};\n", "import { computeEdgePositions, getTransformAttr } from \"../utils.js\";\nimport { createArrowSkeleton, createContainerSkeletonFromSVG, createLineSkeletonFromSVG, createTextSkeleton, } from \"../elementSkeleton.js\";\nimport { StrokeStyle } from \"@plait/common\";\nimport { idCreator } from \"@plait/core\";\n// Taken from mermaidParser.relationType\nconst RELATION_TYPE = {\n    AGGREGATION: 0,\n    EXTENSION: 1,\n    COMPOSITION: 2,\n    DEPENDENCY: 3,\n    LOLLIPOP: 4,\n};\n// Taken from mermaidParser.lineType\nconst LINE_TYPE = {\n    LINE: 0,\n    DOTTED_LINE: 1,\n};\n// This is the offset to update the arrow head postition for rendering in drawnix as mermaid calculates the position until the start of arrowhead\nconst MERMAID_ARROW_HEAD_OFFSET = 16;\nconst getStrokeStyle = (type) => {\n    let lineType;\n    switch (type) {\n        case LINE_TYPE.LINE:\n            lineType = StrokeStyle.solid;\n            break;\n        case LINE_TYPE.DOTTED_LINE:\n            lineType = StrokeStyle.dotted;\n            break;\n        default:\n            lineType = StrokeStyle.solid;\n    }\n    return lineType;\n};\nconst getArrowhead = (type) => {\n    let arrowhead;\n    switch (type) {\n        case RELATION_TYPE.AGGREGATION:\n            arrowhead = \"diamond_outline\";\n            break;\n        case RELATION_TYPE.COMPOSITION:\n            arrowhead = \"diamond\";\n            break;\n        case RELATION_TYPE.EXTENSION:\n            arrowhead = \"triangle_outline\";\n            break;\n        case \"none\":\n            arrowhead = null;\n            break;\n        case RELATION_TYPE.DEPENDENCY:\n        default:\n            arrowhead = \"arrow\";\n            break;\n    }\n    return arrowhead;\n};\nconst parseClasses = (classes, containerEl) => {\n    const nodes = [];\n    const lines = [];\n    const text = [];\n    Object.values(classes).forEach((classNode) => {\n        const { domId, id: classId } = classNode;\n        const groupId = idCreator();\n        const domNode = containerEl.querySelector(`[data-id=${classId}]`);\n        if (!domNode) {\n            throw Error(`DOM Node with id ${domId} not found`);\n        }\n        const { transformX, transformY } = getTransformAttr(domNode);\n        const container = createContainerSkeletonFromSVG(domNode.firstChild, \"rectangle\", { id: classId, groupId });\n        container.x += transformX;\n        container.y += transformY;\n        container.metadata = { classId };\n        nodes.push(container);\n        const lineNodes = Array.from(domNode.querySelectorAll(\".divider\"));\n        lineNodes.forEach((lineNode) => {\n            const startX = Number(lineNode.getAttribute(\"x1\"));\n            const startY = Number(lineNode.getAttribute(\"y1\"));\n            const endX = Number(lineNode.getAttribute(\"x2\"));\n            const endY = Number(lineNode.getAttribute(\"y2\"));\n            const line = createLineSkeletonFromSVG(lineNode, startX, startY, endX, endY, {\n                groupId,\n                id: idCreator(),\n            });\n            line.startX += transformX;\n            line.startY += transformY;\n            line.endX += transformX;\n            line.endY += transformY;\n            line.metadata = { classId };\n            lines.push(line);\n        });\n        const labelNodes = domNode.querySelector(\".label\")?.children;\n        if (!labelNodes) {\n            throw \"label nodes not found\";\n        }\n        Array.from(labelNodes).forEach((node) => {\n            const label = node.textContent;\n            if (!label) {\n                return;\n            }\n            const id = idCreator();\n            const { transformX: textTransformX, transformY: textTransformY } = getTransformAttr(node);\n            const boundingBox = node.getBBox();\n            const offsetY = 10;\n            const textElement = createTextSkeleton(transformX + textTransformX, transformY + textTransformY + offsetY, label, {\n                width: boundingBox.width,\n                height: boundingBox.height,\n                id,\n                groupId,\n                metadata: { classId },\n            });\n            text.push(textElement);\n        });\n    });\n    return { nodes, lines, text };\n};\n// update arrow position by certain offset for triangle and diamond arrow head types\n// as mermaid calculates the position until the start of arrowhead\n// for reference - https://github.com/mermaid-js/mermaid/issues/5417\nconst adjustArrowPosition = (direction, arrow) => {\n    // The arrowhead shapes where we need to update the position by a 16px offset\n    const arrowHeadShapes = [\"triangle_outline\", \"diamond\", \"diamond_outline\"];\n    const shouldUpdateStartArrowhead = arrow.startArrowhead && arrowHeadShapes.includes(arrow.startArrowhead);\n    const shouldUpdateEndArrowhead = arrow.endArrowhead && arrowHeadShapes.includes(arrow.endArrowhead);\n    if (!shouldUpdateEndArrowhead && !shouldUpdateStartArrowhead) {\n        return arrow;\n    }\n    if (shouldUpdateStartArrowhead) {\n        if (direction === \"LR\") {\n            arrow.startX -= MERMAID_ARROW_HEAD_OFFSET;\n        }\n        else if (direction === \"RL\") {\n            arrow.startX += MERMAID_ARROW_HEAD_OFFSET;\n        }\n        else if (direction === \"TB\") {\n            arrow.startY -= MERMAID_ARROW_HEAD_OFFSET;\n        }\n        else if (direction === \"BT\") {\n            arrow.startY += MERMAID_ARROW_HEAD_OFFSET;\n        }\n    }\n    if (shouldUpdateEndArrowhead) {\n        if (direction === \"LR\") {\n            arrow.endX += MERMAID_ARROW_HEAD_OFFSET;\n        }\n        else if (direction === \"RL\") {\n            arrow.endX -= MERMAID_ARROW_HEAD_OFFSET;\n        }\n        else if (direction === \"TB\") {\n            arrow.endY += MERMAID_ARROW_HEAD_OFFSET;\n        }\n        else if (direction === \"BT\") {\n            arrow.endY -= MERMAID_ARROW_HEAD_OFFSET;\n        }\n    }\n    return arrow;\n};\nconst parseRelations = (relations, classNodes, containerEl, direction) => {\n    const edges = containerEl.querySelector(\".edgePaths\")?.children;\n    if (!edges) {\n        throw new Error(\"No Edges found!\");\n    }\n    const arrows = [];\n    const text = [];\n    relations.forEach((relationNode, index) => {\n        const { id1, id2, relation } = relationNode;\n        const node1 = classNodes.find((node) => node.id === id1);\n        const node2 = classNodes.find((node) => node.id === id2);\n        const strokeStyle = getStrokeStyle(relation.lineType);\n        const startArrowhead = getArrowhead(relation.type1);\n        const endArrowhead = getArrowhead(relation.type2);\n        const edgePositionData = computeEdgePositions(edges[index]);\n        const arrowSkeleton = createArrowSkeleton(edgePositionData.startX, edgePositionData.startY, edgePositionData.endX, edgePositionData.endY, {\n            strokeStyle,\n            startArrowhead,\n            endArrowhead,\n            label: relationNode.title ? { text: relationNode.title } : undefined,\n            start: { type: \"rectangle\", id: node1.id },\n            end: { type: \"rectangle\", id: node2.id },\n        });\n        const arrow = adjustArrowPosition(direction, arrowSkeleton);\n        arrows.push(arrow);\n        // Add cardianlities and Multiplicities\n        const { relationTitle1, relationTitle2 } = relationNode;\n        const offsetX = 20;\n        const offsetY = 15;\n        const directionOffset = 15;\n        let x;\n        let y;\n        if (relationTitle1 && relationTitle1 !== \"none\") {\n            switch (direction) {\n                case \"TB\":\n                    x = arrow.startX - offsetX;\n                    if (arrow.endX < arrow.startX) {\n                        x -= directionOffset;\n                    }\n                    y = arrow.startY + offsetY;\n                    break;\n                case \"BT\":\n                    x = arrow.startX + offsetX;\n                    if (arrow.endX > arrow.startX) {\n                        x += directionOffset;\n                    }\n                    y = arrow.startY - offsetY;\n                    break;\n                case \"LR\":\n                    x = arrow.startX + offsetX;\n                    y = arrow.startY + offsetY;\n                    if (arrow.endY > arrow.startY) {\n                        y += directionOffset;\n                    }\n                    break;\n                case \"RL\":\n                    x = arrow.startX - offsetX;\n                    y = arrow.startY - offsetY;\n                    if (arrow.startY > arrow.endY) {\n                        y -= directionOffset;\n                    }\n                    break;\n                default:\n                    x = arrow.startX - offsetX;\n                    y = arrow.startY + offsetY;\n            }\n            const relationTitleElement = createTextSkeleton(x, y, relationTitle1, {\n                fontSize: 16,\n            });\n            text.push(relationTitleElement);\n        }\n        if (relationTitle2 && relationTitle2 !== \"none\") {\n            switch (direction) {\n                case \"TB\":\n                    x = arrow.endX + offsetX;\n                    if (arrow.endX < arrow.startX) {\n                        x += directionOffset;\n                    }\n                    y = arrow.endY - offsetY;\n                    break;\n                case \"BT\":\n                    x = arrow.endX - offsetX;\n                    if (arrow.endX > arrow.startX) {\n                        x -= directionOffset;\n                    }\n                    y = arrow.endY + offsetY;\n                    break;\n                case \"LR\":\n                    x = arrow.endX - offsetX;\n                    y = arrow.endY - offsetY;\n                    if (arrow.endY > arrow.startY) {\n                        y -= directionOffset;\n                    }\n                    break;\n                case \"RL\":\n                    x = arrow.endX + offsetX;\n                    y = arrow.endY + offsetY;\n                    if (arrow.startY > arrow.endY) {\n                        y += directionOffset;\n                    }\n                    break;\n                default:\n                    x = arrow.endX + offsetX;\n                    y = arrow.endY - offsetY;\n            }\n            const relationTitleElement = createTextSkeleton(x, y, relationTitle2, {\n                fontSize: 16,\n            });\n            text.push(relationTitleElement);\n        }\n    });\n    return { arrows, text };\n};\nconst parseNotes = (notes, containerEl, classNodes) => {\n    const noteContainers = [];\n    const connectors = [];\n    notes.forEach((note) => {\n        const { id, text, class: classId } = note;\n        const node = containerEl.querySelector(`#${id}`);\n        if (!node) {\n            throw new Error(`Node with id ${id} not found!`);\n        }\n        const { transformX, transformY } = getTransformAttr(node);\n        const rect = node.firstChild;\n        const container = createContainerSkeletonFromSVG(rect, \"rectangle\", {\n            id,\n            subtype: \"note\",\n            label: { text },\n        });\n        Object.assign(container, {\n            x: container.x + transformX,\n            y: container.y + transformY,\n        });\n        noteContainers.push(container);\n        if (classId) {\n            const classNode = classNodes.find((node) => node.id === classId);\n            if (!classNode) {\n                throw new Error(`class node with id ${classId} not found!`);\n            }\n            const startX = container.x + (container.width || 0) / 2;\n            const startY = container.y + (container.height || 0);\n            const endX = startX;\n            const endY = classNode.y;\n            const connector = createArrowSkeleton(startX, startY, endX, endY, {\n                strokeStyle: \"dotted\",\n                startArrowhead: null,\n                endArrowhead: null,\n                start: { id: container.id, type: \"rectangle\" },\n                end: { id: classNode.id, type: \"rectangle\" },\n            });\n            connectors.push(connector);\n        }\n    });\n    return { notes: noteContainers, connectors };\n};\nexport const parseMermaidClassDiagram = (diagram, containerEl) => {\n    diagram.parse();\n    //@ts-ignore\n    const mermaidParser = diagram.parser.yy;\n    const direction = mermaidParser.getDirection();\n    const nodes = [];\n    const lines = [];\n    const text = [];\n    const classNodes = [];\n    const namespaces = mermaidParser.getNamespaces();\n    const classes = mermaidParser.getClasses();\n    if (Object.keys(classes).length) {\n        const classData = parseClasses(classes, containerEl);\n        nodes.push(classData.nodes);\n        lines.push(...classData.lines);\n        text.push(...classData.text);\n        classNodes.push(...classData.nodes);\n    }\n    const relations = mermaidParser.getRelations();\n    const { arrows, text: relationTitles } = parseRelations(relations, classNodes, containerEl, direction);\n    const { notes, connectors } = parseNotes(mermaidParser.getNotes(), containerEl, classNodes);\n    nodes.push(notes);\n    arrows.push(...connectors);\n    text.push(...relationTitles);\n    return { type: \"class\", nodes, lines, arrows, text, namespaces };\n};\n", "import mermaid from \"mermaid\";\nimport { MERMAID_CONFIG } from \"./constants.js\";\nimport { encodeEntities } from \"./utils.js\";\nimport { parseMermaidFlowChartDiagram } from \"./parser/flowchart.js\";\nimport { parseMermaidSequenceDiagram } from \"./parser/sequence.js\";\nimport { parseMermaidClassDiagram } from \"./parser/class.js\";\n// Fallback to Svg\nconst convertSvgToGraphImage = (svgContainer) => {\n    // Extract SVG width and height\n    // TODO: make width and height change dynamically based on user's screen dimension\n    const svgEl = svgContainer.querySelector(\"svg\");\n    if (!svgEl) {\n        throw new Error(\"SVG element not found\");\n    }\n    const rect = svgEl.getBoundingClientRect();\n    const width = rect.width;\n    const height = rect.height;\n    // Set width and height explictly since in firefox it gets set to 0\n    // if the width and height are not expilcitly set\n    // eg in some cases like er Diagram, gnatt, width and height is set as 100%\n    // which sets the dimensions as 0 in firefox and thus the diagram isn't rendered\n    svgEl.setAttribute(\"width\", `${width}`);\n    svgEl.setAttribute(\"height\", `${height}`);\n    // Convert SVG to image\n    const mimeType = \"image/svg+xml\";\n    const decoded = unescape(encodeURIComponent(svgEl.outerHTML));\n    const base64 = btoa(decoded);\n    const dataURL = `data:image/svg+xml;base64,${base64}`;\n    const graphImage = {\n        type: \"graphImage\",\n        mimeType,\n        dataURL,\n        width,\n        height,\n    };\n    return graphImage;\n};\nexport const parseMermaid = async (definition, config = MERMAID_CONFIG) => {\n    mermaid.initialize({ ...MERMAID_CONFIG, ...config });\n    // Parse the diagram\n    const diagram = await mermaid.mermaidAPI.getDiagramFromText(encodeEntities(definition));\n    // Render the SVG diagram\n    const { svg } = await mermaid.render(\"mermaid-to-drawnix\", definition);\n    // Append Svg to DOM\n    const svgContainer = document.createElement(\"div\");\n    svgContainer.setAttribute(\"style\", `opacity: 0; position: relative; z-index: -1;`);\n    svgContainer.innerHTML = svg;\n    svgContainer.id = \"mermaid-diagram\";\n    document.body.appendChild(svgContainer);\n    let data;\n    switch (diagram.type) {\n        case \"flowchart-v2\": {\n            data = parseMermaidFlowChartDiagram(diagram, svgContainer);\n            break;\n        }\n        case \"sequence\": {\n            data = parseMermaidSequenceDiagram(diagram, svgContainer);\n            break;\n        }\n        case \"classDiagram\": {\n            data = parseMermaidClassDiagram(diagram, svgContainer);\n            break;\n        }\n        // fallback to image if diagram type not-supported\n        default: {\n            data = convertSvgToGraphImage(svgContainer);\n        }\n    }\n    svgContainer.remove();\n    return data;\n};\n", "import { DEFAULT_FONT_SIZE } from \"./constants.js\";\nimport { graphToDrawnix } from \"./graphToDrawnix.js\";\nimport { parseMermaid } from \"./parseMermaid.js\";\nconst parseMermaidToDrawnix = async (definition, config) => {\n    const mermaidConfig = config || {};\n    const fontSize = parseInt(mermaidConfig.themeVariables?.fontSize ?? \"\") || DEFAULT_FONT_SIZE;\n    const parsedMermaidData = await parseMermaid(definition, {\n        ...mermaidConfig,\n        themeVariables: {\n            ...mermaidConfig.themeVariables,\n            // Multiplying by 1.25 to increase the font size by 25% and render correctly in Drawnix\n            fontSize: `${fontSize * 1.25}px`,\n        },\n    });\n    // Only font size supported for drawnix elements\n    const drawnixElements = graphToDrawnix(parsedMermaidData, {\n        fontSize,\n    });\n    return drawnixElements;\n};\nexport { parseMermaidToDrawnix };\n"],
  "mappings": "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",
  "names": ["DEFAULT_FONT_SIZE", "DEFAULT_FONT_SIZE", "VERTEX_TYPE", "LABEL_STYLE_PROPERTY", "CONTAINER_STYLE_PROPERTY", "groupElement", "transformX", "transformY", "DEFAULT_FONT_SIZE", "getStrokeStyle", "node", "DEFAULT_FONT_SIZE"]
}
