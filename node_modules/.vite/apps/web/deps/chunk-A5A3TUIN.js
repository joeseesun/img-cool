import {
  pointsOnBezierCurves
} from "./chunk-4TU3NFLN.js";
import {
  DEFAULT_FONT_SIZE,
  FontSizes,
  MarkTypes,
  PlaitMarkEditor,
  TEXT_DEFAULT_HEIGHT,
  getFirstTextMarks
} from "./chunk-6RPCEARB.js";
import {
  BoardCreationMode,
  CommonElementFlavour,
  DEFAULT_FONT_FAMILY,
  Generator,
  ImageGenerator,
  PropertyTransforms,
  RESIZE_HANDLE_DIAMETER,
  StrokeStyle,
  TRANSPARENT,
  TextManage,
  WithTextPluginKey,
  acceptImageTypes,
  addElementOfFocusedImage,
  buildImage,
  buildText,
  getElementOfFocusedImage,
  getElementSize,
  getElementsText,
  getFirstTextManage,
  getRectangleResizeHandleRefs,
  getStrokeLineDash,
  getXDistanceBetweenPoint,
  isDelete,
  isDndMode,
  isDrawingMode,
  isEnterHotkey,
  isExpandHotkey,
  isResizing,
  isSpaceHotkey,
  isTabHotkey,
  isVirtualKey,
  measureElement,
  moveXOfPoint,
  moveYOfPoint,
  removeElementOfFocusedImage,
  setCreationMode,
  withResize
} from "./chunk-NNVG7YTJ.js";
import {
  Node as Node2,
  Path as Path2
} from "./chunk-OBPCNI2P.js";
import {
  ACTIVE_STROKE_WIDTH,
  BoardTransforms,
  ColorfulThemeColor,
  CoreTransforms,
  DEFAULT_COLOR,
  DarkThemeColor,
  DefaultThemeColor,
  NODE_TO_INDEX,
  NODE_TO_PARENT,
  Path,
  PlaitBoard,
  PlaitElement,
  PlaitHistoryBoard,
  PlaitNode,
  PlaitPointerType,
  Point,
  RectangleClient,
  ResizeCursorClass,
  RetroThemeColor,
  SELECTION_RECTANGLE_CLASS_NAME,
  SoftThemeColor,
  StarryThemeColor,
  Transforms,
  WritableClipboardOperationType,
  WritableClipboardType,
  addOrCreateClipboardContext,
  addSelectedElement,
  clearSelectedElement,
  createClipboardContext,
  createForeignObject,
  createG,
  createText,
  depthFirstRecursion,
  distanceBetweenPointAndPoint,
  distanceBetweenPointAndRectangle,
  drawBezierPath,
  drawLinearPath,
  drawRoundRectangle,
  getHitElementByPoint,
  getI18nValue,
  getIsRecursionFunc,
  getRectangleByElements,
  getSelectedElements,
  hotkeys,
  idCreator,
  isContextmenu,
  isDragging,
  isMainPointer,
  isMovingElements,
  isNullOrUndefined,
  isSelectedElement,
  isSelectionMoving,
  removeSelectedElement,
  rgbaToHEX,
  setDragging,
  setStrokeLinecap,
  temporaryDisableSelection,
  throttleRAF,
  toActivePointFromViewBoxPoint,
  toActiveRectangleFromViewBoxRectangle,
  toHostPoint,
  toViewBoxPoint,
  updateForeignObject
} from "./chunk-6V4XCDNF.js";
import {
  require_lib
} from "./chunk-R23N5LB2.js";
import {
  __toESM
} from "./chunk-2TUXWMP5.js";

// ../../node_modules/@plait/layouts/fesm2022/plait-layouts.mjs
var AbstractNode = {
  isAbstract(value) {
    if (typeof value.start === "number" && typeof value.end === "number") {
      return true;
    } else {
      return false;
    }
  }
};
var MindLayoutType;
(function(MindLayoutType2) {
  MindLayoutType2["right"] = "right";
  MindLayoutType2["left"] = "left";
  MindLayoutType2["standard"] = "standard";
  MindLayoutType2["upward"] = "upward";
  MindLayoutType2["downward"] = "downward";
  MindLayoutType2["rightBottomIndented"] = "right-bottom-indented";
  MindLayoutType2["rightTopIndented"] = "right-top-indented";
  MindLayoutType2["leftTopIndented"] = "left-top-indented";
  MindLayoutType2["leftBottomIndented"] = "left-bottom-indented";
})(MindLayoutType || (MindLayoutType = {}));
var LayoutType;
(function(LayoutType2) {
  LayoutType2["logic"] = "logic";
  LayoutType2["indented"] = "indented";
  LayoutType2["fishBone"] = "fish-bone";
})(LayoutType || (LayoutType = {}));
function findLayoutType(node) {
  if (node.origin.layout) {
    return node.origin.layout;
  }
  if (AbstractNode.isAbstract(node.origin)) {
    return getAbstractLayout(findLayoutType(node.parent));
  }
  if (node.parent) {
    return findLayoutType(node.parent);
  }
  return null;
}
var isIndentedLayout = (layout2) => {
  return layout2 === MindLayoutType.rightBottomIndented || layout2 === MindLayoutType.rightTopIndented || layout2 === MindLayoutType.leftBottomIndented || layout2 === MindLayoutType.leftTopIndented;
};
var isLogicLayout = (layout2) => {
  return layout2 === MindLayoutType.right || layout2 === MindLayoutType.left || layout2 === MindLayoutType.downward || layout2 === MindLayoutType.upward;
};
var isStandardLayout = (layout2) => {
  return layout2 === MindLayoutType.standard;
};
var isHorizontalLayout = (layout2) => {
  return layout2 === MindLayoutType.right || layout2 === MindLayoutType.left || layout2 === MindLayoutType.standard || isIndentedLayout(layout2);
};
var isHorizontalLogicLayout = (layout2) => {
  return layout2 === MindLayoutType.right || layout2 === MindLayoutType.left || layout2 === MindLayoutType.standard;
};
var isVerticalLogicLayout = (layout2) => {
  return layout2 === MindLayoutType.upward || layout2 === MindLayoutType.downward;
};
var isTopLayout = (layout2) => {
  return layout2 === MindLayoutType.leftTopIndented || layout2 === MindLayoutType.rightTopIndented || layout2 === MindLayoutType.upward;
};
var isBottomLayout = (layout2) => {
  return layout2 === MindLayoutType.leftBottomIndented || layout2 === MindLayoutType.rightBottomIndented || layout2 === MindLayoutType.downward;
};
var isLeftLayout = (layout2) => {
  return layout2 === MindLayoutType.left || layout2 === MindLayoutType.leftTopIndented || layout2 === MindLayoutType.leftBottomIndented;
};
var isRightLayout = (layout2) => {
  return layout2 === MindLayoutType.right || layout2 === MindLayoutType.rightTopIndented || layout2 === MindLayoutType.rightBottomIndented;
};
var extractLayoutType = (mindLayoutType) => {
  if (isIndentedLayout(mindLayoutType)) {
    return LayoutType.indented;
  }
  if (isStandardLayout(mindLayoutType)) {
    return LayoutType.logic;
  }
  if (isLogicLayout(mindLayoutType)) {
    return LayoutType.logic;
  }
  return LayoutType.logic;
};
var getAbstractLayout = (parentLayout) => {
  if (isIndentedLayout(parentLayout)) {
    if (isRightLayout(parentLayout)) {
      return MindLayoutType.right;
    } else {
      return MindLayoutType.left;
    }
  }
  return parentLayout;
};
var LayoutNode = class {
  constructor(origin, options, context, parent) {
    this.x = 0;
    this.y = 0;
    this.vGap = 0;
    this.hGap = 0;
    this.width = 0;
    this.height = 0;
    this.depth = 0;
    this.children = [];
    this.left = false;
    this.up = false;
    const hGap = options.getHorizontalGap(origin, parent);
    const vGap = options.getVerticalGap(origin, parent);
    this.origin = origin;
    this.width = options.getWidth(origin);
    this.height = options.getHeight(origin);
    this.x = this.y = 0;
    if (parent) {
      this.parent = parent;
    }
    const layout2 = findLayoutType(this);
    this.layout = layout2 && layout2 !== MindLayoutType.standard ? layout2 : context.rootLayoutType;
    const verticalConnectingPosition = options.getVerticalConnectingPosition(origin, parent);
    if (verticalConnectingPosition) {
      this.verticalConnectingPosition = verticalConnectingPosition;
    }
    this.addGap(hGap, vGap);
  }
  isRoot() {
    return this.depth === 0;
  }
  addGap(hGap, vGap) {
    const me = this;
    me.hGap += hGap;
    me.vGap += vGap;
    me.width += 2 * hGap;
    me.height += 2 * vGap;
  }
  eachNode(callback) {
    depthFirstRecursion2(this, callback);
  }
  getBoundingBox() {
    const bb = {
      left: Number.MAX_VALUE,
      top: Number.MAX_VALUE,
      right: Number.MIN_VALUE,
      bottom: Number.MIN_VALUE,
      width: 0,
      height: 0
    };
    this.eachNode((node) => {
      bb.left = Math.min(bb.left, node.x);
      bb.top = Math.min(bb.top, node.y);
      bb.right = Math.max(bb.right, node.x + node.width);
      bb.bottom = Math.max(bb.bottom, node.y + node.height);
    });
    bb.width = bb.right - bb.left;
    bb.height = bb.bottom - bb.top;
    return bb;
  }
  translate(tx = 0, ty = 0) {
    this.eachNode((node) => {
      node.x += tx;
      node.y += ty;
    });
  }
  right2left() {
    const me = this;
    const bb = me.getBoundingBox();
    me.eachNode((node) => {
      node.x = node.x - (node.x - bb.left) * 2 - node.width;
      node.left = true;
    });
    me.translate(bb.width, 0);
  }
  down2up() {
    const me = this;
    const bb = me.getBoundingBox();
    me.eachNode((node) => {
      node.y = node.y - (node.y - bb.top) * 2 - node.height;
      node.up = true;
    });
    me.translate(0, bb.height);
  }
};
function depthFirstRecursion2(node, callback) {
  var _a;
  (_a = node.children) == null ? void 0 : _a.forEach((child) => {
    depthFirstRecursion2(child, callback);
  });
  callback(node);
}
var LayoutBlockNode = class {
  constructor(left, right, top, bottom, width, height, rootX, rootY, rootWidth, rootHeight) {
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.width = width;
    this.height = height;
    this.rootX = rootX;
    this.rootY = rootY;
    this.rootWidth = rootWidth;
    this.rootHeight = rootHeight;
  }
};
function toHorizontal(black) {
  return {
    left: black.top,
    right: black.bottom,
    top: black.left,
    bottom: black.right,
    width: black.height,
    height: black.width,
    rootX: black.rootY,
    rootY: black.rootX,
    rootWidth: black.rootHeight,
    rootHeight: black.rootWidth
  };
}
var ConnectingPosition;
(function(ConnectingPosition2) {
  ConnectingPosition2["middle"] = "middle";
  ConnectingPosition2["bottom"] = "bottom";
})(ConnectingPosition || (ConnectingPosition = {}));
var LayoutTreeNode = class {
  constructor(width, height, y, children, origin) {
    this.width = width;
    this.height = height;
    this.y = y;
    this.children = children;
    this.childrenCount = children.length;
    this.x = 0;
    this.preliminary = 0;
    this.modifier = 0;
    this.shift = 0;
    this.change = 0;
    this.tl = null;
    this.tr = null;
    this.el = null;
    this.er = null;
    this.msel = 0;
    this.mser = 0;
    this.origin = origin;
  }
};
var getNonAbstractChildren = (parentNode) => {
  var _a;
  if (parentNode.children) {
    return (_a = parentNode.children) == null ? void 0 : _a.filter((child) => {
      if (child instanceof LayoutNode) {
        return !AbstractNode.isAbstract(child.origin);
      }
      if (child instanceof LayoutTreeNode) {
        return !AbstractNode.isAbstract(child.origin.origin);
      }
      return !AbstractNode.isAbstract(child);
    });
  } else {
    return [];
  }
};
var findAbstractByEndNode = (parentNode, endNode) => {
  const index = parentNode.children.indexOf(endNode);
  return parentNode.children.find((child) => {
    if (child instanceof LayoutNode) {
      return AbstractNode.isAbstract(child.origin) && child.origin.end === index;
    }
    if (child instanceof LayoutTreeNode && parentNode instanceof LayoutTreeNode) {
      if (AbstractNode.isAbstract(child.origin.origin)) {
        const { end } = getCorrectStartEnd(child.origin.origin, parentNode.origin);
        return end === index;
      }
      return false;
    }
    return AbstractNode.isAbstract(child) && child.end === index;
  });
};
var findAbstractByStartNode = (parentNode, startNode) => {
  const index = parentNode.children.indexOf(startNode);
  return parentNode.children.find((child) => {
    if (child instanceof LayoutNode) {
      return AbstractNode.isAbstract(child.origin) && child.origin.start === index;
    }
    if (child instanceof LayoutTreeNode && parentNode instanceof LayoutTreeNode) {
      if (AbstractNode.isAbstract(child.origin.origin)) {
        const { start } = getCorrectStartEnd(child.origin.origin, parentNode.origin);
        return start === index;
      }
      return false;
    }
    return AbstractNode.isAbstract(child) && child.start === index;
  });
};
var getCorrectStartEnd = (abstract, parent) => {
  let start = abstract.start;
  let end = abstract.end;
  if (isStandardLayout(parent.layout)) {
    const rightNodeCount = parent.origin.rightNodeCount;
    if (start >= rightNodeCount) {
      end -= rightNodeCount;
      start -= rightNodeCount;
    }
  }
  return { start, end };
};
function moveSubtree(treeNode, i, distance) {
  treeNode.children[i].modifier += distance;
}
function nextLeftContour(treeNode) {
  return treeNode.childrenCount === 0 ? null : treeNode.children[0];
}
function nextRightContour(treeNode) {
  let children = getNonAbstractChildren(treeNode);
  return treeNode.childrenCount === 0 ? null : children[children.length - 1];
}
function separate(treeNode, i) {
  if (AbstractNode.isAbstract(treeNode.children[i].origin.origin)) {
    return;
  }
  let leftNode = treeNode.children[i - 1];
  let rightNode = treeNode.children[i];
  let rightContourOfLeftNode = leftNode.modifier + leftNode.preliminary + leftNode.width;
  let leftContourOfRightNode = rightNode.modifier + rightNode.preliminary;
  let sumOfLeftModifier = 0;
  let leftNodeParent = treeNode;
  let rightNodeParent = treeNode;
  while (leftNode || rightNode) {
    if (leftNode) {
      let right = sumOfLeftModifier + leftNode.modifier + leftNode.preliminary + leftNode.width;
      if (right > rightContourOfLeftNode) {
        rightContourOfLeftNode = right;
      }
      rightContourOfLeftNode = compareAbstractRight(leftNodeParent, leftNode, rightContourOfLeftNode, sumOfLeftModifier);
      leftNodeParent = leftNode;
      sumOfLeftModifier = leftNode.modifier + sumOfLeftModifier;
      leftNode = nextRightContour(leftNode);
    }
    if (rightNode) {
      let left = rightNode.modifier + rightNode.preliminary;
      if (left < leftContourOfRightNode) {
        leftContourOfRightNode = left;
      }
      leftContourOfRightNode = compareAbstractLeft(rightNodeParent, rightNode, leftContourOfRightNode);
      rightNodeParent = rightNode;
      rightNode = nextLeftContour(rightNode);
    }
  }
  const distance = rightContourOfLeftNode - leftContourOfRightNode;
  if (distance > 0) {
    moveSubtree(treeNode, i, distance);
  }
}
function positionRootCenter(treeNode) {
  const startNode = treeNode.children[0];
  let startX = startNode.preliminary + startNode.modifier;
  const children = getNonAbstractChildren(treeNode);
  const endNode = children[children.length - 1];
  let endX = endNode.modifier + endNode.preliminary + endNode.width;
  if (startNode.origin.blackNode && startNode.origin.blackNode.rootX > startNode.origin.blackNode.left) {
    startX = startX + (startNode.origin.blackNode.rootX - startNode.origin.blackNode.left);
  }
  if (endNode.origin.blackNode && endNode.origin.blackNode.rootX + endNode.origin.blackNode.rootWidth < endNode.origin.blackNode.right) {
    endX = endX - (endNode.origin.blackNode.right - (endNode.origin.blackNode.rootX + endNode.origin.blackNode.rootWidth));
  }
  if (startNode.origin.verticalConnectingPosition && endNode.origin.verticalConnectingPosition) {
    startX = startX + startNode.width - startNode.origin.vGap;
    endX = endX - endNode.origin.vGap;
  }
  let treeNodeOffset = treeNode.width / 2;
  if (treeNode.origin.verticalConnectingPosition) {
    treeNodeOffset = treeNode.width - treeNode.origin.vGap;
  }
  const preliminary = (startX + endX) / 2 - treeNodeOffset;
  if (preliminary > 0) {
    treeNode.preliminary = preliminary;
  } else {
    treeNode.children.forEach((c, index) => {
      moveSubtree(treeNode, index, Math.abs(preliminary));
    });
  }
}
function firstWalk(treeNode) {
  if (treeNode.childrenCount === 0) {
    return;
  }
  firstWalk(treeNode.children[0]);
  for (let i = 1; i < treeNode.childrenCount; i++) {
    const abstract = treeNode.children.find((abstract2) => {
      let correctEnd = null;
      if (AbstractNode.isAbstract(abstract2.origin.origin)) {
        let { end } = getCorrectStartEnd(abstract2.origin.origin, treeNode.origin);
        correctEnd = end;
      }
      return correctEnd === i - 1;
    });
    if (abstract) {
      abstractHandle$1(treeNode, abstract, i);
    }
    firstWalk(treeNode.children[i]);
    separate(treeNode, i);
  }
  positionRootCenter(treeNode);
}
function secondWalk(treeNode, sumOfModifier) {
  sumOfModifier += treeNode.modifier;
  treeNode.x = treeNode.preliminary + sumOfModifier;
  for (let i = 0; i < treeNode.childrenCount; i++) {
    secondWalk(treeNode.children[i], sumOfModifier);
  }
}
function abstractHandle$1(treeNode, abstract, i) {
  const { start, end } = getCorrectStartEnd(abstract.origin.origin, treeNode.origin);
  const abstractIndex = treeNode.children.indexOf(abstract);
  const startNode = treeNode.children[start];
  let endNode = treeNode.children[end];
  const includeElementStartX = startNode.modifier;
  let includeElementEndX = endNode.modifier + endNode.preliminary + endNode.width;
  let sumOfLeftModifier = endNode.modifier;
  let nodeParent = treeNode;
  treeNode.children[abstractIndex].modifier = startNode.modifier;
  while (endNode.childrenCount) {
    nodeParent = endNode;
    const nexRightNode = nextRightContour(endNode);
    endNode = nexRightNode ? nexRightNode : endNode;
    let right = sumOfLeftModifier + endNode.modifier + endNode.preliminary + endNode.width;
    includeElementEndX = compareAbstractRight(nodeParent, endNode, includeElementEndX, sumOfLeftModifier);
    sumOfLeftModifier += endNode.modifier;
    if (right > includeElementEndX) {
      includeElementEndX = right;
    }
  }
  const abstractBranchWidth = abstract.origin.blackNode ? abstract.origin.blackNode.rootX * 2 + abstract.origin.blackNode.rootWidth : abstract.width;
  const abstractIncludeElementWidth = includeElementEndX - includeElementStartX;
  if (abstractIncludeElementWidth > abstractBranchWidth) {
    const distance = (abstractIncludeElementWidth - abstractBranchWidth) / 2;
    moveSubtree(treeNode, abstractIndex, distance);
  } else {
    const distance = (abstractBranchWidth - abstractIncludeElementWidth) / 2;
    for (let i2 = start; i2 < end + 1; i2++) {
      moveSubtree(treeNode, i2, distance);
    }
  }
}
function compareAbstractRight(nodeParent, node, compareTarget, sumOfAbstractModifier) {
  const abstract = findAbstractByEndNode(nodeParent, node);
  if (abstract) {
    return Math.max(abstract.modifier + abstract.width + sumOfAbstractModifier, compareTarget);
  }
  return compareTarget;
}
function compareAbstractLeft(nodeParent, node, compareTarget) {
  const abstract = findAbstractByStartNode(nodeParent, node);
  if (abstract) {
    return Math.min(abstract.modifier + abstract.preliminary, compareTarget);
  }
  return compareTarget;
}
function layout(treeNode) {
  firstWalk(treeNode);
  secondWalk(treeNode, 0);
}
function separateXAxle(node, d = 0) {
  node.x = d;
  node.children.forEach((child) => {
    if (AbstractNode.isAbstract(child.origin)) {
      let width = 0;
      for (let i = child.origin.start; i <= child.origin.end; i++) {
        const box = node.children[i].getBoundingBox();
        width = Math.max(box.width, width);
      }
      separateXAxle(child, node.x + node.width / 2 + width);
    } else {
      separateXAxle(child, node.x + node.width / 2);
    }
  });
}
function separateYAxle$1(root, options) {
  let previousBottom = root.y + root.height;
  let previousNode = null;
  updateY(root);
  function updateY(node) {
    node.children.forEach((child, index) => {
      const abstract = node.children.find((child2) => {
        return AbstractNode.isAbstract(child2.origin) && child2.origin.end === index - 1;
      });
      if (abstract) {
        const attach = (previousNode == null ? void 0 : previousNode.origin.isCollapsed) ? options.getExtendHeight(child.origin) : 0;
        previousBottom = abstractHandle(node, abstract) + attach;
      }
      if (AbstractNode.isAbstract(child.origin)) {
        return;
      }
      let y = previousBottom + child.vGap;
      if (previousNode && !isHorizontalLogicLayout(previousNode.layout) && previousNode.origin.children.length > 0) {
        if (previousNode.origin.isCollapsed) {
          y = y + options.getExtendHeight(child.origin);
        } else {
          y = y + options.getIndentedCrossLevelGap();
        }
      }
      child.y = y;
      previousNode = child;
      previousBottom = child.y + child.height;
      updateY(child);
    });
  }
}
function abstractHandle(node, abstract) {
  const abstractNode = abstract.origin;
  const abstractIndex = node.children.indexOf(abstract);
  const startNode = node.children[abstractNode.start];
  const endNode = node.children[abstractNode.end];
  node.children[abstractIndex].y = startNode.y;
  const topContour = startNode.y;
  let bottomContour = endNode.y + endNode.height;
  let bottomContourNode = endNode;
  let bottomContourParenNode = node;
  while (bottomContourNode == null ? void 0 : bottomContourNode.children.length) {
    bottomContourParenNode = bottomContourNode;
    const children = getNonAbstractChildren(bottomContourParenNode);
    bottomContourNode = children[children.length - 1];
    const abstract2 = findAbstractByEndNode(bottomContourParenNode, bottomContourNode);
    bottomContour = abstract2 ? Math.max(abstract2.y + abstract2.height, bottomContourNode.y + bottomContourNode.height) : bottomContourNode.y + bottomContourNode.height;
  }
  const abstractIncludedHeight = bottomContour - topContour;
  const abstractHeight = abstract.blackNode ? abstract.blackNode.height : abstract.height;
  const abstractBranchHeight = abstract.blackNode ? abstract.blackNode.rootY * 2 + abstract.blackNode.rootHeight : abstract.height;
  if (abstractBranchHeight > abstractIncludedHeight) {
    const distance = (abstractBranchHeight - abstractIncludedHeight) / 2;
    for (let i = abstractNode.start; i <= abstractNode.end; i++) {
      node.children[i].eachNode((child) => {
        child.y += distance;
      });
    }
  } else {
    const distance = (abstractIncludedHeight - abstractBranchHeight) / 2;
    node.children[abstractIndex].y += distance;
  }
  return Math.max(abstract.y + abstractHeight, startNode.y + abstractIncludedHeight);
}
function setLayoutTreeResult(tree, root, isHorizontal) {
  if (isHorizontal) {
    root.y = tree.x;
  } else {
    root.x = tree.x;
  }
  tree.children.forEach((child, i) => {
    setLayoutTreeResult(child, root.children[i], isHorizontal);
  });
}
function separateYAxle(node, isHorizontal, d = 0) {
  var _a, _b;
  if (isHorizontal) {
    if (AbstractNode.isAbstract(node.origin)) {
      const { start, end } = getCorrectStartEnd(node.origin, node.parent);
      for (let i = start; i <= end; i++) {
        const right = (_a = node.parent) == null ? void 0 : _a.children[i].getBoundingBox().right;
        d = Math.max(right, d);
      }
    }
    node.x = d;
    d += node.width;
  } else {
    if (AbstractNode.isAbstract(node.origin)) {
      for (let i = node.origin.start; i <= node.origin.end; i++) {
        const bottom = (_b = node.parent) == null ? void 0 : _b.children[i].getBoundingBox().bottom;
        d = Math.max(bottom, d);
      }
    }
    node.y = d;
    d += node.height;
  }
  node.children.forEach((child) => {
    separateYAxle(child, isHorizontal, d);
  });
}
var buildLayoutTree = (root, isHorizontal) => {
  const children = [];
  root.children.forEach((child) => {
    children.push(buildLayoutTree(child, isHorizontal));
  });
  if (isHorizontal) {
    if (root.blackNode) {
      root.blackNode = toHorizontal(root.blackNode);
    }
    return new LayoutTreeNode(root.height, root.width, root.x, children, root);
  }
  return new LayoutTreeNode(root.width, root.height, root.y, children, root);
};
var BaseLayout = class {
  constructor() {
  }
  layout(node, layoutType, options, context, isHorizontal = false, parent) {
    const isolatedNodes = [];
    const isolatedLayoutRoots = [];
    const root = this.buildLayoutNode(node, options, context, isolatedNodes, parent);
    isolatedNodes.filter((v) => v.origin.children.length > 0).forEach((isolatedNode) => {
      const _mindLayoutType = isolatedNode.layout;
      const toTop = context.toTop || isHorizontalLayout(context.rootLayoutType) && isTopLayout(_mindLayoutType);
      const toLeft = context.toLeft || !isHorizontalLayout(context.rootLayoutType) && isLeftLayout(_mindLayoutType);
      const _isHorizontal = isHorizontalLayout(_mindLayoutType);
      const isolatedRoot = this.layout(isolatedNode.origin, extractLayoutType(_mindLayoutType), options, { toTop, toLeft, rootLayoutType: context.rootLayoutType }, _isHorizontal, isolatedNode.parent);
      if (!context.toTop && toTop && layoutType !== LayoutType.indented) {
        isolatedRoot.down2up();
      }
      if (!context.toLeft && toLeft) {
        isolatedRoot.right2left();
      }
      const boundingBox = isolatedRoot.getBoundingBox();
      isolatedNode.width = boundingBox.width;
      isolatedNode.height = boundingBox.height;
      isolatedNode.blackNode = new LayoutBlockNode(boundingBox.left, boundingBox.right, boundingBox.top, boundingBox.bottom, boundingBox.width, boundingBox.height, isolatedRoot.x, isolatedRoot.y, isolatedRoot.width, isolatedRoot.height);
      isolatedLayoutRoots.push(isolatedRoot);
    });
    switch (layoutType) {
      case LayoutType.indented:
        separateXAxle(root);
        separateYAxle$1(root, options);
        break;
      case LayoutType.fishBone:
        break;
      case LayoutType.logic:
      default:
        separateYAxle(root, isHorizontal);
        const layoutTree = buildLayoutTree(root, isHorizontal);
        layout(layoutTree);
        setLayoutTreeResult(layoutTree, root, isHorizontal);
        break;
    }
    const attachedMetaOfIsolatedNodes = [];
    isolatedNodes.filter((v) => v.origin.children.length > 0).forEach((isolatedNode, index) => {
      if (isolatedNode.parent) {
        const layoutRoot = isolatedLayoutRoots[index];
        layoutRoot.parent = isolatedNode.parent;
        let offsetX, offsetY;
        const parentNodeIsHorizontalLayout = isHorizontalLayout(isolatedNode.parent.layout);
        if (parentNodeIsHorizontalLayout) {
          offsetX = layoutRoot.x;
          offsetY = 0;
        } else {
          offsetX = 0;
          offsetY = layoutRoot.y;
        }
        layoutRoot.translate(isolatedNode.x - offsetX, isolatedNode.y - offsetY);
        const _index = isolatedNode.parent.children.indexOf(isolatedNode);
        const oldNode = isolatedNode.parent.children[_index];
        isolatedNode.parent.children[_index] = Object.assign(oldNode, layoutRoot);
        const meta = attachedMetaOfIsolatedNodes.find((m) => m.parent === isolatedNode.parent && !AbstractNode.isAbstract(isolatedNode.origin));
        if (meta) {
          if (meta.offsetX < offsetX) {
            meta.offsetX = offsetX;
          }
          if (meta.offsetX < offsetY) {
            meta.offsetX = offsetY;
          }
        } else if (!AbstractNode.isAbstract(isolatedNode.origin)) {
          attachedMetaOfIsolatedNodes.push({ parent: isolatedNode.parent, offsetX, offsetY });
        }
      }
    });
    attachedMetaOfIsolatedNodes.forEach((meta) => {
      meta.parent.children.forEach((child) => child.translate(meta.offsetX, meta.offsetY));
    });
    return root;
  }
  buildLayoutNode(origin, options, context, isolatedNodes, parent) {
    const root = new LayoutNode(origin, options, context, parent);
    if (!root.origin.isCollapsed) {
      const nodes = [root];
      let node;
      while (node = nodes.pop()) {
        if (!node.origin.isCollapsed) {
          const children = node.origin.children;
          const length = children ? children.length : 0;
          node.children = [];
          if (children && length) {
            for (let i = 0; i < length; i++) {
              const child = new LayoutNode(children[i], options, context, node);
              node.children.push(child);
              child.depth = node.depth + 1;
              const isolated = node.layout !== child.layout && (extractLayoutType(node.layout) !== extractLayoutType(child.layout) || isHorizontalLayout(node.layout) !== isHorizontalLayout(child.layout)) || AbstractNode.isAbstract(child.origin);
              if (isolated && !child.origin.isCollapsed) {
                isolatedNodes.push(child);
              } else {
                nodes.push(child);
              }
            }
          }
        }
      }
    }
    return root;
  }
};
var GlobalLayout = class {
  static layout(root, options, mindLayoutType) {
    const baseLayout = new BaseLayout();
    if (isStandardLayout(mindLayoutType)) {
      const primaryNodeCount = root.children.length;
      const rightBranchNodes = [];
      const leftBranchNodes = [];
      const fakeRootNode = { ...root };
      for (let i = 0; i < primaryNodeCount; i++) {
        const child = root.children[i];
        if (AbstractNode.isAbstract(child) && child.end < root.rightNodeCount) {
          rightBranchNodes.push(child);
          continue;
        }
        if (AbstractNode.isAbstract(child) && child.start >= root.rightNodeCount) {
          leftBranchNodes.push(child);
          continue;
        }
        if (i < root.rightNodeCount) {
          rightBranchNodes.push(child);
        } else {
          leftBranchNodes.push(child);
        }
      }
      fakeRootNode.children = rightBranchNodes;
      const rightRoot = baseLayout.layout(fakeRootNode, LayoutType.logic, options, { toLeft: false, toTop: false, rootLayoutType: mindLayoutType }, true);
      fakeRootNode.children = leftBranchNodes;
      const leftRoot = baseLayout.layout(fakeRootNode, LayoutType.logic, options, { toLeft: true, toTop: false, rootLayoutType: mindLayoutType }, true);
      leftRoot.right2left();
      rightRoot.translate(leftRoot.x - rightRoot.x, leftRoot.y - rightRoot.y);
      const rightAbstractArray = rightRoot.children.filter((child) => AbstractNode.isAbstract(child.origin));
      rightRoot.children = rightRoot.children.filter((child) => !AbstractNode.isAbstract(child.origin));
      leftRoot.children.forEach((leftPrimaryNode) => {
        rightRoot.children.push(leftPrimaryNode);
        leftPrimaryNode.parent = rightRoot;
      });
      rightRoot.children = rightRoot.children.concat(rightAbstractArray);
      rightRoot.x = leftRoot.x;
      rightRoot.origin = root;
      return rightRoot;
    }
    const isIndented = isIndentedLayout(mindLayoutType);
    const layoutType = isIndented ? LayoutType.indented : LayoutType.logic;
    const isHorizontal = isIndented ? true : isHorizontalLayout(mindLayoutType);
    const toTop = isTopLayout(mindLayoutType);
    const toLeft = isLeftLayout(mindLayoutType);
    const resultRoot = baseLayout.layout(root, layoutType, options, { toTop, toLeft, rootLayoutType: mindLayoutType }, isHorizontal);
    if (toTop) {
      resultRoot.down2up();
    }
    if (toLeft) {
      resultRoot.right2left();
    }
    return resultRoot;
  }
};

// ../../node_modules/@plait/mind/fesm2022/plait-mind.mjs
var import_is_hotkey = __toESM(require_lib(), 1);
var ELEMENT_TO_NODE = /* @__PURE__ */ new WeakMap();
var MindNode = {
  get(root, path) {
    let node = root;
    for (let i = 0; i < path.length; i++) {
      const p = path[i];
      if (!node || !node.children || !node.children[p]) {
        throw new Error(`Cannot find a descendant at path [${path}]`);
      }
      node = node.children[p];
    }
    return node;
  }
};
var LayoutDirection;
(function(LayoutDirection2) {
  LayoutDirection2["top"] = "top";
  LayoutDirection2["right"] = "right";
  LayoutDirection2["bottom"] = "bottom";
  LayoutDirection2["left"] = "left";
})(LayoutDirection || (LayoutDirection = {}));
var LayoutDirectionsMap = {
  [MindLayoutType.right]: [LayoutDirection.right],
  [MindLayoutType.left]: [LayoutDirection.left],
  [MindLayoutType.upward]: [LayoutDirection.top],
  [MindLayoutType.downward]: [LayoutDirection.bottom],
  [MindLayoutType.rightBottomIndented]: [LayoutDirection.right, LayoutDirection.bottom],
  [MindLayoutType.rightTopIndented]: [LayoutDirection.right, LayoutDirection.top],
  [MindLayoutType.leftBottomIndented]: [LayoutDirection.left, LayoutDirection.bottom],
  [MindLayoutType.leftTopIndented]: [LayoutDirection.left, LayoutDirection.top]
};
var MindPointerType;
(function(MindPointerType2) {
  MindPointerType2["mind"] = "mind";
})(MindPointerType || (MindPointerType = {}));
var DEFAULT_BRANCH_COLORS = [
  "#A287E0",
  "#6E80DB",
  "#6DC4C4",
  "#E0B75E",
  "#B1C675",
  "#77C386",
  "#C18976",
  "#E48484",
  "#E582D4",
  "#6AB1E4"
];
var COLORFUL_BRANCH_COLORS = [
  "#F94239",
  "#FF8612",
  "#F3D222",
  "#B3D431",
  "#00BC7B",
  "#06ADBF",
  "#476BFF",
  "#4E49BE",
  "#8957E5",
  "#FE5DA1"
];
var SOFT_BRANCH_COLORS = [
  "#6D89C1",
  "#F2BDC7",
  "#B796D9",
  "#5BA683",
  "#B3D431 ",
  "#F2DC6C",
  "#F7C98D",
  "#60B4D1",
  "#838F9E",
  "#C1A381"
];
var RETRO_BRANCH_COLORS = [
  "#459476",
  "#9A894F",
  "#D48444",
  "#E9C358 ",
  "#4B9D9D",
  "#C14C41",
  "#827086 ",
  "#60718D",
  "#D38183",
  "#9DC19D"
];
var DARK_BRANCH_COLORS = [
  "#3DD1AE",
  "#F6C659",
  "#A9E072",
  "#FF877B ",
  "#F693E7",
  "#5DCFFF",
  "#868AF6",
  "#4C6DC7",
  "#D97C26",
  "#268FAC"
];
var STARRY_BRANCH_COLORS = [
  "#E46C57",
  "#579360",
  "#B98339",
  "#3A62D1 ",
  "#B883B7",
  "#42ABE5",
  "#2B9D8F",
  "#A4705E",
  "#265833",
  "#787865"
];
var MindDefaultThemeColor = {
  ...DefaultThemeColor,
  branchColors: DEFAULT_BRANCH_COLORS,
  rootFill: "#f5f5f5",
  rootTextColor: DEFAULT_COLOR
};
var MindColorfulThemeColor = {
  ...ColorfulThemeColor,
  branchColors: COLORFUL_BRANCH_COLORS,
  rootFill: DEFAULT_COLOR,
  rootTextColor: "#FFFFFF"
};
var MindSoftThemeColor = {
  ...SoftThemeColor,
  branchColors: SOFT_BRANCH_COLORS,
  rootFill: "#FFFFFF",
  rootTextColor: DEFAULT_COLOR
};
var MindRetroThemeColor = {
  ...RetroThemeColor,
  branchColors: RETRO_BRANCH_COLORS,
  rootFill: "#153D5D",
  rootTextColor: "#FFFFFF"
};
var MindDarkThemeColor = {
  ...DarkThemeColor,
  branchColors: DARK_BRANCH_COLORS,
  rootFill: "#FFFFFF",
  rootTextColor: DEFAULT_COLOR
};
var MindStarryThemeColor = {
  ...StarryThemeColor,
  branchColors: STARRY_BRANCH_COLORS,
  rootFill: "#FFFFFF",
  rootTextColor: DEFAULT_COLOR
};
var MindThemeColors = [
  MindDefaultThemeColor,
  MindColorfulThemeColor,
  MindSoftThemeColor,
  MindRetroThemeColor,
  MindDarkThemeColor,
  MindStarryThemeColor
];
var MindThemeColor = {
  isMindThemeColor(value) {
    if (value.branchColors && value.rootFill && value.rootTextColor) {
      return true;
    } else {
      return false;
    }
  }
};
var WithMindPluginKey = "plait-mind-plugin-key";
var BASE = 4;
var PRIMARY_COLOR = "#6698FF";
var GRAY_COLOR = "#AAAAAA";
var STROKE_WIDTH = 2;
var RESIZE_HANDLE_BUFFER_DISTANCE = 8;
var NODE_MORE_LINE_DISTANCE = 10;
var NODE_MORE_STROKE_WIDTH = 2;
var NODE_MORE_ICON_DIAMETER = 20;
var NODE_MORE_BRIDGE_DISTANCE = 10;
var NODE_ADD_CIRCLE_COLOR = rgbaToHEX("#000000", 0.2);
var NODE_ADD_HOVER_COLOR = "#6698FF";
var NODE_ADD_INNER_CROSS_COLOR = "white";
var DEFAULT_MIND_IMAGE_WIDTH = 240;
var MindI18nKey;
(function(MindI18nKey2) {
  MindI18nKey2["mindCentralText"] = "mind-center-text";
  MindI18nKey2["abstractNodeText"] = "abstract-node-text";
})(MindI18nKey || (MindI18nKey = {}));
function getEmojisWidthHeight(board, element) {
  const options = board.getPluginOptions(WithMindPluginKey);
  const count = element.data.emojis.length;
  const fontSize = getEmojiFontSize(element);
  return {
    width: fontSize * count + count * 2 * options.emojiPadding + (count - 1) * options.spaceBetweenEmojis,
    height: element.height
  };
}
function getEmojiFontSize(element) {
  if (PlaitMind.isMind(element)) {
    return 18 + 2;
  } else {
    return 14 + 2;
  }
}
var getAvailableProperty = (board, element, propertyKey) => {
  return element[propertyKey];
};
var DefaultAbstractNodeStyle = {
  branch: { color: GRAY_COLOR, width: 2 },
  shape: {
    strokeColor: GRAY_COLOR,
    strokeWidth: 2
  }
};
var DefaultNodeStyle = {
  branch: {
    width: 2
  },
  shape: {
    rectangleRadius: 4,
    strokeWidth: 2,
    fill: "none"
  }
};
var separateChildren = (parentElement) => {
  const rightNodeCount = parentElement.rightNodeCount;
  const children = parentElement.children;
  let rightChildren = [], leftChildren = [];
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (AbstractNode.isAbstract(child) && child.end < rightNodeCount) {
      rightChildren.push(child);
      continue;
    }
    if (AbstractNode.isAbstract(child) && child.start >= rightNodeCount) {
      leftChildren.push(child);
      continue;
    }
    if (i < rightNodeCount) {
      rightChildren.push(child);
    } else {
      leftChildren.push(child);
    }
  }
  return { leftChildren, rightChildren };
};
var isSetAbstract = (element) => {
  return !!getCorrespondingAbstract(element);
};
var canSetAbstract = (element) => {
  return !PlaitElement.isRootElement(element) && !AbstractNode.isAbstract(element) && !isSetAbstract(element);
};
var getCorrespondingAbstract = (element) => {
  const parent = MindElement.findParent(element);
  if (!parent)
    return void 0;
  const elementIndex = parent.children.indexOf(element);
  return parent.children.find((child) => {
    return AbstractNode.isAbstract(child) && elementIndex >= child.start && elementIndex <= child.end;
  });
};
var getBehindAbstracts = (element) => {
  const parent = MindElement.findParent(element);
  if (!parent)
    return [];
  const index = parent.children.indexOf(element);
  return parent.children.filter((child) => AbstractNode.isAbstract(child) && child.start > index);
};
var getOverallAbstracts = (board, elements) => {
  const overallAbstracts = [];
  elements.filter((value) => !AbstractNode.isAbstract(value) && !PlaitMind.isMind(value)).forEach((value) => {
    const abstract = getCorrespondingAbstract(value);
    if (abstract && elements.indexOf(abstract) === -1 && overallAbstracts.indexOf(abstract) === -1) {
      const { start, end } = abstract;
      const parent = MindElement.getParent(value);
      const isOverall = parent.children.slice(start, end + 1).every((includedElement) => elements.indexOf(includedElement) > -1);
      if (isOverall) {
        overallAbstracts.push(abstract);
      }
    }
  });
  return overallAbstracts;
};
var getValidAbstractRefs = (board, elements) => {
  const validAbstractRefs = [];
  elements.filter((value) => !AbstractNode.isAbstract(value) && !PlaitMind.isMind(value)).forEach((value) => {
    const abstract = getCorrespondingAbstract(value);
    if (abstract && elements.indexOf(abstract) > 0) {
      const index = validAbstractRefs.findIndex((value2) => value2.abstract === abstract);
      if (index === -1) {
        validAbstractRefs.push({
          abstract,
          references: [value]
        });
      } else {
        validAbstractRefs[index].references.push(value);
      }
    }
  });
  return validAbstractRefs;
};
function getRelativeStartEndByAbstractRef(abstractRef, elements) {
  const start = elements.indexOf(abstractRef.references[0]);
  const end = elements.indexOf(abstractRef.references[abstractRef.references.length - 1]);
  return { start, end };
}
var insertElementHandleAbstract = (board, path, step = 1, isExtendPreviousNode = true, effectedAbstracts = /* @__PURE__ */ new Map()) => {
  const parent = PlaitNode.parent(board, path);
  const hasPreviousNode = path[path.length - 1] !== 0;
  let behindAbstracts;
  if (!hasPreviousNode) {
    behindAbstracts = parent.children.filter((child) => AbstractNode.isAbstract(child));
  } else {
    const selectedElement2 = PlaitNode.get(board, Path.previous(path));
    behindAbstracts = getBehindAbstracts(selectedElement2);
  }
  if (behindAbstracts.length) {
    behindAbstracts.forEach((abstract) => {
      let newProperties = effectedAbstracts.get(abstract);
      if (!newProperties) {
        newProperties = { start: 0, end: 0 };
        effectedAbstracts.set(abstract, newProperties);
      }
      newProperties.start = newProperties.start + step;
      newProperties.end = newProperties.end + step;
    });
  }
  if (!hasPreviousNode) {
    return effectedAbstracts;
  }
  const selectedElement = PlaitNode.get(board, Path.previous(path));
  const correspondingAbstract = getCorrespondingAbstract(selectedElement);
  const isDragToLast = !isExtendPreviousNode && correspondingAbstract && correspondingAbstract.end === path[path.length - 1] - 1;
  if (correspondingAbstract && !isDragToLast) {
    let newProperties = effectedAbstracts.get(correspondingAbstract);
    if (!newProperties) {
      newProperties = { start: 0, end: 0 };
      effectedAbstracts.set(correspondingAbstract, newProperties);
    }
    newProperties.end = newProperties.end + step;
  }
  return effectedAbstracts;
};
var deleteElementHandleAbstract = (board, deletableElements, effectedAbstracts = /* @__PURE__ */ new Map()) => {
  deletableElements.forEach((node) => {
    if (!PlaitMind.isMind(node)) {
      const behindAbstracts = getBehindAbstracts(node).filter((abstract) => !deletableElements.includes(abstract));
      if (behindAbstracts.length) {
        behindAbstracts.forEach((abstract) => {
          let newProperties = effectedAbstracts.get(abstract);
          if (!newProperties) {
            newProperties = { start: 0, end: 0 };
            effectedAbstracts.set(abstract, newProperties);
          }
          newProperties.start = newProperties.start - 1;
          newProperties.end = newProperties.end - 1;
        });
      }
      const correspondingAbstract = getCorrespondingAbstract(node);
      if (correspondingAbstract && !deletableElements.includes(correspondingAbstract)) {
        let newProperties = effectedAbstracts.get(correspondingAbstract);
        if (!newProperties) {
          newProperties = { start: 0, end: 0 };
          effectedAbstracts.set(correspondingAbstract, newProperties);
        }
        newProperties.end = newProperties.end - 1;
      }
    }
  });
  return effectedAbstracts;
};
var isChildOfAbstract = (board, element) => {
  const ancestors = MindElement.getAncestors(board, element);
  return !!ancestors.find((value) => AbstractNode.isAbstract(value));
};
var getBranchColorByMindElement = (board, element) => {
  if (AbstractNode.isAbstract(element) || isChildOfAbstract(board, element)) {
    return getAbstractBranchColor(board, element);
  }
  const branchColor = getAvailableProperty(board, element, "branchColor") || getAvailableProperty(board, element, "strokeColor");
  return branchColor || getDefaultBranchColor(board, element);
};
var getBranchShapeByMindElement = (board, element) => {
  const branchShape = getAvailableProperty(board, element, "branchShape");
  return branchShape || BranchShape.bight;
};
var getBranchWidthByMindElement = (board, element) => {
  const branchWidth = getAvailableProperty(board, element, "branchWidth") || getAvailableProperty(board, element, "strokeWidth");
  return branchWidth || STROKE_WIDTH;
};
var getAbstractBranchWidth = (board, element) => {
  if (!isNullOrUndefined(element.branchWidth)) {
    return element.branchWidth;
  }
  return DefaultAbstractNodeStyle.branch.width;
};
var getAbstractBranchColor = (board, element) => {
  if (element.branchColor || element.strokeColor) {
    return element.branchColor || element.strokeColor;
  }
  return DefaultAbstractNodeStyle.branch.color;
};
var getNextBranchColor = (board, root) => {
  const index = root.children.length;
  return getDefaultBranchColorByIndex(board, index);
};
var getDefaultBranchColor = (board, element) => {
  const path = PlaitBoard.findPath(board, element);
  return getDefaultBranchColorByIndex(board, path[1]);
};
var getDefaultBranchColorByIndex = (board, index) => {
  const themeColor = getMindThemeColor(board);
  const length = themeColor.branchColors.length;
  const remainder = index % length;
  return themeColor.branchColors[remainder];
};
var getMindThemeColor = (board) => {
  const themeColors = PlaitBoard.getThemeColors(board);
  const themeColor = themeColors.find((val) => val.mode === board.theme.themeColorMode);
  if (themeColor && MindThemeColor.isMindThemeColor(themeColor)) {
    return themeColor;
  } else {
    return MindDefaultThemeColor;
  }
};
var getStrokeColorByElement = (board, element) => {
  if (PlaitMind.isMind(element)) {
    const defaultRootStroke = getMindThemeColor(board).rootFill;
    return element.strokeColor || defaultRootStroke;
  }
  if (AbstractNode.isAbstract(element) || isChildOfAbstract(board, element)) {
    return element.strokeColor || DefaultAbstractNodeStyle.shape.strokeColor;
  }
  return getAvailableProperty(board, element, "strokeColor") || getDefaultBranchColor(board, element);
};
var getStrokeStyleByElement = (board, element) => {
  return element.strokeStyle || StrokeStyle.solid;
};
var getStrokeWidthByElement = (board, element) => {
  const strokeWidth = element.strokeWidth || (AbstractNode.isAbstract(element) ? DefaultAbstractNodeStyle.shape.strokeWidth : DefaultNodeStyle.shape.strokeWidth);
  return strokeWidth;
};
var getFillByElement = (board, element) => {
  if (element.fill) {
    return element.fill;
  }
  const defaultRootFill = getMindThemeColor(board).rootFill;
  return element.isRoot ? defaultRootFill : DefaultNodeStyle.shape.fill;
};
var getShapeByElement = (board, element) => {
  const shape = getAvailableProperty(board, element, "shape");
  return shape || MindElementShape.roundRectangle;
};
function editTopic(element) {
  const textManage = getFirstTextManage(element);
  textManage == null ? void 0 : textManage.edit(() => {
  }, (event) => {
    const keyboardEvent = event;
    return keyboardEvent.key === "Enter" && !keyboardEvent.shiftKey;
  });
}
var getSelectedMindElements = (board, elements) => {
  const selectedElements = (elements == null ? void 0 : elements.length) ? elements : getSelectedElements(board);
  return selectedElements.filter((value) => MindElement.isMindElement(board, value));
};
var getBranchDirectionsByLayouts = (branchLayouts) => {
  const branchDirections = [];
  branchLayouts.forEach((l) => {
    const directions = LayoutDirectionsMap[l];
    directions.forEach((d) => {
      if (!branchDirections.includes(d) && !branchDirections.includes(getLayoutReverseDirection(d))) {
        branchDirections.push(d);
      }
    });
  });
  return branchDirections;
};
var isCorrectLayout = (root, layout2) => {
  const rootLayout = root.layout || getDefaultLayout();
  return !getInCorrectLayoutDirection(rootLayout, layout2);
};
var isMixedLayout = (parentLayout, layout2) => {
  return !isIndentedLayout(parentLayout) && isIndentedLayout(layout2) || isIndentedLayout(parentLayout) && !isIndentedLayout(layout2);
};
var getInCorrectLayoutDirection = (rootLayout, layout2) => {
  const directions = LayoutDirectionsMap[rootLayout];
  const subLayoutDirections = LayoutDirectionsMap[layout2];
  if (!subLayoutDirections) {
    throw new Error(`unexpected layout: ${layout2} on correct layout`);
  }
  return subLayoutDirections.find((d) => directions.includes(getLayoutReverseDirection(d)));
};
var correctLayoutByDirection = (layout2, direction) => {
  const isHorizontal = direction === LayoutDirection.left || direction === LayoutDirection.right ? true : false;
  let inverseDirectionLayout = MindLayoutType.standard;
  switch (layout2) {
    case MindLayoutType.left:
      inverseDirectionLayout = MindLayoutType.right;
      break;
    case MindLayoutType.right:
      inverseDirectionLayout = MindLayoutType.left;
      break;
    case MindLayoutType.downward:
      inverseDirectionLayout = MindLayoutType.upward;
      break;
    case MindLayoutType.upward:
      inverseDirectionLayout = MindLayoutType.downward;
      break;
    case MindLayoutType.rightBottomIndented:
      inverseDirectionLayout = isHorizontal ? MindLayoutType.leftBottomIndented : MindLayoutType.rightTopIndented;
      break;
    case MindLayoutType.leftBottomIndented:
      inverseDirectionLayout = isHorizontal ? MindLayoutType.rightBottomIndented : MindLayoutType.leftTopIndented;
      break;
    case MindLayoutType.rightTopIndented:
      inverseDirectionLayout = isHorizontal ? MindLayoutType.leftTopIndented : MindLayoutType.rightBottomIndented;
      break;
    case MindLayoutType.leftTopIndented:
      inverseDirectionLayout = isHorizontal ? MindLayoutType.rightTopIndented : MindLayoutType.leftBottomIndented;
      break;
  }
  return inverseDirectionLayout;
};
var getLayoutDirection$1 = (root) => {
  const layout2 = root.layout || getDefaultLayout();
  return LayoutDirectionsMap[layout2];
};
var getDefaultLayout = () => {
  return MindLayoutType.standard;
};
var getAvailableSubLayoutsByLayoutDirections = (directions) => {
  const result = [];
  const reverseDirections = directions.map(getLayoutReverseDirection);
  for (const key in MindLayoutType) {
    const layout2 = MindLayoutType[key];
    const layoutDirections = LayoutDirectionsMap[layout2];
    if (layoutDirections) {
      const hasSameDirection = layoutDirections.some((d) => directions.includes(d));
      const hasReverseDirection = layoutDirections.some((r) => reverseDirections.includes(r));
      if (hasSameDirection && !hasReverseDirection) {
        result.push(layout2);
      }
    }
  }
  return result;
};
var getLayoutReverseDirection = (layoutDirection) => {
  let reverseDirection = LayoutDirection.right;
  switch (layoutDirection) {
    case LayoutDirection.top:
      reverseDirection = LayoutDirection.bottom;
      break;
    case LayoutDirection.bottom:
      reverseDirection = LayoutDirection.top;
      break;
    case LayoutDirection.right:
      reverseDirection = LayoutDirection.left;
      break;
    case LayoutDirection.left:
      reverseDirection = LayoutDirection.right;
      break;
  }
  return reverseDirection;
};
var getRootLayout = (root) => {
  return root.layout || getDefaultLayout();
};
var getLayoutOptions = (board) => {
  function getMainAxle(element, parent) {
    if (element.isRoot) {
      return BASE * 12;
    }
    if (parent && parent.isRoot()) {
      return BASE * 3;
    }
    return BASE * 3;
  }
  function getSecondAxle(element, parent) {
    if (element.isRoot) {
      return BASE * 12;
    }
    return BASE * 8.5;
  }
  return {
    getHeight(element) {
      return NodeSpace.getNodeHeight(board, element);
    },
    getWidth(element) {
      return NodeSpace.getNodeWidth(board, element);
    },
    getHorizontalGap(element, parent) {
      const _layout = parent && parent.layout || getRootLayout(element);
      const isHorizontal = isHorizontalLayout(_layout);
      if (isIndentedLayout(_layout)) {
        return BASE * 6;
      }
      if (!isHorizontal) {
        return getMainAxle(element, parent);
      } else {
        return getSecondAxle(element, parent);
      }
    },
    getVerticalGap(element, parent) {
      const _layout = parent && parent.layout || getRootLayout(element);
      if (isIndentedLayout(_layout)) {
        return BASE * 3.5;
      }
      const isHorizontal = isHorizontalLayout(_layout);
      if (isHorizontal) {
        return getMainAxle(element, parent);
      } else {
        return getSecondAxle(element, parent);
      }
    },
    getVerticalConnectingPosition(element, parent) {
      if (element.shape === MindElementShape.underline && parent && isHorizontalLogicLayout(parent.layout)) {
        return ConnectingPosition.bottom;
      }
      return void 0;
    },
    getExtendHeight(node) {
      return 0;
    },
    getIndentedCrossLevelGap() {
      return BASE * 1;
    }
  };
};
var TOPIC_FONT_SIZE = 14;
var ROOT_TOPIC_FONT_SIZE = 18;
var TOPIC_DEFAULT_MAX_WORD_COUNT = 34;
var NodeTopicThreshold = {
  defaultTextMaxWidth: 34 * 14
};
var ABSTRACT_HANDLE_COLOR = "#6698FF80";
var ABSTRACT_INCLUDED_OUTLINE_OFFSET = 3.5;
var ABSTRACT_HANDLE_LENGTH = 10;
var ABSTRACT_HANDLE_MASK_WIDTH = 8;
var MIND_CENTRAL_TEXT = "中心主题";
var ABSTRACT_NODE_TEXT = "概要";
var getDefaultMindNameText = (board) => {
  return getI18nValue(board, MindI18nKey.mindCentralText, MIND_CENTRAL_TEXT);
};
var getAbstractNodeText = (board) => {
  return getI18nValue(board, MindI18nKey.abstractNodeText, ABSTRACT_NODE_TEXT);
};
var getTopicSize = (board, isRoot, isBranch, topic, manualWidth) => {
  let fontFamily = DEFAULT_FONT_FAMILY;
  let fontSize = TOPIC_FONT_SIZE;
  if (isRoot) {
    fontFamily = DEFAULT_FONT_FAMILY;
    fontSize = ROOT_TOPIC_FONT_SIZE;
  } else if (isBranch) {
    fontFamily = DEFAULT_FONT_FAMILY;
  }
  const maxWidth = fontSize * TOPIC_DEFAULT_MAX_WORD_COUNT;
  return measureElement(board, topic, { fontSize, fontFamily }, manualWidth ? manualWidth : maxWidth);
};
var createEmptyMind = (board, point) => {
  const text = getDefaultMindNameText(board);
  const topicSize = getTopicSize(board, true, false, buildText(text));
  const element = createMindElement(text, topicSize.width, topicSize.height, { layout: MindLayoutType.right });
  element.isRoot = true;
  element.type = "mindmap";
  const width = NodeSpace.getNodeWidth(board, element);
  const height = NodeSpace.getNodeHeight(board, element);
  element.points = [[point[0] - width / 2, point[1] - height / 2]];
  return element;
};
var createMindElement = (text, width, height, options) => {
  const newElement = {
    id: idCreator(),
    data: {
      topic: buildText(text)
    },
    children: [],
    width,
    height
  };
  let key;
  for (key in options) {
    if (!isNullOrUndefined(options[key])) {
      newElement[key] = options[key];
    }
  }
  return newElement;
};
var INHERIT_ATTRIBUTE_KEYS = [
  "fill",
  "strokeColor",
  "strokeWidth",
  "strokeStyle",
  "shape",
  "layout",
  "branchColor",
  "branchWidth",
  "branchShape"
];
var getChildrenCount = (element) => {
  const count = element.children.reduce((p, c) => {
    return p + getChildrenCount(c);
  }, 0);
  return count + element.children.length;
};
var isChildElement = (origin, child) => {
  let parent = MindElement.findParent(child);
  while (parent) {
    if (parent === origin) {
      return true;
    }
    parent = MindElement.findParent(parent);
  }
  return false;
};
var getFirstLevelElement = (elements) => {
  let result = [];
  elements.forEach((element) => {
    const isChild = elements.some((node) => {
      return isChildElement(node, element);
    });
    if (!isChild) {
      result.push(element);
    }
  });
  return result;
};
var isChildRight = (parent, child) => {
  return parent.x < child.x;
};
var isChildUp = (parent, child) => {
  return parent.y > child.y;
};
var copyNewNode = (node) => {
  const newNode = { ...node };
  newNode.id = idCreator();
  newNode.children = [];
  for (const childNode of node.children) {
    newNode.children.push(copyNewNode(childNode));
  }
  return newNode;
};
var insertMindElement = (board, inheritNode, path) => {
  const newNode = {};
  if (!inheritNode.isRoot) {
    INHERIT_ATTRIBUTE_KEYS.forEach((attr) => {
      newNode[attr] = inheritNode[attr];
    });
    delete newNode.layout;
  }
  const newElement = createMindElement("", TOPIC_FONT_SIZE, TEXT_DEFAULT_HEIGHT, newNode);
  Transforms.insertNode(board, newElement, path);
  clearSelectedElement(board);
  addSelectedElement(board, newElement);
  setTimeout(() => {
    editTopic(newElement);
  });
};
var findLastChild = (child) => {
  let result = child;
  while (result.children.length !== 0) {
    result = result.children[result.children.length - 1];
  }
  return result;
};
var divideElementByParent = (elements) => {
  const abstractIncludedGroups = [];
  const parentElements = [];
  for (let i = 0; i < elements.length; i++) {
    const parent = MindElement.getParent(elements[i]);
    const parentIndex = parentElements.indexOf(parent);
    if (parentIndex === -1) {
      parentElements.push(parent);
      abstractIncludedGroups.push([elements[i]]);
    } else {
      abstractIncludedGroups[parentIndex].push(elements[i]);
    }
  }
  return { parentElements, abstractIncludedGroups };
};
var getDefaultMindElementFontSize = (board, element) => {
  if (PlaitMind.isMind(element)) {
    return ROOT_TOPIC_FONT_SIZE;
  }
  if (MindElement.isMindElement(board, element)) {
    return TOPIC_FONT_SIZE;
  }
  throw new Error("can not find default font-size");
};
var NodeDefaultSpace = {
  horizontal: {
    nodeAndText: BASE * 2.5,
    emojiAndText: BASE * 1.5
  },
  vertical: {
    nodeAndText: BASE,
    nodeAndImage: BASE,
    imageAndText: BASE * 1.5
  }
};
var RootDefaultSpace = {
  horizontal: {
    nodeAndText: BASE * 4,
    emojiAndText: BASE * 2
  },
  vertical: {
    nodeAndText: BASE * 2
  }
};
var getHorizontalSpaceBetweenNodeAndText = (board, element) => {
  const isMind = PlaitMind.isMind(element);
  const nodeAndText = isMind ? RootDefaultSpace.horizontal.nodeAndText : NodeDefaultSpace.horizontal.nodeAndText;
  const strokeWidth = getStrokeWidthByElement(board, element);
  return nodeAndText + strokeWidth;
};
var getVerticalSpaceBetweenNodeAndText = (board, element) => {
  const isMind = PlaitMind.isMind(element);
  const strokeWidth = getStrokeWidthByElement(board, element);
  const nodeAndText = isMind ? RootDefaultSpace.vertical.nodeAndText : NodeDefaultSpace.vertical.nodeAndText;
  return nodeAndText + strokeWidth;
};
var getSpaceEmojiAndText = (element) => {
  const isMind = PlaitMind.isMind(element);
  const emojiAndText = isMind ? RootDefaultSpace.horizontal.emojiAndText : NodeDefaultSpace.horizontal.emojiAndText;
  return emojiAndText;
};
var NodeSpace = {
  getNodeWidth(board, element) {
    const nodeAndText = getHorizontalSpaceBetweenNodeAndText(board, element);
    if (MindElement.hasEmojis(element)) {
      return NodeSpace.getEmojiLeftSpace(board, element) + getEmojisWidthHeight(board, element).width + getSpaceEmojiAndText(element) + NodeSpace.getTopicDynamicWidth(board, element) + nodeAndText;
    }
    return nodeAndText + NodeSpace.getTopicDynamicWidth(board, element) + nodeAndText;
  },
  getNodeHeight(board, element) {
    const topicSize = getElementSize(board, element.data.topic, { fontSize: DEFAULT_FONT_SIZE, fontFamily: DEFAULT_FONT_FAMILY }, NodeSpace.getTopicMaxDynamicWidth(board, element));
    const normalizedSize = normalizeWidthAndHeight(board, element, topicSize.width, topicSize.height);
    const nodeAndText = getVerticalSpaceBetweenNodeAndText(board, element);
    if (MindElement.hasImage(element)) {
      return NodeSpace.getTextTopSpace(board, element) + normalizedSize.height + nodeAndText;
    }
    return nodeAndText + normalizedSize.height + nodeAndText;
  },
  getTopicDynamicWidth(board, element) {
    var _a;
    const topicSize = getElementSize(board, element.data.topic, { fontSize: getDefaultMindElementFontSize(board, element), fontFamily: DEFAULT_FONT_FAMILY }, NodeSpace.getTopicMaxDynamicWidth(board, element));
    const normalizedSize = normalizeWidthAndHeight(board, element, topicSize.width, topicSize.width);
    const width = element.manualWidth || normalizedSize.width;
    const imageWidth = MindElement.hasImage(element) ? (_a = element.data.image) == null ? void 0 : _a.width : 0;
    return Math.max(width, imageWidth);
  },
  getTopicHeight(board, element) {
    const topicSize = getElementSize(board, element.data.topic, { fontSize: DEFAULT_FONT_SIZE, fontFamily: DEFAULT_FONT_FAMILY }, NodeSpace.getTopicMaxDynamicWidth(board, element));
    const normalizedSize = normalizeWidthAndHeight(board, element, topicSize.width, topicSize.height);
    return normalizedSize.height;
  },
  getTopicMaxDynamicWidth(board, element) {
    var _a;
    return Math.max(NodeTopicThreshold.defaultTextMaxWidth, element.manualWidth || 0, MindElement.hasImage(element) ? (_a = element.data.image) == null ? void 0 : _a.width : 0);
  },
  /**
   * use it when upload image first or resize image
   */
  getNodeNewDynamicWidth(board, element, imageWidth) {
    const width = element.manualWidth || element.width;
    return Math.max(width, imageWidth);
  },
  getNodeResizableMinWidth(board, element) {
    const minTopicWidth = NodeSpace.getNodeTopicMinWidth(board, element);
    if (MindElement.hasImage(element) && element.data.image.width > minTopicWidth) {
      return element.data.image.width;
    } else {
      return minTopicWidth;
    }
  },
  getNodeTopicMinWidth(board, element) {
    const defaultFontSize = getDefaultMindElementFontSize(board, element);
    const firstText = getFirstTextMarks(element.data.topic);
    const fontSize = (firstText[MarkTypes.fontSize] ? Number(firstText[MarkTypes.fontSize]) : null) || defaultFontSize;
    return fontSize;
  },
  getTextLeftSpace(board, element) {
    const nodeAndText = getHorizontalSpaceBetweenNodeAndText(board, element);
    if (MindElement.hasEmojis(element)) {
      return NodeSpace.getEmojiLeftSpace(board, element) + getEmojisWidthHeight(board, element).width + getSpaceEmojiAndText(element);
    } else {
      return nodeAndText;
    }
  },
  getTextTopSpace(board, element) {
    const nodeAndText = getVerticalSpaceBetweenNodeAndText(board, element);
    if (MindElement.hasImage(element)) {
      return NodeSpace.getImageTopSpace(board, element) + element.data.image.height + NodeDefaultSpace.vertical.imageAndText;
    } else {
      return nodeAndText;
    }
  },
  getImageTopSpace(board, element) {
    const strokeWidth = getStrokeWidthByElement(board, element);
    return strokeWidth + NodeDefaultSpace.vertical.nodeAndImage;
  },
  getEmojiLeftSpace(board, element) {
    const options = board.getPluginOptions(WithMindPluginKey);
    const nodeAndText = getHorizontalSpaceBetweenNodeAndText(board, element);
    return nodeAndText - options.emojiPadding;
  },
  getEmojiTopSpace(board, element) {
    const nodeAndText = getVerticalSpaceBetweenNodeAndText(board, element);
    return nodeAndText;
  }
};
var getFontSizeBySlateElement = (text) => {
  const defaultFontSize = DEFAULT_FONT_SIZE;
  if (typeof text === "string") {
    return defaultFontSize;
  }
  const marks = PlaitMarkEditor.getMarksByElement(text);
  const fontSize = marks[MarkTypes.fontSize] || defaultFontSize;
  return fontSize;
};
var normalizeWidthAndHeight = (board, element, width, height) => {
  const minWidth = NodeSpace.getNodeTopicMinWidth(board, element);
  const newWidth = width < minWidth ? minWidth : width;
  return { width: newWidth, height };
};
function getRectangleByNode(node) {
  const x = node.x + node.hGap;
  let y = node.y + node.vGap;
  const width = node.width - node.hGap * 2;
  const height = node.height - node.vGap * 2;
  return {
    x,
    y,
    width,
    height
  };
}
function getRectangleByElement(board, element) {
  const width = NodeSpace.getNodeWidth(board, element);
  const height = NodeSpace.getNodeHeight(board, element);
  const nodeRectangle = {
    x: element.points[0][0],
    y: element.points[0][1],
    width,
    height
  };
  return nodeRectangle;
}
function isHitMindElement(board, point, element) {
  const node = MindElement.getNode(element);
  if (node && distanceBetweenPointAndRectangle(point[0], point[1], getRectangleByNode(node)) === 0) {
    return true;
  } else {
    return false;
  }
}
function getEmojiRectangle(board, element) {
  let { x, y } = getRectangleByNode(MindElement.getNode(element));
  x = x + NodeSpace.getEmojiLeftSpace(board, element);
  const { width, height } = getEmojisWidthHeight(board, element);
  return {
    x,
    y,
    width,
    height
  };
}
function getEmojiForeignRectangle(board, element) {
  let { x, y } = getRectangleByNode(MindElement.getNode(element));
  x = x + NodeSpace.getEmojiLeftSpace(board, element);
  const { width } = getEmojisWidthHeight(board, element);
  return {
    x,
    y,
    width,
    height: NodeSpace.getNodeHeight(board, element)
  };
}
var isHitEmojis = (board, element, point) => {
  return RectangleClient.isHit(RectangleClient.getRectangleByPoints([point, point]), getEmojiRectangle(board, element));
};
function getTopicRectangleByNode(board, node) {
  let nodeRectangle = getRectangleByNode(node);
  const result = getTopicRectangleByElement(board, nodeRectangle, node.origin);
  return result;
}
function getTopicRectangleByElement(board, nodeRectangle, element) {
  const x = nodeRectangle.x + NodeSpace.getTextLeftSpace(board, element);
  const y = nodeRectangle.y + NodeSpace.getTextTopSpace(board, element);
  const width = NodeSpace.getTopicDynamicWidth(board, element);
  const height = NodeSpace.getTopicHeight(board, element);
  return { height, width, x, y };
}
function getImageForeignRectangle(board, element) {
  let { x, y } = getRectangleByNode(MindElement.getNode(element));
  const elementWidth = element.manualWidth || element.width;
  x = elementWidth > element.data.image.width ? x + NodeSpace.getTextLeftSpace(board, element) + (elementWidth - element.data.image.width) / 2 : x + NodeSpace.getTextLeftSpace(board, element);
  y = NodeSpace.getImageTopSpace(board, element) + y;
  const { width, height } = element.data.image;
  const rectangle = {
    x,
    y,
    width,
    height
  };
  return rectangle;
}
var isHitImage = (board, element, point) => {
  const imageRectangle = getImageForeignRectangle(board, element);
  const imageOutlineRectangle = RectangleClient.getOutlineRectangle(imageRectangle, -RESIZE_HANDLE_DIAMETER / 2);
  return RectangleClient.isPointInRectangle(imageOutlineRectangle, point);
};
var getHitImageResizeHandleDirection = (board, element, point) => {
  const imageRectangle = getImageForeignRectangle(board, element);
  const resizeHandleRefs = getRectangleResizeHandleRefs(imageRectangle, RESIZE_HANDLE_DIAMETER);
  const result = resizeHandleRefs.find((resizeHandleRef) => {
    return RectangleClient.isHit(RectangleClient.getRectangleByPoints([point, point]), resizeHandleRef.rectangle);
  });
  return result;
};
var adjustRootToNode = (board, node) => {
  const newNode = { ...node };
  delete newNode.isRoot;
  delete newNode.rightNodeCount;
  delete newNode.type;
  if (newNode.layout === MindLayoutType.standard) {
    delete newNode.layout;
  }
  return newNode;
};
var adjustAbstractToNode = (node) => {
  const newNode = { ...node };
  delete newNode.start;
  delete newNode.end;
  return newNode;
};
var adjustNodeToRoot = (board, node) => {
  const newElement = { ...node };
  if (!Node2.string(newElement.data.topic)) {
    newElement.data.topic = { children: [{ text: "思维导图" }] };
  }
  newElement == null ? true : delete newElement.strokeColor;
  newElement == null ? true : delete newElement.fill;
  newElement == null ? true : delete newElement.shape;
  newElement == null ? true : delete newElement.strokeWidth;
  newElement == null ? true : delete newElement.isCollapsed;
  return {
    ...newElement,
    layout: newElement.layout ?? MindLayoutType.right,
    isRoot: true,
    type: "mindmap"
  };
};
var addImageFocus = (board, element) => {
  addElementOfFocusedImage(board, element);
  const commonElementRef = PlaitElement.getElementRef(element);
  const imageGenerator = commonElementRef.getGenerator(ImageGenerator.key);
  imageGenerator.setFocus(element, true);
};
var removeImageFocus = (board, element) => {
  removeElementOfFocusedImage(board);
  const commonElementRef = PlaitElement.getElementRef(element);
  const imageGenerator = commonElementRef.getGenerator(ImageGenerator.key);
  imageGenerator.setFocus(element, false);
};
var getNewNodeHeight = (board, element, newNodeDynamicWidth) => {
  const textManage = getFirstTextManage(element);
  const { height } = textManage.getSize(void 0, newNodeDynamicWidth);
  if (Math.abs(height - element.height) > 2) {
    return height;
  }
  return void 0;
};
var addActiveOnDragOrigin = (activeElement) => {
  PlaitElement.getElementG(activeElement).classList.add("dragging-node");
  !activeElement.isCollapsed && activeElement.children.forEach((child) => {
    addActiveOnDragOrigin(child);
  });
};
var removeActiveOnDragOrigin = (activeElement) => {
  PlaitElement.getElementG(activeElement).classList.remove("dragging-node");
  !activeElement.isCollapsed && activeElement.children.forEach((child) => {
    removeActiveOnDragOrigin(child);
  });
};
var setMindDragging = (board, state) => {
  setDragging(board, state);
  if (state) {
    PlaitBoard.getBoardContainer(board).classList.add("mind-node-dragging");
  } else {
    PlaitBoard.getBoardContainer(board).classList.remove("mind-node-dragging");
  }
};
var hasPreviousOrNextOfDropPath = (parent, dropTarget, dropPath) => {
  let children = getNonAbstractChildren(parent);
  if (PlaitMind.isMind(parent) && isStandardLayout(getRootLayout(parent))) {
    const isDropRight = isDropStandardRight(parent, dropTarget);
    if (isDropRight) {
      children = children.slice(0, parent.rightNodeCount);
    }
    if (!isDropRight) {
      children = children.slice(parent.rightNodeCount, children.length);
      dropPath = [...dropPath, dropPath[dropPath.length - 1] - parent.rightNodeCount];
    }
  }
  let hasPreviousNode = dropPath[dropPath.length - 1] !== 0;
  let hasNextNode = dropPath[dropPath.length - 1] !== ((children == null ? void 0 : children.length) || 0);
  if (parent.isCollapsed) {
    hasNextNode = false;
    hasPreviousNode = false;
  }
  return {
    hasPreviousNode,
    hasNextNode
  };
};
var isDropStandardRight = (parent, dropTarget) => {
  const target = dropTarget.target;
  return PlaitMind.isMind(parent) && isStandardLayout(getRootLayout(parent)) && parent.children.indexOf(target) !== -1 && parent.children.indexOf(target) < parent.rightNodeCount || PlaitMind.isMind(target) && isStandardLayout(getRootLayout(target)) && dropTarget.detectResult === "right";
};
var directionCorrector = (board, node, detectResults) => {
  if (!node.origin.isRoot && !AbstractNode.isAbstract(node.origin)) {
    const parentLayout = MindQueries.getCorrectLayoutByElement(board, node == null ? void 0 : node.parent.origin);
    if (isStandardLayout(parentLayout)) {
      const idx = node.parent.children.findIndex((x) => x === node);
      const isLeft = idx >= (node.parent.origin.rightNodeCount || 0);
      return getAllowedDirection(detectResults, [isLeft ? "right" : "left"]);
    }
    if (isLeftLayout(parentLayout)) {
      return getAllowedDirection(detectResults, ["right"]);
    }
    if (isRightLayout(parentLayout)) {
      return getAllowedDirection(detectResults, ["left"]);
    }
    if (parentLayout === MindLayoutType.upward) {
      return getAllowedDirection(detectResults, ["bottom"]);
    }
    if (parentLayout === MindLayoutType.downward) {
      return getAllowedDirection(detectResults, ["top"]);
    }
  } else {
    const layout2 = MindQueries.getCorrectLayoutByElement(board, node == null ? void 0 : node.origin);
    if (isStandardLayout(layout2)) {
      return getAllowedDirection(detectResults, ["top", "bottom"]);
    }
    if (layout2 === MindLayoutType.upward) {
      return getAllowedDirection(detectResults, ["left", "right", "bottom"]);
    }
    if (layout2 === MindLayoutType.downward) {
      return getAllowedDirection(detectResults, ["left", "right", "top"]);
    }
    if (isLeftLayout(layout2)) {
      return getAllowedDirection(detectResults, ["right", "top", "bottom"]);
    }
    if (isRightLayout(layout2)) {
      return getAllowedDirection(detectResults, ["left", "top", "bottom"]);
    }
  }
  return null;
};
var getAllowedDirection = (detectResults, illegalDirections) => {
  const directions = detectResults;
  illegalDirections.forEach((item) => {
    const bottomDirectionIndex = directions.findIndex((direction) => direction === item);
    if (bottomDirectionIndex !== -1) {
      directions.splice(bottomDirectionIndex, 1);
    }
  });
  return directions.length ? directions : null;
};
var detectDropTarget = (board, detectPoint, dropTarget, activeElements) => {
  let detectResult = null;
  depthFirstRecursion(board, (element) => {
    if (!MindElement.isMindElement(board, element) || detectResult) {
      return;
    }
    const node = MindElement.getNode(element);
    const directions = directionDetector(node, detectPoint);
    if (directions) {
      detectResult = directionCorrector(board, node, directions);
    }
    dropTarget = null;
    const isValid = activeElements.every((element2) => isValidTarget(element2, node.origin));
    if (detectResult && isValid) {
      dropTarget = { target: node.origin, detectResult: detectResult[0] };
    }
  }, getIsRecursionFunc(board));
  return dropTarget;
};
var directionDetector = (targetNode, centerPoint) => {
  const { x, y, width, height } = getRectangleByNode(targetNode);
  const yCenter = y + height / 2;
  const xCenter = x + width / 2;
  const top = targetNode.y;
  const bottom = targetNode.y + targetNode.height;
  const left = targetNode.x;
  const right = targetNode.x + targetNode.width;
  const direction = [];
  if (centerPoint[1] > y && centerPoint[1] < y + height) {
    if (centerPoint[0] > left && centerPoint[0] < xCenter) {
      direction.push("left");
    }
    if (centerPoint[0] > xCenter && centerPoint[0] < right) {
      direction.push("right");
    }
    if (centerPoint[0] > x && centerPoint[0] < xCenter || centerPoint[0] > xCenter && centerPoint[0] < x + width) {
      if (centerPoint[1] < yCenter) {
        direction.push("top");
      } else {
        direction.push("bottom");
      }
    }
    return direction.length ? direction : null;
  }
  if (centerPoint[0] > x && centerPoint[0] < x + width) {
    if (centerPoint[1] > top && centerPoint[1] < yCenter) {
      direction.push("top");
    }
    if (centerPoint[1] > yCenter && centerPoint[1] < bottom) {
      direction.push("bottom");
    }
    if (centerPoint[1] > y && centerPoint[1] < y + height || centerPoint[1] > yCenter && centerPoint[1] < y + height) {
      if (centerPoint[0] < xCenter) {
        direction.push("left");
      } else {
        direction.push("right");
      }
    }
    return direction.length ? direction : null;
  }
  return null;
};
var isValidTarget = (origin, target) => {
  return origin !== target && !isChildElement(origin, target);
};
var getPathByDropTarget = (board, dropTarget) => {
  let targetPath = PlaitBoard.findPath(board, dropTarget == null ? void 0 : dropTarget.target);
  const layout2 = PlaitMind.isMind(dropTarget == null ? void 0 : dropTarget.target) ? getRootLayout(dropTarget == null ? void 0 : dropTarget.target) : MindQueries.getCorrectLayoutByElement(board, MindElement.getParent(dropTarget == null ? void 0 : dropTarget.target));
  const children = getNonAbstractChildren(dropTarget.target);
  if (isVerticalLogicLayout(layout2)) {
    if (dropTarget.detectResult === "top" || dropTarget.detectResult === "bottom") {
      targetPath.push(children.length);
    }
    if (dropTarget.detectResult === "right") {
      targetPath = Path.next(targetPath);
    }
  }
  if (isHorizontalLogicLayout(layout2)) {
    if (dropTarget.detectResult === "right") {
      if (PlaitMind.isMind(dropTarget == null ? void 0 : dropTarget.target) && isStandardLayout(layout2)) {
        targetPath.push(dropTarget == null ? void 0 : dropTarget.target.rightNodeCount);
      } else {
        targetPath.push(children.length);
      }
    }
    if (dropTarget.detectResult === "left") {
      targetPath.push(children.length);
    }
    if (dropTarget.detectResult === "bottom") {
      targetPath = Path.next(targetPath);
    }
  }
  if (isIndentedLayout(layout2)) {
    if (isTopLayout(layout2) && dropTarget.detectResult === "top") {
      targetPath = Path.next(targetPath);
    }
    if (isBottomLayout(layout2) && dropTarget.detectResult === "bottom") {
      targetPath = Path.next(targetPath);
    }
    if (isLeftLayout(layout2) && dropTarget.detectResult === "left") {
      targetPath.push(children.length);
    }
    if (isRightLayout(layout2) && dropTarget.detectResult === "right") {
      targetPath.push(children.length);
    }
  }
  return targetPath;
};
function drawRoundRectangleByNode(board, node) {
  const rectangle = getRectangleByNode(node);
  return drawRoundRectangleByElement(board, rectangle, node.origin);
}
function drawRoundRectangleByElement(board, nodeRectangle, element) {
  const fill = getFillByElement(board, element);
  const stroke = getStrokeColorByElement(board, element);
  const strokeWidth = getStrokeWidthByElement(board, element);
  const strokeStyle = getStrokeStyleByElement(board, element);
  const strokeLineDash = getStrokeLineDash(strokeStyle, strokeWidth);
  const newNodeRectangle = RectangleClient.inflate(nodeRectangle, -strokeWidth);
  const nodeG = drawRoundRectangle(PlaitBoard.getRoughSVG(board), newNodeRectangle.x, newNodeRectangle.y, newNodeRectangle.x + newNodeRectangle.width, newNodeRectangle.y + newNodeRectangle.height, {
    stroke,
    strokeWidth,
    fill,
    fillStyle: "solid",
    strokeLineDash
  }, false, DefaultNodeStyle.shape.rectangleRadius);
  return nodeG;
}
var HorizontalPlacement;
(function(HorizontalPlacement2) {
  HorizontalPlacement2["left"] = "left";
  HorizontalPlacement2["center"] = "center";
  HorizontalPlacement2["right"] = "right";
})(HorizontalPlacement || (HorizontalPlacement = {}));
var VerticalPlacement;
(function(VerticalPlacement2) {
  VerticalPlacement2["top"] = "top";
  VerticalPlacement2["middle"] = "middle";
  VerticalPlacement2["bottom"] = "bottom";
})(VerticalPlacement || (VerticalPlacement = {}));
var getPointByPlacement = (client, placement) => {
  let x = client.x;
  let y = client.y;
  if (placement[0] === HorizontalPlacement.center) {
    x = client.x + client.width / 2;
  }
  if (placement[0] === HorizontalPlacement.right) {
    x = client.x + client.width;
  }
  if (placement[1] === VerticalPlacement.middle) {
    y = client.y + client.height / 2;
  }
  if (placement[1] === VerticalPlacement.bottom) {
    y = client.y + client.height;
  }
  return [x, y];
};
var getLayoutDirection = (node, isHorizontal) => {
  if (isHorizontal) {
    if (node.left) {
      return LayoutDirection.left;
    } else {
      return LayoutDirection.right;
    }
  } else {
    if (node.up) {
      return LayoutDirection.top;
    } else {
      return LayoutDirection.bottom;
    }
  }
};
var transformPlacement = (placement, direction) => {
  if (direction === LayoutDirection.left) {
    if (placement[0] === HorizontalPlacement.right) {
      placement[0] = HorizontalPlacement.left;
    } else if (placement[0] === HorizontalPlacement.left) {
      placement[0] = HorizontalPlacement.right;
    }
  }
  if (direction === LayoutDirection.bottom || direction === LayoutDirection.top) {
    let horizontal = HorizontalPlacement.center;
    let vertical = VerticalPlacement.middle;
    if (placement[1] === VerticalPlacement.top) {
      horizontal = HorizontalPlacement.left;
    }
    if (placement[1] === VerticalPlacement.bottom) {
      horizontal = HorizontalPlacement.right;
    }
    if (placement[0] === HorizontalPlacement.left) {
      vertical = VerticalPlacement.top;
    }
    if (placement[0] === HorizontalPlacement.right) {
      vertical = VerticalPlacement.bottom;
    }
    placement[0] = horizontal;
    placement[1] = vertical;
  }
  if (direction === LayoutDirection.top) {
    if (placement[1] === VerticalPlacement.bottom) {
      placement[1] = VerticalPlacement.top;
    } else if (placement[1] === VerticalPlacement.top) {
      placement[1] = VerticalPlacement.bottom;
    }
  }
};
function drawIndentedLink(board, parent, child, needDrawUnderline = true, defaultStrokeColor = null, defaultStrokeWidth, defaultStrokeStyle) {
  const branchShape = getBranchShapeByMindElement(board, parent.origin);
  const branchWidth = defaultStrokeWidth || getBranchWidthByMindElement(board, child.origin);
  const branchColor = defaultStrokeColor || getBranchColorByMindElement(board, child.origin);
  const strokeStyle = defaultStrokeStyle || getStrokeStyleByElement(board, child.origin);
  const isUnderlineShape = getShapeByElement(board, child.origin) === MindElementShape.underline;
  let beginX, beginY, endX, endY, beginNode = parent, endNode = child;
  const beginRectangle = getRectangleByNode(beginNode);
  const endRectangle = getRectangleByNode(endNode);
  beginX = beginNode.x + beginNode.width / 2;
  beginY = isChildUp(parent, child) ? beginRectangle.y : beginRectangle.y + beginRectangle.height;
  endX = parent.left ? endNode.x + endNode.hGap + endRectangle.width : endNode.x + endNode.hGap;
  endY = isUnderlineShape ? endNode.y + endNode.height - endNode.vGap : endNode.y + endNode.height / 2;
  let plusMinus = isChildUp(parent, child) ? parent.left ? [-1, -1] : [1, -1] : parent.left ? [-1, 1] : [1, 1];
  let curve = [
    [beginX, beginY],
    [beginX, beginY],
    [beginX, beginY],
    [beginX, endY - endNode.hGap * 3 * plusMinus[1] / 5],
    [beginX, endY - endNode.hGap * plusMinus[1] / 5],
    [beginX + endNode.hGap * plusMinus[0] / 4, endY],
    [beginX + endNode.hGap * plusMinus[0] * 3 / 5, endY],
    isUnderlineShape && needDrawUnderline ? [endX + (endNode.width - endNode.hGap * 2) * plusMinus[0], endY] : [endX, endY],
    isUnderlineShape && needDrawUnderline ? [endX + (endNode.width - endNode.hGap * 2) * plusMinus[0], endY] : [endX, endY],
    isUnderlineShape && needDrawUnderline ? [endX + (endNode.width - endNode.hGap * 2) * plusMinus[0], endY] : [endX, endY]
  ];
  const strokeLineDash = getStrokeLineDash(strokeStyle, branchWidth);
  if (branchShape === BranchShape.polyline) {
    const polylinePoints = [
      [beginX, beginY],
      [beginX, endY],
      [endX, endY],
      isUnderlineShape && needDrawUnderline ? [endX + (endNode.width - endNode.hGap * 2) * plusMinus[0], endY] : [endX, endY]
    ];
    return drawLinearPath(polylinePoints, { stroke: branchColor, strokeWidth: branchWidth, strokeLineDash });
  }
  const points = pointsOnBezierCurves(curve, 1e-3);
  return drawBezierPath(points, { stroke: branchColor, strokeWidth: branchWidth, strokeLineDash });
}
function drawLogicLink(board, parent, node, isHorizontal, defaultStrokeColor = null, defaultStrokeWidth, defaultStrokeStyle) {
  const branchShape = getBranchShapeByMindElement(board, parent.origin);
  const branchColor = defaultStrokeColor || getBranchColorByMindElement(board, node.origin);
  const branchWidth = defaultStrokeWidth || getBranchWidthByMindElement(board, node.origin);
  const strokeStyle = defaultStrokeStyle || getStrokeStyleByElement(board, node.origin);
  const hasStraightLine = branchShape === BranchShape.polyline ? true : !parent.origin.isRoot;
  const parentShape = getShapeByElement(board, parent.origin);
  const shape = getShapeByElement(board, node.origin);
  const hasUnderlineShape = shape === MindElementShape.underline;
  const hasUnderlineShapeOfParent = parentShape === MindElementShape.underline;
  const nodeClient = getRectangleByNode(node);
  const parentClient = getRectangleByNode(parent);
  const linkDirection = getLayoutDirection(node, isHorizontal);
  const beginPlacement = [HorizontalPlacement.right, VerticalPlacement.middle];
  const endPlacement = [HorizontalPlacement.left, VerticalPlacement.middle];
  transformPlacement(beginPlacement, linkDirection);
  transformPlacement(endPlacement, linkDirection);
  if (isHorizontal && hasUnderlineShapeOfParent && !parent.origin.isRoot) {
    beginPlacement[1] = VerticalPlacement.bottom;
  }
  if (isHorizontal && hasUnderlineShape) {
    endPlacement[1] = VerticalPlacement.bottom;
  }
  let beginPoint = getPointByPlacement(parentClient, beginPlacement);
  let endPoint = getPointByPlacement(nodeClient, endPlacement);
  const straightLineDistance = 8;
  const beginPoint2 = hasStraightLine ? moveXOfPoint(beginPoint, straightLineDistance, linkDirection) : beginPoint;
  let straightLine = hasStraightLine ? [beginPoint, beginPoint2, beginPoint2] : [];
  const beginBufferDistance = (parent.hGap + node.hGap) / 3;
  const endBufferDistance = -(parent.hGap + node.hGap) / 2.4;
  let curve = [
    beginPoint2,
    moveXOfPoint(beginPoint2, beginBufferDistance, linkDirection),
    moveXOfPoint(endPoint, endBufferDistance, linkDirection),
    endPoint
  ];
  const underlineEnd = moveXOfPoint(endPoint, nodeClient.width, linkDirection);
  const underline = hasUnderlineShape && isHorizontal ? [underlineEnd, underlineEnd, underlineEnd] : [];
  const points = pointsOnBezierCurves([...straightLine, ...curve, ...underline]);
  const strokeLineDash = getStrokeLineDash(strokeStyle, branchWidth);
  let linkG;
  if (branchShape === BranchShape.polyline) {
    const buffer = 8;
    const movePoint = moveXOfPoint(beginPoint2, buffer, linkDirection);
    const polylinePoints = [
      ...straightLine,
      movePoint,
      isHorizontal ? [movePoint[0], endPoint[1]] : [endPoint[0], movePoint[1]],
      endPoint,
      ...underline
    ];
    linkG = drawLinearPath(polylinePoints, { stroke: branchColor, strokeWidth: branchWidth, strokeLineDash });
  } else {
    linkG = PlaitBoard.getRoughSVG(board).curve(points, { stroke: branchColor, strokeWidth: branchWidth, strokeLineDash });
  }
  if (strokeStyle === StrokeStyle.dotted) {
    setStrokeLinecap(linkG, "round");
  }
  return linkG;
}
function drawLink(board, parentNode, node, isHorizontal, needDrawUnderline, defaultStrokeColor, defaultStrokeWidth, defaultStrokeStyle) {
  return MindElement.isIndentedLayout(parentNode.origin) ? drawIndentedLink(board, parentNode, node, needDrawUnderline, defaultStrokeColor, defaultStrokeWidth, defaultStrokeStyle) : drawLogicLink(board, parentNode, node, isHorizontal, defaultStrokeColor, defaultStrokeWidth, defaultStrokeStyle);
}
var FOREIGN_OBJECT_EMOJI_CLASS_NAME = "foreign-object-emoji";
var EmojiGenerator = class {
  constructor(board) {
    this.board = board;
    this.emojiComponentRef = null;
  }
  draw(container, emoji, element) {
    this.destroy();
    const props = {
      board: this.board,
      emojiItem: emoji,
      element,
      fontSize: getEmojiFontSize(element)
    };
    this.emojiComponentRef = this.board.renderEmoji(container, props);
  }
  destroy() {
    if (this.emojiComponentRef) {
      this.emojiComponentRef.destroy();
      this.emojiComponentRef = null;
    }
  }
};
var _NodeEmojisGenerator = class _NodeEmojisGenerator {
  constructor(board) {
    this.board = board;
    this.emojiGenerators = [];
  }
  drawEmojis(element) {
    this.destroy();
    if (MindElement.hasEmojis(element)) {
      this.g = createG();
      this.g.classList.add("emojis");
      const foreignRectangle = getEmojiForeignRectangle(this.board, element);
      const foreignObject = createForeignObject(foreignRectangle.x, foreignRectangle.y, foreignRectangle.width, foreignRectangle.height);
      foreignObject.classList.add(FOREIGN_OBJECT_EMOJI_CLASS_NAME);
      this.g.append(foreignObject);
      const container = document.createElement("div");
      container.classList.add("node-emojis-container");
      foreignObject.append(container);
      this.emojiGenerators = element.data.emojis.map((emojiItem) => {
        const drawer = new EmojiGenerator(this.board);
        drawer.draw(container, emojiItem, element);
        return drawer;
      });
      return this.g;
    }
    return void 0;
  }
  destroy() {
    if (this.g) {
      this.g.remove();
    }
    this.emojiGenerators.forEach((drawer) => drawer.destroy());
    this.emojiGenerators = [];
  }
};
_NodeEmojisGenerator.key = "node-emojis-generator";
var NodeEmojisGenerator = _NodeEmojisGenerator;
var drawFakeDragNode = (board, element, offsetX, offsetY) => {
  const ref = PlaitElement.getElementRef(element);
  const mindNode = MindElement.getNode(element);
  const dragFakeNodeG = createG();
  dragFakeNodeG.classList.add("dragging", "fake-node", "plait-board-attached");
  const fakeDraggingNode = {
    ...mindNode,
    children: [],
    x: mindNode.x + offsetX,
    y: mindNode.y + offsetY
  };
  const textRectangle = getTopicRectangleByNode(board, mindNode);
  const fakeNodeG = drawRoundRectangleByNode(board, fakeDraggingNode);
  const richtextG = getFirstTextManage(element).g.cloneNode(true);
  updateForeignObject(richtextG, textRectangle.width, textRectangle.height, textRectangle.x + offsetX, textRectangle.y + offsetY);
  dragFakeNodeG == null ? void 0 : dragFakeNodeG.append(fakeNodeG);
  dragFakeNodeG == null ? void 0 : dragFakeNodeG.append(richtextG);
  if (MindElement.hasEmojis(element)) {
    const nodeEmojisGenerator = ref.getGenerator(NodeEmojisGenerator.key);
    const fakeEmojisG = nodeEmojisGenerator.g.cloneNode(true);
    const foreignRectangle = getEmojiForeignRectangle(board, element);
    updateForeignObject(fakeEmojisG, foreignRectangle.width, foreignRectangle.height, foreignRectangle.x + offsetX, foreignRectangle.y + offsetY);
    dragFakeNodeG == null ? void 0 : dragFakeNodeG.append(fakeEmojisG);
  }
  if (MindElement.hasImage(element)) {
    const imageGenerator = ref.getGenerator(ImageGenerator.key);
    const fakeImageG = imageGenerator.g.cloneNode(true);
    const foreignRectangle = getImageForeignRectangle(board, element);
    updateForeignObject(fakeImageG, foreignRectangle.width, foreignRectangle.height, foreignRectangle.x + offsetX, foreignRectangle.y + offsetY);
    dragFakeNodeG == null ? void 0 : dragFakeNodeG.append(fakeImageG);
  }
  return dragFakeNodeG;
};
var drawFakeDropNode = (board, dropTarget, path) => {
  const target = dropTarget.target;
  const fakeDropNodeG = createG();
  const parent = PlaitNode.get(board, Path.parent(path));
  const layout2 = MindQueries.getLayoutByElement(parent);
  const isHorizontal = isHorizontalLayout(layout2);
  const { hasNextNode, hasPreviousNode } = hasPreviousOrNextOfDropPath(parent, dropTarget, path);
  const width = 30;
  const height = 12;
  let fakeNode, centerPoint, basicNode, linkDirection;
  if (!hasPreviousNode && !hasNextNode) {
    const parentNode = MindElement.getNode(parent);
    const parentRect = getRectangleByNode(parentNode);
    linkDirection = getLayoutDirection(parentNode, isHorizontal);
    basicNode = parentNode;
    if (PlaitMind.isMind(target) && isStandardLayout(layout2)) {
      if (dropTarget.detectResult === "left") {
        linkDirection = LayoutDirection.left;
        basicNode.left = true;
      } else {
        linkDirection = LayoutDirection.right;
        basicNode.left = false;
      }
    }
    const placement = [HorizontalPlacement.right, VerticalPlacement.middle];
    transformPlacement(placement, linkDirection);
    const parentCenterPoint = getPointByPlacement(parentRect, placement);
    if (isIndentedLayout(layout2)) {
      const placement2 = [
        HorizontalPlacement.center,
        isTopLayout(layout2) ? VerticalPlacement.top : VerticalPlacement.bottom
      ];
      const parentCenterPoint2 = getPointByPlacement(parentRect, placement2);
      centerPoint = moveXOfPoint(parentCenterPoint2, height, linkDirection);
      centerPoint[1] = isTopLayout(layout2) ? centerPoint[1] - height : centerPoint[1] + height;
    } else {
      centerPoint = moveXOfPoint(parentCenterPoint, width, linkDirection);
    }
  } else if (!hasPreviousNode && hasNextNode) {
    const nextElement = PlaitNode.get(board, path);
    basicNode = MindElement.getNode(nextElement);
    const nextRect = getRectangleByNode(basicNode);
    linkDirection = getLayoutDirection(basicNode, isHorizontal);
    const placement = [HorizontalPlacement.left, VerticalPlacement.top];
    transformPlacement(placement, linkDirection);
    let offset = -height;
    if (MindElement.isIndentedLayout(parent)) {
      offset = isTopLayout(layout2) ? offset / 2 + basicNode.height - basicNode.vGap : 0;
    }
    centerPoint = getPointByPlacement(nextRect, placement);
    centerPoint = moveYOfPoint(centerPoint, offset, linkDirection);
  } else if (hasPreviousNode && !hasNextNode) {
    const previousElement = PlaitNode.get(board, Path.previous(path));
    basicNode = MindElement.getNode(previousElement);
    const previousRect = getRectangleByNode(basicNode);
    linkDirection = getLayoutDirection(basicNode, isHorizontal);
    const placement = [HorizontalPlacement.left, VerticalPlacement.bottom];
    transformPlacement(placement, linkDirection);
    let offset = height;
    if (MindElement.isIndentedLayout(parent)) {
      offset = isTopLayout(layout2) ? -offset - (basicNode.height - basicNode.vGap) : offset;
    }
    centerPoint = getPointByPlacement(previousRect, placement);
    centerPoint = moveYOfPoint(centerPoint, offset, linkDirection);
  } else {
    const previousElement = PlaitNode.get(board, Path.previous(path));
    basicNode = MindElement.getNode(previousElement);
    const previousRect = getRectangleByNode(basicNode);
    const nextElement = PlaitNode.get(board, path);
    const nextNode = MindElement.getNode(nextElement);
    const nextRect = getRectangleByNode(nextNode);
    const beginPlacement = [HorizontalPlacement.left, VerticalPlacement.bottom];
    const endPlacement = [HorizontalPlacement.left, VerticalPlacement.top];
    linkDirection = getLayoutDirection(basicNode, isHorizontal);
    transformPlacement(beginPlacement, linkDirection);
    transformPlacement(endPlacement, linkDirection);
    const previousPoint = getPointByPlacement(previousRect, beginPlacement);
    const nextPoint = getPointByPlacement(nextRect, endPlacement);
    centerPoint = [(previousPoint[0] + nextPoint[0]) / 2, (previousPoint[1] + nextPoint[1]) / 2];
  }
  let cornerPoint = centerPoint, oppositePoint = centerPoint;
  const offsetY = isHorizontal ? height : width;
  const offsetX = isHorizontal ? width : height;
  cornerPoint = moveYOfPoint(cornerPoint, -offsetY / 2, linkDirection);
  oppositePoint = moveYOfPoint(oppositePoint, offsetY / 2, linkDirection);
  oppositePoint = moveXOfPoint(oppositePoint, offsetX, linkDirection);
  const x = Math.min(cornerPoint[0], oppositePoint[0]);
  const y = Math.min(cornerPoint[1], oppositePoint[1]);
  fakeNode = {
    ...basicNode,
    x,
    y,
    width,
    height,
    hGap: MindElement.isIndentedLayout(parent) ? BASE * 4 + (basicNode.origin.strokeWidth || STROKE_WIDTH) : 0,
    vGap: MindElement.isIndentedLayout(parent) ? BASE : 0
  };
  const fakeRectangleG = drawRoundRectangle(PlaitBoard.getRoughSVG(board), fakeNode.x, fakeNode.y, fakeNode.x + width, fakeNode.y + height, {
    stroke: PRIMARY_COLOR,
    strokeWidth: 2,
    fill: PRIMARY_COLOR,
    fillStyle: "solid"
  });
  const link = drawLink(board, MindElement.getNode(parent), fakeNode, isHorizontal, false, PRIMARY_COLOR, STROKE_WIDTH);
  fakeDropNodeG == null ? void 0 : fakeDropNodeG.appendChild(link);
  fakeDropNodeG == null ? void 0 : fakeDropNodeG.appendChild(fakeRectangleG);
  return fakeDropNodeG;
};
var AbstractHandlePosition;
(function(AbstractHandlePosition2) {
  AbstractHandlePosition2["start"] = "start";
  AbstractHandlePosition2["end"] = "end";
})(AbstractHandlePosition || (AbstractHandlePosition = {}));
var AbstractResizeState;
(function(AbstractResizeState2) {
  AbstractResizeState2["start"] = "start";
  AbstractResizeState2["resizing"] = "resizing";
  AbstractResizeState2["end"] = "end";
})(AbstractResizeState || (AbstractResizeState = {}));
function drawAbstractIncludedOutline(board, roughSVG, element, activeHandlePosition, resizingLocation) {
  const abstractIncludedG = createG();
  const parentElement = MindElement.getParent(element);
  const nodeLayout = MindQueries.getCorrectLayoutByElement(board, element);
  const isHorizontal = isHorizontalLayout(nodeLayout);
  const includedElements = parentElement.children.slice(element.start, element.end + 1);
  const abstractRectangle = getRectangleByElements(board, includedElements, true);
  const activeAbstractRectangle = toActiveRectangleFromViewBoxRectangle(board, abstractRectangle);
  let activeAbstractOutlineRectangle = RectangleClient.getOutlineRectangle(activeAbstractRectangle, -ABSTRACT_INCLUDED_OUTLINE_OFFSET);
  if (resizingLocation) {
    activeAbstractOutlineRectangle = getRectangleByResizingLocation(activeAbstractOutlineRectangle, resizingLocation, activeHandlePosition, isHorizontal);
  }
  const rectangle = drawAbstractRoundRectangle(roughSVG, activeAbstractOutlineRectangle.x, activeAbstractOutlineRectangle.y, activeAbstractOutlineRectangle.x + activeAbstractOutlineRectangle.width, activeAbstractOutlineRectangle.y + activeAbstractOutlineRectangle.height, isHorizontal, {
    stroke: PRIMARY_COLOR,
    strokeWidth: 1,
    fillStyle: "solid"
  });
  const startPlacement = [HorizontalPlacement.center, VerticalPlacement.top];
  const endPlacement = [HorizontalPlacement.center, VerticalPlacement.bottom];
  const linkDirection = getLayoutDirection(MindElement.getNode(element), isHorizontal);
  transformPlacement(startPlacement, linkDirection);
  transformPlacement(endPlacement, linkDirection);
  let startCenterPoint = getPointByPlacement(activeAbstractOutlineRectangle, startPlacement);
  let endCenterPoint = getPointByPlacement(activeAbstractOutlineRectangle, endPlacement);
  const startPoint1 = moveXOfPoint(startCenterPoint, -ABSTRACT_HANDLE_LENGTH / 2, linkDirection);
  const startPoint2 = moveXOfPoint(startCenterPoint, ABSTRACT_HANDLE_LENGTH / 2, linkDirection);
  const endPoint1 = moveXOfPoint(endCenterPoint, -ABSTRACT_HANDLE_LENGTH / 2, linkDirection);
  const endPoint2 = moveXOfPoint(endCenterPoint, ABSTRACT_HANDLE_LENGTH / 2, linkDirection);
  const startHandle = roughSVG.line(startPoint1[0], startPoint1[1], startPoint2[0], startPoint2[1], getHandleOption(activeHandlePosition === AbstractHandlePosition.start));
  const endHandle = roughSVG.line(endPoint1[0], endPoint1[1], endPoint2[0], endPoint2[1], getHandleOption(activeHandlePosition === AbstractHandlePosition.end));
  handleBoardClass(board, activeHandlePosition, isHorizontal);
  setStrokeLinecap(startHandle, "round");
  setStrokeLinecap(endHandle, "round");
  abstractIncludedG.append(startHandle);
  abstractIncludedG.append(endHandle);
  abstractIncludedG.append(rectangle);
  return abstractIncludedG;
}
function getHandleOption(isHover) {
  return isHover ? {
    stroke: PRIMARY_COLOR,
    strokeWidth: 4,
    fillStyle: "solid"
  } : {
    stroke: ABSTRACT_HANDLE_COLOR,
    strokeWidth: 3,
    fillStyle: "solid"
  };
}
function handleBoardClass(board, activeHandlePosition, isHorizontal) {
  if (activeHandlePosition) {
    if (isHorizontal) {
      PlaitBoard.getBoardContainer(board).classList.add("abstract-resizing-horizontal");
    } else {
      PlaitBoard.getBoardContainer(board).classList.add("abstract-resizing-vertical");
    }
  } else {
    PlaitBoard.getBoardContainer(board).classList.remove("abstract-resizing-horizontal");
    PlaitBoard.getBoardContainer(board).classList.remove("abstract-resizing-vertical");
  }
}
function drawAbstractRoundRectangle(rs, x1, y1, x2, y2, isHorizontal, options) {
  const width = Math.abs(x1 - x2);
  const height = Math.abs(y1 - y2);
  const radius = 5;
  const handleGap = 4;
  const handleLength = 10;
  const handleSpace = handleLength + handleGap * 2;
  if (isHorizontal) {
    const handleSideLine = (width - handleSpace - radius * 2) / 2;
    const sideLine = height - radius * 2;
    return rs.path(`M${x1 + radius},${y1}
            l${handleSideLine},0
            m${handleSpace},0
            l${handleSideLine},0
            a${radius},${radius},0,0,1,${radius},${radius}
            l0,${sideLine}
            a${radius},${radius},0,0,1,-${radius},${radius}
            l-${handleSideLine},0
            m-${handleSpace},0
            l-${handleSideLine},0
            a${radius},${radius},0,0,1,-${radius},-${radius}
            l0,-${sideLine}
            a${radius},${radius},0,0,1,${radius},-${radius}`, options);
  } else {
    const handleSideLine = (height - handleSpace - radius * 2) / 2;
    const sideLine = width - radius * 2;
    return rs.path(`M${x1 + radius},${y1}
            l${sideLine},0
            a${radius},${radius},0,0,1,${radius},${radius}
            l0,${handleSideLine}
            m0,${handleSpace}
            l0,${handleSideLine}
            a${radius},${radius},0,0,1,-${radius},${radius}
            l-${sideLine},0
            a${radius},${radius},0,0,1,-${radius},-${radius}
            l0,-${handleSideLine}
            m0,-${handleSpace}
            l0,-${handleSideLine}
            a${radius},${radius},0,0,1,${radius},-${radius}`, options);
  }
}
var _NodeActiveGenerator = class _NodeActiveGenerator extends Generator {
  canDraw(element, data) {
    if (data.selected) {
      return true;
    } else {
      return false;
    }
  }
  draw(element, data) {
    const activeG = createG();
    const node = MindElement.getNode(element);
    const rectangle = getRectangleByNode(node);
    const activeRectangle1 = toActiveRectangleFromViewBoxRectangle(this.board, rectangle);
    const strokeWidth = getStrokeWidthByElement(this.board, element);
    const activeStrokeWidth = ACTIVE_STROKE_WIDTH;
    const activeRectangleWithInflated = RectangleClient.inflate(activeRectangle1, activeStrokeWidth);
    const strokeG = drawRoundRectangle(PlaitBoard.getRoughSVG(this.board), activeRectangleWithInflated.x, activeRectangleWithInflated.y, activeRectangleWithInflated.x + activeRectangleWithInflated.width, activeRectangleWithInflated.y + activeRectangleWithInflated.height, { stroke: PRIMARY_COLOR, strokeWidth: activeStrokeWidth, fill: "" }, true, DefaultNodeStyle.shape.rectangleRadius + (activeStrokeWidth + strokeWidth) / 2);
    if (AbstractNode.isAbstract(element)) {
      this.abstractOutlineG = drawAbstractIncludedOutline(this.board, PlaitBoard.getRoughSVG(this.board), element);
      activeG.append(this.abstractOutlineG);
      strokeG.classList.add("abstract-element");
    }
    activeG.appendChild(strokeG);
    activeG.classList.add(SELECTION_RECTANGLE_CLASS_NAME);
    return activeG;
  }
  updateAbstractOutline(element, activeHandlePosition, resizingLocation) {
    const abstractOutlineG = drawAbstractIncludedOutline(this.board, PlaitBoard.getRoughSVG(this.board), element, activeHandlePosition, resizingLocation);
    if (this.abstractOutlineG) {
      this.abstractOutlineG.replaceWith(abstractOutlineG);
      this.abstractOutlineG = abstractOutlineG;
    }
  }
};
_NodeActiveGenerator.key = "mind-node-active";
var NodeActiveGenerator = _NodeActiveGenerator;
var getRectangleByResizingLocation = (abstractRectangle, location, activeHandlePosition, isHorizontal) => {
  if (isHorizontal) {
    if (activeHandlePosition === AbstractHandlePosition.start) {
      return {
        ...abstractRectangle,
        y: location,
        height: abstractRectangle.height + abstractRectangle.y - location
      };
    } else {
      return {
        ...abstractRectangle,
        height: location - abstractRectangle.y
      };
    }
  } else {
    if (activeHandlePosition === AbstractHandlePosition.start) {
      return {
        ...abstractRectangle,
        x: location,
        width: abstractRectangle.width + abstractRectangle.x - location
      };
    } else {
      return {
        ...abstractRectangle,
        width: location - abstractRectangle.x
      };
    }
  }
};
var getLocationScope = (board, handlePosition, parentChildren, element, parent, isHorizontal) => {
  const node = MindElement.getNode(element);
  const { start, end } = getCorrectStartEnd(node.origin, parent);
  const startNode = parentChildren[start];
  const endNode = parentChildren[end];
  if (handlePosition === AbstractHandlePosition.start) {
    const abstractNode = parentChildren.filter((child) => AbstractNode.isAbstract(child) && child.end < element.start);
    let minNode;
    if (abstractNode.length) {
      const index = abstractNode.map((node2) => {
        const { end: end2 } = getCorrectStartEnd(node2, parent);
        return end2;
      }).sort((a, b) => b - a)[0];
      minNode = parentChildren[index + 1];
    } else {
      minNode = parentChildren[0];
    }
    const minNodeRectangle = getRectangleByElements(board, [minNode], true);
    const endNodeRectangle = getRectangleByElements(board, [endNode], false);
    if (isHorizontal) {
      return {
        max: endNodeRectangle.y - ABSTRACT_INCLUDED_OUTLINE_OFFSET,
        min: minNodeRectangle.y - ABSTRACT_INCLUDED_OUTLINE_OFFSET
      };
    } else {
      return {
        max: endNodeRectangle.x - ABSTRACT_INCLUDED_OUTLINE_OFFSET,
        min: minNodeRectangle.x - ABSTRACT_INCLUDED_OUTLINE_OFFSET
      };
    }
  } else {
    const abstractNode = parentChildren.filter((child) => AbstractNode.isAbstract(child) && child.start > element.end);
    let maxNode;
    if (abstractNode.length) {
      const index = abstractNode.map((node2) => {
        const { start: start2 } = getCorrectStartEnd(node2, parent);
        return start2;
      }).sort((a, b) => a - b)[0];
      maxNode = parentChildren[index - 1];
    } else {
      const children = parentChildren.filter((child) => !AbstractNode.isAbstract(child));
      maxNode = parentChildren[children.length - 1];
    }
    const maxNodeRectangle = getRectangleByElements(board, [maxNode], true);
    const startNodeRectangle = getRectangleByElements(board, [startNode], false);
    if (isHorizontal) {
      return {
        max: maxNodeRectangle.y + maxNodeRectangle.height + ABSTRACT_INCLUDED_OUTLINE_OFFSET,
        min: startNodeRectangle.y + startNodeRectangle.height + ABSTRACT_INCLUDED_OUTLINE_OFFSET
      };
    } else {
      return {
        max: maxNodeRectangle.x + maxNodeRectangle.width + ABSTRACT_INCLUDED_OUTLINE_OFFSET,
        min: startNodeRectangle.x + startNodeRectangle.width + ABSTRACT_INCLUDED_OUTLINE_OFFSET
      };
    }
  }
};
var getHitAbstractHandle = (board, element, point) => {
  const nodeLayout = MindQueries.getCorrectLayoutByElement(board, element);
  const isHorizontal = isHorizontalLayout(nodeLayout);
  const parentElement = MindElement.getParent(element);
  const includedElements = parentElement.children.slice(element.start, element.end + 1);
  let abstractRectangle = getRectangleByElements(board, includedElements, true);
  abstractRectangle = RectangleClient.getOutlineRectangle(abstractRectangle, -ABSTRACT_INCLUDED_OUTLINE_OFFSET);
  const startHandleRec = getAbstractHandleRectangle(abstractRectangle, isHorizontal, AbstractHandlePosition.start);
  const endHandleRec = getAbstractHandleRectangle(abstractRectangle, isHorizontal, AbstractHandlePosition.end);
  const pointRec = RectangleClient.getRectangleByPoints([point, point]);
  if (RectangleClient.isHit(pointRec, startHandleRec))
    return AbstractHandlePosition.start;
  if (RectangleClient.isHit(pointRec, endHandleRec))
    return AbstractHandlePosition.end;
  return void 0;
};
var getAbstractHandleRectangle = (rectangle, isHorizontal, position) => {
  let result;
  if (position === AbstractHandlePosition.start) {
    const location = isHorizontal ? rectangle.y : rectangle.x;
    result = getRectangleByResizingLocation(rectangle, location + ABSTRACT_HANDLE_MASK_WIDTH / 2, AbstractHandlePosition.end, isHorizontal);
    result = getRectangleByResizingLocation(result, location - ABSTRACT_HANDLE_MASK_WIDTH / 2, position, isHorizontal);
  } else {
    const location = isHorizontal ? rectangle.y + rectangle.height : rectangle.x + rectangle.width;
    result = getRectangleByResizingLocation(rectangle, location - ABSTRACT_HANDLE_MASK_WIDTH / 2, AbstractHandlePosition.start, isHorizontal);
    result = getRectangleByResizingLocation(result, location + ABSTRACT_HANDLE_MASK_WIDTH / 2, position, isHorizontal);
  }
  return result;
};
function findLocationLeftIndex(board, parentChildren, location, isHorizontal) {
  const children = parentChildren.filter((child) => {
    return !AbstractNode.isAbstract(child);
  });
  const recArray = children.map((child) => {
    return getRectangleByElements(board, [child], false);
  });
  const firstRec = getRectangleByElements(board, [children[0]], true);
  const fakeLeftRec = {
    x: firstRec.x - firstRec.width,
    y: firstRec.y - firstRec.height,
    width: firstRec.width,
    height: firstRec.height
  };
  const lastRec = getRectangleByElements(board, [children[children.length - 1]], true);
  const fakeRightRec = {
    x: lastRec.x + lastRec.width,
    y: lastRec.y + lastRec.height,
    width: lastRec.width,
    height: lastRec.height
  };
  recArray.push(fakeRightRec);
  recArray.unshift(fakeLeftRec);
  for (let i = 0; i < recArray.length - 1; i++) {
    const recXOrY = isHorizontal ? recArray[i].y : recArray[i].x;
    const recWidthOrHeight = isHorizontal ? recArray[i].height : recArray[i].width;
    if (location >= recXOrY + recWidthOrHeight / 2 && location <= recArray[i + 1][isHorizontal ? "y" : "x"] + recArray[i + 1][isHorizontal ? "height" : "width"] / 2) {
      return i - 1;
    }
  }
  return 0;
}
function handleTouchedAbstract(board, touchedAbstract, endPoint) {
  let touchedHandle;
  const abstract = getSelectedElements(board).filter((element) => AbstractNode.isAbstract(element)).find((element) => {
    touchedHandle = getHitAbstractHandle(board, element, endPoint);
    return touchedHandle;
  });
  if (touchedAbstract === abstract) {
    return touchedAbstract;
  }
  if (touchedAbstract) {
    const ref = PlaitElement.getElementRef(touchedAbstract);
    const activeGenerator = ref.getGenerator(NodeActiveGenerator.key);
    activeGenerator.updateAbstractOutline(touchedAbstract);
    touchedAbstract = void 0;
  }
  if (abstract) {
    touchedAbstract = abstract;
    const ref = PlaitElement.getElementRef(touchedAbstract);
    const activeGenerator = ref.getGenerator(NodeActiveGenerator.key);
    activeGenerator.updateAbstractOutline(touchedAbstract, touchedHandle);
  }
  return touchedAbstract;
}
var isInRightBranchOfStandardLayout = (selectedElement) => {
  const parentElement = MindElement.findParent(selectedElement);
  if (parentElement) {
    const nodeIndex = parentElement.children.findIndex((item) => item.id === selectedElement.id);
    if (parentElement.isRoot && getRootLayout(parentElement) === MindLayoutType.standard && parentElement.rightNodeCount && nodeIndex <= parentElement.rightNodeCount - 1) {
      return true;
    }
  }
  return false;
};
var insertElementHandleRightNodeCount = (board, path, insertCount, effectedRightNodeCount = []) => {
  let index = effectedRightNodeCount.findIndex((ref) => Path.equals(ref.path, path));
  const mind = PlaitNode.get(board, path);
  if (index === -1) {
    effectedRightNodeCount.push({ path, rightNodeCount: mind.rightNodeCount + insertCount });
  } else {
    effectedRightNodeCount[index].rightNodeCount += insertCount;
  }
  return effectedRightNodeCount;
};
var deleteElementsHandleRightNodeCount = (board, deletableElements, effectedRightNodeCount = []) => {
  deletableElements.forEach((element) => {
    if (isInRightBranchOfStandardLayout(element)) {
      const mind = MindElement.getParent(element);
      const path = PlaitBoard.findPath(board, mind);
      let index = effectedRightNodeCount.findIndex((ref) => Path.equals(ref.path, path));
      if (index === -1) {
        effectedRightNodeCount.push({ path, rightNodeCount: mind.rightNodeCount - 1 });
      } else {
        effectedRightNodeCount[index].rightNodeCount -= 1;
      }
    }
  });
  return effectedRightNodeCount;
};
function findNewChildNodePath(board, element) {
  const children = getNonAbstractChildren(element);
  return PlaitBoard.findPath(board, element).concat(children.length);
}
function findNewSiblingNodePath(board, element) {
  const path = PlaitBoard.findPath(board, element);
  return Path2.next(path);
}
var getCorrectLayoutByElement = (board, element) => {
  const ancestors = MindElement.getAncestors(board, element);
  ancestors.unshift(element);
  const root = ancestors[ancestors.length - 1];
  let rootLayout = getRootLayout(root);
  if (PlaitMind.isMind(element)) {
    return rootLayout;
  }
  const node = MindElement.getNode(element);
  let correctRootLayout = rootLayout;
  if (rootLayout === MindLayoutType.standard) {
    correctRootLayout = node.left ? MindLayoutType.left : MindLayoutType.right;
  }
  let layout2 = null;
  const elementWithLayout = ancestors.find((value) => value.layout || AbstractNode.isAbstract(value));
  if (elementWithLayout) {
    if (AbstractNode.isAbstract(elementWithLayout)) {
      const parent = MindElement.getParent(elementWithLayout);
      const parentLayout = getCorrectLayoutByElement(board, parent);
      layout2 = getAbstractLayout(parentLayout);
    } else {
      layout2 = elementWithLayout == null ? void 0 : elementWithLayout.layout;
    }
  }
  if (layout2 === MindLayoutType.standard || !layout2) {
    return correctRootLayout;
  } else {
    const incorrectDirection = getInCorrectLayoutDirection(correctRootLayout, layout2);
    if (incorrectDirection) {
      return correctLayoutByDirection(layout2, incorrectDirection);
    } else {
      return layout2;
    }
  }
};
var getBranchLayouts = (board, element) => {
  const layouts = [];
  if (element.layout) {
    layouts.unshift(getCorrectLayoutByElement(board, element));
  }
  let parent = MindElement.findParent(element);
  while (parent) {
    if (parent.layout) {
      layouts.unshift(parent.layout);
    }
    parent = MindElement.findParent(parent);
  }
  return layouts;
};
var getAvailableSubLayoutsByElement = (board, element) => {
  const parentElement = MindElement.findParent(element);
  if (parentElement) {
    const branchLayouts = getBranchLayouts(board, parentElement);
    if (branchLayouts[0] === MindLayoutType.standard) {
      const node = MindElement.getNode(element);
      branchLayouts[0] = node.left ? MindLayoutType.left : MindLayoutType.right;
    }
    const currentLayoutDirections = getBranchDirectionsByLayouts(branchLayouts);
    let availableSubLayouts = getAvailableSubLayoutsByLayoutDirections(currentLayoutDirections);
    const parentLayout = [branchLayouts[branchLayouts.length - 1]];
    const parentDirections = getBranchDirectionsByLayouts(parentLayout);
    const parentAvailableSubLayouts = getAvailableSubLayoutsByLayoutDirections(parentDirections);
    availableSubLayouts = availableSubLayouts.filter((layout2) => parentAvailableSubLayouts.some((parentAvailableSubLayout) => parentAvailableSubLayout === layout2));
    return availableSubLayouts;
  }
  return void 0;
};
var getLayoutByElement = (element) => {
  const layout2 = element.layout;
  if (layout2) {
    return layout2;
  }
  const parent = !PlaitMind.isMind(element) && MindElement.getParent(element);
  if (AbstractNode.isAbstract(element) && parent) {
    return getAbstractLayout(getLayoutByElement(parent));
  }
  if (parent) {
    return getLayoutByElement(parent);
  }
  return getDefaultLayout();
};
var MindQueries = {
  getAvailableSubLayoutsByElement,
  getBranchLayouts,
  getLayoutByElement,
  getCorrectLayoutByElement
};
var PlaitMind = {
  isMind: (value) => {
    return value.type === "mindmap";
  }
};
var MindElement = {
  hasLayout(value, layout2) {
    const _layout = MindQueries.getLayoutByElement(value);
    return _layout === layout2;
  },
  isIndentedLayout(value) {
    const _layout = MindQueries.getLayoutByElement(value);
    return isIndentedLayout(_layout);
  },
  isMindElement(board, element) {
    if (element.data && element.data.topic && !isNullOrUndefined(element.width) && !isNullOrUndefined(element.height)) {
      return true;
    } else {
      return false;
    }
  },
  getParent(node) {
    if (PlaitMind.isMind(node)) {
      throw new Error("mind root node can not get parent");
    }
    const parent = NODE_TO_PARENT.get(node);
    return parent;
  },
  findParent(node) {
    if (PlaitMind.isMind(node)) {
      return void 0;
    }
    const parent = NODE_TO_PARENT.get(node);
    return parent;
  },
  getRoot(board, element) {
    const path = PlaitBoard.findPath(board, element);
    return PlaitNode.get(board, path.slice(0, 1));
  },
  getAncestors(board, element) {
    const path = PlaitBoard.findPath(board, element);
    const parents = [];
    for (const p of Path.ancestors(path, { reverse: true })) {
      const n = PlaitNode.get(board, p);
      if (n && !PlaitBoard.isBoard(n)) {
        parents.push(n);
      }
    }
    return parents;
  },
  getNode(element) {
    const node = ELEMENT_TO_NODE.get(element);
    if (!node) {
      throw new Error(`can not get node from ${JSON.stringify(element)}`);
    }
    return node;
  },
  findParentNode(element) {
    if (PlaitMind.isMind(element)) {
      return void 0;
    }
    const parent = MindElement.getParent(element);
    return MindElement.getNode(parent);
  },
  hasEmojis(element) {
    if (element.data.emojis) {
      return true;
    } else {
      return false;
    }
  },
  hasImage(element) {
    if (element.data.image) {
      return true;
    } else {
      return false;
    }
  },
  getEmojis(element) {
    return element.data.emojis;
  }
};
var MindElementShape;
(function(MindElementShape2) {
  MindElementShape2["roundRectangle"] = "round-rectangle";
  MindElementShape2["underline"] = "underline";
})(MindElementShape || (MindElementShape = {}));
var BranchShape;
(function(BranchShape2) {
  BranchShape2["bight"] = "bight";
  BranchShape2["polyline"] = "polyline";
})(BranchShape || (BranchShape = {}));
function drawAbstractLink(board, node, isHorizontal) {
  const linkPadding = 15;
  const branchWidth = getAbstractBranchWidth(board, node.origin);
  const branchColor = getAbstractBranchColor(board, node.origin);
  const strokeStyle = getStrokeStyleByElement(board, node.origin);
  const parent = node.parent;
  const branchShape = getBranchShapeByMindElement(board, node.origin);
  const abstractRectangle = getRectangleByNode(node);
  let includedElements = parent.children.slice(node.origin.start, node.origin.end + 1).map((node2) => {
    return node2.origin;
  });
  const includedElementsRectangle = getRectangleByElements(board, includedElements, true);
  const linkDirection = getLayoutDirection(node, isHorizontal);
  const bezierBeginPlacement = [HorizontalPlacement.right, VerticalPlacement.top];
  const bezierEndPlacement = [HorizontalPlacement.right, VerticalPlacement.bottom];
  const abstractConnectorPlacement = [HorizontalPlacement.left, VerticalPlacement.middle];
  transformPlacement(bezierBeginPlacement, linkDirection);
  transformPlacement(bezierEndPlacement, linkDirection);
  transformPlacement(abstractConnectorPlacement, linkDirection);
  let bezierBeginPoint = getPointByPlacement(includedElementsRectangle, bezierBeginPlacement);
  let bezierEndPoint = getPointByPlacement(includedElementsRectangle, bezierEndPlacement);
  let abstractConnectorPoint = getPointByPlacement(abstractRectangle, abstractConnectorPlacement);
  let curveDistance = getXDistanceBetweenPoint(abstractConnectorPoint, bezierBeginPoint, isHorizontal) - linkPadding * 2;
  bezierBeginPoint = moveXOfPoint(bezierBeginPoint, linkPadding, linkDirection);
  let c1 = moveXOfPoint(bezierBeginPoint, curveDistance, linkDirection);
  bezierEndPoint = moveXOfPoint(bezierEndPoint, linkPadding, linkDirection);
  let c2 = moveXOfPoint(bezierEndPoint, curveDistance, linkDirection);
  let bezierConnectorPoint = moveXOfPoint(abstractConnectorPoint, -linkPadding, linkDirection);
  const strokeLineDash = getStrokeLineDash(strokeStyle, branchWidth);
  if (branchShape === BranchShape.polyline) {
    const g = createG();
    const polyline = drawLinearPath([bezierBeginPoint, c1, bezierConnectorPoint, c2, bezierEndPoint], {
      stroke: branchColor,
      strokeWidth: branchWidth
    });
    const straightLine = drawLinearPath([abstractConnectorPoint, bezierConnectorPoint], {
      stroke: branchColor,
      strokeWidth: branchWidth,
      strokeLineDash
    });
    g.appendChild(polyline);
    g.appendChild(straightLine);
    return g;
  }
  const link = PlaitBoard.getRoughSVG(board).path(`M${bezierBeginPoint[0]},${bezierBeginPoint[1]} Q${c1[0]},${c1[1]} ${bezierConnectorPoint[0]},${bezierConnectorPoint[1]} Q${c2[0]},${c2[1]} ${bezierEndPoint[0]},${bezierEndPoint[1]} M${abstractConnectorPoint[0]},${abstractConnectorPoint[1]} L${bezierConnectorPoint[0]},${bezierConnectorPoint[1]}`, {
    stroke: branchColor,
    strokeWidth: branchWidth,
    strokeLineDash
  });
  return link;
}
var setAbstractsByRefs = (board, abstractRefs) => {
  abstractRefs.forEach((newProperty, element) => {
    const start = element.start + newProperty.start;
    const end = element.end + newProperty.end;
    const path = PlaitBoard.findPath(board, element);
    if (start > end) {
      Transforms.removeNode(board, path);
    } else {
      Transforms.setNode(board, { start, end }, path);
    }
  });
};
var setAbstractByStandardLayout = (board, element) => {
  const rightNodeCount = element.rightNodeCount;
  const abstract = element.children.find((child) => {
    return AbstractNode.isAbstract(child) && child.end >= rightNodeCount && child.start < rightNodeCount;
  });
  if (abstract) {
    const path = PlaitBoard.findPath(board, abstract);
    Transforms.setNode(board, { end: rightNodeCount - 1 }, path);
  }
};
var insertAbstract = (board, elements) => {
  let elementGroup = getFirstLevelElement(elements);
  const { parentElements, abstractIncludedGroups } = divideElementByParent(elementGroup);
  abstractIncludedGroups.forEach((group, index) => {
    const groupParent = parentElements[index];
    setAbstractByElements(board, groupParent, group);
  });
};
var setAbstractByElements = (board, groupParent, group) => {
  const indexArray = group.map((child) => groupParent.children.indexOf(child)).sort((a, b) => a - b);
  const rightNodeCount = groupParent == null ? void 0 : groupParent.rightNodeCount;
  const start = indexArray[0], end = indexArray[indexArray.length - 1];
  if (isStandardLayout(MindQueries.getLayoutByElement(groupParent)) && rightNodeCount && start < rightNodeCount && end >= rightNodeCount) {
    const childrenLength = groupParent.children.length;
    const path = [...PlaitBoard.findPath(board, groupParent), childrenLength];
    const leftChildren = indexArray.filter((index) => index >= rightNodeCount);
    const rightChildren = indexArray.filter((index) => index < rightNodeCount);
    insertAbstractNode(board, path, rightChildren[0], rightChildren[rightChildren.length - 1]);
    insertAbstractNode(board, Path.next(path), leftChildren[0], leftChildren[leftChildren.length - 1]);
  } else {
    const path = [...PlaitBoard.findPath(board, groupParent), groupParent.children.length];
    insertAbstractNode(board, path, start, end);
  }
};
var insertAbstractNode = (board, path, start, end) => {
  const abstractNodeText = getAbstractNodeText(board);
  const { width, height } = getTopicSize(board, false, false, buildText(abstractNodeText));
  const mindElement = createMindElement(abstractNodeText, width, height, {
    strokeWidth: DefaultAbstractNodeStyle.branch.width,
    branchWidth: DefaultAbstractNodeStyle.branch.width
  });
  mindElement.start = start;
  mindElement.end = end;
  Transforms.insertNode(board, mindElement, path);
  clearSelectedElement(board);
  addSelectedElement(board, mindElement);
};
var setTopic = (board, element, topic, width, height) => {
  const newElement = {
    data: { ...element.data, topic },
    ...normalizeWidthAndHeight(board, element, width, height)
  };
  const path = PlaitBoard.findPath(board, element);
  Transforms.setNode(board, newElement, path);
};
var setNodeManualWidth = (board, element, width, height) => {
  const path = PlaitBoard.findPath(board, element);
  const { width: normalizedWidth, height: normalizedHeight } = normalizeWidthAndHeight(board, element, width, height);
  const newElement = { manualWidth: normalizedWidth, height: normalizedHeight };
  Transforms.setNode(board, newElement, path);
};
var setTopicSize = (board, element, width, height) => {
  const newElement = {
    ...normalizeWidthAndHeight(board, element, width, height)
  };
  let isEqualWidth = Math.ceil(element.width) === Math.ceil(newElement.width);
  let isEqualHeight = Math.ceil(element.height) === Math.ceil(newElement.height);
  if (element.manualWidth) {
    isEqualWidth = true;
  }
  if (!isEqualWidth || !isEqualHeight) {
    const path = PlaitBoard.findPath(board, element);
    Transforms.setNode(board, newElement, path);
  }
};
var insertNodes = (board, elements, path) => {
  const pathRef = board.pathRef(path);
  elements.forEach((element) => {
    if (pathRef.current) {
      Transforms.insertNode(board, element, pathRef.current);
    }
  });
  pathRef.unref();
};
var insertAbstractNodes = (board, validAbstractRefs, elements, path) => {
  var _a;
  const parent = PlaitNode.get(board, Path2.parent(path));
  const abstractPath = [...Path2.parent(path), (_a = parent.children) == null ? void 0 : _a.length];
  const abstracts = validAbstractRefs.map((refs) => {
    const { start, end } = getRelativeStartEndByAbstractRef(refs, elements);
    return {
      ...refs.abstract,
      start: start + path[path.length - 1],
      end: end + path[path.length - 1]
    };
  });
  insertNodes(board, abstracts, abstractPath);
};
var setRightNodeCountByRefs = (board, refs) => {
  refs.forEach((ref) => {
    Transforms.setNode(board, { rightNodeCount: ref.rightNodeCount }, ref.path);
  });
};
var insertChildNode = (board, element) => {
  if (MindElement.isMindElement(board, element)) {
    removeSelectedElement(board, element);
    const targetElementPath = PlaitBoard.findPath(board, element);
    if (element.isCollapsed) {
      const newElement = { isCollapsed: false };
      PlaitHistoryBoard.withoutSaving(board, () => {
        Transforms.setNode(board, newElement, targetElementPath);
      });
    }
    insertMindElement(board, element, findNewChildNodePath(board, element));
  }
};
var insertSiblingNode = (board, element) => {
  if (MindElement.isMindElement(board, element) && !PlaitMind.isMind(element) && !AbstractNode.isAbstract(element)) {
    const path = PlaitBoard.findPath(board, element);
    if (isInRightBranchOfStandardLayout(element)) {
      const refs = insertElementHandleRightNodeCount(board, path.slice(0, 1), 1);
      setRightNodeCountByRefs(board, refs);
    }
    const abstractRefs = insertElementHandleAbstract(board, Path2.next(path));
    setAbstractsByRefs(board, abstractRefs);
    insertMindElement(board, element, findNewSiblingNodePath(board, element));
  }
};
var insertMind = (board, mind) => {
  Transforms.insertNode(board, mind, [board.children.length]);
  Transforms.addSelectionWithTemporaryElements(board, [mind]);
};
var addEmoji = (board, element, emojiItem) => {
  const emojis = element.data.emojis || [];
  const newEmojis = [...emojis];
  newEmojis.push(emojiItem);
  const newElement = {
    data: { ...element.data, emojis: newEmojis }
  };
  const path = PlaitBoard.findPath(board, element);
  Transforms.setNode(board, newElement, path);
};
var removeEmoji = (board, element, emojiItem) => {
  const emojis = element.data.emojis.filter((value) => value !== emojiItem);
  const newElement = {
    data: { topic: element.data.topic }
  };
  if (MindElement.hasImage(element)) {
    newElement.data.image = element.data.image;
  }
  if (emojis.length > 0) {
    newElement.data.emojis = emojis;
  }
  const path = PlaitBoard.findPath(board, element);
  Transforms.setNode(board, newElement, path);
};
var replaceEmoji = (board, element, oldEmoji, newEmoji) => {
  const newElement = {
    data: { ...element.data }
  };
  const newEmojis = element.data.emojis.map((value) => {
    if (value === oldEmoji) {
      return newEmoji;
    }
    return value;
  });
  newElement.data.emojis = newEmojis;
  const path = PlaitBoard.findPath(board, element);
  Transforms.setNode(board, newElement, path);
};
var removeImage = (board, element) => {
  removeImageFocus(board, element);
  const newElement = {
    data: { ...element.data }
  };
  delete newElement.data.image;
  const path = PlaitBoard.findPath(board, element);
  const newDynamicWidth = NodeSpace.getNodeNewDynamicWidth(board, element, 0);
  const newHeight = getNewNodeHeight(board, element, newDynamicWidth);
  if (newHeight) {
    newElement.height = newHeight;
  }
  Transforms.setNode(board, newElement, path);
};
var setImage = (board, element, imageItem) => {
  const newElement = {
    data: { ...element.data, image: imageItem }
  };
  const newDynamicWidth = NodeSpace.getNodeNewDynamicWidth(board, element, imageItem.width);
  const newHeight = getNewNodeHeight(board, element, newDynamicWidth);
  if (newHeight) {
    newElement.height = newHeight;
  }
  const path = PlaitBoard.findPath(board, element);
  Transforms.setNode(board, newElement, path);
};
var correctLogicLayoutNode = (board, layout2, path) => {
  var _a;
  const node = PlaitNode.get(board, path);
  if (node && layout2) {
    (_a = node.children) == null ? void 0 : _a.forEach((value, index) => {
      var _a2;
      if (value.layout) {
        if (isHorizontalLogicLayout(layout2) && isVerticalLogicLayout(value.layout) || isVerticalLogicLayout(layout2) && isHorizontalLogicLayout(value.layout)) {
          Transforms.setNode(board, { layout: null }, [...path, index]);
        }
        if ((_a2 = value.children) == null ? void 0 : _a2.length) {
          correctLogicLayoutNode(board, layout2, [...path, index]);
        }
      }
    });
  }
};
var setLayout = (board, type) => {
  const callback = (element, path) => {
    if (MindElement.isMindElement(board, element)) {
      correctLogicLayoutNode(board, type, path);
      const element2 = PlaitNode.get(board, path);
      if (PlaitMind.isMind(element2) && isStandardLayout(type)) {
        let properties = { rightNodeCount: element2.children.length / 2 };
        Transforms.setNode(board, properties, path);
        setAbstractByStandardLayout(board, element2);
      }
      Transforms.setNode(board, { layout: type }, path);
    }
  };
  PropertyTransforms.setProperty(board, {}, { callback });
};
var setShape = (board, shape) => {
  PropertyTransforms.setProperty(board, { shape });
};
var setBranchShape = (board, branchShape) => {
  PropertyTransforms.setProperty(board, { branchShape });
};
var setBranchWidth = (board, branchWidth) => {
  PropertyTransforms.setProperty(board, { branchWidth });
};
var setBranchColor = (board, branchColor) => {
  PropertyTransforms.setProperty(board, { branchColor });
};
var MindTransforms = {
  setLayout,
  setShape,
  setBranchShape,
  setBranchWidth,
  setBranchColor,
  setTopic,
  setTopicSize,
  setNodeManualWidth,
  addEmoji,
  removeEmoji,
  replaceEmoji,
  insertAbstract,
  setAbstractsByRefs,
  setAbstractByStandardLayout,
  insertNodes,
  insertAbstractNodes,
  setRightNodeCountByRefs,
  removeImage,
  setImage,
  insertChildNode,
  insertSiblingNode,
  insertMind
};
var NodeShapeGenerator = class extends Generator {
  constructor(board) {
    super(board, { prepend: true });
  }
  canDraw(element, data) {
    const shape = getShapeByElement(this.board, element);
    if (shape === MindElementShape.roundRectangle) {
      return true;
    }
    return false;
  }
  draw(element, data) {
    const rectangle = getRectangleByNode(data.node);
    return drawRoundRectangleByElement(this.board, rectangle, data.node.origin);
  }
};
var _NodeMoreGenerator = class _NodeMoreGenerator extends Generator {
  canDraw(element, extraData) {
    if (((extraData == null ? void 0 : extraData.isHovered) || (extraData == null ? void 0 : extraData.isHoveredCollapseArea) || (extraData == null ? void 0 : extraData.isHoveredAddArea)) && canHandleNodeMore(this.board) || (extraData == null ? void 0 : extraData.isSelected) && isLastSelectedMindElement(this.board, element) && canHandleNodeMore(this.board) || element.isCollapsed) {
      return true;
    }
    return false;
  }
  draw(element, extraData) {
    const moreGContainer = createG();
    const stroke = getBranchColorByMindElement(this.board, element);
    const layoutDirection = getNodeMoreLayoutDirection(this.board, element);
    const moreStartAndEnd = getMoreStartAndEnd(this.board, element, layoutDirection);
    const collapseOrExpandCenter = moveXOfPoint(moreStartAndEnd[1], NODE_MORE_ICON_DIAMETER / 2, layoutDirection);
    const hasChildren = element.children.length > 0;
    const isShowCollapseOrAdd = !element.isCollapsed && (isSelectedElement(this.board, element) || !!(extraData == null ? void 0 : extraData.isHovered) || !!(extraData == null ? void 0 : extraData.isHoveredCollapseArea) || !!(extraData == null ? void 0 : extraData.isHoveredAddArea));
    const isShowCollapse = isShowCollapseOrAdd && hasChildren && !PlaitMind.isMind(element);
    const isShowAdd = isShowCollapseOrAdd && !PlaitBoard.isReadonly(this.board);
    const addCenter = isShowCollapseOrAdd && getAddCenterByCollapseOrExpandCenter(element, collapseOrExpandCenter, layoutDirection) || null;
    this.toggleCollapseOrAdd(collapseOrExpandCenter, addCenter, stroke, moreGContainer, isShowCollapse, isShowAdd, !!(extraData == null ? void 0 : extraData.isHoveredAddArea), !!(extraData == null ? void 0 : extraData.isShowCollapseAnimation), !!(extraData == null ? void 0 : extraData.isShowAddAnimation));
    this.toggleExpandBadge(element, moreStartAndEnd, collapseOrExpandCenter, stroke, moreGContainer, !!element.isCollapsed, !!(extraData == null ? void 0 : extraData.isHoveredExpandArea));
    return moreGContainer;
  }
  toggleCollapseOrAdd(center, addCenter, stroke, parentG, isShowCollapse, isShowAdd, isHoveredAddArea, isShowCollapseAnimation, isShowAddAnimation) {
    var _a;
    (_a = this.collapseOrAddG) == null ? void 0 : _a.remove();
    if (!isShowCollapse && !isShowAdd) {
      return;
    }
    this.collapseOrAddG = createG();
    if (isShowCollapse) {
      const collapseG = createG();
      this.collapseOrAddG.appendChild(collapseG);
      collapseG.classList.add("collapse-button");
      if (isShowCollapseAnimation) {
        collapseG.classList.add("animated");
      }
      const collapseCircle = PlaitBoard.getRoughSVG(this.board).circle(center[0], center[1], NODE_MORE_ICON_DIAMETER, {
        fill: "#fff",
        stroke,
        strokeWidth: NODE_MORE_STROKE_WIDTH,
        fillStyle: "solid"
      });
      const start = moveXOfPoint(center, -NODE_MORE_BRIDGE_DISTANCE / 2);
      const end = moveXOfPoint(center, NODE_MORE_BRIDGE_DISTANCE / 2);
      const collapseLine = PlaitBoard.getRoughSVG(this.board).line(start[0], start[1], end[0], end[1], {
        fill: "#fff",
        stroke,
        strokeWidth: NODE_MORE_STROKE_WIDTH,
        fillStyle: "solid"
      });
      collapseG.appendChild(collapseCircle);
      collapseG.appendChild(collapseLine);
      setStrokeLinecap(collapseLine, "round");
    }
    if (isShowAdd && addCenter) {
      const addG = createG();
      this.collapseOrAddG.appendChild(addG);
      addG.classList.add("add-button");
      if (isShowAddAnimation) {
        addG.classList.add("animated");
      }
      const circle = PlaitBoard.getRoughSVG(this.board).circle(addCenter[0], addCenter[1], NODE_MORE_ICON_DIAMETER + NODE_MORE_STROKE_WIDTH, {
        fill: isHoveredAddArea ? NODE_ADD_HOVER_COLOR : NODE_ADD_CIRCLE_COLOR,
        stroke: TRANSPARENT,
        fillStyle: "solid"
      });
      const hLineBeginPoint = [addCenter[0] - NODE_MORE_BRIDGE_DISTANCE / 2, addCenter[1]];
      const hLineEndPoint = [addCenter[0] + NODE_MORE_BRIDGE_DISTANCE / 2, addCenter[1]];
      const vLineBeginPoint = [addCenter[0], addCenter[1] - NODE_MORE_BRIDGE_DISTANCE / 2];
      const vLineEndPoint = [addCenter[0], addCenter[1] + NODE_MORE_BRIDGE_DISTANCE / 2];
      const innerCrossHLine = PlaitBoard.getRoughSVG(this.board).line(hLineBeginPoint[0], hLineBeginPoint[1], hLineEndPoint[0], hLineEndPoint[1], {
        stroke: NODE_ADD_INNER_CROSS_COLOR,
        strokeWidth: NODE_MORE_STROKE_WIDTH
      });
      setStrokeLinecap(innerCrossHLine, "round");
      const innerCrossVLine = PlaitBoard.getRoughSVG(this.board).line(vLineBeginPoint[0], vLineBeginPoint[1], vLineEndPoint[0], vLineEndPoint[1], {
        stroke: NODE_ADD_INNER_CROSS_COLOR,
        strokeWidth: NODE_MORE_STROKE_WIDTH
      });
      setStrokeLinecap(innerCrossVLine, "round");
      addG.appendChild(circle);
      addG.appendChild(innerCrossHLine);
      addG.appendChild(innerCrossVLine);
    }
    parentG.appendChild(this.collapseOrAddG);
  }
  toggleExpandBadge(element, moreStartAndEnd, center, stroke, parentG, isCollapsed, isHoveredExpandIcon) {
    var _a;
    (_a = this.expandG) == null ? void 0 : _a.remove();
    if (!isCollapsed) {
      return;
    }
    this.expandG = createG();
    this.expandG.classList.add("expanded-button");
    const endWithWidth = moreStartAndEnd[1];
    const moreLine = PlaitBoard.getRoughSVG(this.board).line(moreStartAndEnd[0][0], moreStartAndEnd[0][1], endWithWidth[0], endWithWidth[1], {
      fill: stroke,
      stroke,
      fillStyle: "solid",
      strokeWidth: NODE_MORE_STROKE_WIDTH
    });
    const backgroundColor = isHoveredExpandIcon ? rgbaToHEX(stroke, 0.4) : rgbaToHEX(stroke, 0.2);
    const badgeBackground = PlaitBoard.getRoughSVG(this.board).circle(center[0], center[1], NODE_MORE_ICON_DIAMETER + NODE_MORE_STROKE_WIDTH, {
      fill: backgroundColor,
      stroke: TRANSPARENT,
      fillStyle: "solid"
    });
    const childrenCount = getChildrenCount(element);
    let text = `${childrenCount}`;
    let y = center[1] + 4.5;
    if (childrenCount >= 99) {
      text = "...";
      y = center[1] + 1;
    }
    const { width, height } = measureElement(this.board, buildText(text), {
      fontSize: Number(FontSizes.fontSize12),
      fontFamily: DEFAULT_FONT_FAMILY
    });
    const badgeText = createText(center[0] - width / 2, y, stroke, `${text}`);
    badgeText.setAttribute("style", `font-size: ${Number(FontSizes.fontSize12)}px;`);
    this.expandG.appendChild(moreLine);
    this.expandG.appendChild(badgeBackground);
    this.expandG.appendChild(badgeText);
    parentG.appendChild(this.expandG);
  }
};
_NodeMoreGenerator.key = "mind-node-more";
var NodeMoreGenerator = _NodeMoreGenerator;
var getCollapseAndAddCenterPoint = (board, element) => {
  const layoutDirection = getNodeMoreLayoutDirection(board, element);
  const [startPoint, endPoint] = getMoreStartAndEnd(board, element, layoutDirection);
  const collapseCenter = moveXOfPoint(endPoint, NODE_MORE_ICON_DIAMETER / 2, layoutDirection);
  const addCenter = getAddCenterByCollapseOrExpandCenter(element, collapseCenter, layoutDirection);
  return { collapseCenter, addCenter };
};
var getAddCenterByCollapseOrExpandCenter = (target, collapseOrExpandCenter, layoutDirection) => {
  var _a;
  let addCenter = collapseOrExpandCenter;
  if (((_a = target.children) == null ? void 0 : _a.length) > 0 && !PlaitMind.isMind(target)) {
    addCenter = moveXOfPoint(addCenter, NODE_MORE_LINE_DISTANCE + NODE_MORE_ICON_DIAMETER, layoutDirection);
  }
  return addCenter;
};
var getNodeMoreLayoutDirection = (board, element) => {
  const node = MindElement.getNode(element);
  const layout2 = MindQueries.getLayoutByElement(element);
  const isHorizontal = isHorizontalLayout(layout2);
  let layoutDirection = getLayoutDirection(node, isHorizontal);
  if (isIndentedLayout(layout2)) {
    layoutDirection = isTopLayout(layout2) ? LayoutDirection.top : LayoutDirection.bottom;
  }
  return layoutDirection;
};
var getMoreStartAndEnd = (board, element, linkLineDirection) => {
  const node = MindElement.getNode(element);
  const isUnderlineShape = getShapeByElement(board, element) === MindElementShape.underline;
  const nodeClient = getRectangleByNode(node);
  let placement = [HorizontalPlacement.right, VerticalPlacement.middle];
  transformPlacement(placement, linkLineDirection);
  const layout2 = MindQueries.getLayoutByElement(element);
  const isHorizontal = isHorizontalLayout(layout2);
  if (isHorizontal && isUnderlineShape && !element.isRoot) {
    placement[1] = VerticalPlacement.bottom;
  }
  let startPoint = getPointByPlacement(nodeClient, placement);
  const endPoint = moveXOfPoint(startPoint, NODE_MORE_LINE_DISTANCE, linkLineDirection);
  return [startPoint, endPoint];
};
var isLastSelectedMindElement = (board, element) => {
  const selectedElements = getSelectedElements(board);
  const selectedMindElements = selectedElements.filter((element2) => MindElement.isMindElement(board, element2)).reverse();
  return selectedMindElements[selectedMindElements.length - 1] === element;
};
var canHandleNodeMore = (board) => {
  return !isResizing(board) && !isSelectionMoving(board) && !isDragging(board) && !isMovingElements(board);
};
var MindNodeComponent = class extends CommonElementFlavour {
  get textManage() {
    return this.getRef().getTextManages()[0];
  }
  constructor() {
    super();
    this.shapeG = null;
    this.trackBy = (index, node) => {
      return node.origin.id;
    };
  }
  initializeGenerator() {
    this.nodeShapeGenerator = new NodeShapeGenerator(this.board);
    this.nodeEmojisGenerator = new NodeEmojisGenerator(this.board);
    this.activeGenerator = new NodeActiveGenerator(this.board);
    this.nodeMoreGenerator = new NodeMoreGenerator(this.board);
    this.imageGenerator = new ImageGenerator(this.board, {
      getRectangle: (element) => {
        return getImageForeignRectangle(this.board, element);
      },
      getImageItem: (element) => {
        return element.data.image;
      }
    });
    const plugins = (this.board.getPluginOptions(WithTextPluginKey) || {}).textPlugins;
    const textManage = new TextManage(this.board, {
      getRectangle: () => {
        const rect = getTopicRectangleByNode(this.board, this.node);
        return rect;
      },
      onChange: (data) => {
        const width = data.width;
        const height = data.height;
        if (data.newText) {
          MindTransforms.setTopic(this.board, this.element, data.newText, width, height);
        } else {
          MindTransforms.setTopicSize(this.board, this.element, width, height);
        }
      },
      getMaxWidth: () => {
        return NodeSpace.getTopicMaxDynamicWidth(this.board, this.element);
      },
      textPlugins: plugins || []
    });
    this.getRef().addGenerator(NodeActiveGenerator.key, this.activeGenerator);
    this.getRef().addGenerator(NodeEmojisGenerator.key, this.nodeEmojisGenerator);
    this.getRef().addGenerator(ImageGenerator.key, this.imageGenerator);
    this.getRef().addGenerator(NodeMoreGenerator.key, this.nodeMoreGenerator);
    this.getRef().initializeTextManage(textManage);
    this.getRef().updateActiveSection = () => {
      this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {
        selected: this.selected
      });
    };
  }
  initialize() {
    super.initialize();
    this.initializeGenerator();
    this.node = MindElement.getNode(this.element);
    this.index = NODE_TO_INDEX.get(this.element) || 0;
    this.roughSVG = PlaitBoard.getRoughSVG(this.board);
    this.nodeShapeGenerator.processDrawing(this.element, this.getElementG(), { node: this.node });
    this.drawLink();
    this.drawTopic();
    this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {
      selected: this.selected
    });
    this.nodeMoreGenerator.processDrawing(this.element, this.getElementG());
    this.drawEmojis();
    this.imageGenerator.processDrawing(this.element, this.getElementG());
    if (PlaitMind.isMind(this.context.parent)) {
      this.getElementG().classList.add("branch");
    }
  }
  onContextChanged(value, previous) {
    const newNode = MindElement.getNode(value.element);
    const isEqualNode = RectangleClient.isEqual(this.node, newNode);
    this.node = newNode;
    if (!isEqualNode || value.element !== previous.element || value.hasThemeChanged) {
      this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {
        selected: this.selected
      });
      this.nodeMoreGenerator.processDrawing(this.element, this.getElementG(), { isSelected: this.selected });
      this.nodeShapeGenerator.processDrawing(this.element, this.getElementG(), { node: this.node });
      this.drawLink();
      this.drawEmojis();
      if (!MindElement.hasImage(previous.element) && MindElement.hasImage(this.element)) {
        this.imageGenerator.processDrawing(this.element, this.getElementG());
      }
      if (MindElement.hasImage(previous.element) && MindElement.hasImage(this.element)) {
        this.imageGenerator.updateImage(this.getElementG(), previous.element, value.element);
      }
      if (MindElement.hasImage(previous.element) && !MindElement.hasImage(this.element)) {
        this.imageGenerator.destroy();
      }
      this.updateTopic();
    } else {
      const hasSameSelected = value.selected === previous.selected;
      const hasSameParent = value.parent === previous.parent;
      if (!hasSameSelected || value.selected) {
        this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {
          selected: this.selected
        });
        this.nodeMoreGenerator.processDrawing(this.element, this.getElementG(), {
          isSelected: this.selected
        });
      }
      if (!hasSameParent) {
        this.drawLink();
      }
    }
  }
  drawEmojis() {
    const g = this.nodeEmojisGenerator.drawEmojis(this.element);
    if (g) {
      this.getElementG().append(g);
    }
  }
  drawLink() {
    if (PlaitMind.isMind(this.element)) {
      return;
    }
    const parent = MindElement.getParent(this.element);
    const parentNode = MindElement.getNode(parent);
    if (this.linkLineG) {
      this.linkLineG.remove();
    }
    const layout2 = MindQueries.getLayoutByElement(parent);
    if (AbstractNode.isAbstract(this.node.origin)) {
      this.linkLineG = drawAbstractLink(this.board, this.node, isHorizontalLayout(layout2));
    } else {
      this.linkLineG = drawLink(this.board, parentNode, this.node, isHorizontalLayout(layout2));
    }
    this.getElementG().append(this.linkLineG);
  }
  drawTopic() {
    this.textManage.draw(this.element.data.topic);
    this.getElementG().append(this.textManage.g);
  }
  updateTopic() {
    this.textManage.updateText(this.element.data.topic);
    this.textManage.updateRectangle();
  }
  destroy() {
    super.destroy();
    this.nodeEmojisGenerator.destroy();
    this.imageGenerator.destroy();
    this.activeGenerator.destroy();
    if (ELEMENT_TO_NODE.get(this.element) === this.node) {
      ELEMENT_TO_NODE.delete(this.element);
    }
    this.getRef().destroyTextManage();
  }
};
var PlaitMindComponent = class extends MindNodeComponent {
  initialize() {
    this.updateMindLayout();
    super.initialize();
    this.getElementG().classList.add("root");
  }
  beforeContextChange(value) {
    if (value.element !== this.element && this.initialized) {
      this.updateMindLayout(value.element);
    }
  }
  updateMindLayout(element = this.element) {
    const mindLayoutType = element.layout || getDefaultLayout();
    this.root = GlobalLayout.layout(element, getLayoutOptions(this.board), mindLayoutType);
    this.updateMindNodeLocation(element);
  }
  updateMindNodeLocation(element) {
    const { x, y, hGap, vGap } = this.root;
    const offsetX = x + hGap;
    const offsetY = y + vGap;
    depthFirstRecursion(this.root, (node) => {
      node.x = node.x - offsetX + element.points[0][0];
      node.y = node.y - offsetY + element.points[0][1];
      ELEMENT_TO_NODE.set(node.origin, node);
    });
  }
};
var DRAG_MOVE_BUFFER = 5;
var withNodeDnd = (board) => {
  const { pointerDown, pointerMove, globalPointerUp } = board;
  let activeElements = [];
  let correspondingElements = [];
  let startPoint;
  let dragFakeNodeG;
  let fakeDropNodeG;
  let dropTarget = null;
  let targetPath;
  board.pointerDown = (event) => {
    if (PlaitBoard.isReadonly(board) || PlaitBoard.hasBeenTextEditing(board) || !PlaitBoard.isPointer(board, PlaitPointerType.selection) || !isMainPointer(event)) {
      pointerDown(event);
      return;
    }
    const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
    const selectedElements = getSelectedElements(board);
    const hitElement = getHitElementByPoint(board, point);
    if (hitElement && MindElement.isMindElement(board, hitElement) && !PlaitMind.isMind(hitElement) && !AbstractNode.isAbstract(hitElement)) {
      const targetElements = selectedElements.filter((element) => MindElement.isMindElement(board, element) && !element.isRoot && !AbstractNode.isAbstract(element));
      const isMultipleSelection = selectedElements.length > 0 && selectedElements.includes(hitElement);
      if (isMultipleSelection) {
        activeElements = targetElements;
        startPoint = point;
      } else {
        activeElements = [hitElement];
        startPoint = point;
      }
    }
    if (activeElements.length) {
      correspondingElements = getOverallAbstracts(board, activeElements);
    }
    pointerDown(event);
  };
  board.pointerMove = (event) => {
    if (!board.options.readonly && activeElements.length && startPoint) {
      const endPoint = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
      const distance = distanceBetweenPointAndPoint(startPoint[0], startPoint[1], endPoint[0], endPoint[1]);
      if (distance < DRAG_MOVE_BUFFER) {
        return;
      }
      setMindDragging(board, true);
      fakeDropNodeG == null ? void 0 : fakeDropNodeG.remove();
      const detectPoint = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
      dropTarget = detectDropTarget(board, detectPoint, dropTarget, [...activeElements, ...correspondingElements]);
      if (dropTarget == null ? void 0 : dropTarget.target) {
        targetPath = getPathByDropTarget(board, dropTarget);
        fakeDropNodeG = drawFakeDropNode(board, dropTarget, targetPath);
        PlaitBoard.getHost(board).appendChild(fakeDropNodeG);
      }
      const offsetX = endPoint[0] - startPoint[0];
      const offsetY = endPoint[1] - startPoint[1];
      dragFakeNodeG == null ? void 0 : dragFakeNodeG.remove();
      dragFakeNodeG = createG();
      [...activeElements, ...correspondingElements].forEach((element) => {
        addActiveOnDragOrigin(element);
      });
      activeElements.forEach((element) => {
        const nodeG = drawFakeDragNode(board, element, offsetX, offsetY);
        dragFakeNodeG == null ? void 0 : dragFakeNodeG.appendChild(nodeG);
      });
      PlaitBoard.getHost(board).appendChild(dragFakeNodeG);
      return;
    }
    pointerMove(event);
  };
  board.globalPointerUp = (event) => {
    const firstLevelElements = getFirstLevelElement(activeElements);
    if (!board.options.readonly && firstLevelElements.length) {
      firstLevelElements.push(...correspondingElements);
      if (isDragging(board)) {
        firstLevelElements.forEach((element) => {
          removeActiveOnDragOrigin(element);
        });
      }
      if (dropTarget) {
        const targetPathRef = board.pathRef(targetPath);
        const targetPreviousPathRef = Path.hasPrevious(targetPath) && board.pathRef(Path.previous(targetPath));
        const targetElementPathRef = board.pathRef(PlaitBoard.findPath(board, dropTarget.target));
        let abstractRefs = getValidAbstractRefs(board, firstLevelElements);
        const normalElements = firstLevelElements.filter((element) => !abstractRefs.some((refs2) => refs2.abstract === element)).map((element) => {
          if (AbstractNode.isAbstract(element)) {
            return adjustAbstractToNode(element);
          }
          return element;
        });
        const hasPreviousNode = targetPath[targetPath.length - 1] !== 0;
        if (hasPreviousNode) {
          const previousElement = PlaitNode.get(board, Path.previous(targetPath));
          const correspondingAbstract = getCorrespondingAbstract(previousElement);
          const targetHasCorrespondAbstract = correspondingAbstract && correspondingAbstract.end !== targetPath[targetPath.length - 1] - 1;
          if (targetHasCorrespondAbstract) {
            const adjustedNode = abstractRefs.map((ref) => {
              return adjustAbstractToNode(ref.abstract);
            });
            normalElements.push(...adjustedNode);
            abstractRefs = [];
          }
        }
        const effectedAbstracts = deleteElementHandleAbstract(board, firstLevelElements);
        insertElementHandleAbstract(board, targetPath, normalElements.length, false, effectedAbstracts);
        MindTransforms.setAbstractsByRefs(board, effectedAbstracts);
        let refs = deleteElementsHandleRightNodeCount(board, firstLevelElements);
        const parent = PlaitNode.get(board, Path.parent(targetPath));
        const shouldChangeRoot = isDropStandardRight(parent, dropTarget);
        if (shouldChangeRoot && targetElementPathRef.current) {
          refs = insertElementHandleRightNodeCount(board, targetElementPathRef.current.slice(0, 1), normalElements.length, refs);
        }
        MindTransforms.setRightNodeCountByRefs(board, refs);
        CoreTransforms.removeElements(board, firstLevelElements);
        let insertPath = targetPathRef.current;
        const parentPath = Path.parent(targetPathRef.current || targetPath);
        if (!insertPath) {
          const previousPath = targetPreviousPathRef && targetPreviousPathRef.unref();
          if (previousPath) {
            insertPath = Path.next(previousPath);
          } else {
            const parent2 = PlaitNode.get(board, parentPath);
            const children = getNonAbstractChildren(parent2);
            insertPath = [...parentPath, children.length || 0];
          }
        }
        MindTransforms.insertNodes(board, normalElements, insertPath);
        if (abstractRefs.length) {
          MindTransforms.insertAbstractNodes(board, abstractRefs, normalElements, insertPath);
        }
        if (targetElementPathRef.current && targetPathRef.current && Path.isAncestor(targetElementPathRef.current, targetPathRef.current) && dropTarget.target.isCollapsed) {
          Transforms.setNode(board, { isCollapsed: false }, targetElementPathRef.current);
        }
        targetElementPathRef.unref();
        targetPathRef.unref();
        let setActiveElements = [];
        depthFirstRecursion(board, (node) => {
          const isSelected = activeElements.some((element) => element.id === node.id);
          if (isSelected) {
            setActiveElements.push(node);
          }
        });
        Transforms.addSelectionWithTemporaryElements(board, setActiveElements);
      }
      setMindDragging(board, false);
      activeElements = [];
      dragFakeNodeG == null ? void 0 : dragFakeNodeG.remove();
      dragFakeNodeG = void 0;
      fakeDropNodeG == null ? void 0 : fakeDropNodeG.remove();
      fakeDropNodeG = void 0;
      dropTarget = null;
    }
    globalPointerUp(event);
  };
  return board;
};
var withAbstract = (board) => {
  const newBoard = board;
  const { pointerDown, pointerMove, pointerUp } = board;
  let activeAbstractElement;
  let abstractHandlePosition;
  let touchedAbstract;
  let startPoint;
  let newProperty;
  board.pointerDown = (event) => {
    if (!isMainPointer(event) || PlaitBoard.isReadonly(board)) {
      pointerDown(event);
      return;
    }
    const activeAbstractElements = getSelectedElements(board).filter((element) => AbstractNode.isAbstract(element));
    const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
    activeAbstractElement = activeAbstractElements.find((element) => {
      abstractHandlePosition = getHitAbstractHandle(board, element, point);
      return abstractHandlePosition;
    });
    if (activeAbstractElement) {
      if (newBoard == null ? void 0 : newBoard.onAbstractResize) {
        newBoard.onAbstractResize(AbstractResizeState.start);
      }
      startPoint = point;
      return;
    }
    pointerDown(event);
  };
  board.pointerMove = (event) => {
    getSelectedElements(board);
    const endPoint = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
    touchedAbstract = handleTouchedAbstract(board, touchedAbstract, endPoint);
    if (abstractHandlePosition && activeAbstractElement) {
      const nodeLayout = MindQueries.getCorrectLayoutByElement(board, activeAbstractElement);
      const isHorizontal = isHorizontalLayout(nodeLayout);
      const parentElement = MindElement.getParent(activeAbstractElement);
      let children = parentElement.children;
      const parentLayout = MindQueries.getLayoutByElement(parentElement);
      if (isStandardLayout(parentLayout)) {
        const rightNodeCount = parentElement.rightNodeCount;
        const { leftChildren, rightChildren } = separateChildren(parentElement);
        if (activeAbstractElement.end < rightNodeCount) {
          children = rightChildren;
        }
        if (activeAbstractElement.start >= rightNodeCount) {
          children = leftChildren;
        }
      }
      if (newBoard == null ? void 0 : newBoard.onAbstractResize) {
        newBoard.onAbstractResize(AbstractResizeState.resizing);
      }
      const resizingLocation = isHorizontal ? endPoint[1] : endPoint[0];
      const parent = MindElement.getNode(parentElement);
      const scope = getLocationScope(board, abstractHandlePosition, children, activeAbstractElement, parent, isHorizontal);
      const location = Math.min(scope.max, Math.max(scope.min, resizingLocation));
      let locationIndex = findLocationLeftIndex(board, children, location, isHorizontal);
      const isPropertyUnchanged = abstractHandlePosition === AbstractHandlePosition.start && locationIndex + 1 === activeAbstractElement.start || abstractHandlePosition === AbstractHandlePosition.end && locationIndex === activeAbstractElement.end;
      if (isPropertyUnchanged) {
        newProperty = void 0;
      } else {
        if (isStandardLayout(parent.layout)) {
          const rightNodeCount = parent.origin.rightNodeCount;
          let start = activeAbstractElement.start;
          if (start >= rightNodeCount) {
            locationIndex += rightNodeCount;
          }
        }
        newProperty = abstractHandlePosition === AbstractHandlePosition.start ? { start: locationIndex + 1 } : { end: locationIndex };
      }
      const ref = PlaitElement.getElementRef(activeAbstractElement);
      const activeGenerator = ref.getGenerator(NodeActiveGenerator.key);
      const activeLocation = toActivePointFromViewBoxPoint(board, [location, location]);
      activeGenerator.updateAbstractOutline(activeAbstractElement, abstractHandlePosition, isHorizontal ? activeLocation[1] : activeLocation[0]);
    }
    pointerMove(event);
  };
  board.pointerUp = (event) => {
    startPoint = void 0;
    abstractHandlePosition = void 0;
    if (activeAbstractElement) {
      if (newBoard == null ? void 0 : newBoard.onAbstractResize) {
        newBoard.onAbstractResize(AbstractResizeState.end);
      }
      if (newProperty) {
        const path = PlaitBoard.findPath(board, activeAbstractElement);
        Transforms.setNode(board, newProperty, path);
      } else {
        const ref = PlaitElement.getElementRef(activeAbstractElement);
        const activeGenerator = ref.getGenerator(NodeActiveGenerator.key);
        activeGenerator.updateAbstractOutline(activeAbstractElement);
      }
      activeAbstractElement = void 0;
      return;
    }
    pointerUp(event);
  };
  return board;
};
var withMindExtend = (board) => {
  const newBoard = board;
  board.setPluginOptions(WithMindPluginKey, { spaceBetweenEmojis: 4, emojiPadding: 0 });
  return newBoard;
};
var DefaultHotkey = "m";
var withCreateMind = (board) => {
  const newBoard = board;
  const { keyDown, pointerDown, pointerMove, pointerUp } = board;
  let fakeCreateNodeRef = null;
  let emptyMind = null;
  newBoard.pointerDown = (event) => {
    const isMindPointer = PlaitBoard.isPointer(board, MindPointerType.mind);
    if (!PlaitBoard.isReadonly(board) && isDrawingMode(board) && isMindPointer) {
      const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
      const emptyMind2 = createEmptyMind(newBoard, point);
      MindTransforms.insertMind(board, emptyMind2);
      BoardTransforms.updatePointerType(board, PlaitPointerType.selection);
      return;
    }
    pointerDown(event);
  };
  newBoard.pointerMove = (event) => {
    if (PlaitBoard.isReadonly(board)) {
      pointerMove(event);
      return;
    }
    const isMindPointer = PlaitBoard.isPointer(board, MindPointerType.mind);
    if (isDndMode(board) && isMindPointer) {
      throttleRAF(board, "with-mind-create", () => {
        let movingPoint = PlaitBoard.getMovingPointInBoard(board);
        if (movingPoint) {
          movingPoint = toViewBoxPoint(newBoard, toHostPoint(board, movingPoint[0], movingPoint[1]));
          emptyMind = createEmptyMind(newBoard, movingPoint);
          const nodeRectangle = getRectangleByElement(newBoard, emptyMind);
          const nodeG = drawRoundRectangleByElement(board, nodeRectangle, emptyMind);
          const topicRectangle = getTopicRectangleByElement(newBoard, nodeRectangle, emptyMind);
          if (!fakeCreateNodeRef) {
            const textManage = new TextManage(board, {
              getRectangle: () => {
                return topicRectangle;
              }
            });
            textManage.draw(emptyMind.data.topic);
            fakeCreateNodeRef = {
              g: createG(),
              nodeG,
              textManage
            };
            fakeCreateNodeRef.g.classList.add("root");
            fakeCreateNodeRef.g.setAttribute("plait-mind-temporary", "true");
            PlaitBoard.getHost(board).append(fakeCreateNodeRef.g);
            fakeCreateNodeRef.g.append(...[fakeCreateNodeRef.nodeG, textManage.g]);
          } else {
            fakeCreateNodeRef.textManage.updateRectangle(topicRectangle);
            fakeCreateNodeRef.nodeG.remove();
            fakeCreateNodeRef.nodeG = nodeG;
            fakeCreateNodeRef.g.append(nodeG);
            fakeCreateNodeRef.g.append(fakeCreateNodeRef.textManage.g);
          }
        }
      });
    } else {
      destroy();
    }
    pointerMove(event);
  };
  newBoard.pointerUp = (event) => {
    if (emptyMind) {
      MindTransforms.insertMind(board, emptyMind);
      BoardTransforms.updatePointerType(board, PlaitPointerType.selection);
      emptyMind = null;
      destroy();
      return;
    }
    pointerUp(event);
  };
  board.keyDown = (event) => {
    if (PlaitBoard.isReadonly(board) || getSelectedElements(board).length > 0) {
      keyDown(event);
      return;
    }
    if (event.key === DefaultHotkey && !PlaitBoard.isPointer(board, MindPointerType.mind)) {
      BoardTransforms.updatePointerType(board, MindPointerType.mind);
      setCreationMode(board, BoardCreationMode.drawing);
      event.preventDefault();
      return;
    }
    keyDown(event);
  };
  function destroy() {
    if (fakeCreateNodeRef) {
      fakeCreateNodeRef.textManage.destroy();
      fakeCreateNodeRef.g.remove();
      fakeCreateNodeRef = null;
    }
  }
  return newBoard;
};
var withMindHotkey = (baseBoard) => {
  const board = baseBoard;
  const { keyDown, globalKeyDown } = board;
  board.keyDown = (event) => {
    const selectedElements = getSelectedElements(board);
    const isSingleSelection = selectedElements.length === 1;
    const isSingleMindElement = selectedElements.length === 1 && MindElement.isMindElement(board, selectedElements[0]);
    const targetElement = selectedElements[0];
    if (isExpandHotkey(event) && isSingleMindElement && !PlaitMind.isMind(targetElement)) {
      if (targetElement.children && targetElement.children.length > 0) {
        Transforms.setNode(board, { isCollapsed: targetElement.isCollapsed ? false : true }, PlaitBoard.findPath(board, targetElement));
        return;
      }
    }
    if (!PlaitBoard.isReadonly(board)) {
      if (isTabHotkey(event) && isSingleMindElement) {
        event.preventDefault();
        MindTransforms.insertChildNode(board, targetElement);
        return;
      }
      if (isEnterHotkey(event) && isSingleMindElement && !PlaitMind.isMind(targetElement) && !AbstractNode.isAbstract(targetElement)) {
        MindTransforms.insertSiblingNode(board, targetElement);
        return;
      }
      if (!isVirtualKey(event) && !isDelete(event) && !isSpaceHotkey(event) && isSingleSelection && MindElement.isMindElement(board, targetElement)) {
        event.preventDefault();
        editTopic(targetElement);
        return;
      }
    }
    keyDown(event);
  };
  board.globalKeyDown = (event) => {
    if (PlaitBoard.isFocus(board) && PlaitBoard.hasBeenTextEditing(board)) {
      if ((0, import_is_hotkey.isHotkey)("mod+z", event)) {
        const { history } = board;
        const { undos } = history;
        const previousOp = undos.length > 0 ? undos[undos.length - 1][0] : void 0;
        if (previousOp && previousOp.type === "insert_node" && MindElement.isMindElement(board, previousOp.node) && getFirstTextManage(previousOp.node).isEditing) {
          board.undo();
        }
      }
    }
    globalKeyDown(event);
  };
  return board;
};
var withNodeMore = (board) => {
  const { pointerMove, pointerLeave, pointerUp } = board;
  let nodeMoreRef = null;
  board.pointerMove = (event) => {
    if (canHandleNodeMore(board)) {
      throttleRAF(board, "with-mind-node-hover-hit-test", () => {
        if (nodeMoreRef && !PlaitElement.hasMounted(nodeMoreRef.target)) {
          nodeMoreRef = null;
        }
        const newNodeMoreRef = getNodeMoreRef(board, event.x, event.y);
        if (nodeMoreRef && newNodeMoreRef && nodeMoreRef.target === newNodeMoreRef.target) {
          return;
        }
        if (nodeMoreRef) {
          toggleHoveredNodeCallback({
            target: nodeMoreRef.target,
            isHovered: false,
            isHoveredCollapseArea: false,
            isHoveredExpandArea: false,
            isHoveredAddArea: false
          });
        }
        if (newNodeMoreRef) {
          toggleHoveredNodeCallback(newNodeMoreRef);
          if (nodeMoreRef) {
            nodeMoreRef.target = newNodeMoreRef.target;
          } else {
            nodeMoreRef = newNodeMoreRef;
          }
        } else {
          nodeMoreRef = null;
        }
      });
    }
    pointerMove(event);
  };
  board.pointerUp = (event) => {
    if (nodeMoreRef && (nodeMoreRef.isHoveredCollapseArea || nodeMoreRef.isHoveredExpandArea)) {
      const isCollapsed = !nodeMoreRef.target.isCollapsed;
      const newElement = { isCollapsed };
      const path = PlaitBoard.findPath(board, nodeMoreRef.target);
      Transforms.setNode(board, newElement, path);
      setTimeout(() => {
        const newNodeMoreRef = getNodeMoreRef(board, event.x, event.y);
        if (newNodeMoreRef) {
          toggleHoveredNodeCallback(newNodeMoreRef);
          nodeMoreRef = newNodeMoreRef;
        } else {
          nodeMoreRef = null;
        }
      }, 0);
      return;
    }
    if (nodeMoreRef && nodeMoreRef.isHoveredAddArea && !PlaitBoard.isReadonly(board)) {
      if (nodeMoreRef) {
        const path = findNewChildNodePath(board, nodeMoreRef.target);
        insertMindElement(board, nodeMoreRef.target, path);
      }
      return;
    }
    pointerUp(event);
  };
  const toggleHoveredNodeCallback = (ref) => {
    const elementRef = PlaitElement.getElementRef(ref.target);
    const nodeMoreGenerator = elementRef == null ? void 0 : elementRef.getGenerator(NodeMoreGenerator.key);
    if (nodeMoreGenerator) {
      const g = PlaitElement.getElementG(ref.target);
      nodeMoreGenerator.processDrawing(ref.target, g, {
        isHovered: ref.isHovered,
        isHoveredCollapseArea: ref.isHoveredCollapseArea,
        isHoveredExpandArea: ref.isHoveredExpandArea,
        isSelected: isSelectedElement(board, ref.target),
        isHoveredAddArea: ref.isHoveredAddArea,
        isShowCollapseAnimation: (ref.isHovered || ref.isHoveredCollapseArea) && !isSelectedElement(board, ref.target),
        isShowAddAnimation: (ref.isHovered || ref.isHoveredAddArea) && !isSelectedElement(board, ref.target)
      });
    }
  };
  board.pointerLeave = (event) => {
    if (nodeMoreRef) {
      toggleHoveredNodeCallback({
        target: nodeMoreRef.target,
        isHovered: false,
        isHoveredCollapseArea: false,
        isHoveredExpandArea: false,
        isHoveredAddArea: false
      });
    }
    nodeMoreRef = null;
    pointerLeave(event);
  };
  return board;
};
var getNodeMoreRef = (board, x, y) => {
  let target = null;
  let isHovered = false;
  let isHoveredCollapseArea = false;
  let isHoveredExpandArea = false;
  let isHoveredAddArea = false;
  const point = toViewBoxPoint(board, toHostPoint(board, x, y));
  depthFirstRecursion(board, (element) => {
    if (target) {
      return;
    }
    if (!MindElement.isMindElement(board, element)) {
      return;
    }
    const isMind = PlaitMind.isMind(element);
    const isHitElement = isHitMindElement(board, point, element);
    let isHitCollapseOrExpand = false;
    let isHitAdd = false;
    const { collapseCenter, addCenter } = getCollapseAndAddCenterPoint(board, element);
    const collapseOrExpandIconRectangle = !isMind && RectangleClient.getRectangleByCenterPoint(collapseCenter, NODE_MORE_ICON_DIAMETER, NODE_MORE_ICON_DIAMETER);
    isHitCollapseOrExpand = collapseOrExpandIconRectangle && RectangleClient.isHit(RectangleClient.getRectangleByPoints([point, point]), collapseOrExpandIconRectangle);
    const addIconRectangle = RectangleClient.getRectangleByCenterPoint(addCenter, NODE_MORE_ICON_DIAMETER, NODE_MORE_ICON_DIAMETER);
    isHitAdd = RectangleClient.isHit(RectangleClient.getRectangleByPoints([point, point]), addIconRectangle);
    if (isHitElement || isHitCollapseOrExpand || isHitAdd) {
      isHovered = isHitElement;
      if (element.children.length > 0) {
        if (element.isCollapsed) {
          isHoveredExpandArea = isHitCollapseOrExpand;
        } else {
          isHoveredCollapseArea = isHitCollapseOrExpand;
        }
      }
      isHoveredAddArea = isHitAdd;
      target = element;
    }
  }, getIsRecursionFunc(board), true);
  if (!target) {
    return null;
  }
  return {
    target,
    isHovered,
    isHoveredCollapseArea,
    isHoveredExpandArea,
    isHoveredAddArea
  };
};
var withNodeImage = (board) => {
  const { keyDown, pointerUp, globalPointerUp, buildFragment, insertFragment, deleteFragment, afterChange } = board;
  board.pointerUp = (event) => {
    const elementOfFocusedImage = getElementOfFocusedImage(board);
    if (elementOfFocusedImage && MindElement.isMindElement(board, elementOfFocusedImage) && !isContextmenu(event) && (PlaitBoard.isReadonly(board) || !isMainPointer(event) || !PlaitBoard.isPointer(board, PlaitPointerType.selection))) {
      removeImageFocus(board, elementOfFocusedImage);
      pointerUp(event);
      return;
    }
    if (PlaitBoard.isReadonly(board)) {
      pointerUp(event);
      return;
    }
    const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
    const hitElement = getHitElementByPoint(board, point);
    const isHitImageResult = hitElement && MindElement.isMindElement(board, hitElement) && MindElement.hasImage(hitElement) && isHitImage(board, hitElement, point);
    if (isHitImageResult && elementOfFocusedImage && hitElement === elementOfFocusedImage) {
      temporaryDisableSelection(board);
      pointerUp(event);
      return;
    }
    if (elementOfFocusedImage && MindElement.isMindElement(board, elementOfFocusedImage)) {
      removeImageFocus(board, elementOfFocusedImage);
    }
    if (isHitImageResult && hitElement) {
      temporaryDisableSelection(board);
      addImageFocus(board, hitElement);
    }
    pointerUp(event);
  };
  board.keyDown = (event) => {
    const selectedImageElement = getElementOfFocusedImage(board);
    if (!PlaitBoard.isReadonly(board) && selectedImageElement && (hotkeys.isDeleteBackward(event) || hotkeys.isDeleteForward(event))) {
      addSelectedElement(board, selectedImageElement);
      MindTransforms.removeImage(board, selectedImageElement);
      return;
    }
    keyDown(event);
  };
  board.globalPointerUp = (event) => {
    if (PlaitBoard.isFocus(board)) {
      const isInBoard = event.target instanceof Node && PlaitBoard.getBoardContainer(board).contains(event.target);
      const selectedImageElement = getElementOfFocusedImage(board);
      if (selectedImageElement && MindElement.isMindElement(board, selectedImageElement) && !isInBoard) {
        removeImageFocus(board, selectedImageElement);
      }
    }
    globalPointerUp(event);
  };
  board.buildFragment = (clipboardContext, rectangle, operationType, originData) => {
    const selectedImageElement = getElementOfFocusedImage(board);
    if (selectedImageElement) {
      clipboardContext = createClipboardContext(WritableClipboardType.medias, [selectedImageElement.data.image], "");
    }
    return buildFragment(clipboardContext, rectangle, operationType, originData);
  };
  board.deleteFragment = (elements) => {
    const selectedImageElement = getElementOfFocusedImage(board);
    if (selectedImageElement) {
      MindTransforms.removeImage(board, selectedImageElement);
    }
    deleteFragment(elements);
  };
  board.insertFragment = (clipboardData, targetPoint, operationType) => {
    var _a, _b;
    const selectedElements = getSelectedElements(board);
    const isSelectedImage = !!getElementOfFocusedImage(board);
    const isSingleSelection = selectedElements.length === 1 && MindElement.isMindElement(board, selectedElements[0]);
    if (isSelectedImage || isSingleSelection) {
      if ((_a = clipboardData == null ? void 0 : clipboardData.files) == null ? void 0 : _a.length) {
        const acceptImageArray = acceptImageTypes.map((type) => "image/" + type);
        const selectedElement = selectedElements[0] || getElementOfFocusedImage(board);
        if (acceptImageArray.includes(clipboardData.files[0].type)) {
          const imageFile = clipboardData.files[0];
          buildImage(board, imageFile, DEFAULT_MIND_IMAGE_WIDTH, (imageItem) => {
            MindTransforms.setImage(board, selectedElement, imageItem);
          });
          return;
        }
      }
      if ((_b = clipboardData == null ? void 0 : clipboardData.medias) == null ? void 0 : _b.length) {
        const selectedElement = selectedElements[0] || getElementOfFocusedImage(board);
        MindTransforms.setImage(board, selectedElement, clipboardData.medias[0]);
        return;
      }
    }
    insertFragment(clipboardData, targetPoint, operationType);
  };
  board.afterChange = () => {
    afterChange();
    const selectedImageElement = getElementOfFocusedImage(board);
    if (selectedImageElement && MindElement.isMindElement(board, selectedImageElement)) {
      const commonElementRef = PlaitElement.getElementRef(selectedImageElement);
      const imageGenerator = commonElementRef.getGenerator(ImageGenerator.key);
      imageGenerator.setFocus(selectedImageElement, true);
    }
  };
  return board;
};
var withNodeResize = (board) => {
  let targetElementRef = null;
  const options = {
    key: "mind-node",
    canResize: () => {
      return true;
    },
    hitTest: (point) => {
      const newTargetElement = getSelectedTarget(board, point);
      if (newTargetElement) {
        return {
          element: newTargetElement,
          handle: null,
          cursorClass: ResizeCursorClass.ew
        };
      }
      return null;
    },
    beforeResize: (resizeRef) => {
      targetElementRef = {
        minWidth: NodeSpace.getNodeResizableMinWidth(board, resizeRef.element),
        currentWidth: NodeSpace.getTopicDynamicWidth(board, resizeRef.element),
        path: PlaitBoard.findPath(board, resizeRef.element),
        textManage: getFirstTextManage(resizeRef.element)
      };
    },
    onResize: (resizeRef, resizeState) => {
      let resizedWidth = targetElementRef.currentWidth + Point.getOffsetX(resizeState.startPoint, resizeState.endPoint);
      if (resizedWidth <= targetElementRef.minWidth) {
        resizedWidth = targetElementRef.minWidth;
      }
      const newTarget = PlaitNode.get(board, targetElementRef.path);
      if (newTarget && NodeSpace.getNodeTopicMinWidth(board, newTarget) !== resizedWidth) {
        targetElementRef.textManage.updateRectangleWidth(resizedWidth);
        const { height } = targetElementRef.textManage.getSize(void 0, resizedWidth);
        MindTransforms.setNodeManualWidth(board, newTarget, resizedWidth, height);
      }
    },
    afterResize: (resizeRef) => {
      targetElementRef = null;
    }
  };
  withResize(board, options);
  return board;
};
var getSelectedTarget = (board, point) => {
  const selectedElements = getSelectedElements(board).filter((value) => MindElement.isMindElement(board, value));
  if (selectedElements.length > 0) {
    const target = selectedElements.find((value) => {
      const rectangle = getResizeActiveRectangle(board, value);
      return distanceBetweenPointAndRectangle(point[0], point[1], rectangle) <= 0;
    });
    return target ? target : null;
  }
  return null;
};
var getResizeActiveRectangle = (board, element) => {
  const node = MindElement.getNode(element);
  const rectangle = getRectangleByNode(node);
  return {
    x: rectangle.x + rectangle.width - RESIZE_HANDLE_BUFFER_DISTANCE,
    y: rectangle.y,
    width: RESIZE_HANDLE_BUFFER_DISTANCE * 2,
    height: rectangle.height
  };
};
var withNodeImageResize = (board) => {
  const options = {
    key: "mind-node-image",
    canResize: () => {
      return true;
    },
    hitTest: (point) => {
      const elementOfFocusedImage = getElementOfFocusedImage(board);
      const selectedMindElement = elementOfFocusedImage && MindElement.isMindElement(board, elementOfFocusedImage) ? elementOfFocusedImage : void 0;
      if (selectedMindElement) {
        const result = getHitImageResizeHandleDirection(board, selectedMindElement, point);
        if (result) {
          return {
            element: selectedMindElement,
            handle: result.handle,
            cursorClass: result.cursorClass
          };
        }
      }
      return null;
    },
    onResize: (resizeRef, resizeState) => {
      const offsetX = Point.getOffsetX(resizeState.startPoint, resizeState.endPoint);
      const originWidth = resizeRef.element.data.image.width;
      const originHeight = resizeRef.element.data.image.height;
      const path = resizeRef.path;
      let width = originWidth + offsetX;
      if (width <= 100) {
        width = 100;
      }
      const ratio = originWidth / originHeight;
      const height = width / ratio;
      const imageItem = { ...resizeRef.element.data.image, width, height };
      MindTransforms.setImage(board, PlaitNode.get(board, path), imageItem);
      addElementOfFocusedImage(board, PlaitNode.get(board, path));
    }
  };
  withResize(board, options);
  return board;
};
var buildClipboardData = (board, selectedElements, startPoint) => {
  let result = [];
  const overallAbstracts = getOverallAbstracts(board, selectedElements);
  const validAbstractRefs = getValidAbstractRefs(board, [...selectedElements, ...overallAbstracts]);
  const newSelectedElements = selectedElements.filter((value) => !validAbstractRefs.find((ref) => ref.abstract === value));
  newSelectedElements.push(...validAbstractRefs.map((value) => value.abstract));
  const selectedMindNodes = newSelectedElements.map((value) => MindElement.getNode(value));
  newSelectedElements.forEach((element, index) => {
    const nodeRectangle = getRectangleByNode(selectedMindNodes[index]);
    const points = [[nodeRectangle.x - startPoint[0], nodeRectangle.y - startPoint[1]]];
    const abstractRef = validAbstractRefs.find((ref) => ref.abstract === element);
    if (AbstractNode.isAbstract(element) && abstractRef) {
      const { start, end } = getRelativeStartEndByAbstractRef(abstractRef, newSelectedElements);
      result.push({
        ...element,
        points,
        start,
        end
      });
    } else {
      if (AbstractNode.isAbstract(element)) {
        let newElement = { ...element, points };
        delete newElement.start;
        delete newElement.end;
        result.push(newElement);
      } else {
        result.push({
          ...element,
          points
        });
      }
    }
  });
  return result;
};
var insertClipboardData = (board, elements, targetPoint, operationType) => {
  let newElement, path;
  const selectedElements = getSelectedElements(board);
  let newELements = [];
  const hasTargetParent = selectedElements.length === 1;
  const targetParent = selectedElements[0];
  const targetParentPath = targetParent && PlaitBoard.findPath(board, targetParent);
  const nonAbstractChildrenLength = targetParent && getNonAbstractChildren(targetParent).length;
  elements.forEach((item, index) => {
    newElement = copyNewNode(item);
    if (hasTargetParent && operationType !== WritableClipboardOperationType.duplicate) {
      if (item.isRoot) {
        newElement = adjustRootToNode(board, newElement);
        const { width, height } = getTopicSizeByElement(board, newElement, targetParent);
        newElement.width = width;
        newElement.height = height;
      }
      if (AbstractNode.isAbstract(newElement)) {
        newElement.start = newElement.start + nonAbstractChildrenLength;
        newElement.end = newElement.end + nonAbstractChildrenLength;
      }
      path = [...targetParentPath, nonAbstractChildrenLength + index];
    } else {
      const point = [targetPoint[0] + item.points[0][0], targetPoint[1] + item.points[0][1]];
      newElement.points = [point];
      if (AbstractNode.isAbstract(item)) {
        newElement = adjustAbstractToNode(newElement);
      }
      if (!item.isRoot) {
        newElement = adjustNodeToRoot(board, newElement);
        const { width, height } = getTopicSizeByElement(board, newElement);
        newElement.width = width;
        newElement.height = height;
      }
      path = [board.children.length];
    }
    newELements.push(newElement);
    Transforms.insertNode(board, newElement, path);
    return;
  });
  Transforms.addSelectionWithTemporaryElements(board, newELements);
};
var insertClipboardText = (board, targetParent, text) => {
  const { width, height } = getTopicSize(board, false, PlaitMind.isMind(targetParent), buildText(text));
  const newElement = createMindElement(text, Math.max(width, getFontSizeBySlateElement(text)), height, {});
  Transforms.insertNode(board, newElement, findNewChildNodePath(board, targetParent));
  Transforms.addSelectionWithTemporaryElements(board, [newElement]);
};
var getTopicSizeByElement = (board, element, parentElement) => {
  return getTopicSize(board, PlaitMind.isMind(element), parentElement && PlaitMind.isMind(parentElement) || false, element.data.topic, element.manualWidth);
};
var withMindFragment = (baseBoard) => {
  const board = baseBoard;
  let firstLevelElements;
  const { getDeletedFragment, insertFragment, buildFragment, deleteFragment } = board;
  board.getDeletedFragment = (data) => {
    const targetMindElements = getSelectedMindElements(board);
    if (targetMindElements.length) {
      firstLevelElements = getFirstLevelElement(targetMindElements).reverse();
      const abstractRefs = deleteElementHandleAbstract(board, firstLevelElements);
      MindTransforms.setAbstractsByRefs(board, abstractRefs);
      const refs = deleteElementsHandleRightNodeCount(board, targetMindElements);
      MindTransforms.setRightNodeCountByRefs(board, refs);
      const deletableElements = getFirstLevelElement(targetMindElements);
      data.push(...deletableElements);
    }
    return getDeletedFragment(data);
  };
  board.deleteFragment = (elements) => {
    deleteFragment(elements);
    if (firstLevelElements) {
      const nextSelected = getNextSelectedElement(board, firstLevelElements);
      if (nextSelected) {
        addSelectedElement(board, nextSelected);
      }
      firstLevelElements = null;
    }
  };
  board.buildFragment = (clipboardContext, rectangle, operationType, originData) => {
    const targetMindElements = getSelectedMindElements(board, originData);
    const firstLevelElements2 = getFirstLevelElement(targetMindElements);
    if (firstLevelElements2.length) {
      const elements = buildClipboardData(board, firstLevelElements2, rectangle ? [rectangle.x, rectangle.y] : [0, 0]);
      const text = getElementsText(targetMindElements);
      const addition = {
        text,
        type: WritableClipboardType.elements,
        elements
      };
      clipboardContext = addOrCreateClipboardContext(clipboardContext, addition);
    }
    return buildFragment(clipboardContext, rectangle, operationType, originData);
  };
  board.insertFragment = (clipboardData, targetPoint, operationType) => {
    var _a, _b;
    if ((_a = clipboardData == null ? void 0 : clipboardData.elements) == null ? void 0 : _a.length) {
      const mindElements = (_b = clipboardData.elements) == null ? void 0 : _b.filter((value) => MindElement.isMindElement(board, value));
      if (mindElements && mindElements.length > 0) {
        insertClipboardData(board, mindElements, targetPoint, operationType);
      }
    }
    if (clipboardData == null ? void 0 : clipboardData.text) {
      const mindElements = getSelectedMindElements(board);
      if (mindElements.length === 1) {
        insertClipboardText(board, mindElements[0], buildText(clipboardData.text));
        return;
      }
    }
    insertFragment(clipboardData, targetPoint, operationType);
  };
  return board;
};
var getNextSelectedElement = (board, firstLevelElements) => {
  let activeElement;
  const firstLevelElement = firstLevelElements[0];
  const firstLevelElementPath = PlaitBoard.findPath(board, firstLevelElement);
  let nextSelectedPath = firstLevelElementPath;
  if (Path.hasPrevious(firstLevelElementPath)) {
    nextSelectedPath = Path.previous(firstLevelElementPath);
  }
  if (AbstractNode.isAbstract(firstLevelElement)) {
    const parent = MindElement.getParent(firstLevelElement);
    if (!firstLevelElements.includes(parent.children[firstLevelElement.start])) {
      activeElement = parent.children[firstLevelElement.start];
    }
  }
  try {
    if (!activeElement) {
      activeElement = PlaitNode.get(board, nextSelectedPath);
    }
  } catch (error) {
  }
  const firstElement = firstLevelElements[0];
  const firstElementParent = MindElement.findParent(firstElement);
  const hasSameParent = firstLevelElements.every((element) => {
    return MindElement.findParent(element) === firstElementParent;
  });
  if (firstElementParent && hasSameParent && !activeElement) {
    activeElement = firstElementParent;
  }
  return activeElement;
};
var withEmoji = (board) => {
  const newBoard = board;
  newBoard.renderEmoji = (container, props) => {
    throw new Error("No implementation for renderEmoji method.");
  };
  return newBoard;
};
var isNormalizedData = (element) => {
  if (!element.data || !element.data.topic) {
    return false;
  }
  return true;
};
var isNormalizedWidthAndHeight = (element) => {
  if (isNullOrUndefined(element.width) || isNullOrUndefined(element.height)) {
    return false;
  }
  return true;
};
var fixMindElementData = (element) => {
  const emptyTopic = {
    children: [
      {
        text: ""
      }
    ]
  };
  if (!element.data) {
    const data = {
      topic: emptyTopic
    };
    element.data = data;
  } else if (!element.data.topic) {
    element.data.topic = emptyTopic;
  }
};
var fixMindElementWidthAndHeight = (element) => {
  if (isNullOrUndefined(element.width)) {
    element.width = 56;
  }
  if (isNullOrUndefined(element.height)) {
    element.width = 20;
  }
};
var withMind = (baseBoard) => {
  const board = baseBoard;
  const { drawElement, dblClick, isRectangleHit, isHit, getRectangle, isMovable, isRecursion, isAlign, isImageBindingAllowed, canAddToGroup, canSetZIndex, isExpanded, getOneHitElement, normalizeElement } = board;
  board.normalizeElement = (context) => {
    if (PlaitMind.isMind(context.element)) {
      depthFirstRecursion(context.element, (node) => {
        if (!isNormalizedData(node)) {
          fixMindElementData(node);
        }
        if (!isNormalizedWidthAndHeight(node)) {
          fixMindElementWidthAndHeight(node);
        }
      });
    }
    normalizeElement(context);
  };
  board.drawElement = (context) => {
    if (PlaitMind.isMind(context.element)) {
      return PlaitMindComponent;
    } else if (MindElement.isMindElement(board, context.element)) {
      return MindNodeComponent;
    }
    return drawElement(context);
  };
  board.applyTheme = (element) => {
    const mindElement = element;
    const shouldClearProperty = !PlaitBoard.isBoard(element) && ((mindElement == null ? void 0 : mindElement.branchColor) || (mindElement == null ? void 0 : mindElement.fill) || (mindElement == null ? void 0 : mindElement.strokeColor));
    if (PlaitMind.isMind(element) && shouldClearProperty) {
      const path = PlaitBoard.findPath(board, element);
      Transforms.setNode(board, { fill: null, strokeColor: null, branchColor: null }, path);
    }
  };
  board.getRectangle = (element) => {
    if (MindElement.isMindElement(board, element)) {
      if (!PlaitElement.hasMounted(element)) {
        console.error("mind element has not been mounted");
      }
      return getRectangleByNode(MindElement.getNode(element));
    }
    return getRectangle(element);
  };
  board.canAddToGroup = (element) => {
    if (MindElement.isMindElement(board, element) && !element.isRoot) {
      return false;
    }
    return canAddToGroup(element);
  };
  board.canSetZIndex = (element) => {
    if (MindElement.isMindElement(board, element) && !element.isRoot) {
      return false;
    }
    return canSetZIndex(element);
  };
  board.isRecursion = (element) => {
    if (MindElement.isMindElement(board, element) && element.isCollapsed) {
      return false;
    }
    return isRecursion(element);
  };
  board.isRectangleHit = (element, selection) => {
    if (MindElement.isMindElement(board, element)) {
      const client = getRectangleByNode(MindElement.getNode(element));
      const isHit2 = RectangleClient.isHit(RectangleClient.getRectangleByPoints([selection.anchor, selection.focus]), client);
      return isHit2;
    }
    return isRectangleHit(element, selection);
  };
  board.isHit = (element, point, isStrict) => {
    if (MindElement.isMindElement(board, element)) {
      const client = getRectangleByNode(MindElement.getNode(element));
      const isHit2 = RectangleClient.isHit(RectangleClient.getRectangleByPoints([point, point]), client);
      return isHit2;
    }
    return isHit(element, point, isStrict);
  };
  board.getOneHitElement = (elements) => {
    const isAllMindElements = elements.every((item) => MindElement.isMindElement(board, item));
    if (isAllMindElements) {
      return elements[0];
    }
    return getOneHitElement(elements);
  };
  board.isMovable = (element) => {
    if (PlaitMind.isMind(element) && element.isRoot) {
      return true;
    }
    return isMovable(element);
  };
  board.isImageBindingAllowed = (element) => {
    if (MindElement.isMindElement(board, element)) {
      return true;
    }
    return isImageBindingAllowed(element);
  };
  board.isAlign = (element) => {
    if (PlaitMind.isMind(element) && element.isRoot) {
      return true;
    }
    return isAlign(element);
  };
  board.isExpanded = (element) => {
    if (MindElement.isMindElement(board, element) && !PlaitMind.isMind(element)) {
      return !element.isCollapsed;
    }
    return isExpanded(element);
  };
  board.dblClick = (event) => {
    if (PlaitBoard.isReadonly(board)) {
      dblClick(event);
      return;
    }
    const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));
    board.children.filter((value) => PlaitMind.isMind(value)).forEach((mindMap) => {
      depthFirstRecursion(mindMap, (node) => {
        if (!PlaitBoard.hasBeenTextEditing(board) && isHitMindElement(board, point, node)) {
          editTopic(node);
        }
      }, getIsRecursionFunc(board));
    });
    if (PlaitBoard.hasBeenTextEditing(board)) {
      return;
    }
    dblClick(event);
  };
  return withEmoji(withNodeResize(withNodeImageResize(withNodeImage(withNodeMore(withMindFragment(withMindHotkey(withMindExtend(withCreateMind(withAbstract(withNodeDnd(board)))))))))));
};
var MindEmojiBaseComponent = class {
  constructor() {
    this.fontSize = 14;
  }
};

export {
  MindLayoutType,
  ELEMENT_TO_NODE,
  MindNode,
  LayoutDirection,
  LayoutDirectionsMap,
  MindPointerType,
  MindDefaultThemeColor,
  MindColorfulThemeColor,
  MindSoftThemeColor,
  MindRetroThemeColor,
  MindDarkThemeColor,
  MindStarryThemeColor,
  MindThemeColors,
  MindThemeColor,
  WithMindPluginKey,
  BASE,
  PRIMARY_COLOR,
  GRAY_COLOR,
  STROKE_WIDTH,
  RESIZE_HANDLE_BUFFER_DISTANCE,
  NODE_MORE_LINE_DISTANCE,
  NODE_MORE_STROKE_WIDTH,
  NODE_MORE_ICON_DIAMETER,
  NODE_MORE_BRIDGE_DISTANCE,
  NODE_ADD_CIRCLE_COLOR,
  NODE_ADD_HOVER_COLOR,
  NODE_ADD_INNER_CROSS_COLOR,
  DEFAULT_MIND_IMAGE_WIDTH,
  MindI18nKey,
  getEmojisWidthHeight,
  getEmojiFontSize,
  DefaultAbstractNodeStyle,
  DefaultNodeStyle,
  separateChildren,
  isSetAbstract,
  canSetAbstract,
  getCorrespondingAbstract,
  getBehindAbstracts,
  getOverallAbstracts,
  getValidAbstractRefs,
  getRelativeStartEndByAbstractRef,
  insertElementHandleAbstract,
  deleteElementHandleAbstract,
  isChildOfAbstract,
  getBranchColorByMindElement,
  getBranchShapeByMindElement,
  getBranchWidthByMindElement,
  getAbstractBranchWidth,
  getAbstractBranchColor,
  getNextBranchColor,
  getDefaultBranchColor,
  getDefaultBranchColorByIndex,
  getMindThemeColor,
  getStrokeColorByElement,
  getStrokeStyleByElement,
  getStrokeWidthByElement,
  getFillByElement,
  getShapeByElement,
  editTopic,
  getSelectedMindElements,
  getBranchDirectionsByLayouts,
  isCorrectLayout,
  isMixedLayout,
  getInCorrectLayoutDirection,
  correctLayoutByDirection,
  getLayoutDirection$1,
  getDefaultLayout,
  getAvailableSubLayoutsByLayoutDirections,
  getLayoutReverseDirection,
  getRootLayout,
  getLayoutOptions,
  TOPIC_FONT_SIZE,
  ROOT_TOPIC_FONT_SIZE,
  TOPIC_DEFAULT_MAX_WORD_COUNT,
  NodeTopicThreshold,
  ABSTRACT_HANDLE_COLOR,
  ABSTRACT_INCLUDED_OUTLINE_OFFSET,
  ABSTRACT_HANDLE_LENGTH,
  ABSTRACT_HANDLE_MASK_WIDTH,
  MIND_CENTRAL_TEXT,
  ABSTRACT_NODE_TEXT,
  getDefaultMindNameText,
  getAbstractNodeText,
  getTopicSize,
  createEmptyMind,
  createMindElement,
  INHERIT_ATTRIBUTE_KEYS,
  getChildrenCount,
  isChildElement,
  getFirstLevelElement,
  isChildRight,
  isChildUp,
  copyNewNode,
  insertMindElement,
  findLastChild,
  divideElementByParent,
  getDefaultMindElementFontSize,
  NodeSpace,
  getFontSizeBySlateElement,
  normalizeWidthAndHeight,
  getRectangleByNode,
  getRectangleByElement,
  isHitMindElement,
  getEmojiRectangle,
  getEmojiForeignRectangle,
  isHitEmojis,
  getTopicRectangleByNode,
  getTopicRectangleByElement,
  getImageForeignRectangle,
  isHitImage,
  getHitImageResizeHandleDirection,
  adjustRootToNode,
  adjustAbstractToNode,
  adjustNodeToRoot,
  addImageFocus,
  removeImageFocus,
  getNewNodeHeight,
  addActiveOnDragOrigin,
  removeActiveOnDragOrigin,
  setMindDragging,
  hasPreviousOrNextOfDropPath,
  isDropStandardRight,
  directionCorrector,
  getAllowedDirection,
  detectDropTarget,
  directionDetector,
  isValidTarget,
  getPathByDropTarget,
  drawFakeDragNode,
  drawFakeDropNode,
  AbstractHandlePosition,
  AbstractResizeState,
  getRectangleByResizingLocation,
  getLocationScope,
  getHitAbstractHandle,
  getAbstractHandleRectangle,
  findLocationLeftIndex,
  handleTouchedAbstract,
  isInRightBranchOfStandardLayout,
  insertElementHandleRightNodeCount,
  deleteElementsHandleRightNodeCount,
  findNewChildNodePath,
  findNewSiblingNodePath,
  MindQueries,
  PlaitMind,
  MindElement,
  MindElementShape,
  BranchShape,
  MindTransforms,
  MindNodeComponent,
  PlaitMindComponent,
  withMindExtend,
  withEmoji,
  withMind,
  MindEmojiBaseComponent
};
//# sourceMappingURL=chunk-A5A3TUIN.js.map
