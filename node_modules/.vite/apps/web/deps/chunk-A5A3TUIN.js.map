{
  "version": 3,
  "sources": ["../../../../packages/layouts/src/interfaces/mind.ts", "../../../../packages/layouts/src/utils/layout.ts", "../../../../packages/layouts/src/interfaces/layout-node.ts", "../../../../packages/layouts/src/interfaces/layout-tree-node.ts", "../../../../packages/layouts/src/utils/abstract.ts", "../../../../packages/layouts/src/algorithms/non-overlapping-tree-layout.ts", "../../../../packages/layouts/src/layouts/indent.ts", "../../../../packages/layouts/src/layouts/logic.ts", "../../../../packages/layouts/src/layouts/base-layout.ts", "../../../../packages/layouts/src/layouts/global-layout.ts", "../../../../packages/layouts/src/public-api.ts", "../../../../packages/layouts/src/plait-layouts.ts", "../../../../packages/mind/src/utils/weak-maps.ts", "../../../../packages/mind/src/interfaces/node.ts", "../../../../packages/mind/src/interfaces/layout.ts", "../../../../packages/mind/src/interfaces/pointer.ts", "../../../../packages/mind/src/constants/theme.ts", "../../../../packages/mind/src/interfaces/theme-color.ts", "../../../../packages/mind/src/constants/default.ts", "../../../../packages/mind/src/utils/space/emoji.ts", "../../../../packages/mind/src/utils/node-style/common.ts", "../../../../packages/mind/src/constants/node-style.ts", "../../../../packages/mind/src/utils/abstract/common.ts", "../../../../packages/mind/src/utils/node-style/branch.ts", "../../../../packages/mind/src/utils/node-style/shape.ts", "../../../../packages/mind/src/utils/node/common.ts", "../../../../packages/mind/src/utils/layout.ts", "../../../../packages/mind/src/utils/space/layout-options.ts", "../../../../packages/mind/src/constants/node-topic-style.ts", "../../../../packages/mind/src/constants/abstract-node.ts", "../../../../packages/mind/src/utils/common.ts", "../../../../packages/mind/src/utils/node/create-node.ts", "../../../../packages/mind/src/utils/mind.ts", "../../../../packages/mind/src/utils/space/node-space.ts", "../../../../packages/mind/src/utils/position/node.ts", "../../../../packages/mind/src/utils/position/emoji.ts", "../../../../packages/mind/src/utils/position/topic.ts", "../../../../packages/mind/src/utils/position/image.ts", "../../../../packages/mind/src/utils/node/adjust-node.ts", "../../../../packages/mind/src/utils/node/image.ts", "../../../../packages/mind/src/utils/node/dynamic-width.ts", "../../../../packages/mind/src/utils/dnd/common.ts", "../../../../packages/mind/src/utils/dnd/detector.ts", "../../../../packages/mind/src/utils/draw/node-shape.ts", "../../../../packages/mind/src/interfaces/types.ts", "../../../../packages/mind/src/utils/point-placement.ts", "../../../../packages/mind/src/utils/draw/node-link/indented-link.ts", "../../../../packages/mind/src/utils/draw/node-link/logic-link.ts", "../../../../packages/mind/src/utils/draw/node-link/draw-link.ts", "../../../../packages/mind/src/generators/node-emojis.generator.ts", "../../../../packages/mind/src/utils/draw/node-dnd.ts", "../../../../packages/mind/src/plugins/with-abstract-resize.board.ts", "../../../../packages/mind/src/utils/draw/abstract-outline.ts", "../../../../packages/mind/src/generators/node-active.generator.ts", "../../../../packages/mind/src/utils/abstract/resize.ts", "../../../../packages/mind/src/utils/node/right-node-count.ts", "../../../../packages/mind/src/utils/path.ts", "../../../../packages/mind/src/queries/get-correct-layout-by-element.ts", "../../../../packages/mind/src/queries/get-branch-layouts.ts", "../../../../packages/mind/src/queries/get-available-sublayouts-by-element.ts", "../../../../packages/mind/src/queries/get-layout-by-element.ts", "../../../../packages/mind/src/queries/index.ts", "../../../../packages/mind/src/interfaces/element.ts", "../../../../packages/mind/src/utils/draw/node-link/abstract-link.ts", "../../../../packages/mind/src/transforms/abstract-node.ts", "../../../../packages/mind/src/transforms/node.ts", "../../../../packages/mind/src/transforms/emoji.ts", "../../../../packages/mind/src/transforms/image.ts", "../../../../packages/mind/src/transforms/layout.ts", "../../../../packages/mind/src/transforms/property.ts", "../../../../packages/mind/src/transforms/index.ts", "../../../../packages/mind/src/generators/node-shape.generator.ts", "../../../../packages/mind/src/generators/node-more.generator.ts", "../../../../packages/mind/src/mind-node.component.ts", "../../../../packages/mind/src/mind.component.ts", "../../../../packages/mind/src/plugins/with-node-dnd.ts", "../../../../packages/mind/src/plugins/with-abstract-resize.ts", "../../../../packages/mind/src/plugins/with-mind-extend.ts", "../../../../packages/mind/src/plugins/with-mind-create.ts", "../../../../packages/mind/src/plugins/with-mind-hotkey.ts", "../../../../packages/mind/src/plugins/with-node-more.ts", "../../../../packages/mind/src/plugins/with-node-image.ts", "../../../../packages/mind/src/plugins/with-node-resize.ts", "../../../../packages/mind/src/plugins/with-node-image-resize.ts", "../../../../packages/mind/src/utils/clipboard.ts", "../../../../packages/mind/src/plugins/with-mind-fragment.ts", "../../../../packages/mind/src/emoji/with-emoji.ts", "../../../../packages/mind/src/utils/normalize.ts", "../../../../packages/mind/src/plugins/with-mind.ts", "../../../../packages/mind/src/emoji/emoji-base.component.ts", "../../../../packages/mind/src/public-api.ts", "../../../../packages/mind/src/plait-mind.ts"],
  "sourcesContent": ["import { LayoutNode, ConnectingPosition } from './layout-node';\n\nexport interface LayoutOptions {\n    getHeight: (node: OriginNode) => number;\n    getWidth: (node: OriginNode) => number;\n    getHorizontalGap: (node: OriginNode, parent?: LayoutNode) => number;\n    getVerticalGap: (node: OriginNode, parent?: LayoutNode) => number;\n    getVerticalConnectingPosition: (node: OriginNode, parent?: LayoutNode) => ConnectingPosition;\n    getExtendWidth?: (node: OriginNode) => number;\n    getExtendHeight: (node: OriginNode) => number;\n    getIndentedCrossLevelGap: () => number;\n}\n\nexport interface LayoutContext {\n    toLeft: boolean;\n    toTop: boolean;\n    rootLayoutType: MindLayoutType;\n}\n\nexport interface OriginNode {\n    children: OriginNode[];\n    isCollapsed?: boolean;\n    layout?: string;\n    rightNodeCount: number;\n}\n\nexport interface AbstractNode extends OriginNode {\n    start: number;\n    end: number;\n}\n\nexport const AbstractNode = {\n    isAbstract(value: any): value is AbstractNode {\n        if (typeof value.start === 'number' && typeof value.end === 'number') {\n            return true;\n        } else {\n            return false;\n        }\n    }\n};\n\nexport enum MindLayoutType {\n    'right' = 'right',\n    'left' = 'left',\n    'standard' = 'standard',\n    'upward' = 'upward',\n    'downward' = 'downward',\n    'rightBottomIndented' = 'right-bottom-indented',\n    'rightTopIndented' = 'right-top-indented',\n    'leftTopIndented' = 'left-top-indented',\n    'leftBottomIndented' = 'left-bottom-indented'\n}\n\nexport enum LayoutType {\n    'logic' = 'logic',\n    'indented' = 'indented',\n    'fishBone' = 'fish-bone'\n}\n", "import { LayoutNode } from '../interfaces/layout-node';\nimport { AbstractNode, LayoutType, MindLayoutType } from '../interfaces/mind';\n\nexport function findLayoutType(node: LayoutNode): MindLayoutType | null {\n    if (node.origin.layout) {\n        return node.origin.layout as MindLayoutType;\n    }\n\n    if (AbstractNode.isAbstract(node.origin)) {\n        return getAbstractLayout(findLayoutType(node.parent!)!);\n    }\n\n    if (node.parent) {\n        return findLayoutType(node.parent);\n    }\n\n    return null;\n}\n\nexport const isIndentedLayout = (layout: MindLayoutType) => {\n    return (\n        layout === MindLayoutType.rightBottomIndented ||\n        layout === MindLayoutType.rightTopIndented ||\n        layout === MindLayoutType.leftBottomIndented ||\n        layout === MindLayoutType.leftTopIndented\n    );\n};\n\nexport const isLogicLayout = (layout: MindLayoutType) => {\n    return (\n        layout === MindLayoutType.right ||\n        layout === MindLayoutType.left ||\n        layout === MindLayoutType.downward ||\n        layout === MindLayoutType.upward\n    );\n};\n\nexport const isStandardLayout = (layout: MindLayoutType) => {\n    return layout === MindLayoutType.standard;\n};\n\nexport const isHorizontalLayout = (layout: MindLayoutType) => {\n    return (\n        layout === MindLayoutType.right || layout === MindLayoutType.left || layout === MindLayoutType.standard || isIndentedLayout(layout)\n    );\n};\n\nexport const isHorizontalLogicLayout = (layout: MindLayoutType) => {\n    return layout === MindLayoutType.right || layout === MindLayoutType.left || layout === MindLayoutType.standard;\n};\n\nexport const isVerticalLogicLayout = (layout: MindLayoutType) => {\n    return layout === MindLayoutType.upward || layout === MindLayoutType.downward;\n};\n\nexport const isTopLayout = (layout: MindLayoutType) => {\n    return layout === MindLayoutType.leftTopIndented || layout === MindLayoutType.rightTopIndented || layout === MindLayoutType.upward;\n};\n\nexport const isBottomLayout = (layout: MindLayoutType) => {\n    return (\n        layout === MindLayoutType.leftBottomIndented || layout === MindLayoutType.rightBottomIndented || layout === MindLayoutType.downward\n    );\n};\n\nexport const isLeftLayout = (layout: MindLayoutType) => {\n    return layout === MindLayoutType.left || layout === MindLayoutType.leftTopIndented || layout === MindLayoutType.leftBottomIndented;\n};\n\nexport const isRightLayout = (layout: MindLayoutType) => {\n    return layout === MindLayoutType.right || layout === MindLayoutType.rightTopIndented || layout === MindLayoutType.rightBottomIndented;\n};\n\nexport const extractLayoutType = (mindLayoutType: MindLayoutType): LayoutType => {\n    if (isIndentedLayout(mindLayoutType)) {\n        return LayoutType.indented;\n    }\n    if (isStandardLayout(mindLayoutType)) {\n        return LayoutType.logic;\n    }\n    if (isLogicLayout(mindLayoutType)) {\n        return LayoutType.logic;\n    }\n    return LayoutType.logic;\n};\n\nexport const getAbstractLayout = (parentLayout: MindLayoutType) => {\n    if (isIndentedLayout(parentLayout)) {\n        if (isRightLayout(parentLayout)) {\n            return MindLayoutType.right;\n        } else {\n            return MindLayoutType.left;\n        }\n    }\n    return parentLayout;\n};\n", "import { LayoutContext, LayoutOptions, MindLayoutType, OriginNode } from './mind';\nimport { findLayoutType } from '../utils/layout';\n\n/**\n * abstract layout node\n */\nexport class LayoutNode {\n    x = 0;\n    y = 0;\n    vGap = 0;\n    hGap = 0;\n    origin: OriginNode;\n    blackNode?: LayoutBlockNode;\n    width = 0;\n    height = 0;\n    depth = 0;\n    children: LayoutNode[] = [];\n    parent?: LayoutNode;\n    left = false;\n    up = false;\n    layout: MindLayoutType;\n    verticalConnectingPosition?: ConnectingPosition;\n\n    constructor(origin: OriginNode, options: LayoutOptions, context: LayoutContext, parent?: LayoutNode) {\n        const hGap = options.getHorizontalGap(origin, parent);\n        const vGap = options.getVerticalGap(origin, parent);\n        this.origin = origin;\n        this.width = options.getWidth(origin);\n        this.height = options.getHeight(origin);\n        this.x = this.y = 0;\n        if (parent) {\n            this.parent = parent;\n        }\n        const layout = findLayoutType(this);\n        this.layout = layout && layout !== MindLayoutType.standard ? layout : context.rootLayoutType;\n\n        const verticalConnectingPosition = options.getVerticalConnectingPosition(origin, parent);\n        if (verticalConnectingPosition) {\n            this.verticalConnectingPosition = verticalConnectingPosition;\n        }\n        this.addGap(hGap, vGap);\n    }\n\n    isRoot() {\n        return this.depth === 0;\n    }\n\n    addGap(hGap: number, vGap: number) {\n        const me = this;\n        me.hGap += hGap;\n        me.vGap += vGap;\n        me.width += 2 * hGap;\n        me.height += 2 * vGap;\n    }\n\n    eachNode(callback: (node: LayoutNode) => void) {\n        depthFirstRecursion(this, callback);\n    }\n\n    getBoundingBox(): BoundingBox {\n        const bb: BoundingBox = {\n            left: Number.MAX_VALUE,\n            top: Number.MAX_VALUE,\n            right: Number.MIN_VALUE,\n            bottom: Number.MIN_VALUE,\n            width: 0,\n            height: 0\n        };\n        this.eachNode(node => {\n            bb.left = Math.min(bb.left, node.x);\n            bb.top = Math.min(bb.top, node.y);\n            bb.right = Math.max(bb.right, node.x + node.width);\n            bb.bottom = Math.max(bb.bottom, node.y + node.height);\n        });\n        bb.width = bb.right - bb.left;\n        bb.height = bb.bottom - bb.top;\n        return bb;\n    }\n\n    translate(tx = 0, ty = 0) {\n        this.eachNode(node => {\n            node.x += tx;\n            node.y += ty;\n        });\n    }\n\n    right2left() {\n        const me = this;\n        const bb = me.getBoundingBox();\n        me.eachNode(node => {\n            node.x = node.x - (node.x - bb.left) * 2 - node.width;\n            node.left = true;\n        });\n        me.translate(bb.width, 0);\n    }\n\n    down2up() {\n        const me = this;\n        const bb = me.getBoundingBox();\n        me.eachNode(node => {\n            node.y = node.y - (node.y - bb.top) * 2 - node.height;\n            node.up = true;\n        });\n        me.translate(0, bb.height);\n    }\n}\n\nfunction depthFirstRecursion(node: LayoutNode, callback: (node: LayoutNode) => void) {\n    node.children?.forEach(child => {\n        depthFirstRecursion(child, callback);\n    });\n    callback(node);\n}\n\nexport interface BoundingBox {\n    left: number;\n    top: number;\n    right: number;\n    bottom: number;\n    width: number;\n    height: number;\n}\n\nexport class LayoutBlockNode {\n    left: number;\n    right: number;\n    top: number;\n    bottom: number;\n    width: number;\n    height: number;\n    rootX: number;\n    rootY: number;\n    rootWidth: number;\n    rootHeight: number;\n\n    constructor(\n        left: number,\n        right: number,\n        top: number,\n        bottom: number,\n        width: number,\n        height: number,\n        rootX: number,\n        rootY: number,\n        rootWidth: number,\n        rootHeight: number\n    ) {\n        this.left = left;\n        this.right = right;\n        this.top = top;\n        this.bottom = bottom;\n        this.width = width;\n        this.height = height;\n        this.rootX = rootX;\n        this.rootY = rootY;\n        this.rootWidth = rootWidth;\n        this.rootHeight = rootHeight;\n    }\n}\n\nexport function toHorizontal(black: LayoutBlockNode): LayoutBlockNode {\n    return {\n        left: black.top,\n        right: black.bottom,\n        top: black.left,\n        bottom: black.right,\n        width: black.height,\n        height: black.width,\n        rootX: black.rootY,\n        rootY: black.rootX,\n        rootWidth: black.rootHeight,\n        rootHeight: black.rootWidth\n    };\n}\n\n/**\n * Connecting position, affecting horizontal layout\n */\nexport enum ConnectingPosition {\n    middle = 'middle',\n    bottom = 'bottom'\n}\n", "import { LayoutNode } from './layout-node';\n\n/**\n * abstract tree node for tree layout algorithm\n */\nexport class LayoutTreeNode {\n    width: number;\n    height: number;\n    y: number;\n    children: LayoutTreeNode[];\n    childrenCount: number;\n    x: number;\n    preliminary: number;\n    modifier: number; // Describes how much the entire subtree should be moved horizontally\n    shift: number;\n    change: number;\n    tl: any;\n    tr: any;\n    el: LayoutTreeNode | null;\n    er: LayoutTreeNode | null;\n    msel: number;\n    mser: number;\n    origin: LayoutNode;\n\n    constructor(width: number, height: number, y: number, children: LayoutTreeNode[], origin: LayoutNode) {\n        this.width = width;\n        this.height = height;\n        this.y = y;\n        this.children = children;\n        this.childrenCount = children.length;\n\n        this.x = 0;\n        this.preliminary = 0; // initial horizontal coordinates\n        this.modifier = 0;\n        this.shift = 0;\n        this.change = 0;\n        this.tl = null; // Left thread\n        this.tr = null; // Right thread\n        this.el = null; // extreme left nodes\n        this.er = null; // extreme right nodes\n        //sum of modifiers at the extreme nodes\n        this.msel = 0;\n        this.mser = 0;\n        this.origin = origin;\n    }\n}\n", "import { LayoutNode } from '../interfaces/layout-node';\nimport { LayoutTreeNode } from '../interfaces/layout-tree-node';\nimport { AbstractNode } from '../interfaces/mind';\nimport { isStandardLayout } from './layout';\n\nexport const getNonAbstractChildren = <T extends { children?: T[] } = LayoutNode | LayoutTreeNode>(parentNode: T) => {\n    if (parentNode.children) {\n        return parentNode.children?.filter(child => {\n            if (child instanceof LayoutNode) {\n                return !AbstractNode.isAbstract(child.origin);\n            }\n            if (child instanceof LayoutTreeNode) {\n                return !AbstractNode.isAbstract(child.origin.origin);\n            }\n            return !AbstractNode.isAbstract(child);\n        });\n    } else {\n        return [];\n    }\n};\n\nexport const findAbstractByEndNode = <T extends { children: T[] } = LayoutNode | LayoutTreeNode>(parentNode: T, endNode: T) => {\n    const index = parentNode.children.indexOf(endNode);\n    return parentNode.children.find(child => {\n        if (child instanceof LayoutNode) {\n            return AbstractNode.isAbstract(child.origin) && child.origin.end === index;\n        }\n        if (child instanceof LayoutTreeNode && parentNode instanceof LayoutTreeNode) {\n            if (AbstractNode.isAbstract(child.origin.origin)) {\n                const { end } = getCorrectStartEnd(child.origin.origin, parentNode.origin);\n                return end === index;\n            }\n            return false;\n        }\n        return AbstractNode.isAbstract(child) && child.end === index;\n    });\n};\n\nexport const findAbstractByStartNode = <T extends { children: T[] } = LayoutNode | LayoutTreeNode>(parentNode: T, startNode: T) => {\n    const index = parentNode.children.indexOf(startNode);\n    return parentNode.children.find(child => {\n        if (child instanceof LayoutNode) {\n            return AbstractNode.isAbstract(child.origin) && child.origin.start === index;\n        }\n        if (child instanceof LayoutTreeNode && parentNode instanceof LayoutTreeNode) {\n            if (AbstractNode.isAbstract(child.origin.origin)) {\n                const { start } = getCorrectStartEnd(child.origin.origin, parentNode.origin);\n                return start === index;\n            }\n            return false;\n        }\n        return AbstractNode.isAbstract(child) && child.start === index;\n    });\n};\n\n/**\n * handle standard layout effect\n * the abstract correct start and end should sub rightNodeCount when it is set on left area\n */\nexport const getCorrectStartEnd = (abstract: AbstractNode, parent: LayoutNode) => {\n    let start = abstract.start;\n    let end = abstract.end;\n    if (isStandardLayout(parent.layout)) {\n        const rightNodeCount = parent.origin.rightNodeCount;\n        if (start >= rightNodeCount) {\n            end -= rightNodeCount;\n            start -= rightNodeCount;\n        }\n    }\n    return { start, end };\n};\n", "import { LayoutTreeNode } from '../interfaces/layout-tree-node';\nimport { findAbstractByEndNode, findAbstractByStartNode, getNonAbstractChildren, getCorrectStartEnd } from '../utils/abstract';\nimport { AbstractNode } from '../interfaces/mind';\n\nfunction moveSubtree(treeNode: LayoutTreeNode, i: number, distance: number) {\n    // Move subtree by changing modifier.\n    treeNode.children[i].modifier += distance;\n}\n\nfunction nextLeftContour(treeNode: LayoutTreeNode) {\n    return treeNode.childrenCount === 0 ? null : treeNode.children[0];\n}\n\nfunction nextRightContour(treeNode: LayoutTreeNode) {\n    let children = getNonAbstractChildren(treeNode);\n    return treeNode.childrenCount === 0 ? null : children[children.length - 1];\n}\n\n// separate left siblings\nfunction separate(treeNode: LayoutTreeNode, i: number) {\n    if (AbstractNode.isAbstract(treeNode.children[i].origin.origin)) {\n        return;\n    }\n\n    let leftNode: LayoutTreeNode | null = treeNode.children[i - 1];\n    let rightNode: LayoutTreeNode | null = treeNode.children[i];\n\n    let rightContourOfLeftNode = leftNode.modifier + leftNode.preliminary + leftNode.width;\n    let leftContourOfRightNode = rightNode.modifier + rightNode.preliminary;\n    let sumOfLeftModifier = 0;\n\n    let leftNodeParent = treeNode;\n    let rightNodeParent = treeNode;\n\n    while (leftNode || rightNode) {\n        if (leftNode) {\n            let right = sumOfLeftModifier + leftNode.modifier + leftNode.preliminary + leftNode.width;\n\n            if (right > rightContourOfLeftNode) {\n                rightContourOfLeftNode = right;\n            }\n            rightContourOfLeftNode = compareAbstractRight(leftNodeParent, leftNode, rightContourOfLeftNode, sumOfLeftModifier);\n\n            leftNodeParent = leftNode;\n            sumOfLeftModifier = leftNode.modifier + sumOfLeftModifier;\n            leftNode = nextRightContour(leftNode);\n        }\n\n        if (rightNode) {\n            let left = rightNode.modifier + rightNode.preliminary;\n            if (left < leftContourOfRightNode) {\n                leftContourOfRightNode = left;\n            }\n\n            leftContourOfRightNode = compareAbstractLeft(rightNodeParent, rightNode, leftContourOfRightNode);\n\n            rightNodeParent = rightNode;\n            rightNode = nextLeftContour(rightNode);\n        }\n    }\n\n    const distance = rightContourOfLeftNode - leftContourOfRightNode;\n    if (distance > 0) {\n        moveSubtree(treeNode, i, distance);\n    }\n}\n\nfunction positionRootCenter(treeNode: LayoutTreeNode) {\n    // Position root between children, taking into account their mod.\n    const startNode = treeNode.children[0];\n    let startX = startNode.preliminary + startNode.modifier;\n    const children = getNonAbstractChildren(treeNode);\n    const endNode = children[children.length - 1];\n    let endX = endNode.modifier + endNode.preliminary + endNode.width;\n\n    /**\n     * nested layout: handle black node\n     *                ---------\n     *              |   parent  |\n     *                ---------\n     *  -------------\n     * |     | ------ |        | ------ |\n     * |     | child1 |        | child2 |\n     * |     | ------ |        | ------ |\n     * |    black     |\n     * |              |\n     *  -------------\n     * The parent is in the center of child 1 and child 2, not black and child2\n     */\n    if (startNode.origin.blackNode && startNode.origin.blackNode.rootX > startNode.origin.blackNode.left) {\n        startX = startX + (startNode.origin.blackNode.rootX - startNode.origin.blackNode.left);\n    }\n    if (endNode.origin.blackNode && endNode.origin.blackNode.rootX + endNode.origin.blackNode.rootWidth < endNode.origin.blackNode.right) {\n        endX = endX - (endNode.origin.blackNode.right - (endNode.origin.blackNode.rootX + endNode.origin.blackNode.rootWidth));\n    }\n\n    /**\n     * has underline shape: handle connecting position\n     */\n    if (startNode.origin.verticalConnectingPosition && endNode.origin.verticalConnectingPosition) {\n        startX = startX + startNode.width - startNode.origin.vGap;\n        endX = endX - endNode.origin.vGap;\n    }\n    let treeNodeOffset = treeNode.width / 2;\n    if (treeNode.origin.verticalConnectingPosition) {\n        treeNodeOffset = treeNode.width - treeNode.origin.vGap;\n    }\n\n    const preliminary = (startX + endX) / 2 - treeNodeOffset;\n    // move sub tree when preliminary to avoid root shifting to left\n    if (preliminary > 0) {\n        treeNode.preliminary = preliminary;\n    } else {\n        treeNode.children.forEach((c, index) => {\n            moveSubtree(treeNode, index, Math.abs(preliminary));\n        });\n    }\n}\n\n// update node's modifier and root node preliminary\nfunction firstWalk(treeNode: LayoutTreeNode) {\n    if (treeNode.childrenCount === 0) {\n        return;\n    }\n    firstWalk(treeNode.children[0]);\n    for (let i = 1; i < treeNode.childrenCount; i++) {\n        // Handle abstract effects on layout at the next node next of abstract end node\n        const abstract = treeNode.children.find(abstract => {\n            let correctEnd = null;\n            if (AbstractNode.isAbstract(abstract.origin.origin)) {\n                let { end } = getCorrectStartEnd(abstract.origin.origin, treeNode.origin);\n                correctEnd = end;\n            }\n            return correctEnd === i - 1;\n        });\n\n        if (abstract) {\n            abstractHandle(treeNode, abstract, i);\n        }\n\n        firstWalk(treeNode.children[i]);\n        separate(treeNode, i);\n    }\n    positionRootCenter(treeNode);\n}\n\nfunction secondWalk(treeNode: LayoutTreeNode, sumOfModifier: number) {\n    sumOfModifier += treeNode.modifier;\n    // Set absolute (no-relative) horizontal coordinates.\n    treeNode.x = treeNode.preliminary + sumOfModifier;\n    for (let i = 0; i < treeNode.childrenCount; i++) {\n        secondWalk(treeNode.children[i], sumOfModifier);\n    }\n}\n\nfunction abstractHandle(treeNode: LayoutTreeNode, abstract: LayoutTreeNode, i: number) {\n    const { start, end } = getCorrectStartEnd(abstract.origin.origin as AbstractNode, treeNode.origin);\n\n    const abstractIndex = treeNode.children.indexOf(abstract);\n    const startNode = treeNode.children[start];\n\n    let endNode = treeNode.children[end];\n\n    const includeElementStartX = startNode.modifier;\n    let includeElementEndX = endNode.modifier + endNode.preliminary + endNode.width;\n\n    let sumOfLeftModifier = endNode.modifier;\n    let nodeParent = treeNode;\n\n    // Align the abstract node with the start node of abstract included\n    treeNode.children[abstractIndex].modifier = startNode.modifier;\n\n    while (endNode.childrenCount) {\n        nodeParent = endNode;\n        const nexRightNode = nextRightContour(endNode);\n        endNode = nexRightNode ? nexRightNode : endNode;\n        let right = sumOfLeftModifier + endNode.modifier + endNode.preliminary + endNode.width;\n\n        includeElementEndX = compareAbstractRight(nodeParent, endNode, includeElementEndX, sumOfLeftModifier);\n        sumOfLeftModifier += endNode.modifier;\n\n        if (right > includeElementEndX) {\n            includeElementEndX = right;\n        }\n    }\n\n    const abstractBranchWidth = abstract.origin.blackNode\n        ? abstract.origin.blackNode.rootX * 2 + abstract.origin.blackNode.rootWidth\n        : abstract.width;\n    const abstractIncludeElementWidth = includeElementEndX - includeElementStartX;\n\n    // move abstract of it included node to ensures that the abstract node and its included nodes are aligned based on the horizontal center\n    if (abstractIncludeElementWidth > abstractBranchWidth) {\n        const distance = (abstractIncludeElementWidth - abstractBranchWidth) / 2;\n        // move abstract node and it's children\n        moveSubtree(treeNode, abstractIndex, distance);\n    } else {\n        const distance = (abstractBranchWidth - abstractIncludeElementWidth) / 2;\n        // move all of abstract included\n        for (let i = start; i < end + 1; i++) {\n            moveSubtree(treeNode, i, distance);\n        }\n    }\n}\n\nfunction compareAbstractRight(nodeParent: LayoutTreeNode, node: LayoutTreeNode, compareTarget: number, sumOfAbstractModifier: number) {\n    const abstract = findAbstractByEndNode(nodeParent, node);\n    if (abstract) {\n        return Math.max(abstract.modifier + abstract.width + sumOfAbstractModifier, compareTarget);\n    }\n    return compareTarget;\n}\n\nfunction compareAbstractLeft(nodeParent: LayoutTreeNode, node: LayoutTreeNode, compareTarget: number) {\n    const abstract = findAbstractByStartNode(nodeParent, node);\n\n    if (abstract) {\n        return Math.min(abstract.modifier + abstract.preliminary, compareTarget);\n    }\n    return compareTarget;\n}\n\nfunction layout(treeNode: LayoutTreeNode) {\n    firstWalk(treeNode);\n    secondWalk(treeNode, 0);\n}\n\nexport { layout };\n", "import { LayoutNode } from '../interfaces/layout-node';\nimport { AbstractNode, LayoutOptions } from '../interfaces/mind';\nimport { findAbstractByEndNode, getNonAbstractChildren } from '../utils/abstract';\nimport { isHorizontalLogicLayout } from '../utils/layout';\n\nexport function separateXAxle(node: LayoutNode, d = 0) {\n    node.x = d;\n    node.children.forEach(child => {\n        if (AbstractNode.isAbstract(child.origin)) {\n            let width = 0;\n            for (let i = child.origin.start!; i <= child.origin.end!; i++) {\n                const box = node.children[i].getBoundingBox();\n                width = Math.max(box.width, width);\n            }\n            separateXAxle(child, node.x + node.width / 2 + width);\n        } else {\n            separateXAxle(child, node.x + node.width / 2);\n        }\n    });\n}\n\nexport function separateYAxle(root: LayoutNode, options: LayoutOptions) {\n    let previousBottom = root.y + root.height;\n    let previousNode: null | LayoutNode = null;\n    updateY(root);\n    function updateY(node: LayoutNode) {\n        node.children.forEach((child, index) => {\n            const abstract = node.children.find(child => {\n                return AbstractNode.isAbstract(child.origin) && child.origin.end === index - 1;\n            });\n            if (abstract) {\n                const attach = previousNode?.origin.isCollapsed ? options.getExtendHeight(child.origin) : 0;\n                previousBottom = abstractHandle(node, abstract) + attach;\n            }\n\n            if (AbstractNode.isAbstract(child.origin)) {\n                return;\n            }\n\n            let y = previousBottom + child.vGap;\n            if (previousNode && !isHorizontalLogicLayout(previousNode.layout) && previousNode.origin.children.length > 0) {\n                if (previousNode.origin.isCollapsed) {\n                    y = y + options.getExtendHeight(child.origin);\n                } else {\n                    y = y + options.getIndentedCrossLevelGap();\n                }\n            }\n            child.y = y;\n            previousNode = child;\n            previousBottom = child.y + child.height;\n            updateY(child);\n        });\n    }\n}\n\nfunction abstractHandle(node: LayoutNode, abstract: LayoutNode) {\n    const abstractNode = abstract.origin as AbstractNode;\n    const abstractIndex = node.children.indexOf(abstract);\n    const startNode = node.children[abstractNode.start];\n    const endNode = node.children[abstractNode.end];\n\n    // abstract and start node alignment\n    node.children[abstractIndex].y = startNode.y;\n\n    const topContour = startNode.y;\n    let bottomContour = endNode.y + endNode.height;\n\n    let bottomContourNode: LayoutNode | null = endNode;\n    let bottomContourParenNode = node;\n\n    while (bottomContourNode?.children.length) {\n        bottomContourParenNode = bottomContourNode;\n        const children = getNonAbstractChildren(bottomContourParenNode);\n        bottomContourNode = children[children.length - 1];\n\n        const abstract = findAbstractByEndNode(bottomContourParenNode, bottomContourNode);\n        bottomContour = abstract\n            ? Math.max(abstract.y + abstract.height, bottomContourNode.y + bottomContourNode.height)\n            : bottomContourNode.y + bottomContourNode.height;\n    }\n\n    const abstractIncludedHeight = bottomContour - topContour;\n    const abstractHeight = abstract.blackNode ? abstract.blackNode.height : abstract.height;\n    const abstractBranchHeight = abstract.blackNode ? abstract.blackNode.rootY * 2 + abstract.blackNode.rootHeight : abstract.height;\n    if (abstractBranchHeight > abstractIncludedHeight) {\n        const distance = (abstractBranchHeight - abstractIncludedHeight) / 2;\n        for (let i = abstractNode.start; i <= abstractNode.end; i++) {\n            node.children[i].eachNode(child => {\n                child.y += distance;\n            });\n        }\n    } else {\n        const distance = (abstractIncludedHeight - abstractBranchHeight) / 2;\n        node.children[abstractIndex].y += distance;\n    }\n    return Math.max(abstract.y + abstractHeight, startNode.y + abstractIncludedHeight);\n}\n", "import { LayoutNode, toHorizontal } from '../interfaces/layout-node';\nimport { LayoutTreeNode } from '../interfaces/layout-tree-node';\nimport { AbstractNode } from '../interfaces/mind';\nimport { getCorrectStartEnd } from '../utils/abstract';\n\nexport function setLayoutTreeResult(tree: LayoutTreeNode, root: LayoutNode, isHorizontal: Boolean) {\n    if (isHorizontal) {\n        root.y = tree.x;\n    } else {\n        root.x = tree.x;\n    }\n    tree.children.forEach((child, i) => {\n        setLayoutTreeResult(child, root.children[i], isHorizontal);\n    });\n}\n\nexport function separateYAxle(node: LayoutNode, isHorizontal: boolean, d = 0) {\n    if (isHorizontal) {\n        if (AbstractNode.isAbstract(node.origin)) {\n            const { start, end } = getCorrectStartEnd(node.origin, node.parent!);\n\n            for (let i = start!; i <= end!; i++) {\n                const right = node.parent?.children[i].getBoundingBox().right;\n                d = Math.max(right!, d);\n            }\n        }\n        node.x = d;\n\n        d += node.width;\n    } else {\n        if (AbstractNode.isAbstract(node.origin)) {\n            for (let i = node.origin.start!; i <= node.origin.end!; i++) {\n                const bottom = node.parent?.children[i].getBoundingBox().bottom;\n                d = Math.max(bottom!, d);\n            }\n        }\n        node.y = d;\n        d += node.height;\n    }\n    node.children.forEach(child => {\n        separateYAxle(child, isHorizontal, d);\n    });\n}\n\nexport const buildLayoutTree = (root: LayoutNode, isHorizontal: boolean) => {\n    const children: LayoutTreeNode[] = [];\n    root.children.forEach(child => {\n        children.push(buildLayoutTree(child, isHorizontal));\n    });\n    if (isHorizontal) {\n        if (root.blackNode) {\n            root.blackNode = toHorizontal(root.blackNode);\n        }\n        return new LayoutTreeNode(root.height, root.width, root.x, children, root);\n    }\n    return new LayoutTreeNode(root.width, root.height, root.y, children, root);\n};\n", "import { layout } from '../algorithms/non-overlapping-tree-layout';\nimport { LayoutBlockNode, LayoutNode } from '../interfaces/layout-node';\nimport { AbstractNode, LayoutContext, LayoutOptions, LayoutType, MindLayoutType, OriginNode } from '../interfaces/mind';\nimport { extractLayoutType, isHorizontalLayout, isLeftLayout, isTopLayout } from '../utils/layout';\nimport * as indent from './indent';\nimport * as logic from './logic';\n\nexport class BaseLayout {\n    constructor() {}\n\n    layout(\n        node: OriginNode,\n        layoutType: string,\n        options: LayoutOptions,\n        context: LayoutContext,\n        isHorizontal = false,\n        parent?: LayoutNode\n    ) {\n        // build layout node\n        const isolatedNodes: LayoutNode[] = [];\n        const isolatedLayoutRoots: LayoutNode[] = [];\n\n        // 1、build layout node\n        const root = this.buildLayoutNode(node, options, context, isolatedNodes, parent);\n\n        // 2、handle sub node layout\n        isolatedNodes\n            .filter(v => v.origin.children.length > 0)\n            .forEach((isolatedNode: LayoutNode) => {\n                const _mindLayoutType = isolatedNode.layout as MindLayoutType;\n                const toTop = context.toTop || (isHorizontalLayout(context.rootLayoutType) && isTopLayout(_mindLayoutType));\n                const toLeft = context.toLeft || (!isHorizontalLayout(context.rootLayoutType) && isLeftLayout(_mindLayoutType));\n                const _isHorizontal = isHorizontalLayout(_mindLayoutType);\n                const isolatedRoot = this.layout(\n                    isolatedNode.origin,\n                    extractLayoutType(_mindLayoutType),\n                    options,\n                    { toTop, toLeft, rootLayoutType: context.rootLayoutType },\n                    _isHorizontal,\n                    isolatedNode.parent\n                );\n                if (!context.toTop && toTop && layoutType !== LayoutType.indented) {\n                    isolatedRoot.down2up();\n                }\n                if (!context.toLeft && toLeft) {\n                    isolatedRoot.right2left();\n                }\n                // 3、set sub node as black box\n                const boundingBox = isolatedRoot.getBoundingBox();\n                isolatedNode.width = boundingBox.width;\n                isolatedNode.height = boundingBox.height;\n                isolatedNode.blackNode = new LayoutBlockNode(\n                    boundingBox.left,\n                    boundingBox.right,\n                    boundingBox.top,\n                    boundingBox.bottom,\n                    boundingBox.width,\n                    boundingBox.height,\n                    isolatedRoot.x,\n                    isolatedRoot.y,\n                    isolatedRoot.width,\n                    isolatedRoot.height\n                );\n\n                isolatedLayoutRoots.push(isolatedRoot);\n            });\n\n        // 4、layout handle\n        switch (layoutType) {\n            case LayoutType.indented:\n                indent.separateXAxle(root);\n                indent.separateYAxle(root, options);\n                break;\n            case LayoutType.fishBone:\n                break;\n            case LayoutType.logic:\n            default:\n                logic.separateYAxle(root, isHorizontal);\n                const layoutTree = logic.buildLayoutTree(root, isHorizontal);\n                layout(layoutTree);\n                logic.setLayoutTreeResult(layoutTree, root, isHorizontal);\n                break;\n        }\n\n        // 5、apply isolated nodes to root\n        const attachedMetaOfIsolatedNodes: { parent: LayoutNode; offsetX: number; offsetY: number }[] = []; // store the offset caused by isolated nodes to avoid multiple offset accumulation\n        isolatedNodes\n            .filter(v => v.origin.children.length > 0)\n            .forEach((isolatedNode: LayoutNode, index) => {\n                if (isolatedNode.parent) {\n                    const layoutRoot = isolatedLayoutRoots[index];\n                    layoutRoot.parent = isolatedNode.parent;\n                    let offsetX, offsetY;\n                    const parentNodeIsHorizontalLayout = isHorizontalLayout(isolatedNode.parent.layout);\n                    // the cross direction does not need to be transformed\n                    if (parentNodeIsHorizontalLayout) {\n                        offsetX = layoutRoot.x;\n                        offsetY = 0;\n                    } else {\n                        offsetX = 0;\n                        offsetY = layoutRoot.y;\n                    }\n                    layoutRoot.translate(isolatedNode.x - offsetX, isolatedNode.y - offsetY);\n                    const _index = isolatedNode.parent.children.indexOf(isolatedNode);\n                    const oldNode = isolatedNode.parent.children[_index];\n                    isolatedNode.parent.children[_index] = Object.assign(oldNode, layoutRoot);\n                    const meta = attachedMetaOfIsolatedNodes.find(\n                        m => m.parent === isolatedNode.parent && !AbstractNode.isAbstract(isolatedNode.origin)\n                    );\n                    if (meta) {\n                        if (meta.offsetX < offsetX) {\n                            meta.offsetX = offsetX;\n                        }\n                        if (meta.offsetX < offsetY) {\n                            meta.offsetX = offsetY;\n                        }\n                    } else if (!AbstractNode.isAbstract(isolatedNode.origin)) {\n                        attachedMetaOfIsolatedNodes.push({ parent: isolatedNode.parent, offsetX, offsetY });\n                    }\n                }\n            });\n        // 6、correct the offset of sibling nodes caused by sub-layout\n        attachedMetaOfIsolatedNodes.forEach(meta => {\n            meta.parent.children.forEach(child => child.translate(meta.offsetX, meta.offsetY));\n        });\n\n        return root;\n    }\n\n    private buildLayoutNode(\n        origin: OriginNode,\n        options: LayoutOptions,\n        context: LayoutContext,\n        isolatedNodes: LayoutNode[],\n        parent?: LayoutNode\n    ) {\n        const root = new LayoutNode(origin, options, context, parent);\n        if (!root.origin.isCollapsed) {\n            const nodes: LayoutNode[] = [root];\n            let node: LayoutNode | undefined;\n            while ((node = nodes.pop())) {\n                if (!node.origin.isCollapsed) {\n                    const children = node.origin.children;\n                    const length = children ? children.length : 0;\n                    node.children = [];\n                    if (children && length) {\n                        for (let i = 0; i < length; i++) {\n                            const child = new LayoutNode(children[i], options, context, node);\n                            node.children.push(child);\n                            child.depth = node.depth + 1;\n                            const isolated =\n                                (node.layout !== child.layout &&\n                                    (extractLayoutType(node.layout) !== extractLayoutType(child.layout) ||\n                                        isHorizontalLayout(node.layout) !== isHorizontalLayout(child.layout))) ||\n                                AbstractNode.isAbstract(child.origin);\n                            if (isolated && !child.origin.isCollapsed) {\n                                isolatedNodes.push(child);\n                            } else {\n                                nodes.push(child);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return root;\n    }\n}\n", "import { AbstractNode, LayoutOptions, LayoutType, MindLayoutType, OriginNode } from '../interfaces/mind';\nimport { isHorizontalLayout, isIndentedLayout, isLeftLayout, isStandardLayout, isTopLayout } from '../utils/layout';\nimport { BaseLayout } from './base-layout';\n\nexport class GlobalLayout {\n    static layout(root: OriginNode, options: LayoutOptions, mindLayoutType: MindLayoutType) {\n        const baseLayout = new BaseLayout();\n\n        if (isStandardLayout(mindLayoutType)) {\n            const primaryNodeCount = root.children.length;\n            const rightBranchNodes = [];\n            const leftBranchNodes = [];\n            const fakeRootNode = { ...root };\n            for (let i = 0; i < primaryNodeCount; i++) {\n                const child = root.children[i];\n\n                if (AbstractNode.isAbstract(child) && child.end < root.rightNodeCount) {\n                    rightBranchNodes.push(child);\n                    continue;\n                }\n                if (AbstractNode.isAbstract(child) && child.start >= root.rightNodeCount) {\n                    leftBranchNodes.push(child);\n                    continue;\n                }\n\n                if (i < root.rightNodeCount) {\n                    rightBranchNodes.push(child);\n                } else {\n                    leftBranchNodes.push(child);\n                }\n            }\n            // right\n            fakeRootNode.children = rightBranchNodes;\n            const rightRoot = baseLayout.layout(\n                fakeRootNode,\n                LayoutType.logic,\n                options,\n                { toLeft: false, toTop: false, rootLayoutType: mindLayoutType },\n                true\n            );\n            fakeRootNode.children = leftBranchNodes;\n            const leftRoot = baseLayout.layout(\n                fakeRootNode,\n                LayoutType.logic,\n                options,\n                { toLeft: true, toTop: false, rootLayoutType: mindLayoutType },\n                true\n            );\n            leftRoot.right2left();\n            rightRoot.translate(leftRoot.x - rightRoot.x, leftRoot.y - rightRoot.y);\n\n            const rightAbstractArray = rightRoot.children.filter(child => AbstractNode.isAbstract(child.origin));\n            rightRoot.children = rightRoot.children.filter(child => !AbstractNode.isAbstract(child.origin));\n\n            leftRoot.children.forEach(leftPrimaryNode => {\n                rightRoot.children.push(leftPrimaryNode);\n                leftPrimaryNode.parent = rightRoot;\n            });\n            rightRoot.children = rightRoot.children.concat(rightAbstractArray);\n\n            rightRoot.x = leftRoot.x;\n            rightRoot.origin = root;\n            return rightRoot;\n        }\n\n        const isIndented = isIndentedLayout(mindLayoutType);\n        const layoutType = isIndented ? LayoutType.indented : LayoutType.logic;\n        const isHorizontal = isIndented ? true : isHorizontalLayout(mindLayoutType);\n        const toTop = isTopLayout(mindLayoutType);\n        const toLeft = isLeftLayout(mindLayoutType);\n        const resultRoot = baseLayout.layout(root, layoutType, options, { toTop, toLeft, rootLayoutType: mindLayoutType }, isHorizontal);\n        if (toTop) {\n            resultRoot.down2up();\n        }\n        if (toLeft) {\n            resultRoot.right2left();\n        }\n        return resultRoot;\n    }\n}\n", "/*\n * Public API Surface of layouts\n */\n\nexport * from './layouts/global-layout';\nexport * from './utils/layout';\nexport * from './utils/abstract';\nexport * from './interfaces/layout-node';\nexport * from './interfaces/mind';\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n", "import { MindElement } from '../interfaces/element';\nimport { MindNode } from '../interfaces/node';\n\nexport const ELEMENT_TO_NODE = new WeakMap<MindElement, MindNode>();\n", "import { MindLayoutType } from '@plait/layouts';\nimport { Path } from '@plait/core';\nimport { MindElement } from './element';\n\nexport interface MindNode {\n    depth: number;\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    hGap: number;\n    vGap: number;\n    children: MindNode[];\n    origin: MindElement;\n    parent: MindNode;\n    left: boolean;\n    up: boolean;\n}\n\nexport const MindNode = {\n    get(root: MindNode, path: Path) {\n        let node = root;\n        for (let i = 0; i < path.length; i++) {\n            const p = path[i];\n            if (!node || !node.children || !node.children[p]) {\n                throw new Error(`Cannot find a descendant at path [${path}]`);\n            }\n            node = node.children[p];\n        }\n        return node;\n    }\n};\n\nexport type ExtendLayoutType = Exclude<MindLayoutType, MindLayoutType.standard>;\n\nexport type CoordinateType = {\n    startX: number;\n    startY: number;\n    endX: number;\n    endY: number;\n};\n\nexport type ExtendUnderlineCoordinateType = {\n    [key in ExtendLayoutType]: CoordinateType;\n};\n\nexport type DetectResult = 'top' | 'bottom' | 'right' | 'left' | null;\n\nexport type RootBaseDirection = 'right' | 'left' | null;\n", "import { MindLayoutType } from '@plait/layouts';\n\nexport enum LayoutDirection {\n    'top' = 'top',\n    'right' = 'right',\n    'bottom' = 'bottom',\n    'left' = 'left'\n}\n\nexport const LayoutDirectionsMap: LayoutDirectionMapType = {\n    [MindLayoutType.right]: [LayoutDirection.right],\n    [MindLayoutType.left]: [LayoutDirection.left],\n    [MindLayoutType.upward]: [LayoutDirection.top],\n    [MindLayoutType.downward]: [LayoutDirection.bottom],\n    [MindLayoutType.rightBottomIndented]: [LayoutDirection.right, LayoutDirection.bottom],\n    [MindLayoutType.rightTopIndented]: [LayoutDirection.right, LayoutDirection.top],\n    [MindLayoutType.leftBottomIndented]: [LayoutDirection.left, LayoutDirection.bottom],\n    [MindLayoutType.leftTopIndented]: [LayoutDirection.left, LayoutDirection.top]\n};\n\nexport type LayoutDirectionMapType = { [key: string]: LayoutDirection[] };\n", "export enum MindPointerType {\n    'mind' = 'mind'\n}\n", "export const DEFAULT_BRANCH_COLORS = [\n    '#A287E0',\n    '#6E80DB',\n    '#6DC4C4',\n    '#E0B75E',\n    '#B1C675',\n    '#77C386',\n    '#C18976',\n    '#E48484',\n    '#E582D4',\n    '#6AB1E4'\n];\n\nexport const COLORFUL_BRANCH_COLORS = [\n    '#F94239',\n    '#FF8612',\n    '#F3D222',\n    '#B3D431',\n    '#00BC7B',\n    '#06ADBF',\n    '#476BFF',\n    '#4E49BE',\n    '#8957E5',\n    '#FE5DA1'\n];\n\nexport const SOFT_BRANCH_COLORS = [\n    '#6D89C1',\n    '#F2BDC7',\n    '#B796D9',\n    '#5BA683',\n    '#B3D431 ',\n    '#F2DC6C',\n    '#F7C98D',\n    '#60B4D1',\n    '#838F9E',\n    '#C1A381'\n];\n\nexport const RETRO_BRANCH_COLORS = [\n    '#459476',\n    '#9A894F',\n    '#D48444',\n    '#E9C358 ',\n    '#4B9D9D',\n    '#C14C41',\n    '#827086 ',\n    '#60718D',\n    '#D38183',\n    '#9DC19D'\n];\n\nexport const DARK_BRANCH_COLORS = [\n    '#3DD1AE',\n    '#F6C659',\n    '#A9E072',\n    '#FF877B ',\n    '#F693E7',\n    '#5DCFFF',\n    '#868AF6',\n    '#4C6DC7',\n    '#D97C26',\n    '#268FAC'\n];\n\nexport const STARRY_BRANCH_COLORS = [\n    '#E46C57',\n    '#579360',\n    '#B98339',\n    '#3A62D1 ',\n    '#B883B7',\n    '#42ABE5',\n    '#2B9D8F',\n    '#A4705E',\n    '#265833',\n    '#787865'\n];\n", "import {\n    DefaultThemeColor,\n    StarryThemeColor,\n    ThemeColor,\n    ThemeColorMode,\n    DarkThemeColor,\n    ColorfulThemeColor,\n    SoftThemeColor,\n    RetroThemeColor,\n    DEFAULT_COLOR\n} from '@plait/core';\nimport {\n    COLORFUL_BRANCH_COLORS,\n    DARK_BRANCH_COLORS,\n    DEFAULT_BRANCH_COLORS,\n    RETRO_BRANCH_COLORS,\n    SOFT_BRANCH_COLORS,\n    STARRY_BRANCH_COLORS\n} from '../constants/theme';\n\nexport interface MindThemeColor extends ThemeColor {\n    mode: ThemeColorMode | string;\n    branchColors: string[];\n    rootFill: string;\n    rootTextColor: string;\n}\n\nexport const MindDefaultThemeColor: MindThemeColor = {\n    ...DefaultThemeColor,\n    branchColors: DEFAULT_BRANCH_COLORS,\n    rootFill: '#f5f5f5',\n    rootTextColor: DEFAULT_COLOR\n};\n\nexport const MindColorfulThemeColor: MindThemeColor = {\n    ...ColorfulThemeColor,\n    branchColors: COLORFUL_BRANCH_COLORS,\n    rootFill: DEFAULT_COLOR,\n    rootTextColor: '#FFFFFF'\n};\n\nexport const MindSoftThemeColor: MindThemeColor = {\n    ...SoftThemeColor,\n    branchColors: SOFT_BRANCH_COLORS,\n    rootFill: '#FFFFFF',\n    rootTextColor: DEFAULT_COLOR\n};\n\nexport const MindRetroThemeColor: MindThemeColor = {\n    ...RetroThemeColor,\n    branchColors: RETRO_BRANCH_COLORS,\n    rootFill: '#153D5D',\n    rootTextColor: '#FFFFFF'\n};\n\nexport const MindDarkThemeColor: MindThemeColor = {\n    ...DarkThemeColor,\n    branchColors: DARK_BRANCH_COLORS,\n    rootFill: '#FFFFFF',\n    rootTextColor: DEFAULT_COLOR\n};\n\nexport const MindStarryThemeColor: MindThemeColor = {\n    ...StarryThemeColor,\n    branchColors: STARRY_BRANCH_COLORS,\n    rootFill: '#FFFFFF',\n    rootTextColor: DEFAULT_COLOR\n};\n\nexport const MindThemeColors: MindThemeColor[] = [\n    MindDefaultThemeColor,\n    MindColorfulThemeColor,\n    MindSoftThemeColor,\n    MindRetroThemeColor,\n    MindDarkThemeColor,\n    MindStarryThemeColor\n];\n\nexport const MindThemeColor = {\n    isMindThemeColor(value: any): value is MindThemeColor {\n        if (value.branchColors && value.rootFill && value.rootTextColor) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n};\n", "import { rgbaToHEX } from \"@plait/core\";\n\nexport const WithMindPluginKey = 'plait-mind-plugin-key';\n\nexport const BASE = 4;\nexport const PRIMARY_COLOR = '#6698FF';\nexport const GRAY_COLOR = '#AAAAAA';\nexport const STROKE_WIDTH = 2;\n\nexport const RESIZE_HANDLE_BUFFER_DISTANCE = 8;\n\nexport const NODE_MORE_LINE_DISTANCE = 10;\n\nexport const NODE_MORE_STROKE_WIDTH = 2;\n\nexport const NODE_MORE_ICON_DIAMETER = 20;\n\nexport const NODE_MORE_BRIDGE_DISTANCE = 10;\n\nexport const NODE_ADD_CIRCLE_COLOR = rgbaToHEX('#000000', 0.2);\n\nexport const NODE_ADD_HOVER_COLOR = '#6698FF';\n\nexport const NODE_ADD_INNER_CROSS_COLOR = 'white';\n\nexport const DEFAULT_MIND_IMAGE_WIDTH = 240;\n\nexport enum MindI18nKey {\n    mindCentralText = 'mind-center-text',\n    abstractNodeText = 'abstract-node-text'\n}", "import { WithMindPluginKey } from '../../constants/default';\nimport { EmojiData, MindElement, PlaitMind } from '../../interfaces';\nimport { WithMindOptions } from '../../interfaces/options';\nimport { PlaitMindBoard } from '../../plugins/with-mind.board';\n\nexport function getEmojisWidthHeight(board: PlaitMindBoard, element: MindElement<EmojiData>) {\n    const options = board.getPluginOptions<WithMindOptions>(WithMindPluginKey);\n    const count = element.data.emojis.length;\n    const fontSize = getEmojiFontSize(element);\n    return {\n        width: fontSize * count + count * 2 * options.emojiPadding + (count - 1) * options.spaceBetweenEmojis,\n        height: element.height\n    };\n}\n\nexport function getEmojiFontSize(element: MindElement<EmojiData>) {\n    if (PlaitMind.isMind(element)) {\n        return 18 + 2;\n    } else {\n        return 14 + 2;\n    }\n}\n", "import { PlaitBoard } from '@plait/core';\nimport { MindElement } from '../../interfaces/element';\n\nexport const getAvailableProperty = (board: PlaitBoard, element: MindElement, propertyKey: keyof MindElement) => {\n    return element[propertyKey];\n};\n", "import { GRAY_COLOR } from './default';\n\nexport const DefaultAbstractNodeStyle = {\n    branch: { color: GRAY_COLOR, width: 2 },\n    shape: {\n        strokeColor: GRAY_COLOR,\n        strokeWidth: 2\n    }\n};\n\nexport const DefaultNodeStyle = {\n    branch: {\n        width: 2\n    },\n    shape: {\n        rectangleRadius: 4,\n        strokeWidth: 2,\n        fill: 'none'\n    }\n};\n", "import { AbstractNode } from '@plait/layouts';\nimport { MindElement, PlaitMind } from '../../interfaces/element';\nimport { Path, PlaitBoard, PlaitElement, PlaitNode } from '@plait/core';\n\nexport const separateChildren = (parentElement: MindElement) => {\n    const rightNodeCount = parentElement.rightNodeCount!;\n    const children = parentElement.children;\n    let rightChildren = [],\n        leftChildren = [];\n\n    for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        if (AbstractNode.isAbstract(child) && child.end < rightNodeCount) {\n            rightChildren.push(child);\n            continue;\n        }\n        if (AbstractNode.isAbstract(child) && child.start >= rightNodeCount) {\n            leftChildren.push(child);\n            continue;\n        }\n\n        if (i < rightNodeCount) {\n            rightChildren.push(child);\n        } else {\n            leftChildren.push(child);\n        }\n    }\n\n    return { leftChildren, rightChildren };\n};\n\nexport const isSetAbstract = (element: PlaitElement) => {\n    return !!getCorrespondingAbstract(element as MindElement);\n};\n\nexport const canSetAbstract = (element: PlaitElement) => {\n    return !PlaitElement.isRootElement(element) && !AbstractNode.isAbstract(element) && !isSetAbstract(element);\n};\n\nexport const getCorrespondingAbstract = (element: MindElement) => {\n    const parent = MindElement.findParent(element as MindElement);\n    if (!parent) return undefined;\n\n    const elementIndex = parent.children.indexOf(element);\n    return parent.children.find(child => {\n        return AbstractNode.isAbstract(child) && elementIndex >= child.start! && elementIndex <= child.end!;\n    });\n};\n\nexport const getBehindAbstracts = (element: MindElement) => {\n    const parent = MindElement.findParent(element as MindElement);\n    if (!parent) return [];\n    const index = parent.children.indexOf(element);\n    return parent.children.filter(child => AbstractNode.isAbstract(child) && child.start! > index);\n};\n\n/**\n * return corresponding abstract that is not child of elements\n */\nexport const getOverallAbstracts = (board: PlaitBoard, elements: MindElement[]) => {\n    const overallAbstracts: MindElement[] = [];\n    elements\n        .filter(value => !AbstractNode.isAbstract(value) && !PlaitMind.isMind(value))\n        .forEach(value => {\n            const abstract = getCorrespondingAbstract(value);\n            if (abstract && elements.indexOf(abstract) === -1 && overallAbstracts.indexOf(abstract) === -1) {\n                const { start, end } = abstract;\n                const parent = MindElement.getParent(value);\n                const isOverall = parent.children.slice(start!, end! + 1).every(includedElement => elements.indexOf(includedElement) > -1);\n                if (isOverall) {\n                    overallAbstracts.push(abstract);\n                }\n            }\n        });\n    return overallAbstracts as (MindElement & AbstractNode)[];\n};\n\nexport interface AbstractRef {\n    abstract: MindElement & AbstractNode;\n    references: MindElement[];\n}\n\n/**\n * abstract node is valid when elements contains at least one element it is referenced with\n */\nexport const getValidAbstractRefs = (board: PlaitBoard, elements: MindElement[]) => {\n    const validAbstractRefs: AbstractRef[] = [];\n    elements\n        .filter(value => !AbstractNode.isAbstract(value) && !PlaitMind.isMind(value))\n        .forEach(value => {\n            const abstract = getCorrespondingAbstract(value);\n            if (abstract && elements.indexOf(abstract) > 0) {\n                const index = validAbstractRefs.findIndex(value => value.abstract === abstract);\n                if (index === -1) {\n                    validAbstractRefs.push({\n                        abstract: abstract as MindElement & AbstractNode,\n                        references: [value]\n                    });\n                } else {\n                    validAbstractRefs[index].references.push(value);\n                }\n            }\n        });\n    return validAbstractRefs;\n};\n\nexport function getRelativeStartEndByAbstractRef(abstractRef: AbstractRef, elements: MindElement[]) {\n    const start = elements.indexOf(abstractRef.references[0]);\n    const end = elements.indexOf(abstractRef.references[abstractRef.references.length - 1]);\n    return { start, end };\n}\n\nexport const insertElementHandleAbstract = (\n    board: PlaitBoard,\n    path: Path,\n    step = 1,\n    // This distinguishes between dragging and adding to the last node summarized in the abstract node\n    isExtendPreviousNode: boolean = true,\n    effectedAbstracts = new Map<MindElement, Pick<AbstractNode, 'start' | 'end'>>()\n) => {\n    const parent = PlaitNode.parent(board, path) as MindElement;\n    const hasPreviousNode = path[path.length - 1] !== 0;\n    let behindAbstracts: MindElement[];\n\n    if (!hasPreviousNode) {\n        behindAbstracts = parent.children.filter(child => AbstractNode.isAbstract(child));\n    } else {\n        const selectedElement = PlaitNode.get(board, Path.previous(path)) as MindElement;\n        behindAbstracts = getBehindAbstracts(selectedElement);\n    }\n\n    if (behindAbstracts.length) {\n        behindAbstracts.forEach(abstract => {\n            let newProperties = effectedAbstracts.get(abstract);\n            if (!newProperties) {\n                newProperties = { start: 0, end: 0 };\n                effectedAbstracts.set(abstract, newProperties);\n            }\n            newProperties.start = newProperties.start + step;\n            newProperties.end = newProperties.end + step;\n        });\n    }\n\n    if (!hasPreviousNode) {\n        return effectedAbstracts;\n    }\n\n    const selectedElement = PlaitNode.get(board, Path.previous(path)) as MindElement;\n    const correspondingAbstract = getCorrespondingAbstract(selectedElement);\n    const isDragToLast = !isExtendPreviousNode && correspondingAbstract && correspondingAbstract.end === path[path.length - 1] - 1;\n\n    if (correspondingAbstract && !isDragToLast) {\n        let newProperties = effectedAbstracts.get(correspondingAbstract);\n        if (!newProperties) {\n            newProperties = { start: 0, end: 0 };\n            effectedAbstracts.set(correspondingAbstract, newProperties);\n        }\n        newProperties.end = newProperties.end + step;\n    }\n\n    return effectedAbstracts;\n};\n\nexport const deleteElementHandleAbstract = (\n    board: PlaitBoard,\n    deletableElements: MindElement[],\n    effectedAbstracts = new Map<MindElement, Pick<AbstractNode, 'start' | 'end'>>()\n) => {\n    deletableElements.forEach(node => {\n        if (!PlaitMind.isMind(node)) {\n            const behindAbstracts = getBehindAbstracts(node).filter(abstract => !deletableElements.includes(abstract));\n            if (behindAbstracts.length) {\n                behindAbstracts.forEach(abstract => {\n                    let newProperties = effectedAbstracts.get(abstract);\n                    if (!newProperties) {\n                        newProperties = { start: 0, end: 0 };\n                        effectedAbstracts.set(abstract, newProperties);\n                    }\n                    newProperties.start = newProperties.start - 1;\n                    newProperties.end = newProperties.end - 1;\n                });\n            }\n\n            const correspondingAbstract = getCorrespondingAbstract(node);\n            if (correspondingAbstract && !deletableElements.includes(correspondingAbstract)) {\n                let newProperties = effectedAbstracts.get(correspondingAbstract);\n                if (!newProperties) {\n                    newProperties = { start: 0, end: 0 };\n\n                    effectedAbstracts.set(correspondingAbstract, newProperties);\n                }\n                newProperties.end = newProperties.end - 1;\n            }\n        }\n    });\n    return effectedAbstracts;\n};\n\nexport const isChildOfAbstract = (board: PlaitBoard, element: MindElement) => {\n    const ancestors = MindElement.getAncestors(board, element) as MindElement[];\n    return !!ancestors.find(value => AbstractNode.isAbstract(value));\n};\n", "/**\n * Processing of branch color, width, style, etc. of the mind node\n */\nimport { PlaitBoard, isNullOrUndefined } from '@plait/core';\nimport { BranchShape, MindElement } from '../../interfaces/element';\nimport { STROKE_WIDTH } from '../../constants/default';\nimport { DefaultAbstractNodeStyle } from '../../constants/node-style';\nimport { getAvailableProperty } from './common';\nimport { MindDefaultThemeColor, MindThemeColor } from '../../interfaces/theme-color';\nimport { AbstractNode } from '@plait/layouts';\nimport { isChildOfAbstract } from '../abstract/common';\n\nexport const getBranchColorByMindElement = (board: PlaitBoard, element: MindElement) => {\n    if (AbstractNode.isAbstract(element) || isChildOfAbstract(board, element)) {\n        return getAbstractBranchColor(board, element);\n    }\n\n    const branchColor = getAvailableProperty(board, element, 'branchColor') || getAvailableProperty(board, element, 'strokeColor');\n    return branchColor || getDefaultBranchColor(board, element);\n};\n\nexport const getBranchShapeByMindElement = (board: PlaitBoard, element: MindElement) => {\n    const branchShape = getAvailableProperty(board, element, 'branchShape');\n    return branchShape || BranchShape.bight;\n};\n\nexport const getBranchWidthByMindElement = (board: PlaitBoard, element: MindElement) => {\n    const branchWidth = getAvailableProperty(board, element, 'branchWidth') || getAvailableProperty(board, element, 'strokeWidth');\n    return branchWidth || STROKE_WIDTH;\n};\n\nexport const getAbstractBranchWidth = (board: PlaitBoard, element: MindElement) => {\n    if (!isNullOrUndefined(element.branchWidth)) {\n        return element.branchWidth as number;\n    }\n    return DefaultAbstractNodeStyle.branch.width;\n};\n\nexport const getAbstractBranchColor = (board: PlaitBoard, element: MindElement) => {\n    if (element.branchColor || element.strokeColor) {\n        return element.branchColor || element.strokeColor;\n    }\n    return DefaultAbstractNodeStyle.branch.color;\n};\n\nexport const getNextBranchColor = (board: PlaitBoard, root: MindElement) => {\n    const index = root.children.length;\n    return getDefaultBranchColorByIndex(board, index);\n};\n\nexport const getDefaultBranchColor = (board: PlaitBoard, element: MindElement) => {\n    const path = PlaitBoard.findPath(board, element);\n    return getDefaultBranchColorByIndex(board, path[1]);\n};\n\nexport const getDefaultBranchColorByIndex = (board: PlaitBoard, index: number) => {\n    const themeColor = getMindThemeColor(board);\n    const length = themeColor.branchColors.length;\n    const remainder = index % length;\n    return themeColor.branchColors[remainder];\n};\n\nexport const getMindThemeColor = (board: PlaitBoard) => {\n    const themeColors = PlaitBoard.getThemeColors(board);\n    const themeColor = themeColors.find(val => val.mode === board.theme.themeColorMode);\n    if (themeColor && MindThemeColor.isMindThemeColor(themeColor)) {\n        return themeColor;\n    } else {\n        return MindDefaultThemeColor;\n    }\n};\n", "import { PlaitBoard } from '@plait/core';\nimport { MindElement, MindElementShape, PlaitMind } from '../../interfaces/element';\nimport { getAvailableProperty } from './common';\nimport { getDefaultBranchColor, getMindThemeColor } from './branch';\nimport { AbstractNode } from '@plait/layouts';\nimport { isChildOfAbstract } from '../abstract/common';\nimport { DefaultAbstractNodeStyle, DefaultNodeStyle } from '../../constants/node-style';\nimport { StrokeStyle } from '@plait/common';\n\nexport const getStrokeColorByElement = (board: PlaitBoard, element: MindElement) => {\n    if (PlaitMind.isMind(element)) {\n        const defaultRootStroke = getMindThemeColor(board).rootFill;\n        return element.strokeColor || defaultRootStroke;\n    }\n\n    if (AbstractNode.isAbstract(element) || isChildOfAbstract(board, element)) {\n        return element.strokeColor || DefaultAbstractNodeStyle.shape.strokeColor;\n    }\n\n    return getAvailableProperty(board, element, 'strokeColor') || getDefaultBranchColor(board, element);\n};\n\nexport const getStrokeStyleByElement = (board: PlaitBoard, element: MindElement) => {\n    return element.strokeStyle || StrokeStyle.solid;\n};\n\nexport const getStrokeWidthByElement = (board: PlaitBoard, element: MindElement) => {\n    const strokeWidth =\n        element.strokeWidth ||\n        (AbstractNode.isAbstract(element) ? DefaultAbstractNodeStyle.shape.strokeWidth : DefaultNodeStyle.shape.strokeWidth);\n    return strokeWidth;\n};\n\nexport const getFillByElement = (board: PlaitBoard, element: MindElement) => {\n    if (element.fill) {\n        return element.fill;\n    }\n    const defaultRootFill = getMindThemeColor(board).rootFill;\n    return element.isRoot ? defaultRootFill : DefaultNodeStyle.shape.fill;\n};\n\nexport const getShapeByElement = (board: PlaitBoard, element: MindElement): MindElementShape => {\n    const shape = getAvailableProperty(board, element, 'shape');\n    return shape || MindElementShape.roundRectangle;\n};\n", "import { PlaitBoard, PlaitElement, getSelectedElements } from '@plait/core';\nimport { MindElement } from '../../interfaces/element';\nimport { getFirstTextManage } from '@plait/common';\n\nexport function editTopic(element: MindElement) {\n    const textManage = getFirstTextManage(element);\n    textManage?.edit(\n        () => {},\n        event => {\n            const keyboardEvent = event as KeyboardEvent;\n            return keyboardEvent.key === 'Enter' && !keyboardEvent.shiftKey;\n        }\n    );\n}\n\nexport const getSelectedMindElements = (board: PlaitBoard, elements?: PlaitElement[]) => {\n    const selectedElements = elements?.length ? elements : getSelectedElements(board);\n    return selectedElements.filter(value => MindElement.isMindElement(board, value)) as MindElement[];\n};\n", "import { LayoutDirection, LayoutDirectionsMap, MindElement, PlaitMind } from '../interfaces';\nimport { isIndentedLayout, MindLayoutType } from '@plait/layouts';\n\nexport const getBranchDirectionsByLayouts = (branchLayouts: MindLayoutType[]) => {\n    const branchDirections: LayoutDirection[] = [];\n    branchLayouts.forEach(l => {\n        const directions = LayoutDirectionsMap[l];\n        directions.forEach(d => {\n            if (!branchDirections.includes(d) && !branchDirections.includes(getLayoutReverseDirection(d))) {\n                branchDirections.push(d);\n            }\n        });\n    });\n    return branchDirections;\n};\n\nexport const isCorrectLayout = (root: MindElement, layout: MindLayoutType) => {\n    const rootLayout = root.layout || getDefaultLayout();\n    return !getInCorrectLayoutDirection(rootLayout, layout);\n};\n\nexport const isMixedLayout = (parentLayout: MindLayoutType, layout: MindLayoutType) => {\n    return (!isIndentedLayout(parentLayout) && isIndentedLayout(layout)) || (isIndentedLayout(parentLayout) && !isIndentedLayout(layout));\n};\n\nexport const getInCorrectLayoutDirection = (rootLayout: MindLayoutType, layout: MindLayoutType) => {\n    const directions = LayoutDirectionsMap[rootLayout];\n    const subLayoutDirections = LayoutDirectionsMap[layout];\n    if (!subLayoutDirections) {\n        throw new Error(`unexpected layout: ${layout} on correct layout`);\n    }\n    return subLayoutDirections.find(d => directions.includes(getLayoutReverseDirection(d)));\n};\n\nexport const correctLayoutByDirection = (layout: MindLayoutType, direction: LayoutDirection) => {\n    const isHorizontal = direction === LayoutDirection.left || direction === LayoutDirection.right ? true : false;\n    let inverseDirectionLayout = MindLayoutType.standard;\n    switch (layout) {\n        case MindLayoutType.left:\n            inverseDirectionLayout = MindLayoutType.right;\n            break;\n        case MindLayoutType.right:\n            inverseDirectionLayout = MindLayoutType.left;\n            break;\n        case MindLayoutType.downward:\n            inverseDirectionLayout = MindLayoutType.upward;\n            break;\n        case MindLayoutType.upward:\n            inverseDirectionLayout = MindLayoutType.downward;\n            break;\n        case MindLayoutType.rightBottomIndented:\n            inverseDirectionLayout = isHorizontal ? MindLayoutType.leftBottomIndented : MindLayoutType.rightTopIndented;\n            break;\n        case MindLayoutType.leftBottomIndented:\n            inverseDirectionLayout = isHorizontal ? MindLayoutType.rightBottomIndented : MindLayoutType.leftTopIndented;\n            break;\n        case MindLayoutType.rightTopIndented:\n            inverseDirectionLayout = isHorizontal ? MindLayoutType.leftTopIndented : MindLayoutType.rightBottomIndented;\n            break;\n        case MindLayoutType.leftTopIndented:\n            inverseDirectionLayout = isHorizontal ? MindLayoutType.rightTopIndented : MindLayoutType.leftBottomIndented;\n            break;\n    }\n    return inverseDirectionLayout;\n};\n\nexport const getLayoutDirection = (root: MindElement) => {\n    const layout = root.layout || getDefaultLayout();\n    return LayoutDirectionsMap[layout];\n};\n\nexport const getDefaultLayout = () => {\n    return MindLayoutType.standard;\n};\n\nexport const getAvailableSubLayoutsByLayoutDirections = (directions: LayoutDirection[]): MindLayoutType[] => {\n    const result: MindLayoutType[] = [];\n    const reverseDirections = directions.map(getLayoutReverseDirection);\n    for (const key in MindLayoutType) {\n        const layout = MindLayoutType[key as keyof typeof MindLayoutType];\n        const layoutDirections = LayoutDirectionsMap[layout];\n        if (layoutDirections) {\n            const hasSameDirection = layoutDirections.some(d => directions.includes(d));\n            const hasReverseDirection = layoutDirections.some(r => reverseDirections.includes(r));\n            if (hasSameDirection && !hasReverseDirection) {\n                result.push(layout);\n            }\n        }\n    }\n    return result;\n};\n\nexport const getLayoutReverseDirection = (layoutDirection: LayoutDirection) => {\n    let reverseDirection = LayoutDirection.right;\n    switch (layoutDirection) {\n        case LayoutDirection.top:\n            reverseDirection = LayoutDirection.bottom;\n            break;\n        case LayoutDirection.bottom:\n            reverseDirection = LayoutDirection.top;\n            break;\n        case LayoutDirection.right:\n            reverseDirection = LayoutDirection.left;\n            break;\n        case LayoutDirection.left:\n            reverseDirection = LayoutDirection.right;\n            break;\n    }\n    return reverseDirection;\n};\n\nexport const getRootLayout = (root: MindElement) => {\n    return root.layout || getDefaultLayout();\n};\n", "import {\n    ConnectingPosition,\n    LayoutNode,\n    LayoutOptions,\n    OriginNode,\n    isHorizontalLayout,\n    isHorizontalLogicLayout,\n    isIndentedLayout\n} from '@plait/layouts';\nimport { MindElement, MindElementShape } from '../../interfaces/element';\nimport { BASE } from '../../constants/default';\nimport { getRootLayout } from '../layout';\nimport { NodeSpace } from './node-space';\nimport { PlaitMindBoard } from '../../plugins/with-mind.board';\n\nexport const getLayoutOptions = (board: PlaitMindBoard) => {\n    function getMainAxle(element: MindElement, parent?: LayoutNode) {\n        if (element.isRoot) {\n            return BASE * 12;\n        }\n        if (parent && parent.isRoot()) {\n            return BASE * 3;\n        }\n        return BASE * 3;\n    }\n\n    function getSecondAxle(element: MindElement, parent?: LayoutNode) {\n        if (element.isRoot) {\n            return BASE * 12;\n        }\n        return BASE * 8.5;\n    }\n\n    return {\n        getHeight(element: MindElement) {\n            return NodeSpace.getNodeHeight(board, element);\n        },\n        getWidth(element: MindElement) {\n            return NodeSpace.getNodeWidth(board, element);\n        },\n        getHorizontalGap(element: MindElement, parent?: LayoutNode) {\n            const _layout = (parent && parent.layout) || getRootLayout(element);\n            const isHorizontal = isHorizontalLayout(_layout);\n            if (isIndentedLayout(_layout)) {\n                return BASE * 6;\n            }\n            if (!isHorizontal) {\n                return getMainAxle(element, parent);\n            } else {\n                return getSecondAxle(element, parent);\n            }\n        },\n        getVerticalGap(element: MindElement, parent?: LayoutNode) {\n            const _layout = (parent && parent.layout) || getRootLayout(element);\n            if (isIndentedLayout(_layout)) {\n                return BASE * 3.5;\n            }\n            const isHorizontal = isHorizontalLayout(_layout);\n            if (isHorizontal) {\n                return getMainAxle(element, parent);\n            } else {\n                return getSecondAxle(element, parent);\n            }\n        },\n        getVerticalConnectingPosition(element: MindElement, parent?: LayoutNode) {\n            if (element.shape === MindElementShape.underline && parent && isHorizontalLogicLayout(parent.layout)) {\n                return ConnectingPosition.bottom;\n            }\n            return undefined;\n        },\n        getExtendHeight(node: OriginNode) {\n            return 0;\n        },\n        getIndentedCrossLevelGap() {\n            return BASE * 1;\n        }\n    } as LayoutOptions;\n};\n", "export const TOPIC_FONT_SIZE = 14;\n\nexport const ROOT_TOPIC_FONT_SIZE = 18;\n\nexport const TOPIC_DEFAULT_MAX_WORD_COUNT = 34;\n\nexport const NodeTopicThreshold = {\n    defaultTextMaxWidth: 34 * 14\n};\n", "export const ABSTRACT_HANDLE_COLOR = '#6698FF80'; //primary color 50% opacity\nexport const ABSTRACT_INCLUDED_OUTLINE_OFFSET = 3.5;\nexport const ABSTRACT_HANDLE_LENGTH = 10;\n\nexport const ABSTRACT_HANDLE_MASK_WIDTH = 8;\n", "import { getI18nValue, PlaitBoard } from '@plait/core';\nimport { MindI18nKey } from '../constants/default';\nimport { ROOT_TOPIC_FONT_SIZE, TOPIC_DEFAULT_MAX_WORD_COUNT, TOPIC_FONT_SIZE } from '../constants';\nimport { DEFAULT_FONT_FAMILY, measureElement, ParagraphElement } from '@plait/common';\n\nexport const MIND_CENTRAL_TEXT = '中心主题';\n\nexport const ABSTRACT_NODE_TEXT = '概要';\n\nexport const getDefaultMindNameText = (board: PlaitBoard) => {\n    return getI18nValue(board, MindI18nKey.mindCentralText, MIND_CENTRAL_TEXT);\n};\n\nexport const getAbstractNodeText = (board: PlaitBoard) => {\n    return getI18nValue(board, MindI18nKey.abstractNodeText, ABSTRACT_NODE_TEXT);\n};\n\nexport const getTopicSize = (board: PlaitBoard | null, isRoot: boolean, isBranch: boolean, topic: ParagraphElement, manualWidth?: number) => {\n    let fontFamily = DEFAULT_FONT_FAMILY;\n    let fontSize = TOPIC_FONT_SIZE;\n    if (isRoot) {\n        fontFamily = DEFAULT_FONT_FAMILY;\n        fontSize = ROOT_TOPIC_FONT_SIZE;\n    } else if (isBranch) {\n        fontFamily = DEFAULT_FONT_FAMILY;\n    }\n    const maxWidth = fontSize * TOPIC_DEFAULT_MAX_WORD_COUNT;\n    return measureElement(board, topic, { fontSize, fontFamily }, manualWidth ? manualWidth : maxWidth);\n};\n", "import { PlaitBoard, Point, idCreator, isNullOrUndefined } from '@plait/core';\nimport { MindLayoutType } from '@plait/layouts';\nimport { BranchShape, MindElement, MindElementShape } from '../../interfaces/element';\nimport { Element } from 'slate';\nimport { NodeSpace } from '../space';\nimport { PlaitMindBoard } from '../../plugins/with-mind.board';\nimport { buildText } from '@plait/common';\nimport { getDefaultMindNameText, getTopicSize } from '../common';\n\nexport const createEmptyMind = (board: PlaitBoard, point: Point) => {\n    const text = getDefaultMindNameText(board);\n    const topicSize = getTopicSize(board, true, false, buildText(text));\n    const element = createMindElement(text, topicSize.width, topicSize.height, { layout: MindLayoutType.right });\n    element.isRoot = true;\n    element.type = 'mindmap';\n    const width = NodeSpace.getNodeWidth(board as PlaitMindBoard, element);\n    const height = NodeSpace.getNodeHeight(board as PlaitMindBoard, element);\n    element.points = [[point[0] - width / 2, point[1] - height / 2]];\n    return element;\n};\n\nexport const createMindElement = (text: string | Element, width: number, height: number, options: InheritAttribute) => {\n    const newElement: MindElement = {\n        id: idCreator(),\n        data: {\n            topic: buildText(text)\n        },\n        children: [],\n        width,\n        height\n    };\n\n    let key: keyof typeof options;\n    for (key in options) {\n        if (!isNullOrUndefined(options[key])) {\n            (newElement as any)[key] = options[key];\n        }\n    }\n\n    return newElement;\n};\n\nexport interface InheritAttribute {\n    fill?: string;\n    strokeColor?: string;\n    strokeWidth?: number;\n    strokeStyle?: number;\n    shape?: MindElementShape;\n    layout?: MindLayoutType;\n    branchColor?: string;\n    branchWidth?: number;\n    branchShape?: BranchShape;\n}\n\nexport const INHERIT_ATTRIBUTE_KEYS = [\n    'fill',\n    'strokeColor',\n    'strokeWidth',\n    'strokeStyle',\n    'shape',\n    'layout',\n    'branchColor',\n    'branchWidth',\n    'branchShape'\n];\n", "import { addSelectedElement, clearSelectedElement, idCreator, Path, PlaitBoard, Transforms } from '@plait/core';\nimport { MindElement, PlaitMind } from '../interfaces/element';\nimport { editTopic } from './node/common';\nimport { createMindElement, INHERIT_ATTRIBUTE_KEYS, InheritAttribute } from './node/create-node';\nimport { MindNode } from '../interfaces/node';\nimport { PlaitMindBoard } from '../plugins/with-mind.board';\nimport { ROOT_TOPIC_FONT_SIZE, TOPIC_FONT_SIZE } from '../constants/node-topic-style';\nimport { TEXT_DEFAULT_HEIGHT } from '@plait/text-plugins';\n\nexport const getChildrenCount = (element: MindElement) => {\n    const count: number = element.children.reduce((p: number, c: MindElement) => {\n        return p + getChildrenCount(c);\n    }, 0);\n    return count + element.children.length;\n};\n\nexport const isChildElement = (origin: MindElement, child: MindElement) => {\n    let parent = MindElement.findParent(child);\n    while (parent) {\n        if (parent === origin) {\n            return true;\n        }\n        parent = MindElement.findParent(parent);\n    }\n    return false;\n};\n\nexport const getFirstLevelElement = (elements: MindElement[]) => {\n    let result: MindElement[] = [];\n    elements.forEach(element => {\n        const isChild = elements.some(node => {\n            return isChildElement(node, element);\n        });\n\n        if (!isChild) {\n            result.push(element);\n        }\n    });\n    return result;\n};\n\nexport const isChildRight = (parent: MindNode, child: MindNode) => {\n    return parent.x < child.x;\n};\n\nexport const isChildUp = (parent: MindNode, child: MindNode) => {\n    return parent.y > child.y;\n};\n\nexport const copyNewNode = (node: MindElement) => {\n    const newNode: MindElement = { ...node };\n    newNode.id = idCreator();\n    newNode.children = [];\n\n    for (const childNode of node.children) {\n        newNode.children.push(copyNewNode(childNode));\n    }\n    return newNode;\n};\n\nexport const insertMindElement = (board: PlaitMindBoard, inheritNode: MindElement, path: Path) => {\n    const newNode: InheritAttribute = {};\n    if (!inheritNode.isRoot) {\n        INHERIT_ATTRIBUTE_KEYS.forEach(attr => {\n            (newNode as any)[attr] = inheritNode[attr];\n        });\n        delete newNode.layout;\n    }\n    const newElement = createMindElement('', TOPIC_FONT_SIZE, TEXT_DEFAULT_HEIGHT, newNode);\n    Transforms.insertNode(board, newElement, path);\n    clearSelectedElement(board);\n    addSelectedElement(board, newElement);\n    setTimeout(() => {\n        editTopic(newElement);\n    });\n};\n\nexport const findLastChild = (child: MindNode) => {\n    let result = child;\n    while (result.children.length !== 0) {\n        result = result.children[result.children.length - 1];\n    }\n    return result;\n};\n\nexport const divideElementByParent = (elements: MindElement[]) => {\n    const abstractIncludedGroups = [];\n    const parentElements: MindElement[] = [];\n\n    for (let i = 0; i < elements.length; i++) {\n        const parent = MindElement.getParent(elements[i]);\n        const parentIndex = parentElements.indexOf(parent);\n        if (parentIndex === -1) {\n            parentElements.push(parent);\n            abstractIncludedGroups.push([elements[i]]);\n        } else {\n            abstractIncludedGroups[parentIndex].push(elements[i]);\n        }\n    }\n    return { parentElements, abstractIncludedGroups };\n};\n\nexport const getDefaultMindElementFontSize = (board: PlaitBoard, element: MindElement) => {\n    if (PlaitMind.isMind(element)) {\n        return ROOT_TOPIC_FONT_SIZE;\n    }\n    if (MindElement.isMindElement(board, element)) {\n        return TOPIC_FONT_SIZE;\n    }\n    throw new Error('can not find default font-size');\n};\n", "import { BASE, WithMindPluginKey } from '../../constants/default';\nimport { PlaitMind } from '../../interfaces/element';\nimport { MindElement } from '../../interfaces/element';\nimport { EmojiData } from '../../interfaces/element-data';\nimport { WithMindOptions } from '../../interfaces/options';\nimport { PlaitMindBoard } from '../../plugins/with-mind.board';\nimport { getEmojisWidthHeight } from './emoji';\nimport { Element } from 'slate';\nimport { getStrokeWidthByElement } from '../node-style/shape';\nimport { getDefaultMindElementFontSize } from '../mind';\nimport { DEFAULT_FONT_SIZE, getFirstTextMarks, MarkTypes, PlaitMarkEditor } from '@plait/text-plugins';\nimport { DEFAULT_FONT_FAMILY, getElementSize, getFirstTextEditor } from '@plait/common';\nimport { NodeTopicThreshold } from '../../constants/node-topic-style';\n\nconst NodeDefaultSpace = {\n    horizontal: {\n        nodeAndText: BASE * 2.5,\n        emojiAndText: BASE * 1.5\n    },\n    vertical: {\n        nodeAndText: BASE,\n        nodeAndImage: BASE,\n        imageAndText: BASE * 1.5\n    }\n};\n\nconst RootDefaultSpace = {\n    horizontal: {\n        nodeAndText: BASE * 4,\n        emojiAndText: BASE * 2\n    },\n    vertical: {\n        nodeAndText: BASE * 2\n    }\n};\n\nconst getHorizontalSpaceBetweenNodeAndText = (board: PlaitMindBoard, element: MindElement) => {\n    const isMind = PlaitMind.isMind(element);\n    const nodeAndText = isMind ? RootDefaultSpace.horizontal.nodeAndText : NodeDefaultSpace.horizontal.nodeAndText;\n    const strokeWidth = getStrokeWidthByElement(board, element);\n    return nodeAndText + strokeWidth;\n};\n\nconst getVerticalSpaceBetweenNodeAndText = (board: PlaitMindBoard, element: MindElement) => {\n    const isMind = PlaitMind.isMind(element);\n    const strokeWidth = getStrokeWidthByElement(board, element);\n    const nodeAndText = isMind ? RootDefaultSpace.vertical.nodeAndText : NodeDefaultSpace.vertical.nodeAndText;\n    return nodeAndText + strokeWidth;\n};\n\nconst getSpaceEmojiAndText = (element: MindElement) => {\n    const isMind = PlaitMind.isMind(element);\n    const emojiAndText = isMind ? RootDefaultSpace.horizontal.emojiAndText : NodeDefaultSpace.horizontal.emojiAndText;\n    return emojiAndText;\n};\n\nexport const NodeSpace = {\n    getNodeWidth(board: PlaitMindBoard, element: MindElement) {\n        const nodeAndText = getHorizontalSpaceBetweenNodeAndText(board, element);\n        if (MindElement.hasEmojis(element)) {\n            return (\n                NodeSpace.getEmojiLeftSpace(board, element) +\n                getEmojisWidthHeight(board, element).width +\n                getSpaceEmojiAndText(element) +\n                NodeSpace.getTopicDynamicWidth(board, element) +\n                nodeAndText\n            );\n        }\n        return nodeAndText + NodeSpace.getTopicDynamicWidth(board, element) + nodeAndText;\n    },\n    getNodeHeight(board: PlaitMindBoard, element: MindElement) {\n        const topicSize = getElementSize(\n            board,\n            element.data.topic,\n            { fontSize: DEFAULT_FONT_SIZE, fontFamily: DEFAULT_FONT_FAMILY },\n            NodeSpace.getTopicMaxDynamicWidth(board, element)\n        );\n        const normalizedSize = normalizeWidthAndHeight(board, element, topicSize.width, topicSize.height);\n        const nodeAndText = getVerticalSpaceBetweenNodeAndText(board, element);\n        if (MindElement.hasImage(element)) {\n            return NodeSpace.getTextTopSpace(board, element) + normalizedSize.height + nodeAndText;\n        }\n        return nodeAndText + normalizedSize.height + nodeAndText;\n    },\n    getTopicDynamicWidth(board: PlaitMindBoard, element: MindElement) {\n        const topicSize = getElementSize(\n            board,\n            element.data.topic,\n            { fontSize: getDefaultMindElementFontSize(board, element), fontFamily: DEFAULT_FONT_FAMILY },\n            NodeSpace.getTopicMaxDynamicWidth(board, element)\n        );\n        const normalizedSize = normalizeWidthAndHeight(board, element, topicSize.width, topicSize.width);\n        const width = element.manualWidth || normalizedSize.width;\n        const imageWidth = MindElement.hasImage(element) ? element.data.image?.width : 0;\n        return Math.max(width, imageWidth);\n    },\n    getTopicHeight(board: PlaitMindBoard, element: MindElement) {\n        const topicSize = getElementSize(\n            board,\n            element.data.topic,\n            { fontSize: DEFAULT_FONT_SIZE, fontFamily: DEFAULT_FONT_FAMILY },\n            NodeSpace.getTopicMaxDynamicWidth(board, element)\n        );\n        const normalizedSize = normalizeWidthAndHeight(board, element, topicSize.width, topicSize.height);\n        return normalizedSize.height;\n    },\n    getTopicMaxDynamicWidth(board: PlaitMindBoard, element: MindElement) {\n        return Math.max(\n            NodeTopicThreshold.defaultTextMaxWidth,\n            element.manualWidth || 0,\n            MindElement.hasImage(element) ? element.data.image?.width : 0\n        );\n    },\n    /**\n     * use it when upload image first or resize image\n     */\n    getNodeNewDynamicWidth(board: PlaitMindBoard, element: MindElement, imageWidth: number) {\n        const width = element.manualWidth || element.width;\n        return Math.max(width, imageWidth);\n    },\n    getNodeResizableMinWidth(board: PlaitMindBoard, element: MindElement) {\n        const minTopicWidth = NodeSpace.getNodeTopicMinWidth(board, element);\n        if (MindElement.hasImage(element) && element.data.image.width > minTopicWidth) {\n            return element.data.image.width;\n        } else {\n            return minTopicWidth;\n        }\n    },\n    getNodeTopicMinWidth(board: PlaitMindBoard, element: MindElement) {\n        const defaultFontSize = getDefaultMindElementFontSize(board, element);\n        const firstText = getFirstTextMarks(element.data.topic);\n        const fontSize = (firstText[MarkTypes.fontSize] ? Number(firstText[MarkTypes.fontSize]) : null) || defaultFontSize;\n        return fontSize;\n    },\n    getTextLeftSpace(board: PlaitMindBoard, element: MindElement) {\n        const nodeAndText = getHorizontalSpaceBetweenNodeAndText(board, element);\n        if (MindElement.hasEmojis(element)) {\n            return NodeSpace.getEmojiLeftSpace(board, element) + getEmojisWidthHeight(board, element).width + getSpaceEmojiAndText(element);\n        } else {\n            return nodeAndText;\n        }\n    },\n    getTextTopSpace(board: PlaitMindBoard, element: MindElement) {\n        const nodeAndText = getVerticalSpaceBetweenNodeAndText(board, element);\n        if (MindElement.hasImage(element)) {\n            return NodeSpace.getImageTopSpace(board, element) + element.data.image.height + NodeDefaultSpace.vertical.imageAndText;\n        } else {\n            return nodeAndText;\n        }\n    },\n    getImageTopSpace(board: PlaitMindBoard, element: MindElement) {\n        const strokeWidth = getStrokeWidthByElement(board, element);\n        return strokeWidth + NodeDefaultSpace.vertical.nodeAndImage;\n    },\n    getEmojiLeftSpace(board: PlaitMindBoard, element: MindElement<EmojiData>) {\n        const options = board.getPluginOptions<WithMindOptions>(WithMindPluginKey);\n        const nodeAndText = getHorizontalSpaceBetweenNodeAndText(board, element);\n        return nodeAndText - options.emojiPadding;\n    },\n    getEmojiTopSpace(board: PlaitMindBoard, element: MindElement) {\n        const nodeAndText = getVerticalSpaceBetweenNodeAndText(board, element);\n        return nodeAndText;\n    }\n};\n\nexport const getFontSizeBySlateElement = (text: string | Element) => {\n    const defaultFontSize = DEFAULT_FONT_SIZE;\n    if (typeof text === 'string') {\n        return defaultFontSize;\n    }\n    const marks = PlaitMarkEditor.getMarksByElement(text);\n    const fontSize = (marks[MarkTypes.fontSize] as number) || defaultFontSize;\n    return fontSize;\n};\n\nexport const normalizeWidthAndHeight = (board: PlaitMindBoard, element: MindElement, width: number, height: number) => {\n    const minWidth = NodeSpace.getNodeTopicMinWidth(board, element);\n    const newWidth = width < minWidth ? minWidth : width;\n    return { width: newWidth, height };\n};\n", "import { PlaitBoard, Point, RectangleClient, distanceBetweenPointAndRectangle } from '@plait/core';\nimport { MindNode } from '../../interfaces/node';\nimport { MindElement } from '../../interfaces/element';\nimport { NodeSpace } from '../space/node-space';\nimport { PlaitMindBoard } from '../../plugins/with-mind.board';\n\nexport function getRectangleByNode(node: MindNode): RectangleClient {\n    const x = node.x + node.hGap;\n    let y = node.y + node.vGap;\n    const width = node.width - node.hGap * 2;\n    const height = node.height - node.vGap * 2;\n    return {\n        x,\n        y,\n        width,\n        height\n    };\n}\n\nexport function getRectangleByElement(board: PlaitMindBoard, element: MindElement) {\n    const width = NodeSpace.getNodeWidth(board, element);\n    const height = NodeSpace.getNodeHeight(board, element);\n    const nodeRectangle = {\n        x: element.points![0][0],\n        y: element.points![0][1],\n        width,\n        height\n    };\n    return nodeRectangle;\n}\n\nexport function isHitMindElement(board: PlaitBoard, point: Point, element: MindElement) {\n    const node = MindElement.getNode(element);\n    if (node && distanceBetweenPointAndRectangle(point[0], point[1], getRectangleByNode(node)) === 0) {\n        return true;\n    } else {\n        return false;\n    }\n}\n", "import { PlaitBoard, Point, RectangleClient } from '@plait/core';\nimport { MindElement } from '../../interfaces/element';\nimport { EmojiData } from '../../interfaces/element-data';\nimport { getRectangleByNode } from './node';\nimport { NodeSpace } from '../space/node-space';\nimport { getEmojisWidthHeight } from '../space/emoji';\nimport { PlaitMindBoard } from '../../plugins/with-mind.board';\n\nexport function getEmojiRectangle(board: PlaitMindBoard, element: MindElement<EmojiData>): RectangleClient {\n    let { x, y } = getRectangleByNode(MindElement.getNode(element));\n    x = x + NodeSpace.getEmojiLeftSpace(board, element);\n    const { width, height } = getEmojisWidthHeight(board, element);\n    return {\n        x,\n        y,\n        width,\n        height\n    };\n}\n\nexport function getEmojiForeignRectangle(board: PlaitMindBoard, element: MindElement<EmojiData>): RectangleClient {\n    let { x, y } = getRectangleByNode(MindElement.getNode(element));\n    x = x + NodeSpace.getEmojiLeftSpace(board, element);\n    const { width } = getEmojisWidthHeight(board, element);\n    return {\n        x,\n        y,\n        width,\n        height: NodeSpace.getNodeHeight(board, element)\n    };\n}\n\nexport const isHitEmojis = (board: PlaitBoard, element: MindElement<EmojiData>, point: Point) => {\n    return RectangleClient.isHit(RectangleClient.getRectangleByPoints([point, point]), getEmojiRectangle(board as PlaitMindBoard, element));\n};\n", "import { MindElement } from '../../interfaces/element';\nimport { MindNode } from '../../interfaces/node';\nimport { PlaitMindBoard } from '../../plugins/with-mind.board';\nimport { NodeSpace } from '../space/node-space';\nimport { getRectangleByNode } from './node';\nimport { RectangleClient } from '@plait/core';\n\nexport function getTopicRectangleByNode(board: PlaitMindBoard, node: MindNode) {\n    let nodeRectangle = getRectangleByNode(node);\n    const result = getTopicRectangleByElement(board, nodeRectangle, node.origin);\n    return result;\n}\n\nexport function getTopicRectangleByElement(board: PlaitMindBoard, nodeRectangle: RectangleClient, element: MindElement) {\n    const x = nodeRectangle.x + NodeSpace.getTextLeftSpace(board, element);\n    const y = nodeRectangle.y + NodeSpace.getTextTopSpace(board, element);\n    const width = NodeSpace.getTopicDynamicWidth(board, element);\n    const height = NodeSpace.getTopicHeight(board, element);\n    return { height, width, x, y };\n}\n", "import { PlaitBoard, Point, RectangleClient } from '@plait/core';\nimport { MindElement } from '../../interfaces/element';\nimport { ImageData } from '../../interfaces/element-data';\nimport { getRectangleByNode } from './node';\nimport { NodeSpace } from '../space/node-space';\nimport { PlaitMindBoard } from '../../plugins/with-mind.board';\nimport { RESIZE_HANDLE_DIAMETER, getRectangleResizeHandleRefs } from '@plait/common';\n\nexport function getImageForeignRectangle(board: PlaitMindBoard, element: MindElement<ImageData>): RectangleClient {\n    let { x, y } = getRectangleByNode(MindElement.getNode(element));\n    const elementWidth = element.manualWidth || element.width;\n\n    x =\n        elementWidth > element.data.image.width\n            ? x + NodeSpace.getTextLeftSpace(board, element) + (elementWidth - element.data.image.width) / 2\n            : x + NodeSpace.getTextLeftSpace(board, element);\n    y = NodeSpace.getImageTopSpace(board, element) + y;\n    const { width, height } = element.data.image!;\n    const rectangle = {\n        x,\n        y,\n        width,\n        height\n    };\n    return rectangle;\n}\n\nexport const isHitImage = (board: PlaitBoard, element: MindElement<ImageData>, point: Point) => {\n    const imageRectangle = getImageForeignRectangle(board as PlaitMindBoard, element);\n    const imageOutlineRectangle = RectangleClient.getOutlineRectangle(imageRectangle, -RESIZE_HANDLE_DIAMETER / 2);\n    return RectangleClient.isPointInRectangle(imageOutlineRectangle, point);\n};\n\nexport const getHitImageResizeHandleDirection = (board: PlaitBoard, element: MindElement<ImageData>, point: Point) => {\n    const imageRectangle = getImageForeignRectangle(board as PlaitMindBoard, element);\n    const resizeHandleRefs = getRectangleResizeHandleRefs(imageRectangle, RESIZE_HANDLE_DIAMETER);\n    const result = resizeHandleRefs.find(resizeHandleRef => {\n        return RectangleClient.isHit(RectangleClient.getRectangleByPoints([point, point]), resizeHandleRef.rectangle);\n    });\n    return result;\n};\n", "import { PlaitBoard } from '@plait/core';\nimport { MindElement } from '../../interfaces/element';\nimport { Node } from 'slate';\nimport { MindLayoutType } from '@plait/layouts';\nimport { PlaitMindBoard } from '../../plugins/with-mind.board';\n\nexport const adjustRootToNode = (board: PlaitBoard, node: MindElement) => {\n    const newNode: MindElement = { ...node };\n    delete newNode.isRoot;\n    delete newNode.rightNodeCount;\n    delete newNode.type;\n    if (newNode.layout === MindLayoutType.standard) {\n        delete newNode.layout;\n    }\n    return newNode;\n};\n\nexport const adjustAbstractToNode = (node: MindElement) => {\n    const newNode: MindElement = { ...node };\n    delete newNode.start;\n    delete newNode.end;\n\n    return newNode;\n};\n\nexport const adjustNodeToRoot = (board: PlaitMindBoard, node: MindElement): MindElement => {\n    const newElement = { ...node };\n    if (!Node.string(newElement.data.topic)) {\n        newElement.data.topic = { children: [{ text: '思维导图' }] };\n    }\n    delete newElement?.strokeColor;\n    delete newElement?.fill;\n    delete newElement?.shape;\n    delete newElement?.strokeWidth;\n    delete newElement?.isCollapsed;\n    return {\n        ...newElement,\n        layout: newElement.layout ?? MindLayoutType.right,\n        isRoot: true,\n        type: 'mindmap'\n    };\n};\n", "import { PlaitBoard, PlaitElement } from '@plait/core';\nimport { MindElement } from '../../interfaces/element';\nimport { ImageData } from '../../interfaces/element-data';\nimport { ImageGenerator, PlaitCommonElementRef, addElementOfFocusedImage, removeElementOfFocusedImage } from '@plait/common';\n\nexport const addImageFocus = (board: PlaitBoard, element: MindElement<ImageData>) => {\n    addElementOfFocusedImage(board, element);\n    const commonElementRef = PlaitElement.getElementRef<PlaitCommonElementRef>(element);\n    const imageGenerator = commonElementRef.getGenerator<ImageGenerator>(ImageGenerator.key);\n    imageGenerator.setFocus(element, true);\n};\n\nexport const removeImageFocus = (board: PlaitBoard, element: MindElement<ImageData>) => {\n    removeElementOfFocusedImage(board);\n    const commonElementRef = PlaitElement.getElementRef<PlaitCommonElementRef>(element);\n    const imageGenerator = commonElementRef.getGenerator<ImageGenerator>(ImageGenerator.key);\n    imageGenerator.setFocus(element, false);\n};\n", "import { PlaitBoard } from '@plait/core';\nimport { MindElement } from '../../interfaces/element';\nimport { getFirstTextManage } from '@plait/common';\n\n/**\n * 1. return new node height if height changed\n * 2. new height is effected by zoom\n */\nexport const getNewNodeHeight = (board: PlaitBoard, element: MindElement, newNodeDynamicWidth: number) => {\n    const textManage = getFirstTextManage(element);\n    const { height } = textManage.getSize(undefined, newNodeDynamicWidth);\n    if (Math.abs(height - element.height) > 2) {\n        return height;\n    }\n    return undefined;\n};\n", "import { getNonAbstractChildren, isStandardLayout } from '@plait/layouts';\nimport { MindElement, PlaitMind } from '../../interfaces/element';\nimport { Path, PlaitBoard, PlaitElement, setDragging } from '@plait/core';\nimport { getRootLayout } from '../layout';\nimport { DetectResult } from '../../interfaces/node';\n\nexport const addActiveOnDragOrigin = (activeElement: MindElement) => {\n    PlaitElement.getElementG(activeElement).classList.add('dragging-node');\n\n    !activeElement.isCollapsed &&\n        activeElement.children.forEach(child => {\n            addActiveOnDragOrigin(child);\n        });\n};\n\nexport const removeActiveOnDragOrigin = (activeElement: MindElement) => {\n    PlaitElement.getElementG(activeElement).classList.remove('dragging-node');\n    !activeElement.isCollapsed &&\n        activeElement.children.forEach(child => {\n            removeActiveOnDragOrigin(child);\n        });\n};\n\nexport const setMindDragging = (board: PlaitBoard, state: boolean) => {\n    setDragging(board, state);\n    if (state) {\n        PlaitBoard.getBoardContainer(board).classList.add('mind-node-dragging');\n    } else {\n        PlaitBoard.getBoardContainer(board).classList.remove('mind-node-dragging');\n    }\n};\n\nexport const hasPreviousOrNextOfDropPath = (\n    parent: MindElement,\n    dropTarget: {\n        target: MindElement;\n        detectResult: DetectResult;\n    },\n    dropPath: Path\n) => {\n    let children = getNonAbstractChildren(parent);\n\n    if (PlaitMind.isMind(parent) && isStandardLayout(getRootLayout(parent))) {\n        const isDropRight = isDropStandardRight(parent, dropTarget);\n\n        if (isDropRight) {\n            children = children.slice(0, parent.rightNodeCount!);\n        }\n        if (!isDropRight) {\n            children = children.slice(parent.rightNodeCount!, children.length);\n            dropPath = [...dropPath, dropPath[dropPath.length - 1] - parent.rightNodeCount!];\n        }\n    }\n\n    let hasPreviousNode = dropPath[dropPath.length - 1] !== 0;\n    let hasNextNode = dropPath[dropPath.length - 1] !== (children?.length || 0);\n\n    if (parent.isCollapsed) {\n        hasNextNode = false;\n        hasPreviousNode = false;\n    }\n\n    return {\n        hasPreviousNode,\n        hasNextNode\n    };\n};\n\nexport const isDropStandardRight = (\n    parent: MindElement,\n    dropTarget: {\n        target: MindElement;\n        detectResult: DetectResult;\n    }\n) => {\n    const target = dropTarget.target;\n\n    return (\n        (PlaitMind.isMind(parent) &&\n            isStandardLayout(getRootLayout(parent)) &&\n            parent.children.indexOf(target) !== -1 &&\n            parent.children.indexOf(target) < parent.rightNodeCount!) ||\n        (PlaitMind.isMind(target) && isStandardLayout(getRootLayout(target)) && dropTarget.detectResult === 'right')\n    );\n};\n", "import { MindElement, PlaitMind } from '../../interfaces/element';\nimport { PlaitBoard, Point, depthFirstRecursion, Path, getIsRecursionFunc } from '@plait/core';\nimport { DetectResult, MindNode } from '../../interfaces/node';\nimport { getRectangleByNode } from '../position/node';\nimport { MindQueries } from '../../queries';\nimport { getRootLayout } from '../layout';\nimport {\n    MindLayoutType,\n    getNonAbstractChildren,\n    isHorizontalLogicLayout,\n    isIndentedLayout,\n    isStandardLayout,\n    isTopLayout,\n    isVerticalLogicLayout\n} from '@plait/layouts';\nimport { isBottomLayout, isRightLayout, isLeftLayout, AbstractNode } from '@plait/layouts';\nimport { isChildElement } from '../mind';\n\nexport const directionCorrector = (board: PlaitBoard, node: MindNode, detectResults: DetectResult[]): DetectResult[] | null => {\n    if (!node.origin.isRoot && !AbstractNode.isAbstract(node.origin)) {\n        const parentLayout = MindQueries.getCorrectLayoutByElement(board, node?.parent.origin as MindElement);\n        if (isStandardLayout(parentLayout)) {\n            const idx = node.parent.children.findIndex(x => x === node);\n            const isLeft = idx >= (node.parent.origin.rightNodeCount || 0);\n            return getAllowedDirection(detectResults, [isLeft ? 'right' : 'left']);\n        }\n\n        if (isLeftLayout(parentLayout)) {\n            return getAllowedDirection(detectResults, ['right']);\n        }\n\n        if (isRightLayout(parentLayout)) {\n            return getAllowedDirection(detectResults, ['left']);\n        }\n\n        if (parentLayout === MindLayoutType.upward) {\n            return getAllowedDirection(detectResults, ['bottom']);\n        }\n\n        if (parentLayout === MindLayoutType.downward) {\n            return getAllowedDirection(detectResults, ['top']);\n        }\n    } else {\n        const layout = MindQueries.getCorrectLayoutByElement(board, node?.origin as MindElement);\n        if (isStandardLayout(layout)) {\n            return getAllowedDirection(detectResults, ['top', 'bottom']);\n        }\n\n        if (layout === MindLayoutType.upward) {\n            return getAllowedDirection(detectResults, ['left', 'right', 'bottom']);\n        }\n\n        if (layout === MindLayoutType.downward) {\n            return getAllowedDirection(detectResults, ['left', 'right', 'top']);\n        }\n\n        if (isLeftLayout(layout)) {\n            return getAllowedDirection(detectResults, ['right', 'top', 'bottom']);\n        }\n\n        if (isRightLayout(layout)) {\n            return getAllowedDirection(detectResults, ['left', 'top', 'bottom']);\n        }\n    }\n\n    return null;\n};\n\nexport const getAllowedDirection = (detectResults: DetectResult[], illegalDirections: DetectResult[]): DetectResult[] | null => {\n    const directions = detectResults;\n    illegalDirections.forEach(item => {\n        const bottomDirectionIndex = directions.findIndex(direction => direction === item);\n        if (bottomDirectionIndex !== -1) {\n            directions.splice(bottomDirectionIndex, 1);\n        }\n    });\n    return directions.length ? directions : null;\n};\n\nexport const detectDropTarget = (\n    board: PlaitBoard,\n    detectPoint: Point,\n    dropTarget: { target: MindElement; detectResult: DetectResult } | null,\n    activeElements: MindElement[]\n) => {\n    let detectResult: DetectResult[] | null = null;\n    depthFirstRecursion(\n        (board as unknown) as MindElement,\n        element => {\n            if (!MindElement.isMindElement(board, element) || detectResult) {\n                return;\n            }\n            const node = MindElement.getNode(element);\n            const directions = directionDetector(node, detectPoint);\n            if (directions) {\n                detectResult = directionCorrector(board, node, directions);\n            }\n            dropTarget = null;\n            const isValid = activeElements.every(element => isValidTarget(element, node.origin));\n            if (detectResult && isValid) {\n                dropTarget = { target: node.origin, detectResult: detectResult[0] };\n            }\n        },\n        getIsRecursionFunc(board)\n    );\n    return dropTarget;\n};\n\nexport const directionDetector = (targetNode: MindNode, centerPoint: Point): DetectResult[] | null => {\n    const { x, y, width, height } = getRectangleByNode(targetNode);\n    const yCenter = y + height / 2;\n    const xCenter = x + width / 2;\n\n    const top = targetNode.y;\n    const bottom = targetNode.y + targetNode.height;\n    const left = targetNode.x;\n    const right = targetNode.x + targetNode.width;\n    const direction: DetectResult[] = [];\n\n    // x-axis\n    if (centerPoint[1] > y && centerPoint[1] < y + height) {\n        if (centerPoint[0] > left && centerPoint[0] < xCenter) {\n            direction.push('left');\n        }\n        if (centerPoint[0] > xCenter && centerPoint[0] < right) {\n            direction.push('right');\n        }\n        // Overlapping area, return in both directions\n        if ((centerPoint[0] > x && centerPoint[0] < xCenter) || (centerPoint[0] > xCenter && centerPoint[0] < x + width)) {\n            if (centerPoint[1] < yCenter) {\n                direction.push('top');\n            } else {\n                direction.push('bottom');\n            }\n        }\n        return direction.length ? direction : null;\n    }\n\n    // y-axis\n    if (centerPoint[0] > x && centerPoint[0] < x + width) {\n        if (centerPoint[1] > top && centerPoint[1] < yCenter) {\n            direction.push('top');\n        }\n        if (centerPoint[1] > yCenter && centerPoint[1] < bottom) {\n            direction.push('bottom');\n        }\n        if ((centerPoint[1] > y && centerPoint[1] < y + height) || (centerPoint[1] > yCenter && centerPoint[1] < y + height)) {\n            if (centerPoint[0] < xCenter) {\n                direction.push('left');\n            } else {\n                direction.push('right');\n            }\n        }\n        return direction.length ? direction : null;\n    }\n\n    return null;\n};\n\nexport const isValidTarget = (origin: MindElement, target: MindElement) => {\n    return origin !== target && !isChildElement(origin, target);\n};\n\nexport const getPathByDropTarget = (board: PlaitBoard, dropTarget: { target: MindElement; detectResult: DetectResult }) => {\n    let targetPath = PlaitBoard.findPath(board, dropTarget?.target);\n    const layout = PlaitMind.isMind(dropTarget?.target)\n        ? getRootLayout(dropTarget?.target)\n        : MindQueries.getCorrectLayoutByElement(board, MindElement.getParent(dropTarget?.target));\n    const children = getNonAbstractChildren(dropTarget.target);\n    if (isVerticalLogicLayout(layout)) {\n        if (dropTarget.detectResult === 'top' || dropTarget.detectResult === 'bottom') {\n            targetPath.push(children.length);\n        }\n        if (dropTarget.detectResult === 'right') {\n            targetPath = Path.next(targetPath);\n        }\n    }\n    if (isHorizontalLogicLayout(layout)) {\n        if (dropTarget.detectResult === 'right') {\n            if (PlaitMind.isMind(dropTarget?.target) && isStandardLayout(layout)) {\n                targetPath.push(dropTarget?.target.rightNodeCount!);\n            } else {\n                targetPath.push(children.length);\n            }\n        }\n        if (dropTarget.detectResult === 'left') {\n            targetPath.push(children.length);\n        }\n        if (dropTarget.detectResult === 'bottom') {\n            targetPath = Path.next(targetPath);\n        }\n    }\n    if (isIndentedLayout(layout)) {\n        if (isTopLayout(layout) && dropTarget.detectResult === 'top') {\n            targetPath = Path.next(targetPath);\n        }\n        if (isBottomLayout(layout) && dropTarget.detectResult === 'bottom') {\n            targetPath = Path.next(targetPath);\n        }\n        if (isLeftLayout(layout) && dropTarget.detectResult === 'left') {\n            targetPath.push(children.length);\n        }\n        if (isRightLayout(layout) && dropTarget.detectResult === 'right') {\n            targetPath.push(children.length);\n        }\n    }\n    return targetPath;\n};\n", "import { MindNode } from '../../interfaces/node';\nimport { getRectangleByNode } from '../position/node';\nimport { PlaitBoard, RectangleClient, drawRoundRectangle } from '@plait/core';\nimport { getFillByElement, getStrokeColorByElement, getStrokeStyleByElement, getStrokeWidthByElement } from '../node-style/shape';\nimport { DefaultNodeStyle } from '../../constants/node-style';\nimport { MindElement } from '../../interfaces';\nimport { getStrokeLineDash } from '@plait/common';\n\nexport function drawRoundRectangleByNode(board: PlaitBoard, node: MindNode) {\n    const rectangle = getRectangleByNode(node);\n    return drawRoundRectangleByElement(board, rectangle, node.origin);\n}\n\nexport function drawRoundRectangleByElement(board: PlaitBoard, nodeRectangle: RectangleClient, element: MindElement) {\n    const fill = getFillByElement(board, element);\n    const stroke = getStrokeColorByElement(board, element);\n    const strokeWidth = getStrokeWidthByElement(board, element);\n    const strokeStyle = getStrokeStyleByElement(board, element);\n    const strokeLineDash = getStrokeLineDash(strokeStyle, strokeWidth);\n    const newNodeRectangle = RectangleClient.inflate(nodeRectangle, -strokeWidth);\n    const nodeG = drawRoundRectangle(\n        PlaitBoard.getRoughSVG(board),\n        newNodeRectangle.x,\n        newNodeRectangle.y,\n        newNodeRectangle.x + newNodeRectangle.width,\n        newNodeRectangle.y + newNodeRectangle.height,\n        {\n            stroke,\n            strokeWidth,\n            fill,\n            fillStyle: 'solid',\n            strokeLineDash\n        },\n        false,\n        DefaultNodeStyle.shape.rectangleRadius\n    );\n\n    return nodeG;\n}\n", "export enum HorizontalPlacement {\n    left = 'left',\n    center = 'center',\n    right = 'right'\n}\n\nexport enum VerticalPlacement {\n    top = 'top',\n    middle = 'middle',\n    bottom = 'bottom'\n}\n\nexport type PointPlacement = [HorizontalPlacement, VerticalPlacement];\n", "import { Point, RectangleClient } from '@plait/core';\nimport { MindNode } from '../interfaces/node';\nimport { LayoutDirection } from '../interfaces/layout';\nimport { HorizontalPlacement, PointPlacement, VerticalPlacement } from '../interfaces/types';\nimport { getXDistanceBetweenPoint } from '@plait/common';\n\nexport const getPointByPlacement = (client: RectangleClient, placement: PointPlacement): Point => {\n    let x = client.x;\n    let y = client.y;\n    if (placement[0] === HorizontalPlacement.center) {\n        x = client.x + client.width / 2;\n    }\n    if (placement[0] === HorizontalPlacement.right) {\n        x = client.x + client.width;\n    }\n    if (placement[1] === VerticalPlacement.middle) {\n        y = client.y + client.height / 2;\n    }\n    if (placement[1] === VerticalPlacement.bottom) {\n        y = client.y + client.height;\n    }\n    return [x, y];\n};\n\nexport interface PlacementRef {\n    placement: PointPlacement;\n    client: RectangleClient;\n}\n\nexport const getYDistanceBetweenPoint = (point1: Point, point2: Point, isHorizontalLayout: boolean) => {\n    getXDistanceBetweenPoint(point1, point2, !isHorizontalLayout);\n};\n\nexport const getLayoutDirection = (node: MindNode, isHorizontal: boolean) => {\n    if (isHorizontal) {\n        if (node.left) {\n            return LayoutDirection.left;\n        } else {\n            return LayoutDirection.right;\n        }\n    } else {\n        if (node.up) {\n            return LayoutDirection.top;\n        } else {\n            return LayoutDirection.bottom;\n        }\n    }\n};\n\nexport const transformPlacement = (placement: PointPlacement, direction: LayoutDirection) => {\n    // to left\n    if (direction === LayoutDirection.left) {\n        if (placement[0] === HorizontalPlacement.right) {\n            placement[0] = HorizontalPlacement.left;\n        } else if (placement[0] === HorizontalPlacement.left) {\n            placement[0] = HorizontalPlacement.right;\n        }\n    }\n    // to bottom\n    if (direction === LayoutDirection.bottom || direction === LayoutDirection.top) {\n        let horizontal = HorizontalPlacement.center;\n        let vertical = VerticalPlacement.middle;\n        if (placement[1] === VerticalPlacement.top) {\n            horizontal = HorizontalPlacement.left;\n        }\n        if (placement[1] === VerticalPlacement.bottom) {\n            horizontal = HorizontalPlacement.right;\n        }\n        if (placement[0] === HorizontalPlacement.left) {\n            vertical = VerticalPlacement.top;\n        }\n        if (placement[0] === HorizontalPlacement.right) {\n            vertical = VerticalPlacement.bottom;\n        }\n        placement[0] = horizontal;\n        placement[1] = vertical;\n    }\n    // to up\n    if (direction === LayoutDirection.top) {\n        if (placement[1] === VerticalPlacement.bottom) {\n            placement[1] = VerticalPlacement.top;\n        } else if (placement[1] === VerticalPlacement.top) {\n            placement[1] = VerticalPlacement.bottom;\n        }\n    }\n};\n", "import { pointsOnBezierCurves } from 'points-on-curve';\nimport { MindNode } from '../../../interfaces/node';\nimport { PlaitBoard, Point, drawBezierPath, drawLinearPath } from '@plait/core';\nimport { getShapeByElement, getRectangleByNode, isChildUp, getStrokeStyleByElement } from '../..';\nimport { getBranchColorByMindElement, getBranchShapeByMindElement, getBranchWidthByMindElement } from '../../node-style/branch';\nimport { BranchShape, MindElementShape } from '../../../interfaces/element';\nimport { getStrokeLineDash, StrokeStyle } from '@plait/common';\n\nexport function drawIndentedLink(\n    board: PlaitBoard,\n    parent: MindNode,\n    child: MindNode,\n    needDrawUnderline = true,\n    defaultStrokeColor: string | null = null,\n    defaultStrokeWidth?: number,\n    defaultStrokeStyle?: StrokeStyle\n) {\n    const branchShape = getBranchShapeByMindElement(board, parent.origin);\n    const branchWidth = defaultStrokeWidth || getBranchWidthByMindElement(board, child.origin);\n    const branchColor = defaultStrokeColor || getBranchColorByMindElement(board, child.origin);\n    const strokeStyle = defaultStrokeStyle || getStrokeStyleByElement(board, child.origin);\n\n    const isUnderlineShape = (getShapeByElement(board, child.origin) as MindElementShape) === MindElementShape.underline;\n    let beginX,\n        beginY,\n        endX,\n        endY,\n        beginNode = parent,\n        endNode = child;\n    const beginRectangle = getRectangleByNode(beginNode);\n    const endRectangle = getRectangleByNode(endNode);\n\n    beginX = beginNode.x + beginNode.width / 2;\n    beginY = isChildUp(parent, child) ? beginRectangle.y : beginRectangle.y + beginRectangle.height;\n    endX = parent.left ? endNode.x + endNode.hGap + endRectangle.width : endNode.x + endNode.hGap;\n    endY = isUnderlineShape ? endNode.y + endNode.height - endNode.vGap : endNode.y + endNode.height / 2;\n\n    let plusMinus = isChildUp(parent, child) ? (parent.left ? [-1, -1] : [1, -1]) : parent.left ? [-1, 1] : [1, 1];\n\n    let curve: Point[] = [\n        [beginX, beginY],\n        [beginX, beginY],\n        [beginX, beginY],\n        [beginX, endY - (endNode.hGap * 3 * plusMinus[1]) / 5],\n        [beginX, endY - (endNode.hGap * plusMinus[1]) / 5],\n        [beginX + (endNode.hGap * plusMinus[0]) / 4, endY],\n        [beginX + (endNode.hGap * plusMinus[0] * 3) / 5, endY],\n        isUnderlineShape && needDrawUnderline ? [endX + (endNode.width - endNode.hGap * 2) * plusMinus[0], endY] : [endX, endY],\n        isUnderlineShape && needDrawUnderline ? [endX + (endNode.width - endNode.hGap * 2) * plusMinus[0], endY] : [endX, endY],\n        isUnderlineShape && needDrawUnderline ? [endX + (endNode.width - endNode.hGap * 2) * plusMinus[0], endY] : [endX, endY]\n    ];\n    const strokeLineDash = getStrokeLineDash(strokeStyle, branchWidth);\n    if (branchShape === BranchShape.polyline) {\n        const polylinePoints = [\n            [beginX, beginY],\n            [beginX, endY],\n            [endX, endY],\n            isUnderlineShape && needDrawUnderline ? [endX + (endNode.width - endNode.hGap * 2) * plusMinus[0], endY] : [endX, endY]\n        ];\n\n        return drawLinearPath(polylinePoints as Point[], { stroke: branchColor, strokeWidth: branchWidth, strokeLineDash });\n    }\n\n    const points = pointsOnBezierCurves(curve, 0.001);\n    return drawBezierPath(points as Point[], { stroke: branchColor, strokeWidth: branchWidth, strokeLineDash });\n}\n", "import { pointsOnBezierCurves } from 'points-on-curve';\nimport { MindNode } from '../../../interfaces/node';\nimport { Direction, PlaitBoard, Point, drawLinearPath, setStrokeLinecap } from '@plait/core';\nimport { getRectangleByNode, getShapeByElement, getStrokeStyleByElement } from '../..';\nimport { getLayoutDirection, getPointByPlacement, transformPlacement } from '../../point-placement';\nimport { HorizontalPlacement, PointPlacement, VerticalPlacement } from '../../../interfaces/types';\nimport { getBranchColorByMindElement, getBranchShapeByMindElement, getBranchWidthByMindElement } from '../../node-style/branch';\nimport { BranchShape, MindElementShape } from '../../../interfaces/element';\nimport { getStrokeLineDash, moveXOfPoint, StrokeStyle } from '@plait/common';\n\nexport function drawLogicLink(\n    board: PlaitBoard,\n    parent: MindNode,\n    node: MindNode,\n    isHorizontal: boolean,\n    defaultStrokeColor: string | null = null,\n    defaultStrokeWidth?: number,\n    defaultStrokeStyle?: StrokeStyle\n) {\n    const branchShape = getBranchShapeByMindElement(board, parent.origin);\n    const branchColor = defaultStrokeColor || getBranchColorByMindElement(board, node.origin);\n    const branchWidth = defaultStrokeWidth || getBranchWidthByMindElement(board, node.origin);\n    const strokeStyle = defaultStrokeStyle || getStrokeStyleByElement(board, node.origin);\n    const hasStraightLine = branchShape === BranchShape.polyline ? true : !parent.origin.isRoot;\n    const parentShape = getShapeByElement(board, parent.origin);\n    const shape = getShapeByElement(board, node.origin);\n    const hasUnderlineShape = shape === MindElementShape.underline;\n    const hasUnderlineShapeOfParent = parentShape === MindElementShape.underline;\n    const nodeClient = getRectangleByNode(node);\n    const parentClient = getRectangleByNode(parent);\n    const linkDirection = getLayoutDirection(node, isHorizontal);\n\n    // ① ensure begin placement and end placement\n    // begin placement represent parent connector position and end placement represent child connector\n    const beginPlacement: PointPlacement = [HorizontalPlacement.right, VerticalPlacement.middle];\n    const endPlacement: PointPlacement = [HorizontalPlacement.left, VerticalPlacement.middle];\n\n    transformPlacement(beginPlacement, linkDirection);\n    transformPlacement(endPlacement, linkDirection);\n\n    // underline shape and horizontal\n    if (isHorizontal && hasUnderlineShapeOfParent && !parent.origin.isRoot) {\n        beginPlacement[1] = VerticalPlacement.bottom;\n    }\n    if (isHorizontal && hasUnderlineShape) {\n        endPlacement[1] = VerticalPlacement.bottom;\n    }\n\n    let beginPoint = getPointByPlacement(parentClient, beginPlacement);\n    let endPoint = getPointByPlacement(nodeClient, endPlacement);\n\n    // ② Determine the convex straight line\n    const straightLineDistance = 8;\n    const beginPoint2 = hasStraightLine\n        ? moveXOfPoint(beginPoint, straightLineDistance, linkDirection as unknown as Direction)\n        : beginPoint;\n    let straightLine: Point[] = hasStraightLine ? [beginPoint, beginPoint2, beginPoint2] : [];\n\n    // ③ Determine the curve\n    const beginBufferDistance = (parent.hGap + node.hGap) / 3;\n    const endBufferDistance = -(parent.hGap + node.hGap) / 2.4;\n    let curve: Point[] = [\n        beginPoint2,\n        moveXOfPoint(beginPoint2, beginBufferDistance, linkDirection as unknown as Direction),\n        moveXOfPoint(endPoint, endBufferDistance, linkDirection as unknown as Direction),\n        endPoint\n    ];\n\n    // ④ underline shape and horizontal\n    const underlineEnd = moveXOfPoint(endPoint, nodeClient.width, linkDirection as unknown as Direction);\n    const underline: Point[] = hasUnderlineShape && isHorizontal ? [underlineEnd, underlineEnd, underlineEnd] : [];\n    const points = pointsOnBezierCurves([...straightLine, ...curve, ...underline]);\n    const strokeLineDash = getStrokeLineDash(strokeStyle, branchWidth);\n    let linkG: SVGGElement;\n    if (branchShape === BranchShape.polyline) {\n        const buffer = 8;\n        const movePoint = moveXOfPoint(beginPoint2, buffer, linkDirection as unknown as Direction);\n        const polylinePoints = [\n            ...straightLine,\n            movePoint,\n            isHorizontal ? [movePoint[0], endPoint[1]] : [endPoint[0], movePoint[1]],\n            endPoint,\n            ...underline\n        ];\n        linkG = drawLinearPath(polylinePoints as Point[], { stroke: branchColor, strokeWidth: branchWidth, strokeLineDash });\n    } else {\n        linkG = PlaitBoard.getRoughSVG(board).curve(points as any, { stroke: branchColor, strokeWidth: branchWidth, strokeLineDash });\n    }\n    if (strokeStyle === StrokeStyle.dotted) {\n        setStrokeLinecap(linkG, 'round');\n    }\n    return linkG;\n}\n", "import { PlaitBoard } from '@plait/core';\nimport { drawIndentedLink } from './indented-link';\nimport { drawLogicLink } from './logic-link';\nimport { MindElement } from '../../../interfaces/element';\nimport { MindNode } from '../../../interfaces/node';\nimport { StrokeStyle } from '@plait/common';\n\nexport function drawLink(\n    board: PlaitBoard,\n    parentNode: MindNode,\n    node: MindNode,\n    isHorizontal: boolean,\n    needDrawUnderline?: boolean,\n    defaultStrokeColor?: string,\n    defaultStrokeWidth?: number,\n    defaultStrokeStyle?: StrokeStyle\n) {\n    return MindElement.isIndentedLayout(parentNode.origin)\n        ? drawIndentedLink(board, parentNode, node, needDrawUnderline, defaultStrokeColor, defaultStrokeWidth, defaultStrokeStyle)\n        : drawLogicLink(board, parentNode, node, isHorizontal, defaultStrokeColor, defaultStrokeWidth, defaultStrokeStyle);\n}\n", "import { EmojiData, EmojiItem, MindElement } from '../interfaces';\nimport { PlaitBoard, createForeignObject, createG } from '@plait/core';\nimport { getEmojiFontSize } from '../utils/space/emoji';\nimport { getEmojiForeignRectangle } from '../utils/position/emoji';\nimport { PlaitMindBoard } from '../plugins/with-mind.board';\nimport { EmojiComponentRef, EmojiProps, PlaitMindEmojiBoard } from '../emoji/with-emoji';\n\nexport const FOREIGN_OBJECT_EMOJI_CLASS_NAME = 'foreign-object-emoji';\n\nclass EmojiGenerator {\n    emojiComponentRef: EmojiComponentRef | null = null;\n\n    constructor(private board: PlaitMindEmojiBoard & PlaitBoard) {}\n\n    draw(container: Element | DocumentFragment, emoji: EmojiItem, element: MindElement<EmojiData>) {\n        this.destroy();\n        const props: EmojiProps = {\n            board: this.board,\n            emojiItem: emoji,\n            element,\n            fontSize: getEmojiFontSize(element)\n        };\n        this.emojiComponentRef = this.board.renderEmoji(container, props);\n    }\n\n    destroy() {\n        if (this.emojiComponentRef) {\n            this.emojiComponentRef.destroy();\n            this.emojiComponentRef = null;\n        }\n    }\n}\n\nexport class NodeEmojisGenerator {\n    static key = 'node-emojis-generator';\n\n    emojiGenerators: EmojiGenerator[] = [];\n\n    g?: SVGGElement;\n\n    constructor(private board: PlaitMindBoard) {}\n\n    drawEmojis(element: MindElement) {\n        this.destroy();\n        if (MindElement.hasEmojis(element)) {\n            this.g = createG();\n            this.g.classList.add('emojis');\n            const foreignRectangle = getEmojiForeignRectangle(this.board, element);\n            const foreignObject = createForeignObject(\n                foreignRectangle.x,\n                foreignRectangle.y,\n                foreignRectangle.width,\n                foreignRectangle.height\n            );\n            foreignObject.classList.add(FOREIGN_OBJECT_EMOJI_CLASS_NAME);\n            this.g.append(foreignObject);\n            const container = document.createElement('div');\n            container.classList.add('node-emojis-container');\n            foreignObject.append(container);\n            this.emojiGenerators = element.data.emojis.map(emojiItem => {\n                const drawer = new EmojiGenerator((this.board as unknown) as PlaitBoard & PlaitMindEmojiBoard);\n                drawer.draw(container, emojiItem, element);\n                return drawer;\n            });\n            return this.g;\n        }\n        return undefined;\n    }\n\n    destroy() {\n        if (this.g) {\n            this.g.remove();\n        }\n        this.emojiGenerators.forEach(drawer => drawer.destroy());\n        this.emojiGenerators = [];\n    }\n}\n", "import { drawRoundRectangleByNode } from './node-shape';\nimport { BASE, PRIMARY_COLOR, STROKE_WIDTH } from '../../constants';\nimport { DetectResult, LayoutDirection, MindElement, MindNode, PlaitMind } from '../../interfaces';\nimport { getRectangleByNode } from '../position/node';\nimport { PlaitBoard, Point, drawRoundRectangle, createG, Path, PlaitNode, PlaitElement, updateForeignObject, Direction } from '@plait/core';\nimport { MindQueries } from '../../queries';\nimport { isHorizontalLayout, isIndentedLayout, isStandardLayout, isTopLayout, MindLayoutType } from '@plait/layouts';\nimport { getTopicRectangleByNode } from '../position/topic';\nimport { HorizontalPlacement, PointPlacement, VerticalPlacement } from '../../interfaces/types';\nimport { getLayoutDirection, getPointByPlacement, transformPlacement } from '../point-placement';\nimport { PlaitMindBoard } from '../../plugins/with-mind.board';\nimport { hasPreviousOrNextOfDropPath } from '../dnd/common';\nimport { drawLink } from './node-link/draw-link';\nimport { getEmojiForeignRectangle } from '../position/emoji';\nimport { getImageForeignRectangle } from '../position';\nimport { ImageGenerator, PlaitCommonElementRef, getFirstTextManage, moveXOfPoint, moveYOfPoint } from '@plait/common';\nimport { NodeEmojisGenerator } from '../../generators/node-emojis.generator';\n\nexport const drawFakeDragNode = (board: PlaitBoard, element: MindElement, offsetX: number, offsetY: number) => {\n    const ref = PlaitElement.getElementRef<PlaitCommonElementRef>(element);\n    const mindNode = MindElement.getNode(element);\n    const dragFakeNodeG = createG();\n    dragFakeNodeG.classList.add('dragging', 'fake-node', 'plait-board-attached');\n\n    const fakeDraggingNode: MindNode = {\n        ...mindNode,\n        children: [],\n        x: mindNode.x + offsetX,\n        y: mindNode.y + offsetY\n    };\n    const textRectangle = getTopicRectangleByNode(board as PlaitMindBoard, mindNode);\n    const fakeNodeG = drawRoundRectangleByNode(board, fakeDraggingNode);\n\n    const richtextG = getFirstTextManage(element).g.cloneNode(true) as SVGGElement;\n    updateForeignObject(richtextG, textRectangle.width, textRectangle.height, textRectangle.x + offsetX, textRectangle.y + offsetY);\n\n    dragFakeNodeG?.append(fakeNodeG);\n    dragFakeNodeG?.append(richtextG);\n\n    // draw emojis\n    if (MindElement.hasEmojis(element)) {\n        const nodeEmojisGenerator = ref.getGenerator<NodeEmojisGenerator>(NodeEmojisGenerator.key);\n        const fakeEmojisG = (nodeEmojisGenerator.g as SVGGElement).cloneNode(true) as SVGGElement;\n        const foreignRectangle = getEmojiForeignRectangle(board as PlaitMindBoard, element);\n        updateForeignObject(\n            fakeEmojisG,\n            foreignRectangle.width,\n            foreignRectangle.height,\n            foreignRectangle.x + offsetX,\n            foreignRectangle.y + offsetY\n        );\n        dragFakeNodeG?.append(fakeEmojisG);\n    }\n\n    if (MindElement.hasImage(element)) {\n        const imageGenerator = ref.getGenerator<ImageGenerator>(ImageGenerator.key);\n        const fakeImageG = (imageGenerator.g as SVGGElement).cloneNode(true) as SVGGElement;\n        const foreignRectangle = getImageForeignRectangle(board as PlaitMindBoard, element);\n        updateForeignObject(\n            fakeImageG,\n            foreignRectangle.width,\n            foreignRectangle.height,\n            foreignRectangle.x + offsetX,\n            foreignRectangle.y + offsetY\n        );\n        dragFakeNodeG?.append(fakeImageG);\n    }\n    return dragFakeNodeG;\n};\n\nexport const drawFakeDropNode = (\n    board: PlaitBoard,\n    dropTarget: {\n        target: MindElement;\n        detectResult: DetectResult;\n    },\n    path: Path\n) => {\n    const target = dropTarget.target;\n    const fakeDropNodeG = createG();\n    const parent = PlaitNode.get(board, Path.parent(path)) as MindElement;\n    const layout = MindQueries.getLayoutByElement(parent) as MindLayoutType;\n    const isHorizontal = isHorizontalLayout(layout);\n    const { hasNextNode, hasPreviousNode } = hasPreviousOrNextOfDropPath(parent, dropTarget, path);\n\n    const width = 30;\n    const height = 12;\n    let fakeNode: MindNode, centerPoint: Point, basicNode: MindNode, linkDirection: LayoutDirection;\n\n    if (!hasPreviousNode && !hasNextNode) {\n        const parentNode = MindElement.getNode(parent);\n        const parentRect = getRectangleByNode(parentNode);\n\n        linkDirection = getLayoutDirection(parentNode, isHorizontal);\n        basicNode = parentNode;\n\n        if (PlaitMind.isMind(target) && isStandardLayout(layout)) {\n            if (dropTarget.detectResult === 'left') {\n                linkDirection = LayoutDirection.left;\n                basicNode.left = true;\n            } else {\n                linkDirection = LayoutDirection.right;\n                basicNode.left = false;\n            }\n        }\n\n        const placement: PointPlacement = [HorizontalPlacement.right, VerticalPlacement.middle];\n        transformPlacement(placement, linkDirection);\n        const parentCenterPoint = getPointByPlacement(parentRect, placement);\n\n        if (isIndentedLayout(layout)) {\n            const placement: PointPlacement = [\n                HorizontalPlacement.center,\n                isTopLayout(layout) ? VerticalPlacement.top : VerticalPlacement.bottom\n            ];\n            const parentCenterPoint = getPointByPlacement(parentRect, placement);\n\n            centerPoint = moveXOfPoint(parentCenterPoint, height, linkDirection as unknown as Direction);\n            centerPoint[1] = isTopLayout(layout) ? centerPoint[1] - height : centerPoint[1] + height;\n        } else {\n            centerPoint = moveXOfPoint(parentCenterPoint, width, linkDirection as unknown as Direction);\n        }\n    } else if (!hasPreviousNode && hasNextNode) {\n        const nextElement = PlaitNode.get(board, path) as MindElement;\n        basicNode = MindElement.getNode(nextElement);\n        const nextRect = getRectangleByNode(basicNode);\n        linkDirection = getLayoutDirection(basicNode, isHorizontal);\n\n        const placement: PointPlacement = [HorizontalPlacement.left, VerticalPlacement.top];\n\n        transformPlacement(placement, linkDirection);\n\n        let offset = -height;\n        if (MindElement.isIndentedLayout(parent)) {\n            offset = isTopLayout(layout) ? offset / 2 + basicNode.height - basicNode.vGap : 0;\n        }\n\n        centerPoint = getPointByPlacement(nextRect, placement);\n        centerPoint = moveYOfPoint(centerPoint, offset, linkDirection as unknown as Direction);\n    } else if (hasPreviousNode && !hasNextNode) {\n        const previousElement = PlaitNode.get(board, Path.previous(path)) as MindElement;\n        basicNode = MindElement.getNode(previousElement);\n        const previousRect = getRectangleByNode(basicNode);\n        linkDirection = getLayoutDirection(basicNode, isHorizontal);\n\n        const placement: PointPlacement = [HorizontalPlacement.left, VerticalPlacement.bottom];\n\n        transformPlacement(placement, linkDirection);\n\n        let offset = height;\n        if (MindElement.isIndentedLayout(parent)) {\n            offset = isTopLayout(layout) ? -offset - (basicNode.height - basicNode.vGap) : offset;\n        }\n        centerPoint = getPointByPlacement(previousRect, placement);\n        centerPoint = moveYOfPoint(centerPoint, offset, linkDirection as unknown as Direction);\n    } else {\n        const previousElement = PlaitNode.get(board, Path.previous(path)) as MindElement;\n        basicNode = MindElement.getNode(previousElement);\n        const previousRect = getRectangleByNode(basicNode);\n\n        const nextElement = PlaitNode.get(board, path) as MindElement;\n        const nextNode = MindElement.getNode(nextElement);\n        const nextRect = getRectangleByNode(nextNode);\n\n        const beginPlacement: PointPlacement = [HorizontalPlacement.left, VerticalPlacement.bottom];\n        const endPlacement: PointPlacement = [HorizontalPlacement.left, VerticalPlacement.top];\n        linkDirection = getLayoutDirection(basicNode, isHorizontal);\n\n        transformPlacement(beginPlacement, linkDirection);\n        transformPlacement(endPlacement, linkDirection);\n\n        const previousPoint = getPointByPlacement(previousRect, beginPlacement);\n        const nextPoint = getPointByPlacement(nextRect, endPlacement);\n\n        centerPoint = [(previousPoint[0] + nextPoint[0]) / 2, (previousPoint[1] + nextPoint[1]) / 2];\n    }\n\n    let cornerPoint = centerPoint,\n        oppositePoint = centerPoint;\n\n    const offsetY = isHorizontal ? height : width;\n    const offsetX = isHorizontal ? width : height;\n\n    cornerPoint = moveYOfPoint(cornerPoint, -offsetY / 2, linkDirection! as unknown as Direction);\n\n    oppositePoint = moveYOfPoint(oppositePoint, offsetY / 2, linkDirection! as unknown as Direction);\n    oppositePoint = moveXOfPoint(oppositePoint, offsetX, linkDirection! as unknown as Direction);\n\n    const x = Math.min(cornerPoint[0], oppositePoint[0]);\n    const y = Math.min(cornerPoint[1], oppositePoint[1]);\n\n    fakeNode = {\n        ...basicNode!,\n        x,\n        y,\n        width,\n        height,\n        hGap: MindElement.isIndentedLayout(parent) ? BASE * 4 + (basicNode.origin.strokeWidth || STROKE_WIDTH) : 0,\n        vGap: MindElement.isIndentedLayout(parent) ? BASE : 0\n    };\n\n    const fakeRectangleG = drawRoundRectangle(\n        PlaitBoard.getRoughSVG(board),\n        fakeNode!.x,\n        fakeNode!.y,\n        fakeNode!.x + width,\n        fakeNode!.y + height,\n        {\n            stroke: PRIMARY_COLOR,\n            strokeWidth: 2,\n            fill: PRIMARY_COLOR,\n            fillStyle: 'solid'\n        }\n    );\n\n    const link = drawLink(board, MindElement.getNode(parent), fakeNode, isHorizontal, false, PRIMARY_COLOR, STROKE_WIDTH);\n    fakeDropNodeG?.appendChild(link);\n    fakeDropNodeG?.appendChild(fakeRectangleG);\n\n    return fakeDropNodeG;\n};\n", "import { PlaitOptionsBoard } from '@plait/core';\nimport { MindElement } from '../interfaces/element';\nimport { AbstractNode } from '@plait/layouts';\n\nexport enum AbstractHandlePosition {\n    start = 'start',\n    end = 'end'\n}\n\nexport enum AbstractResizeState {\n    start = 'start',\n    resizing = 'resizing',\n    end = 'end'\n}\n\nexport interface PlaitAbstractBoard extends PlaitOptionsBoard {\n    onAbstractResize?: (state: AbstractResizeState) => void;\n}\n\nexport type AbstractRefs = Map<MindElement, Pick<AbstractNode, 'start' | 'end'>>;\n", "import {\n    createG,\n    Direction,\n    getRectangleByElements,\n    PlaitBoard,\n    RectangleClient,\n    setStrokeLinecap,\n    toActiveRectangleFromViewBoxRectangle\n} from '@plait/core';\nimport { PRIMARY_COLOR } from '../../constants';\nimport { ABSTRACT_HANDLE_COLOR, ABSTRACT_HANDLE_LENGTH, ABSTRACT_INCLUDED_OUTLINE_OFFSET } from '../../constants/abstract-node';\nimport { RoughSVG } from 'roughjs/bin/svg';\nimport { MindElement } from '../../interfaces';\nimport { MindLayoutType, isHorizontalLayout } from '@plait/layouts';\nimport { MindQueries } from '../../queries';\nimport { getLayoutDirection, getPointByPlacement, transformPlacement } from '../point-placement';\nimport { HorizontalPlacement, PointPlacement, VerticalPlacement } from '../../interfaces/types';\nimport { getRectangleByResizingLocation } from '../abstract/resize';\nimport { AbstractHandlePosition } from '../../plugins/with-abstract-resize.board';\nimport { Options } from 'roughjs/bin/core';\nimport { moveXOfPoint } from '@plait/common';\n\nexport function drawAbstractIncludedOutline(\n    board: PlaitBoard,\n    roughSVG: RoughSVG,\n    element: MindElement,\n    activeHandlePosition?: AbstractHandlePosition,\n    resizingLocation?: number\n) {\n    const abstractIncludedG = createG();\n\n    const parentElement = MindElement.getParent(element);\n    const nodeLayout = MindQueries.getCorrectLayoutByElement(board, element) as MindLayoutType;\n    const isHorizontal = isHorizontalLayout(nodeLayout);\n\n    const includedElements = parentElement.children.slice(element.start!, element.end! + 1);\n    const abstractRectangle = getRectangleByElements(board, includedElements, true);\n    const activeAbstractRectangle = toActiveRectangleFromViewBoxRectangle(board, abstractRectangle);\n    let activeAbstractOutlineRectangle = RectangleClient.getOutlineRectangle(activeAbstractRectangle, -ABSTRACT_INCLUDED_OUTLINE_OFFSET);\n\n    if (resizingLocation) {\n        activeAbstractOutlineRectangle = getRectangleByResizingLocation(\n            activeAbstractOutlineRectangle,\n            resizingLocation,\n            activeHandlePosition!,\n            isHorizontal\n        );\n    }\n\n    const rectangle = drawAbstractRoundRectangle(\n        roughSVG,\n        activeAbstractOutlineRectangle.x,\n        activeAbstractOutlineRectangle.y,\n        activeAbstractOutlineRectangle.x + activeAbstractOutlineRectangle.width,\n        activeAbstractOutlineRectangle.y + activeAbstractOutlineRectangle.height,\n        isHorizontal,\n        {\n            stroke: PRIMARY_COLOR,\n            strokeWidth: 1,\n            fillStyle: 'solid'\n        }\n    );\n\n    const startPlacement = [HorizontalPlacement.center, VerticalPlacement.top] as PointPlacement;\n    const endPlacement = [HorizontalPlacement.center, VerticalPlacement.bottom] as PointPlacement;\n\n    const linkDirection = getLayoutDirection(MindElement.getNode(element), isHorizontal);\n\n    transformPlacement(startPlacement, linkDirection);\n    transformPlacement(endPlacement, linkDirection);\n\n    let startCenterPoint = getPointByPlacement(activeAbstractOutlineRectangle, startPlacement);\n    let endCenterPoint = getPointByPlacement(activeAbstractOutlineRectangle, endPlacement);\n\n    const startPoint1 = moveXOfPoint(startCenterPoint, -ABSTRACT_HANDLE_LENGTH / 2, linkDirection as unknown as Direction);\n    const startPoint2 = moveXOfPoint(startCenterPoint, ABSTRACT_HANDLE_LENGTH / 2, linkDirection as unknown as Direction);\n\n    const endPoint1 = moveXOfPoint(endCenterPoint, -ABSTRACT_HANDLE_LENGTH / 2, linkDirection as unknown as Direction);\n    const endPoint2 = moveXOfPoint(endCenterPoint, ABSTRACT_HANDLE_LENGTH / 2, linkDirection as unknown as Direction);\n\n    const startHandle = roughSVG.line(\n        startPoint1[0],\n        startPoint1[1],\n        startPoint2[0],\n        startPoint2[1],\n        getHandleOption(activeHandlePosition === AbstractHandlePosition.start)\n    );\n\n    const endHandle = roughSVG.line(\n        endPoint1[0],\n        endPoint1[1],\n        endPoint2[0],\n        endPoint2[1],\n        getHandleOption(activeHandlePosition === AbstractHandlePosition.end)\n    );\n\n    handleBoardClass(board, activeHandlePosition, isHorizontal);\n\n    setStrokeLinecap(startHandle, 'round');\n    setStrokeLinecap(endHandle, 'round');\n\n    abstractIncludedG.append(startHandle);\n    abstractIncludedG.append(endHandle);\n    abstractIncludedG.append(rectangle);\n\n    return abstractIncludedG;\n}\n\nexport function getHandleOption(isHover: boolean) {\n    return isHover\n        ? {\n              stroke: PRIMARY_COLOR,\n              strokeWidth: 4,\n              fillStyle: 'solid'\n          }\n        : {\n              stroke: ABSTRACT_HANDLE_COLOR,\n              strokeWidth: 3,\n              fillStyle: 'solid'\n          };\n}\n\nfunction handleBoardClass(board: PlaitBoard, activeHandlePosition: AbstractHandlePosition | undefined, isHorizontal: boolean) {\n    if (activeHandlePosition) {\n        if (isHorizontal) {\n            PlaitBoard.getBoardContainer(board).classList.add('abstract-resizing-horizontal');\n        } else {\n            PlaitBoard.getBoardContainer(board).classList.add('abstract-resizing-vertical');\n        }\n    } else {\n        PlaitBoard.getBoardContainer(board).classList.remove('abstract-resizing-horizontal');\n        PlaitBoard.getBoardContainer(board).classList.remove('abstract-resizing-vertical');\n    }\n}\n\nexport function drawAbstractRoundRectangle(\n    rs: RoughSVG,\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    isHorizontal: boolean,\n    options: Options\n) {\n    const width = Math.abs(x1 - x2);\n    const height = Math.abs(y1 - y2);\n\n    const radius = 5;\n    const handleGap = 4;\n    const handleLength = 10;\n\n    const handleSpace = handleLength + handleGap * 2;\n\n    if (isHorizontal) {\n        const handleSideLine = (width - handleSpace - radius * 2) / 2;\n        const sideLine = height - radius * 2;\n        return rs.path(\n            `M${x1 + radius},${y1}\n            l${handleSideLine},0\n            m${handleSpace},0\n            l${handleSideLine},0\n            a${radius},${radius},0,0,1,${radius},${radius}\n            l0,${sideLine}\n            a${radius},${radius},0,0,1,-${radius},${radius}\n            l-${handleSideLine},0\n            m-${handleSpace},0\n            l-${handleSideLine},0\n            a${radius},${radius},0,0,1,-${radius},-${radius}\n            l0,-${sideLine}\n            a${radius},${radius},0,0,1,${radius},-${radius}`,\n            options\n        );\n    } else {\n        const handleSideLine = (height - handleSpace - radius * 2) / 2;\n        const sideLine = width - radius * 2;\n        return rs.path(\n            `M${x1 + radius},${y1}\n            l${sideLine},0\n            a${radius},${radius},0,0,1,${radius},${radius}\n            l0,${handleSideLine}\n            m0,${handleSpace}\n            l0,${handleSideLine}\n            a${radius},${radius},0,0,1,-${radius},${radius}\n            l-${sideLine},0\n            a${radius},${radius},0,0,1,-${radius},-${radius}\n            l0,-${handleSideLine}\n            m0,-${handleSpace}\n            l0,-${handleSideLine}\n            a${radius},${radius},0,0,1,${radius},-${radius}`,\n            options\n        );\n    }\n}\n", "import {\n    ACTIVE_STROKE_WIDTH,\n    PlaitBoard,\n    RectangleClient,\n    SELECTION_RECTANGLE_CLASS_NAME,\n    createG,\n    drawRoundRectangle,\n    toActiveRectangleFromViewBoxRectangle\n} from '@plait/core';\nimport { MindElement, BaseData } from '../interfaces';\nimport { getRectangleByNode } from '../utils/position/node';\nimport { PRIMARY_COLOR } from '../constants/default';\nimport { AbstractNode } from '@plait/layouts';\nimport { drawAbstractIncludedOutline } from '../utils/draw/abstract-outline';\nimport { AbstractHandlePosition } from '../plugins/with-abstract-resize.board';\nimport { DefaultNodeStyle } from '../constants/node-style';\nimport { getStrokeWidthByElement } from '../utils/node-style/shape';\nimport { Generator } from '@plait/common';\n\nexport interface ActiveData {\n    selected: boolean;\n}\n\nexport class NodeActiveGenerator extends Generator<MindElement, ActiveData> {\n    static key = 'mind-node-active';\n\n    abstractOutlineG?: SVGGElement;\n\n    canDraw(element: MindElement<BaseData>, data: ActiveData): boolean {\n        if (data.selected) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    draw(element: MindElement<BaseData>, data: ActiveData): SVGGElement {\n        const activeG = createG();\n        const node = MindElement.getNode(element);\n        const rectangle = getRectangleByNode(node);\n        const activeRectangle1 = toActiveRectangleFromViewBoxRectangle(this.board, rectangle);\n        const strokeWidth = getStrokeWidthByElement(this.board, element);\n        const activeStrokeWidth = ACTIVE_STROKE_WIDTH;\n        const activeRectangleWithInflated = RectangleClient.inflate(activeRectangle1, activeStrokeWidth);\n        const strokeG = drawRoundRectangle(\n            PlaitBoard.getRoughSVG(this.board),\n            activeRectangleWithInflated.x,\n            activeRectangleWithInflated.y,\n            activeRectangleWithInflated.x + activeRectangleWithInflated.width,\n            activeRectangleWithInflated.y + activeRectangleWithInflated.height,\n            { stroke: PRIMARY_COLOR, strokeWidth: activeStrokeWidth, fill: '' },\n            true,\n            DefaultNodeStyle.shape.rectangleRadius + (activeStrokeWidth + strokeWidth) / 2\n        );\n        if (AbstractNode.isAbstract(element)) {\n            this.abstractOutlineG = drawAbstractIncludedOutline(this.board, PlaitBoard.getRoughSVG(this.board), element);\n            activeG.append(this.abstractOutlineG);\n            strokeG.classList.add('abstract-element');\n        }\n        activeG.appendChild(strokeG);\n        activeG.classList.add(SELECTION_RECTANGLE_CLASS_NAME);\n        return activeG;\n    }\n\n    updateAbstractOutline(element: MindElement, activeHandlePosition?: AbstractHandlePosition, resizingLocation?: number) {\n        const abstractOutlineG = drawAbstractIncludedOutline(\n            this.board,\n            PlaitBoard.getRoughSVG(this.board),\n            element,\n            activeHandlePosition,\n            resizingLocation\n        );\n        if (this.abstractOutlineG) {\n            this.abstractOutlineG.replaceWith(abstractOutlineG);\n            this.abstractOutlineG = abstractOutlineG;\n        }\n    }\n}\n", "import { PlaitBoard, PlaitElement, Point, RectangleClient, getRectangleByElements, getSelectedElements } from '@plait/core';\nimport { MindElement } from '../../interfaces';\nimport { AbstractNode, LayoutNode, MindLayoutType, isHorizontalLayout } from '@plait/layouts';\nimport { ABSTRACT_HANDLE_MASK_WIDTH, ABSTRACT_INCLUDED_OUTLINE_OFFSET } from '../../constants/abstract-node';\nimport { MindQueries } from '../../queries';\nimport { getCorrectStartEnd } from '@plait/layouts';\nimport { MindNodeComponent } from '../../mind-node.component';\nimport { AbstractHandlePosition } from '../../plugins/with-abstract-resize.board';\nimport { PlaitCommonElementRef } from '@plait/common';\nimport { NodeActiveGenerator } from '../../generators/node-active.generator';\n\nexport const getRectangleByResizingLocation = (\n    abstractRectangle: RectangleClient,\n    location: number,\n    activeHandlePosition: AbstractHandlePosition,\n    isHorizontal: boolean\n) => {\n    if (isHorizontal) {\n        if (activeHandlePosition === AbstractHandlePosition.start) {\n            return {\n                ...abstractRectangle,\n                y: location,\n                height: abstractRectangle.height + abstractRectangle.y - location\n            };\n        } else {\n            return {\n                ...abstractRectangle,\n                height: location - abstractRectangle.y\n            };\n        }\n    } else {\n        if (activeHandlePosition === AbstractHandlePosition.start) {\n            return {\n                ...abstractRectangle,\n                x: location,\n                width: abstractRectangle.width + abstractRectangle.x - location\n            };\n        } else {\n            return {\n                ...abstractRectangle,\n                width: location - abstractRectangle.x\n            };\n        }\n    }\n};\n\nexport const getLocationScope = (\n    board: PlaitBoard,\n    handlePosition: AbstractHandlePosition,\n    parentChildren: MindElement[],\n    element: MindElement,\n    parent: LayoutNode,\n    isHorizontal: boolean\n) => {\n    const node = (MindElement.getNode(element) as unknown) as LayoutNode;\n    const { start, end } = getCorrectStartEnd(node.origin as AbstractNode, parent);\n\n    const startNode = parentChildren[start];\n    const endNode = parentChildren[end];\n\n    if (handlePosition === AbstractHandlePosition.start) {\n        const abstractNode = parentChildren.filter(child => AbstractNode.isAbstract(child) && child.end < element.start!);\n        let minNode;\n\n        if (abstractNode.length) {\n            const index = abstractNode\n                .map(node => {\n                    const { end } = getCorrectStartEnd(node as AbstractNode, parent);\n                    return end;\n                })\n                .sort((a, b) => b - a)[0];\n            minNode = parentChildren[index + 1];\n        } else {\n            minNode = parentChildren[0];\n        }\n\n        const minNodeRectangle = getRectangleByElements(board, [minNode], true);\n        const endNodeRectangle = getRectangleByElements(board, [endNode], false);\n\n        if (isHorizontal) {\n            return {\n                max: endNodeRectangle.y - ABSTRACT_INCLUDED_OUTLINE_OFFSET,\n                min: minNodeRectangle.y - ABSTRACT_INCLUDED_OUTLINE_OFFSET\n            };\n        } else {\n            return {\n                max: endNodeRectangle.x - ABSTRACT_INCLUDED_OUTLINE_OFFSET,\n                min: minNodeRectangle.x - ABSTRACT_INCLUDED_OUTLINE_OFFSET\n            };\n        }\n    } else {\n        const abstractNode = parentChildren.filter(child => AbstractNode.isAbstract(child) && child.start > element.end!);\n        let maxNode;\n\n        if (abstractNode.length) {\n            const index = abstractNode\n                .map(node => {\n                    const { start } = getCorrectStartEnd(node as AbstractNode, parent);\n                    return start;\n                })\n                .sort((a, b) => a - b)[0];\n            maxNode = parentChildren[index - 1];\n        } else {\n            const children = parentChildren.filter(child => !AbstractNode.isAbstract(child));\n            maxNode = parentChildren[children.length - 1];\n        }\n\n        const maxNodeRectangle = getRectangleByElements(board, [maxNode], true);\n        const startNodeRectangle = getRectangleByElements(board, [startNode], false);\n\n        if (isHorizontal) {\n            return {\n                max: maxNodeRectangle.y + maxNodeRectangle.height + ABSTRACT_INCLUDED_OUTLINE_OFFSET,\n                min: startNodeRectangle.y + startNodeRectangle.height + ABSTRACT_INCLUDED_OUTLINE_OFFSET\n            };\n        } else {\n            return {\n                max: maxNodeRectangle.x + maxNodeRectangle.width + ABSTRACT_INCLUDED_OUTLINE_OFFSET,\n                min: startNodeRectangle.x + startNodeRectangle.width + ABSTRACT_INCLUDED_OUTLINE_OFFSET\n            };\n        }\n    }\n};\n\nexport const getHitAbstractHandle = (board: PlaitBoard, element: MindElement, point: Point) => {\n    const nodeLayout = MindQueries.getCorrectLayoutByElement(board, element) as MindLayoutType;\n    const isHorizontal = isHorizontalLayout(nodeLayout);\n\n    const parentElement = MindElement.getParent(element);\n    const includedElements = parentElement.children.slice(element.start!, element.end! + 1);\n    let abstractRectangle = getRectangleByElements(board, includedElements, true);\n    abstractRectangle = RectangleClient.getOutlineRectangle(abstractRectangle, -ABSTRACT_INCLUDED_OUTLINE_OFFSET);\n\n    const startHandleRec = getAbstractHandleRectangle(abstractRectangle, isHorizontal, AbstractHandlePosition.start);\n    const endHandleRec = getAbstractHandleRectangle(abstractRectangle, isHorizontal, AbstractHandlePosition.end);\n\n    const pointRec = RectangleClient.getRectangleByPoints([point, point]);\n    if (RectangleClient.isHit(pointRec, startHandleRec)) return AbstractHandlePosition.start;\n    if (RectangleClient.isHit(pointRec, endHandleRec)) return AbstractHandlePosition.end;\n    return undefined;\n};\n\nexport const getAbstractHandleRectangle = (rectangle: RectangleClient, isHorizontal: boolean, position: AbstractHandlePosition) => {\n    let result;\n    if (position === AbstractHandlePosition.start) {\n        const location = isHorizontal ? rectangle.y : rectangle.x;\n\n        result = getRectangleByResizingLocation(\n            rectangle,\n            location + ABSTRACT_HANDLE_MASK_WIDTH / 2,\n            AbstractHandlePosition.end,\n            isHorizontal\n        );\n        result = getRectangleByResizingLocation(result, location - ABSTRACT_HANDLE_MASK_WIDTH / 2, position, isHorizontal);\n    } else {\n        const location = isHorizontal ? rectangle.y + rectangle.height : rectangle.x + rectangle.width;\n\n        result = getRectangleByResizingLocation(\n            rectangle,\n            location - ABSTRACT_HANDLE_MASK_WIDTH / 2,\n            AbstractHandlePosition.start,\n            isHorizontal\n        );\n        result = getRectangleByResizingLocation(result, location + ABSTRACT_HANDLE_MASK_WIDTH / 2, position, isHorizontal);\n    }\n    return result;\n};\n\nexport function findLocationLeftIndex(board: PlaitBoard, parentChildren: MindElement[], location: number, isHorizontal: boolean) {\n    const children = parentChildren.filter(child => {\n        return !AbstractNode.isAbstract(child);\n    });\n    const recArray = children.map(child => {\n        return getRectangleByElements(board, [child], false);\n    });\n\n    const firstRec = getRectangleByElements(board, [children[0]], true);\n    const fakeLeftRec = {\n        x: firstRec.x - firstRec.width,\n        y: firstRec.y - firstRec.height,\n        width: firstRec.width,\n        height: firstRec.height\n    };\n    const lastRec = getRectangleByElements(board, [children[children.length - 1]], true);\n    const fakeRightRec = {\n        x: lastRec.x + lastRec.width,\n        y: lastRec.y + lastRec.height,\n        width: lastRec.width,\n        height: lastRec.height\n    };\n\n    recArray.push(fakeRightRec);\n    recArray.unshift(fakeLeftRec);\n\n    for (let i = 0; i < recArray.length - 1; i++) {\n        const recXOrY = isHorizontal ? recArray[i].y : recArray[i].x;\n        const recWidthOrHeight = isHorizontal ? recArray[i].height : recArray[i].width;\n\n        if (\n            location >= recXOrY + recWidthOrHeight / 2 &&\n            location <= recArray[i + 1][isHorizontal ? 'y' : 'x'] + recArray[i + 1][isHorizontal ? 'height' : 'width'] / 2\n        ) {\n            return i - 1;\n        }\n    }\n    return 0;\n}\n\nexport function handleTouchedAbstract(board: PlaitBoard, touchedAbstract: MindElement | undefined, endPoint: Point) {\n    let touchedHandle;\n    const abstract = (getSelectedElements(board).filter(element => AbstractNode.isAbstract(element)) as MindElement[]).find(element => {\n        touchedHandle = getHitAbstractHandle(board, element as MindElement, endPoint);\n        return touchedHandle;\n    });\n\n    if (touchedAbstract === abstract) {\n        return touchedAbstract;\n    }\n\n    if (touchedAbstract) {\n        const ref = PlaitElement.getElementRef<PlaitCommonElementRef>(touchedAbstract);\n        const activeGenerator = ref.getGenerator<NodeActiveGenerator>(NodeActiveGenerator.key);\n        activeGenerator.updateAbstractOutline(touchedAbstract);\n        touchedAbstract = undefined;\n    }\n\n    if (abstract) {\n        touchedAbstract = abstract;\n        const ref = PlaitElement.getElementRef<PlaitCommonElementRef>(touchedAbstract);\n        const activeGenerator = ref.getGenerator<NodeActiveGenerator>(NodeActiveGenerator.key);\n        activeGenerator.updateAbstractOutline(touchedAbstract, touchedHandle);\n    }\n\n    return touchedAbstract;\n}\n", "import { Path, PlaitBoard, PlaitNode } from '@plait/core';\nimport { MindElement } from '../../interfaces/element';\nimport { getRootLayout } from '../layout';\nimport { MindLayoutType } from '@plait/layouts';\n\nexport const isInRightBranchOfStandardLayout = (selectedElement: MindElement) => {\n    const parentElement = MindElement.findParent(selectedElement);\n    if (parentElement) {\n        const nodeIndex: number = parentElement.children.findIndex(item => item.id === selectedElement.id);\n        if (\n            parentElement.isRoot &&\n            getRootLayout(parentElement) === MindLayoutType.standard &&\n            parentElement.rightNodeCount &&\n            nodeIndex <= parentElement.rightNodeCount - 1\n        ) {\n            return true;\n        }\n    }\n    return false;\n};\n\nexport interface RightNodeCountRef {\n    path: Path;\n    rightNodeCount: number;\n}\n\nexport const insertElementHandleRightNodeCount = (\n    board: PlaitBoard,\n    path: Path,\n    insertCount: number,\n    effectedRightNodeCount: RightNodeCountRef[] = []\n) => {\n    let index = effectedRightNodeCount.findIndex(ref => Path.equals(ref.path, path));\n    const mind = PlaitNode.get(board, path) as MindElement;\n    if (index === -1) {\n        effectedRightNodeCount.push({ path, rightNodeCount: mind.rightNodeCount! + insertCount });\n    } else {\n        effectedRightNodeCount[index].rightNodeCount += insertCount;\n    }\n    return effectedRightNodeCount;\n};\n\nexport const deleteElementsHandleRightNodeCount = (\n    board: PlaitBoard,\n    deletableElements: MindElement[],\n    effectedRightNodeCount: RightNodeCountRef[] = []\n) => {\n    deletableElements.forEach(element => {\n        if (isInRightBranchOfStandardLayout(element)) {\n            const mind = MindElement.getParent(element);\n            const path = PlaitBoard.findPath(board, mind);\n            let index = effectedRightNodeCount.findIndex(ref => Path.equals(ref.path, path));\n            if (index === -1) {\n                effectedRightNodeCount.push({ path, rightNodeCount: mind.rightNodeCount! - 1 });\n            } else {\n                effectedRightNodeCount[index].rightNodeCount -= 1;\n            }\n        }\n    });\n    return effectedRightNodeCount;\n};\n", "import { PlaitBoard, PlaitElement } from '@plait/core';\nimport { getNonAbstractChildren } from '@plait/layouts';\nimport { Path } from 'slate';\n\nexport function findNewChildNodePath(board: PlaitBoard, element: PlaitElement) {\n    const children = getNonAbstractChildren(element);\n    return PlaitBoard.findPath(board, element).concat(children.length);\n}\n\nexport function findNewSiblingNodePath(board: PlaitBoard, element: PlaitElement) {\n    const path = PlaitBoard.findPath(board, element);\n    return Path.next(path);\n}\n", "import { PlaitBoard } from '@plait/core';\nimport { MindElement, PlaitMind } from '../interfaces';\nimport { correctLayoutByDirection, getInCorrectLayoutDirection, getRootLayout } from '../utils';\nimport { AbstractNode, MindLayoutType, getAbstractLayout } from '@plait/layouts';\n\n/**\n * get correctly layout：\n * 1. root is standard -> left or right\n * 2. correct layout by incorrect layout direction\n * @param element\n */\nexport const getCorrectLayoutByElement = (board: PlaitBoard, element: MindElement) => {\n    const ancestors = MindElement.getAncestors(board, element) as MindElement[];\n    ancestors.unshift(element);\n    const root = ancestors[ancestors.length - 1];\n    let rootLayout = getRootLayout(root);\n\n    if (PlaitMind.isMind(element)) {\n        return rootLayout;\n    }\n\n    const node = MindElement.getNode(element);\n    let correctRootLayout = rootLayout;\n    if (rootLayout === MindLayoutType.standard) {\n        correctRootLayout = node.left ? MindLayoutType.left : MindLayoutType.right;\n    }\n\n    let layout = null;\n    const elementWithLayout = ancestors.find(value => value.layout || AbstractNode.isAbstract(value));\n    if (elementWithLayout) {\n        if (AbstractNode.isAbstract(elementWithLayout)) {\n            const parent = MindElement.getParent(elementWithLayout);\n            const parentLayout = getCorrectLayoutByElement(board, parent);\n            layout = getAbstractLayout(parentLayout);\n        } else {\n            layout = elementWithLayout?.layout;\n        }\n    }\n\n    if (layout === MindLayoutType.standard || !layout) {\n        return correctRootLayout;\n    } else {\n        const incorrectDirection = getInCorrectLayoutDirection(correctRootLayout, layout);\n        if (incorrectDirection) {\n            return correctLayoutByDirection(layout, incorrectDirection);\n        } else {\n            return layout;\n        }\n    }\n};\n", "import { MindElement } from '../interfaces';\nimport { MindLayoutType } from '@plait/layouts';\nimport { getCorrectLayoutByElement } from './get-correct-layout-by-element';\nimport { PlaitBoard } from '@plait/core';\n\nexport const getBranchLayouts = (board: PlaitBoard, element: MindElement) => {\n    const layouts: MindLayoutType[] = [];\n    if (element.layout) {\n        // TODO: getCorrectLayoutByElement Contains recursive operations. getBranchLayouts itself also has recursive operations and needs to be optimized.\n        layouts.unshift(getCorrectLayoutByElement(board, element));\n    }\n    let parent = MindElement.findParent(element);\n    while (parent) {\n        if (parent.layout) {\n            layouts.unshift(parent.layout);\n        }\n        parent = MindElement.findParent(parent);\n    }\n    return layouts;\n};\n", "import { MindElement } from '../interfaces';\nimport { getAvailableSubLayoutsByLayoutDirections, getBranchDirectionsByLayouts } from '../utils';\nimport { MindLayoutType } from '@plait/layouts';\nimport { getBranchLayouts } from './get-branch-layouts';\nimport { PlaitBoard } from '@plait/core';\n\nexport const getAvailableSubLayoutsByElement = (board: PlaitBoard, element: MindElement) => {\n    const parentElement = MindElement.findParent(element);\n    if (parentElement) {\n        const branchLayouts = getBranchLayouts(board, parentElement);\n        if (branchLayouts[0] === MindLayoutType.standard) {\n            const node = MindElement.getNode(element);\n            branchLayouts[0] = node.left ? MindLayoutType.left : MindLayoutType.right;\n        }\n        const currentLayoutDirections = getBranchDirectionsByLayouts(branchLayouts);\n        let availableSubLayouts = getAvailableSubLayoutsByLayoutDirections(currentLayoutDirections);\n        const parentLayout = [branchLayouts[branchLayouts.length - 1]];\n        const parentDirections = getBranchDirectionsByLayouts(parentLayout);\n        const parentAvailableSubLayouts = getAvailableSubLayoutsByLayoutDirections(parentDirections);\n\n        availableSubLayouts = availableSubLayouts.filter(layout =>\n            parentAvailableSubLayouts.some(parentAvailableSubLayout => parentAvailableSubLayout === layout)\n        );\n        return availableSubLayouts;\n    }\n    return undefined;\n};\n", "import { MindElement, PlaitMind } from '../interfaces';\nimport { AbstractNode, MindLayoutType, getAbstractLayout } from '@plait/layouts';\nimport { getDefaultLayout } from '../utils/layout';\n\nexport const getLayoutByElement = (element: MindElement): MindLayoutType => {\n    const layout = element.layout;\n    if (layout) {\n        return layout;\n    }\n\n    const parent = !PlaitMind.isMind(element) && MindElement.getParent(element);\n\n    if (AbstractNode.isAbstract(element) && parent) {\n        return getAbstractLayout(getLayoutByElement(parent));\n    }\n\n    if (parent) {\n        return getLayoutByElement(parent);\n    }\n\n    return getDefaultLayout();\n};\n", "import { getAvailableSubLayoutsByElement } from './get-available-sublayouts-by-element';\nimport { getBranchLayouts } from './get-branch-layouts';\nimport { getCorrectLayoutByElement } from './get-correct-layout-by-element';\nimport { getLayoutByElement } from './get-layout-by-element';\n\nexport const MindQueries = {\n    getAvailableSubLayoutsByElement,\n    getBranchLayouts,\n    getLayoutByElement,\n    getCorrectLayoutByElement\n};\n", "import { isIndentedLayout, MindLayoutType } from '@plait/layouts';\nimport { isNullOrUndefined, NODE_TO_PARENT, Path, PlaitBoard, PlaitElement, PlaitNode, Point } from '@plait/core';\nimport { MindQueries } from '../queries';\nimport { ELEMENT_TO_NODE } from '../utils';\nimport { BaseData, EmojiData, ImageData } from './element-data';\nimport { StrokeStyle } from '@plait/common';\n\nexport interface MindElement<T = BaseData> extends PlaitElement {\n    data: T;\n    children: MindElement[];\n    rightNodeCount?: number;\n    width: number;\n    manualWidth?: number;\n    height: number;\n    isRoot?: boolean;\n\n    // node style attributes\n    fill?: string;\n    strokeColor?: string;\n    strokeWidth?: number;\n    strokeStyle?: StrokeStyle;\n    shape?: MindElementShape;\n\n    // link style attributes\n    branchColor?: string;\n    branchWidth?: number;\n    branchShape?: BranchShape;\n\n    // layout\n    layout?: MindLayoutType;\n    isCollapsed?: boolean;\n\n    start?: number;\n    end?: number;\n}\n\nexport interface PlaitMind extends MindElement {\n    type: 'mindmap';\n    points: Point[];\n}\n\nexport const PlaitMind = {\n    isMind: (value: any): value is PlaitMind => {\n        return value.type === 'mindmap';\n    }\n};\n\nexport const MindElement = {\n    hasLayout(value: MindElement, layout: MindLayoutType) {\n        const _layout = MindQueries.getLayoutByElement(value);\n        return _layout === layout;\n    },\n    isIndentedLayout(value: MindElement) {\n        const _layout = MindQueries.getLayoutByElement(value) as MindLayoutType;\n        return isIndentedLayout(_layout);\n    },\n    isMindElement(board: PlaitBoard, element: PlaitElement): element is MindElement {\n        // Design error: The type of the element should be identified based on type.\n        // Now it is very awkward whether it is dynamically calculated(query root node) or using other characteristic attributes(current).\n        // Using dynamically calculated will cause more issue like pasting from clipboard, finding elements by id(isRecursion)\n        if (element.data && element.data.topic && !isNullOrUndefined(element.width) && !isNullOrUndefined(element.height)) {\n            return true;\n        } else {\n            return false;\n        }\n    },\n    getParent(node: MindElement) {\n        if (PlaitMind.isMind(node)) {\n            throw new Error('mind root node can not get parent');\n        }\n        const parent = NODE_TO_PARENT.get(node) as MindElement;\n        return parent;\n    },\n    findParent(node: MindElement) {\n        if (PlaitMind.isMind(node)) {\n            return undefined;\n        }\n        const parent = NODE_TO_PARENT.get(node) as MindElement;\n        return parent;\n    },\n    getRoot(board: PlaitBoard, element: MindElement) {\n        const path = PlaitBoard.findPath(board, element);\n        return PlaitNode.get(board, path.slice(0, 1)) as PlaitMind;\n    },\n    getAncestors(board: PlaitBoard, element: MindElement) {\n        const path = PlaitBoard.findPath(board, element);\n        const parents: PlaitElement[] = [];\n        for (const p of Path.ancestors(path, { reverse: true })) {\n            const n = PlaitNode.get(board, p);\n            if (n && !PlaitBoard.isBoard(n)) {\n                parents.push(n);\n            }\n        }\n        return parents;\n    },\n    getNode(element: MindElement) {\n        const node = ELEMENT_TO_NODE.get(element);\n        if (!node) {\n            throw new Error(`can not get node from ${JSON.stringify(element)}`);\n        }\n        return node;\n    },\n    findParentNode(element: MindElement) {\n        if (PlaitMind.isMind(element)) {\n            return undefined;\n        }\n        const parent = MindElement.getParent(element);\n        return MindElement.getNode(parent);\n    },\n    hasEmojis(element: MindElement): element is MindElement<EmojiData> {\n        if (element.data.emojis) {\n            return true;\n        } else {\n            return false;\n        }\n    },\n    hasImage(element: MindElement): element is MindElement<ImageData> {\n        if (element.data.image) {\n            return true;\n        } else {\n            return false;\n        }\n    },\n    getEmojis(element: MindElement<EmojiData>) {\n        return element.data.emojis;\n    }\n};\n\nexport enum MindElementShape {\n    roundRectangle = 'round-rectangle',\n    underline = 'underline'\n}\n\nexport enum BranchShape {\n    bight = 'bight',\n    polyline = 'polyline'\n}\n", "import { Direction, PlaitBoard, createG, drawLinearPath, getRectangleByElements } from '@plait/core';\nimport { MindNode } from '../../../interfaces/node';\nimport { getRectangleByNode } from '../../position/node';\nimport { HorizontalPlacement, PointPlacement, VerticalPlacement } from '../../../interfaces/types';\nimport { getLayoutDirection, getPointByPlacement, transformPlacement } from '../../point-placement';\nimport { getAbstractBranchColor, getAbstractBranchWidth, getBranchShapeByMindElement } from '../../node-style/branch';\nimport { BranchShape } from '../../../interfaces/element';\nimport { getStrokeStyleByElement } from '../../node-style';\nimport { getStrokeLineDash, getXDistanceBetweenPoint, moveXOfPoint } from '@plait/common';\n\nexport function drawAbstractLink(board: PlaitBoard, node: MindNode, isHorizontal: boolean) {\n    const linkPadding = 15;\n    const branchWidth = getAbstractBranchWidth(board, node.origin);\n    const branchColor = getAbstractBranchColor(board, node.origin);\n    const strokeStyle = getStrokeStyleByElement(board, node.origin);\n    const parent = node.parent;\n    const branchShape = getBranchShapeByMindElement(board, node.origin);\n    const abstractRectangle = getRectangleByNode(node);\n    let includedElements = parent.children.slice(node.origin.start, node.origin.end! + 1).map(node => {\n        return node.origin;\n    });\n    const includedElementsRectangle = getRectangleByElements(board, includedElements, true);\n\n    const linkDirection = getLayoutDirection(node, isHorizontal);\n    const bezierBeginPlacement = [HorizontalPlacement.right, VerticalPlacement.top] as PointPlacement;\n    const bezierEndPlacement = [HorizontalPlacement.right, VerticalPlacement.bottom] as PointPlacement;\n    const abstractConnectorPlacement = [HorizontalPlacement.left, VerticalPlacement.middle] as PointPlacement;\n\n    transformPlacement(bezierBeginPlacement, linkDirection);\n    transformPlacement(bezierEndPlacement, linkDirection);\n    transformPlacement(abstractConnectorPlacement, linkDirection);\n\n    let bezierBeginPoint = getPointByPlacement(includedElementsRectangle, bezierBeginPlacement);\n    let bezierEndPoint = getPointByPlacement(includedElementsRectangle, bezierEndPlacement);\n    let abstractConnectorPoint = getPointByPlacement(abstractRectangle, abstractConnectorPlacement);\n    let curveDistance = getXDistanceBetweenPoint(abstractConnectorPoint, bezierBeginPoint, isHorizontal) - linkPadding * 2;\n    bezierBeginPoint = moveXOfPoint(bezierBeginPoint, linkPadding, linkDirection as unknown as Direction);\n    let c1 = moveXOfPoint(bezierBeginPoint, curveDistance, linkDirection as unknown as Direction);\n    bezierEndPoint = moveXOfPoint(bezierEndPoint, linkPadding, linkDirection as unknown as Direction);\n    let c2 = moveXOfPoint(bezierEndPoint, curveDistance, linkDirection as unknown as Direction);\n    let bezierConnectorPoint = moveXOfPoint(abstractConnectorPoint, -linkPadding, linkDirection as unknown as Direction);\n    const strokeLineDash = getStrokeLineDash(strokeStyle, branchWidth);\n    if (branchShape === BranchShape.polyline) {\n        const g = createG();\n        const polyline = drawLinearPath([bezierBeginPoint, c1, bezierConnectorPoint, c2, bezierEndPoint], {\n            stroke: branchColor,\n            strokeWidth: branchWidth\n        });\n        const straightLine = drawLinearPath([abstractConnectorPoint, bezierConnectorPoint], {\n            stroke: branchColor,\n            strokeWidth: branchWidth,\n            strokeLineDash\n        });\n\n        g.appendChild(polyline);\n        g.appendChild(straightLine);\n\n        return g;\n    }\n\n    const link = PlaitBoard.getRoughSVG(board).path(\n        `M${bezierBeginPoint[0]},${bezierBeginPoint[1]} Q${c1[0]},${c1[1]} ${bezierConnectorPoint[0]},${bezierConnectorPoint[1]} Q${c2[0]},${c2[1]} ${bezierEndPoint[0]},${bezierEndPoint[1]} M${abstractConnectorPoint[0]},${abstractConnectorPoint[1]} L${bezierConnectorPoint[0]},${bezierConnectorPoint[1]}`,\n        {\n            stroke: branchColor,\n            strokeWidth: branchWidth,\n            strokeLineDash\n        }\n    );\n    return link;\n}\n", "import { Path, PlaitBoard, PlaitElement, Transforms, addSelectedElement, clearSelectedElement } from '@plait/core';\nimport { AbstractRefs } from '../plugins/with-abstract-resize.board';\nimport { MindElement, PlaitMind } from '../interfaces/element';\nimport { AbstractNode, isStandardLayout } from '@plait/layouts';\nimport { divideElementByParent, getFirstLevelElement } from '../utils/mind';\nimport { MindQueries } from '../queries';\nimport { DefaultAbstractNodeStyle } from '../constants/node-style';\nimport { createMindElement } from '../utils/node/create-node';\nimport { getAbstractNodeText, getTopicSize } from '../utils/common';\nimport { buildText } from '@plait/common';\n\nexport const setAbstractsByRefs = (board: PlaitBoard, abstractRefs: AbstractRefs) => {\n    abstractRefs.forEach((newProperty, element) => {\n        const start = element.start! + newProperty.start;\n        const end = element.end! + newProperty.end;\n        const path = PlaitBoard.findPath(board, element as MindElement);\n\n        if (start > end) {\n            Transforms.removeNode(board, path);\n        } else {\n            Transforms.setNode(board, { start, end }, path);\n        }\n    });\n};\n\nexport const setAbstractByStandardLayout = (board: PlaitBoard, element: MindElement) => {\n    const rightNodeCount = element.rightNodeCount!;\n    const abstract = element.children.find((child) => {\n        return AbstractNode.isAbstract(child) && child.end >= rightNodeCount && child.start < rightNodeCount;\n    });\n\n    if (abstract) {\n        const path = PlaitBoard.findPath(board, abstract);\n        Transforms.setNode(board, { end: rightNodeCount - 1 }, path);\n    }\n};\n\nexport const insertAbstract = (board: PlaitBoard, elements: PlaitElement[]) => {\n    let elementGroup = getFirstLevelElement(elements as MindElement[]);\n    const { parentElements, abstractIncludedGroups } = divideElementByParent(elementGroup);\n\n    abstractIncludedGroups.forEach((group, index) => {\n        const groupParent = parentElements[index];\n        setAbstractByElements(board, groupParent, group);\n    });\n};\n\nconst setAbstractByElements = (board: PlaitBoard, groupParent: MindElement, group: MindElement[]) => {\n    const indexArray = group.map((child) => groupParent!.children.indexOf(child)).sort((a, b) => a - b);\n    const rightNodeCount = groupParent?.rightNodeCount;\n    const start = indexArray[0],\n        end = indexArray[indexArray.length - 1];\n\n    if (\n        isStandardLayout(MindQueries.getLayoutByElement(groupParent)) &&\n        rightNodeCount &&\n        start < rightNodeCount &&\n        end >= rightNodeCount\n    ) {\n        const childrenLength = groupParent.children.length;\n        const path = [...PlaitBoard.findPath(board, groupParent), childrenLength];\n        const leftChildren = indexArray.filter((index) => index >= rightNodeCount);\n        const rightChildren = indexArray.filter((index) => index < rightNodeCount);\n        insertAbstractNode(board, path, rightChildren[0], rightChildren[rightChildren.length - 1]);\n        insertAbstractNode(board, Path.next(path), leftChildren[0], leftChildren[leftChildren.length - 1]);\n    } else {\n        const path = [...PlaitBoard.findPath(board, groupParent), groupParent.children.length];\n        insertAbstractNode(board, path, start, end);\n    }\n};\n\nconst insertAbstractNode = (board: PlaitBoard, path: Path, start: number, end: number) => {\n    const abstractNodeText = getAbstractNodeText(board);\n    const { width, height } = getTopicSize(board, false, false, buildText(abstractNodeText));\n    const mindElement = createMindElement(abstractNodeText, width, height, {\n        strokeWidth: DefaultAbstractNodeStyle.branch.width,\n        branchWidth: DefaultAbstractNodeStyle.branch.width\n    });\n\n    mindElement.start = start;\n    mindElement.end = end;\n\n    Transforms.insertNode(board, mindElement, path);\n\n    clearSelectedElement(board);\n    addSelectedElement(board, mindElement);\n};\n", "import { Element, Path } from 'slate';\nimport { MindElement, PlaitMind } from '../interfaces/element';\nimport { PlaitBoard, PlaitHistoryBoard, PlaitNode, Transforms, removeSelectedElement } from '@plait/core';\nimport { AbstractRef, getRelativeStartEndByAbstractRef, insertElementHandleAbstract } from '../utils/abstract/common';\nimport { RightNodeCountRef, insertElementHandleRightNodeCount, isInRightBranchOfStandardLayout } from '../utils/node/right-node-count';\nimport { normalizeWidthAndHeight } from '../utils/space/node-space';\nimport { PlaitMindBoard } from '../plugins/with-mind.board';\nimport { findNewChildNodePath, findNewSiblingNodePath, insertMindElement } from '../utils';\nimport { setAbstractsByRefs } from './abstract-node';\nimport { AbstractNode } from '@plait/layouts';\n\nexport const setTopic = (board: PlaitMindBoard, element: MindElement, topic: Element, width: number, height: number) => {\n    const newElement = {\n        data: { ...element.data, topic },\n        ...normalizeWidthAndHeight(board, element, width, height)\n    } as MindElement;\n    const path = PlaitBoard.findPath(board, element);\n    Transforms.setNode(board, newElement, path);\n};\n\nexport const setNodeManualWidth = (board: PlaitMindBoard, element: MindElement, width: number, height: number) => {\n    const path = PlaitBoard.findPath(board, element);\n    const { width: normalizedWidth, height: normalizedHeight } = normalizeWidthAndHeight(board, element, width, height);\n    const newElement = { manualWidth: normalizedWidth, height: normalizedHeight } as MindElement;\n    Transforms.setNode(board, newElement, path);\n};\n\nexport const setTopicSize = (board: PlaitMindBoard, element: MindElement, width: number, height: number) => {\n    const newElement = {\n        ...normalizeWidthAndHeight(board, element, width, height)\n    };\n    let isEqualWidth = Math.ceil(element.width) === Math.ceil(newElement.width);\n    let isEqualHeight = Math.ceil(element.height) === Math.ceil(newElement.height);\n    if (element.manualWidth) {\n        isEqualWidth = true;\n    }\n    if (!isEqualWidth || !isEqualHeight) {\n        const path = PlaitBoard.findPath(board, element);\n        Transforms.setNode(board, newElement, path);\n    }\n};\n\nexport const insertNodes = (board: PlaitBoard, elements: MindElement[], path: Path) => {\n    const pathRef = board.pathRef(path);\n    elements.forEach((element) => {\n        if (pathRef.current) {\n            Transforms.insertNode(board, element, pathRef.current);\n        }\n    });\n    pathRef.unref();\n};\n\nexport const insertAbstractNodes = (board: PlaitBoard, validAbstractRefs: AbstractRef[], elements: MindElement[], path: Path) => {\n    const parent = PlaitNode.get(board, Path.parent(path));\n    const abstractPath = [...Path.parent(path), parent.children?.length!];\n    const abstracts = validAbstractRefs.map((refs) => {\n        const { start, end } = getRelativeStartEndByAbstractRef(refs, elements);\n        return {\n            ...refs.abstract,\n            start: start + path[path.length - 1],\n            end: end + path[path.length - 1]\n        };\n    });\n\n    insertNodes(board, abstracts, abstractPath);\n};\n\nexport const setRightNodeCountByRefs = (board: PlaitBoard, refs: RightNodeCountRef[]) => {\n    refs.forEach((ref) => {\n        Transforms.setNode(board, { rightNodeCount: ref.rightNodeCount }, ref.path);\n    });\n};\n\nexport const insertChildNode = (board: PlaitMindBoard, element: MindElement) => {\n    if (MindElement.isMindElement(board, element)) {\n        removeSelectedElement(board, element);\n        const targetElementPath = PlaitBoard.findPath(board, element);\n        if (element.isCollapsed) {\n            const newElement: Partial<MindElement> = { isCollapsed: false };\n            PlaitHistoryBoard.withoutSaving(board, () => {\n                Transforms.setNode(board, newElement, targetElementPath);\n            });\n        }\n        insertMindElement(board, element, findNewChildNodePath(board, element));\n    }\n};\n\nexport const insertSiblingNode = (board: PlaitMindBoard, element: MindElement) => {\n    if (MindElement.isMindElement(board, element) && !PlaitMind.isMind(element) && !AbstractNode.isAbstract(element)) {\n        const path = PlaitBoard.findPath(board, element);\n        if (isInRightBranchOfStandardLayout(element)) {\n            const refs = insertElementHandleRightNodeCount(board, path.slice(0, 1), 1);\n            setRightNodeCountByRefs(board, refs);\n        }\n        const abstractRefs = insertElementHandleAbstract(board, Path.next(path));\n        setAbstractsByRefs(board, abstractRefs);\n        insertMindElement(board, element, findNewSiblingNodePath(board, element));\n    }\n};\n\nexport const insertMind = (board: PlaitMindBoard, mind: MindElement) => {\n    Transforms.insertNode(board, mind, [board.children.length]);\n    Transforms.addSelectionWithTemporaryElements(board, [mind]);\n};\n", "import { MindElement } from '../interfaces/element';\nimport { PlaitBoard, Transforms } from '@plait/core';\nimport { EmojiData, EmojiItem } from '../interfaces/element-data';\n\nexport const addEmoji = (board: PlaitBoard, element: MindElement, emojiItem: EmojiItem) => {\n    const emojis = element.data.emojis || [];\n    const newEmojis = [...emojis];\n    newEmojis.push(emojiItem);\n    const newElement = {\n        data: { ...element.data, emojis: newEmojis }\n    } as MindElement;\n    const path = PlaitBoard.findPath(board, element);\n    Transforms.setNode(board, newElement, path);\n};\n\nexport const removeEmoji = (board: PlaitBoard, element: MindElement<EmojiData>, emojiItem: EmojiItem) => {\n    const emojis = element.data.emojis.filter(value => value !== emojiItem);\n    const newElement = {\n        data: { topic: element.data.topic }\n    } as MindElement;\n\n    if (MindElement.hasImage(element)) {\n        newElement.data.image = element.data.image;\n    }\n\n    if (emojis.length > 0) {\n        newElement.data.emojis = emojis;\n    }\n    const path = PlaitBoard.findPath(board, element);\n    Transforms.setNode(board, newElement, path);\n};\n\nexport const replaceEmoji = (board: PlaitBoard, element: MindElement<EmojiData>, oldEmoji: EmojiItem, newEmoji: EmojiItem) => {\n    const newElement = {\n        data: { ...element.data }\n    } as MindElement;\n    const newEmojis = element.data.emojis.map(value => {\n        if (value === oldEmoji) {\n            return newEmoji;\n        }\n        return value;\n    });\n    newElement.data.emojis = newEmojis;\n    const path = PlaitBoard.findPath(board, element);\n    Transforms.setNode(board, newElement, path);\n};\n", "import { PlaitBoard, Transforms } from '@plait/core';\nimport { ImageData, MindElement } from '../interfaces';\nimport { removeImageFocus } from '../utils/node/image';\nimport { NodeSpace } from '../utils/space/node-space';\nimport { PlaitMindBoard } from '../plugins/with-mind.board';\nimport { getNewNodeHeight } from '../utils/node/dynamic-width';\nimport { CommonImageItem } from '@plait/common';\n\nexport const removeImage = (board: PlaitBoard, element: MindElement<ImageData>) => {\n    removeImageFocus(board, element);\n    const newElement = {\n        data: { ...element.data }\n    } as MindElement;\n    delete newElement.data.image;\n    const path = PlaitBoard.findPath(board, element);\n    const newDynamicWidth = NodeSpace.getNodeNewDynamicWidth(board as PlaitMindBoard, element, 0);\n    const newHeight = getNewNodeHeight(board as PlaitMindBoard, element, newDynamicWidth);\n    if (newHeight) {\n        newElement.height = newHeight;\n    }\n    Transforms.setNode(board, newElement, path);\n};\n\nexport const setImage = (board: PlaitBoard, element: MindElement, imageItem: CommonImageItem) => {\n    const newElement = {\n        data: { ...element.data, image: imageItem }\n    };\n    const newDynamicWidth = NodeSpace.getNodeNewDynamicWidth(board as PlaitMindBoard, element, imageItem.width);\n    const newHeight = getNewNodeHeight(board as PlaitMindBoard, element, newDynamicWidth);\n    if (newHeight) {\n        (newElement as MindElement).height = newHeight;\n    }\n    const path = PlaitBoard.findPath(board, element);\n    Transforms.setNode(board, newElement, path);\n};\n", "import { PlaitBoard, Path, PlaitNode, Transforms } from '@plait/core';\nimport { isHorizontalLogicLayout, isVerticalLogicLayout, MindLayoutType } from '@plait/layouts';\n\nexport const correctLogicLayoutNode = (board: PlaitBoard, layout: MindLayoutType, path: Path) => {\n    const node = PlaitNode.get(board, path);\n    if (node && layout) {\n        node.children?.forEach((value: PlaitNode, index) => {\n            if (value.layout) {\n                if (\n                    (isHorizontalLogicLayout(layout) && isVerticalLogicLayout(value.layout)) ||\n                    (isVerticalLogicLayout(layout) && isHorizontalLogicLayout(value.layout))\n                ) {\n                    Transforms.setNode(board, { layout: null }, [...path, index]);\n                }\n                if (value.children?.length) {\n                    correctLogicLayoutNode(board, layout, [...path, index]);\n                }\n            }\n        });\n    }\n};\n", "import { Path, PlaitBoard, PlaitNode, Transforms } from '@plait/core';\nimport { MindLayoutType, isStandardLayout } from '@plait/layouts';\nimport { PropertyTransforms } from '@plait/common';\nimport { BranchShape, MindElementShape, MindElement, PlaitMind } from '../interfaces';\nimport { correctLogicLayoutNode } from './layout';\nimport { setAbstractByStandardLayout } from './abstract-node';\n\nexport const setLayout = (board: PlaitBoard, type: MindLayoutType) => {\n    const callback = (element: MindElement, path: Path) => {\n        if (MindElement.isMindElement(board, element)) {\n            correctLogicLayoutNode(board, type, path);\n            const element = PlaitNode.get(board, path) as MindElement;\n            if (PlaitMind.isMind(element) && isStandardLayout(type)) {\n                let properties = { rightNodeCount: element.children.length / 2 };\n                Transforms.setNode(board, properties, path);\n                setAbstractByStandardLayout(board, element);\n            }\n            Transforms.setNode(board, { layout: type }, path);\n        }\n    };\n    PropertyTransforms.setProperty<MindElement>(board, {}, { callback });\n};\n\nexport const setShape = (board: PlaitBoard, shape: MindElementShape) => {\n    PropertyTransforms.setProperty(board, { shape });\n};\n\nexport const setBranchShape = (board: PlaitBoard, branchShape: BranchShape) => {\n    PropertyTransforms.setProperty(board, { branchShape });\n};\n\nexport const setBranchWidth = (board: PlaitBoard, branchWidth: number) => {\n    PropertyTransforms.setProperty(board, { branchWidth });\n};\n\nexport const setBranchColor = (board: PlaitBoard, branchColor: string) => {\n    PropertyTransforms.setProperty(board, { branchColor });\n};\n", "import { insertAbstract, setAbstractsByRefs, setAbstractByStandardLayout } from './abstract-node';\nimport {\n    setTopic,\n    setTopicSize,\n    insertNodes,\n    insertAbstractNodes,\n    setRightNodeCountByRefs,\n    setNodeManualWidth,\n    insertChildNode,\n    insertSiblingNode,\n    insertMind\n} from './node';\nimport { addEmoji, removeEmoji, replaceEmoji } from './emoji';\nimport { removeImage, setImage } from './image';\nimport { setShape, setBranchShape, setBranchWidth, setLayout, setBranchColor } from './property';\n\nexport const MindTransforms = {\n    setLayout,\n    setShape,\n    setBranchShape,\n    setBranchWidth,\n    setBranchColor,\n    setTopic,\n    setTopicSize,\n    setNodeManualWidth,\n    addEmoji,\n    removeEmoji,\n    replaceEmoji,\n    insertAbstract,\n    setAbstractsByRefs,\n    setAbstractByStandardLayout,\n    insertNodes,\n    insertAbstractNodes,\n    setRightNodeCountByRefs,\n    removeImage,\n    setImage,\n    insertChildNode,\n    insertSiblingNode,\n    insertMind\n};\n", "import { Generator } from '@plait/common';\nimport { MindElement, MindElementShape } from '../interfaces/element';\nimport { getRectangleByNode } from '../utils/position/node';\nimport { MindNode } from '../interfaces/node';\nimport { drawRoundRectangleByElement } from '../utils/draw/node-shape';\nimport { getShapeByElement } from '../utils/node-style/shape';\nimport { PlaitBoard } from '@plait/core';\n\nexport interface ShapeData {\n    node: MindNode;\n}\n\nexport class NodeShapeGenerator extends Generator<MindElement, ShapeData> {\n    constructor(board: PlaitBoard) {\n        super(board, { prepend: true });\n    }\n\n    canDraw(element: MindElement, data: ShapeData): boolean {\n        const shape = getShapeByElement(this.board, element);\n        if (shape === MindElementShape.roundRectangle) {\n            return true;\n        }\n        return false;\n    }\n\n    draw(element: MindElement, data: ShapeData) {\n        const rectangle = getRectangleByNode(data.node);\n        return drawRoundRectangleByElement(this.board, rectangle, data.node.origin);\n    }\n}\n", "import {\n    Direction,\n    PlaitBoard,\n    Point,\n    createG,\n    createText,\n    getSelectedElements,\n    isDragging,\n    isMovingElements,\n    isSelectedElement,\n    isSelectionMoving,\n    rgbaToHEX,\n    setStrokeLinecap\n} from '@plait/core';\nimport { MindElement, BaseData, PlaitMind, MindElementShape, LayoutDirection } from '../interfaces';\nimport { getRectangleByNode } from '../utils/position/node';\nimport { getShapeByElement } from '../utils/node-style/shape';\nimport {\n    NODE_MORE_ICON_DIAMETER,\n    NODE_MORE_LINE_DISTANCE,\n    NODE_MORE_STROKE_WIDTH,\n    NODE_ADD_CIRCLE_COLOR,\n    NODE_ADD_INNER_CROSS_COLOR,\n    NODE_ADD_HOVER_COLOR,\n    NODE_MORE_BRIDGE_DISTANCE\n} from '../constants/default';\nimport { MindLayoutType, isHorizontalLayout, isIndentedLayout, isTopLayout } from '@plait/layouts';\nimport { MindQueries } from '../queries';\nimport { getBranchColorByMindElement } from '../utils/node-style/branch';\nimport { getLayoutDirection, getPointByPlacement, transformPlacement } from '../utils/point-placement';\nimport { HorizontalPlacement, PointPlacement, VerticalPlacement } from '../interfaces/types';\nimport { buildText, DEFAULT_FONT_FAMILY, Generator, isResizing, measureElement, moveXOfPoint, TRANSPARENT } from '@plait/common';\nimport { getChildrenCount } from '../utils/mind';\nimport { FontSizes } from '@plait/text-plugins';\n\nexport interface NodeMoreExtraData {\n    isSelected: boolean;\n    isHovered?: boolean;\n    isHoveredCollapseArea?: boolean;\n    isHoveredExpandArea?: boolean;\n    isHoveredAddArea?: boolean;\n    isShowCollapseAnimation?: boolean;\n    isShowAddAnimation?: boolean;\n}\n\nexport class NodeMoreGenerator extends Generator<MindElement, NodeMoreExtraData> {\n    static key = 'mind-node-more';\n\n    collapseOrAddG: SVGGElement | undefined | null;\n\n    expandG: SVGGElement | undefined | null;\n\n    canDraw(element: MindElement<BaseData>, extraData: NodeMoreExtraData): boolean {\n        if (\n            ((extraData?.isHovered || extraData?.isHoveredCollapseArea || extraData?.isHoveredAddArea) && canHandleNodeMore(this.board)) ||\n            (extraData?.isSelected && isLastSelectedMindElement(this.board, element) && canHandleNodeMore(this.board)) ||\n            element.isCollapsed\n        ) {\n            return true;\n        }\n        return false;\n    }\n\n    draw(element: MindElement<BaseData>, extraData: NodeMoreExtraData): SVGGElement {\n        const moreGContainer = createG();\n        const stroke = getBranchColorByMindElement(this.board, element);\n        const layoutDirection = getNodeMoreLayoutDirection(this.board, element);\n        const moreStartAndEnd = getMoreStartAndEnd(this.board, element, layoutDirection);\n        const collapseOrExpandCenter = moveXOfPoint(\n            moreStartAndEnd[1],\n            NODE_MORE_ICON_DIAMETER / 2,\n            layoutDirection as unknown as Direction\n        );\n        const hasChildren = element.children.length > 0;\n        const isShowCollapseOrAdd =\n            !element.isCollapsed &&\n            (isSelectedElement(this.board, element) ||\n                !!extraData?.isHovered ||\n                !!extraData?.isHoveredCollapseArea ||\n                !!extraData?.isHoveredAddArea);\n        const isShowCollapse = isShowCollapseOrAdd && hasChildren && !PlaitMind.isMind(element);\n        const isShowAdd = isShowCollapseOrAdd && !PlaitBoard.isReadonly(this.board);\n        const addCenter =\n            (isShowCollapseOrAdd && getAddCenterByCollapseOrExpandCenter(element, collapseOrExpandCenter, layoutDirection)) || null;\n        this.toggleCollapseOrAdd(\n            collapseOrExpandCenter,\n            addCenter,\n            stroke,\n            moreGContainer,\n            isShowCollapse,\n            isShowAdd,\n            !!extraData?.isHoveredAddArea,\n            !!extraData?.isShowCollapseAnimation,\n            !!extraData?.isShowAddAnimation\n        );\n        this.toggleExpandBadge(\n            element,\n            moreStartAndEnd,\n            collapseOrExpandCenter,\n            stroke,\n            moreGContainer,\n            !!element.isCollapsed,\n            !!extraData?.isHoveredExpandArea\n        );\n        return moreGContainer;\n    }\n\n    toggleCollapseOrAdd(\n        center: Point,\n        addCenter: Point | null,\n        stroke: string,\n        parentG: SVGGElement,\n        isShowCollapse: boolean,\n        isShowAdd: boolean,\n        isHoveredAddArea: boolean,\n        isShowCollapseAnimation: boolean,\n        isShowAddAnimation: boolean\n    ) {\n        this.collapseOrAddG?.remove();\n        if (!isShowCollapse && !isShowAdd) {\n            return;\n        }\n        this.collapseOrAddG = createG();\n        if (isShowCollapse) {\n            const collapseG = createG();\n            this.collapseOrAddG.appendChild(collapseG);\n            collapseG.classList.add('collapse-button');\n            if (isShowCollapseAnimation) {\n                collapseG.classList.add('animated');\n            }\n            const collapseCircle = PlaitBoard.getRoughSVG(this.board).circle(center[0], center[1], NODE_MORE_ICON_DIAMETER, {\n                fill: '#fff',\n                stroke,\n                strokeWidth: NODE_MORE_STROKE_WIDTH,\n                fillStyle: 'solid'\n            });\n            const start = moveXOfPoint(center, -NODE_MORE_BRIDGE_DISTANCE / 2);\n            const end = moveXOfPoint(center, NODE_MORE_BRIDGE_DISTANCE / 2);\n            const collapseLine = PlaitBoard.getRoughSVG(this.board).line(start[0], start[1], end[0], end[1], {\n                fill: '#fff',\n                stroke,\n                strokeWidth: NODE_MORE_STROKE_WIDTH,\n                fillStyle: 'solid'\n            });\n            collapseG.appendChild(collapseCircle);\n            collapseG.appendChild(collapseLine);\n            setStrokeLinecap(collapseLine, 'round');\n        }\n        if (isShowAdd && addCenter) {\n            const addG = createG();\n            this.collapseOrAddG.appendChild(addG);\n            addG.classList.add('add-button');\n            if (isShowAddAnimation) {\n                addG.classList.add('animated');\n            }\n            const circle = PlaitBoard.getRoughSVG(this.board).circle(\n                addCenter[0],\n                addCenter[1],\n                NODE_MORE_ICON_DIAMETER + NODE_MORE_STROKE_WIDTH,\n                {\n                    fill: isHoveredAddArea ? NODE_ADD_HOVER_COLOR : NODE_ADD_CIRCLE_COLOR,\n                    stroke: TRANSPARENT,\n                    fillStyle: 'solid'\n                }\n            );\n            const hLineBeginPoint = [addCenter[0] - NODE_MORE_BRIDGE_DISTANCE / 2, addCenter[1]];\n            const hLineEndPoint = [addCenter[0] + NODE_MORE_BRIDGE_DISTANCE / 2, addCenter[1]];\n            const vLineBeginPoint = [addCenter[0], addCenter[1] - NODE_MORE_BRIDGE_DISTANCE / 2];\n            const vLineEndPoint = [addCenter[0], addCenter[1] + NODE_MORE_BRIDGE_DISTANCE / 2];\n\n            const innerCrossHLine = PlaitBoard.getRoughSVG(this.board).line(\n                hLineBeginPoint[0],\n                hLineBeginPoint[1],\n                hLineEndPoint[0],\n                hLineEndPoint[1],\n                {\n                    stroke: NODE_ADD_INNER_CROSS_COLOR,\n                    strokeWidth: NODE_MORE_STROKE_WIDTH\n                }\n            );\n            setStrokeLinecap(innerCrossHLine, 'round');\n            const innerCrossVLine = PlaitBoard.getRoughSVG(this.board).line(\n                vLineBeginPoint[0],\n                vLineBeginPoint[1],\n                vLineEndPoint[0],\n                vLineEndPoint[1],\n                {\n                    stroke: NODE_ADD_INNER_CROSS_COLOR,\n                    strokeWidth: NODE_MORE_STROKE_WIDTH\n                }\n            );\n            setStrokeLinecap(innerCrossVLine, 'round');\n            addG.appendChild(circle);\n            addG.appendChild(innerCrossHLine);\n            addG.appendChild(innerCrossVLine);\n        }\n        parentG.appendChild(this.collapseOrAddG);\n    }\n\n    toggleExpandBadge(\n        element: MindElement,\n        moreStartAndEnd: [Point, Point],\n        center: Point,\n        stroke: string,\n        parentG: SVGGElement,\n        isCollapsed: boolean,\n        isHoveredExpandIcon: boolean\n    ) {\n        this.expandG?.remove();\n        if (!isCollapsed) {\n            return;\n        }\n        this.expandG = createG();\n        this.expandG.classList.add('expanded-button');\n        const endWithWidth = moreStartAndEnd[1];\n        const moreLine = PlaitBoard.getRoughSVG(this.board).line(\n            moreStartAndEnd[0][0],\n            moreStartAndEnd[0][1],\n            endWithWidth[0],\n            endWithWidth[1],\n            {\n                fill: stroke,\n                stroke,\n                fillStyle: 'solid',\n                strokeWidth: NODE_MORE_STROKE_WIDTH\n            }\n        );\n        const backgroundColor = isHoveredExpandIcon ? rgbaToHEX(stroke, 0.4) : rgbaToHEX(stroke, 0.2);\n        const badgeBackground = PlaitBoard.getRoughSVG(this.board).circle(\n            center[0],\n            center[1],\n            NODE_MORE_ICON_DIAMETER + NODE_MORE_STROKE_WIDTH,\n            {\n                fill: backgroundColor,\n                stroke: TRANSPARENT,\n                fillStyle: 'solid'\n            }\n        );\n        const childrenCount = getChildrenCount(element);\n        let text = `${childrenCount}`;\n        let y = center[1] + 4.5;\n        if (childrenCount >= 99) {\n            text = '...';\n            y = center[1] + 1;\n        }\n        const { width, height } = measureElement(this.board, buildText(text), {\n            fontSize: Number(FontSizes.fontSize12),\n            fontFamily: DEFAULT_FONT_FAMILY\n        });\n        const badgeText = createText(center[0] - width / 2, y, stroke, `${text}`);\n        badgeText.setAttribute('style', `font-size: ${Number(FontSizes.fontSize12)}px;`);\n        this.expandG.appendChild(moreLine);\n        this.expandG.appendChild(badgeBackground);\n        this.expandG.appendChild(badgeText);\n        parentG.appendChild(this.expandG);\n    }\n}\n\nexport const getCollapseAndAddCenterPoint = (board: PlaitBoard, element: MindElement) => {\n    const layoutDirection = getNodeMoreLayoutDirection(board, element);\n    const [startPoint, endPoint] = getMoreStartAndEnd(board, element, layoutDirection);\n    const collapseCenter = moveXOfPoint(endPoint, NODE_MORE_ICON_DIAMETER / 2, layoutDirection as unknown as Direction);\n    const addCenter = getAddCenterByCollapseOrExpandCenter(element, collapseCenter, layoutDirection);\n    return { collapseCenter, addCenter };\n};\n\nexport const getAddCenterByCollapseOrExpandCenter = (\n    target: MindElement,\n    collapseOrExpandCenter: Point,\n    layoutDirection: LayoutDirection\n) => {\n    let addCenter = collapseOrExpandCenter;\n    if (target.children?.length > 0 && !PlaitMind.isMind(target)) {\n        addCenter = moveXOfPoint(addCenter, NODE_MORE_LINE_DISTANCE + NODE_MORE_ICON_DIAMETER, layoutDirection as unknown as Direction);\n    }\n    return addCenter;\n};\n\nexport const getNodeMoreLayoutDirection = (board: PlaitBoard, element: MindElement) => {\n    const node = MindElement.getNode(element);\n    const layout = MindQueries.getLayoutByElement(element) as MindLayoutType;\n    const isHorizontal = isHorizontalLayout(layout);\n    let layoutDirection = getLayoutDirection(node, isHorizontal);\n    if (isIndentedLayout(layout)) {\n        layoutDirection = isTopLayout(layout) ? LayoutDirection.top : LayoutDirection.bottom;\n    }\n    return layoutDirection;\n};\n\nexport const getMoreStartAndEnd = (board: PlaitBoard, element: MindElement, linkLineDirection: LayoutDirection) => {\n    const node = MindElement.getNode(element);\n    const isUnderlineShape = getShapeByElement(board, element) === MindElementShape.underline;\n    const nodeClient = getRectangleByNode(node);\n    let placement: PointPlacement = [HorizontalPlacement.right, VerticalPlacement.middle];\n    transformPlacement(placement, linkLineDirection);\n    // underline shape and horizontal\n    const layout = MindQueries.getLayoutByElement(element) as MindLayoutType;\n    const isHorizontal = isHorizontalLayout(layout);\n    if (isHorizontal && isUnderlineShape && !element.isRoot) {\n        placement[1] = VerticalPlacement.bottom;\n    }\n    let startPoint = getPointByPlacement(nodeClient, placement);\n    const endPoint = moveXOfPoint(startPoint, NODE_MORE_LINE_DISTANCE, linkLineDirection as unknown as Direction);\n    return [startPoint, endPoint] as [Point, Point];\n};\n\nexport const isLastSelectedMindElement = (board: PlaitBoard, element: MindElement) => {\n    const selectedElements = getSelectedElements(board);\n    const selectedMindElements = selectedElements.filter((element) => MindElement.isMindElement(board, element)).reverse();\n    return selectedMindElements[selectedMindElements.length - 1] === element;\n};\n\nexport const canHandleNodeMore = (board: PlaitBoard) => {\n    return !isResizing(board) && !isSelectionMoving(board) && !isDragging(board) && !isMovingElements(board);\n};\n", "import { PlaitBoard, NODE_TO_INDEX, PlaitPluginElementContext, OnContextChanged, RectangleClient } from '@plait/core';\nimport { isHorizontalLayout, AbstractNode, MindLayoutType } from '@plait/layouts';\nimport { RoughSVG } from 'roughjs/bin/svg';\nimport { MindElement, PlaitMind } from './interfaces/element';\nimport { MindNode } from './interfaces/node';\nimport { MindQueries } from './queries';\nimport { ELEMENT_TO_NODE } from './utils/weak-maps';\nimport { drawAbstractLink } from './utils/draw/node-link/abstract-link';\nimport { NodeEmojisGenerator } from './generators/node-emojis.generator';\nimport { MindTransforms } from './transforms';\nimport { PlaitMindBoard } from './plugins/with-mind.board';\nimport { drawLink } from './utils/draw/node-link/draw-link';\nimport { getTopicRectangleByNode } from './utils/position/topic';\nimport { NodeActiveGenerator } from './generators/node-active.generator';\nimport { NodeSpace } from './utils/space/node-space';\nimport { NodeTopicThreshold } from './constants/node-topic-style';\nimport {\n    CommonElementFlavour,\n    ImageGenerator,\n    TextManage,\n    TextManageChangeData,\n    WithTextPluginKey,\n    WithTextPluginOptions\n} from '@plait/common';\nimport { NodeShapeGenerator } from './generators/node-shape.generator';\nimport { getImageForeignRectangle } from './utils';\nimport { ImageData } from './interfaces';\nimport { NodeMoreGenerator } from './generators/node-more.generator';\n\nexport class MindNodeComponent\n    extends CommonElementFlavour<MindElement, PlaitMindBoard>\n    implements OnContextChanged<MindElement, PlaitMindBoard>\n{\n    roughSVG!: RoughSVG;\n\n    node!: MindNode;\n\n    index!: number;\n\n    shapeG: SVGGElement | null = null;\n\n    linkLineG?: SVGGElement;\n\n    nodeEmojisGenerator!: NodeEmojisGenerator;\n\n    nodeShapeGenerator!: NodeShapeGenerator;\n\n    imageGenerator!: ImageGenerator<MindElement<ImageData>>;\n\n    activeGenerator!: NodeActiveGenerator;\n\n    nodeMoreGenerator!: NodeMoreGenerator;\n\n    get textManage() {\n        return this.getRef().getTextManages()[0];\n    }\n\n    constructor() {\n        super();\n    }\n\n    initializeGenerator() {\n        this.nodeShapeGenerator = new NodeShapeGenerator(this.board);\n        this.nodeEmojisGenerator = new NodeEmojisGenerator(this.board);\n        this.activeGenerator = new NodeActiveGenerator(this.board);\n        this.nodeMoreGenerator = new NodeMoreGenerator(this.board);\n        this.imageGenerator = new ImageGenerator<MindElement<ImageData>>(this.board, {\n            getRectangle: (element: MindElement<ImageData>) => {\n                return getImageForeignRectangle(this.board as PlaitMindBoard, element);\n            },\n            getImageItem: (element: MindElement<ImageData>) => {\n                return element.data.image;\n            }\n        });\n        const plugins = (this.board.getPluginOptions<WithTextPluginOptions>(WithTextPluginKey) || {}).textPlugins;\n        const textManage = new TextManage(this.board, {\n            getRectangle: () => {\n                const rect = getTopicRectangleByNode(this.board, this.node);\n                return rect;\n            },\n            onChange: (data: TextManageChangeData) => {\n                const width = data.width;\n                const height = data.height;\n                if (data.newText) {\n                    MindTransforms.setTopic(this.board, this.element, data.newText as MindElement, width, height);\n                } else {\n                    MindTransforms.setTopicSize(this.board, this.element, width, height);\n                }\n            },\n            getMaxWidth: () => {\n                return NodeSpace.getTopicMaxDynamicWidth(this.board, this.element);\n            },\n            textPlugins: plugins || []\n        });\n        this.getRef().addGenerator(NodeActiveGenerator.key, this.activeGenerator);\n        this.getRef().addGenerator(NodeEmojisGenerator.key, this.nodeEmojisGenerator);\n        this.getRef().addGenerator(ImageGenerator.key, this.imageGenerator);\n        this.getRef().addGenerator(NodeMoreGenerator.key, this.nodeMoreGenerator);\n        this.getRef().initializeTextManage(textManage);\n        this.getRef().updateActiveSection = () => {\n            this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {\n                selected: this.selected\n            });\n        };\n    }\n\n    initialize(): void {\n        super.initialize();\n        this.initializeGenerator();\n        this.node = MindElement.getNode(this.element);\n        this.index = NODE_TO_INDEX.get(this.element) || 0;\n        this.roughSVG = PlaitBoard.getRoughSVG(this.board);\n        this.nodeShapeGenerator.processDrawing(this.element, this.getElementG(), { node: this.node });\n        this.drawLink();\n        this.drawTopic();\n        this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {\n            selected: this.selected\n        });\n        this.nodeMoreGenerator.processDrawing(this.element, this.getElementG());\n        this.drawEmojis();\n        this.imageGenerator.processDrawing(this.element as MindElement<ImageData>, this.getElementG());\n        if (PlaitMind.isMind(this.context.parent)) {\n            this.getElementG().classList.add('branch');\n        }\n    }\n\n    onContextChanged(\n        value: PlaitPluginElementContext<MindElement, PlaitMindBoard>,\n        previous: PlaitPluginElementContext<MindElement, PlaitMindBoard>\n    ) {\n        const newNode = MindElement.getNode(value.element);\n        const isEqualNode = RectangleClient.isEqual(this.node, newNode);\n        this.node = newNode;\n        if (!isEqualNode || value.element !== previous.element || value.hasThemeChanged) {\n            this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {\n                selected: this.selected\n            });\n            this.nodeMoreGenerator.processDrawing(this.element, this.getElementG(), { isSelected: this.selected });\n            this.nodeShapeGenerator.processDrawing(this.element, this.getElementG(), { node: this.node });\n            this.drawLink();\n            this.drawEmojis();\n            if (!MindElement.hasImage(previous.element) && MindElement.hasImage(this.element)) {\n                this.imageGenerator.processDrawing(this.element, this.getElementG());\n            }\n            if (MindElement.hasImage(previous.element) && MindElement.hasImage(this.element)) {\n                this.imageGenerator.updateImage(\n                    this.getElementG(),\n                    previous.element as MindElement<ImageData>,\n                    value.element as MindElement<ImageData>\n                );\n            }\n            if (MindElement.hasImage(previous.element) && !MindElement.hasImage(this.element)) {\n                this.imageGenerator.destroy();\n            }\n            this.updateTopic();\n        } else {\n            const hasSameSelected = value.selected === previous.selected;\n            const hasSameParent = value.parent === previous.parent;\n            if (!hasSameSelected || value.selected) {\n                this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {\n                    selected: this.selected\n                });\n                this.nodeMoreGenerator.processDrawing(this.element, this.getElementG(), {\n                    isSelected: this.selected\n                });\n            }\n            if (!hasSameParent) {\n                this.drawLink();\n            }\n        }\n    }\n\n    drawEmojis() {\n        const g = this.nodeEmojisGenerator.drawEmojis(this.element);\n        if (g) {\n            this.getElementG().append(g);\n        }\n    }\n\n    drawLink() {\n        if (PlaitMind.isMind(this.element)) {\n            return;\n        }\n\n        const parent = MindElement.getParent(this.element);\n        const parentNode = MindElement.getNode(parent);\n\n        if (this.linkLineG) {\n            this.linkLineG.remove();\n        }\n\n        const layout = MindQueries.getLayoutByElement(parent) as MindLayoutType;\n        if (AbstractNode.isAbstract(this.node.origin)) {\n            this.linkLineG = drawAbstractLink(this.board, this.node, isHorizontalLayout(layout));\n        } else {\n            this.linkLineG = drawLink(this.board, parentNode, this.node, isHorizontalLayout(layout));\n        }\n        this.getElementG().append(this.linkLineG);\n    }\n\n    drawTopic() {\n        this.textManage.draw(this.element.data.topic);\n        this.getElementG().append(this.textManage.g);\n    }\n\n    updateTopic() {\n        this.textManage.updateText(this.element.data.topic);\n        this.textManage.updateRectangle();\n    }\n\n    trackBy = (index: number, node: MindNode) => {\n        return node.origin.id;\n    };\n\n    destroy(): void {\n        super.destroy();\n        this.nodeEmojisGenerator.destroy();\n        this.imageGenerator.destroy();\n        this.activeGenerator.destroy();\n        if (ELEMENT_TO_NODE.get(this.element) === this.node) {\n            ELEMENT_TO_NODE.delete(this.element);\n        }\n        this.getRef().destroyTextManage();\n    }\n}\n", "import { PlaitMind } from './interfaces/element';\nimport { MindNode } from './interfaces/node';\nimport { BeforeContextChange, PlaitPluginElementContext, depthFirstRecursion, isDebug } from '@plait/core';\nimport { GlobalLayout, OriginNode } from '@plait/layouts';\nimport { ELEMENT_TO_NODE } from './utils/weak-maps';\nimport { MindNodeComponent } from './mind-node.component';\nimport { getLayoutOptions } from './utils/space/layout-options';\nimport { getDefaultLayout } from './utils/layout';\n\nexport class PlaitMindComponent extends MindNodeComponent implements BeforeContextChange<PlaitMind> {\n    root!: MindNode;\n\n    initialize(): void {\n        this.updateMindLayout();\n        super.initialize();\n        this.getElementG().classList.add('root');\n    }\n\n    beforeContextChange(value: PlaitPluginElementContext<PlaitMind>) {\n        if (value.element !== this.element && this.initialized) {\n            this.updateMindLayout(value.element);\n        }\n    }\n\n    updateMindLayout(element = this.element) {\n        const mindLayoutType = element.layout || getDefaultLayout();\n        this.root = GlobalLayout.layout(\n            element as unknown as OriginNode,\n            getLayoutOptions(this.board),\n            mindLayoutType\n        ) as unknown as MindNode;\n        this.updateMindNodeLocation(element as PlaitMind);\n    }\n\n    updateMindNodeLocation(element: PlaitMind) {\n        const { x, y, hGap, vGap } = this.root;\n        const offsetX = x + hGap;\n        const offsetY = y + vGap;\n        depthFirstRecursion<MindNode>(this.root, (node) => {\n            node.x = node.x - offsetX + element.points[0][0];\n            node.y = node.y - offsetY + element.points[0][1];\n            ELEMENT_TO_NODE.set(node.origin, node);\n        });\n    }\n}\n", "import {\n    distanceBetweenPointAndPoint,\n    Path,\n    PlaitBoard,\n    Point,\n    Transforms,\n    getSelectedElements,\n    depthFirstRecursion,\n    createG,\n    PlaitNode,\n    PlaitPointerType,\n    isMainPointer,\n    CoreTransforms,\n    getHitElementByPoint,\n    toHostPoint,\n    toViewBoxPoint,\n    isDragging\n} from '@plait/core';\nimport { AbstractNode, getNonAbstractChildren } from '@plait/layouts';\nimport { MindElement, PlaitMind } from '../interfaces/element';\nimport { DetectResult } from '../interfaces/node';\nimport {\n    deleteElementHandleAbstract,\n    deleteElementsHandleRightNodeCount,\n    getCorrespondingAbstract,\n    getFirstLevelElement,\n    getOverallAbstracts,\n    getValidAbstractRefs,\n    insertElementHandleAbstract,\n    insertElementHandleRightNodeCount\n} from '../utils';\nimport { addActiveOnDragOrigin, isDropStandardRight, removeActiveOnDragOrigin, setMindDragging } from '../utils/dnd/common';\nimport { detectDropTarget, getPathByDropTarget } from '../utils/dnd/detector';\nimport { drawFakeDragNode, drawFakeDropNode } from '../utils/draw/node-dnd';\nimport { MindTransforms } from '../transforms';\nimport { adjustAbstractToNode } from '../utils/node/adjust-node';\n\nconst DRAG_MOVE_BUFFER = 5;\n\nexport const withNodeDnd = (board: PlaitBoard) => {\n    const { pointerDown, pointerMove, globalPointerUp } = board;\n\n    let activeElements: MindElement[] = [];\n    let correspondingElements: MindElement[] = [];\n    let startPoint: Point;\n    let dragFakeNodeG: SVGGElement | undefined;\n    let fakeDropNodeG: SVGGElement | undefined;\n    let dropTarget: { target: MindElement; detectResult: DetectResult } | null = null;\n    let targetPath: Path;\n\n    board.pointerDown = (event: PointerEvent) => {\n        if (\n            PlaitBoard.isReadonly(board) ||\n            PlaitBoard.hasBeenTextEditing(board) ||\n            !PlaitBoard.isPointer(board, PlaitPointerType.selection) ||\n            !isMainPointer(event)\n        ) {\n            pointerDown(event);\n            return;\n        }\n        const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n        const selectedElements = getSelectedElements(board);\n        const hitElement = getHitElementByPoint(board, point);\n        if (\n            hitElement &&\n            MindElement.isMindElement(board, hitElement) &&\n            !PlaitMind.isMind(hitElement) &&\n            !AbstractNode.isAbstract(hitElement)\n        ) {\n            const targetElements = selectedElements.filter(\n                element => MindElement.isMindElement(board, element) && !element.isRoot && !AbstractNode.isAbstract(element)\n            ) as MindElement[];\n            const isMultipleSelection = selectedElements.length > 0 && selectedElements.includes(hitElement);\n            if (isMultipleSelection) {\n                activeElements = targetElements;\n                startPoint = point;\n            } else {\n                activeElements = [hitElement];\n                startPoint = point;\n            }\n        }\n\n        if (activeElements.length) {\n            correspondingElements = getOverallAbstracts(board, activeElements);\n        }\n\n        pointerDown(event);\n    };\n\n    board.pointerMove = (event: PointerEvent) => {\n        if (!board.options.readonly && activeElements.length && startPoint) {\n            const endPoint = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n            const distance = distanceBetweenPointAndPoint(startPoint[0], startPoint[1], endPoint[0], endPoint[1]);\n            if (distance < DRAG_MOVE_BUFFER) {\n                return;\n            }\n\n            setMindDragging(board, true);\n\n            fakeDropNodeG?.remove();\n            const detectPoint = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n            dropTarget = detectDropTarget(board, detectPoint, dropTarget, [...activeElements, ...correspondingElements]);\n            if (dropTarget?.target) {\n                targetPath = getPathByDropTarget(board, dropTarget);\n\n                fakeDropNodeG = drawFakeDropNode(board, dropTarget, targetPath);\n                PlaitBoard.getHost(board).appendChild(fakeDropNodeG);\n            }\n\n            const offsetX = endPoint[0] - startPoint[0];\n            const offsetY = endPoint[1] - startPoint[1];\n            dragFakeNodeG?.remove();\n            dragFakeNodeG = createG();\n            [...activeElements, ...correspondingElements].forEach(element => {\n                addActiveOnDragOrigin(element);\n            });\n            activeElements.forEach(element => {\n                const nodeG = drawFakeDragNode(board, element, offsetX, offsetY);\n                dragFakeNodeG?.appendChild(nodeG);\n            });\n\n            PlaitBoard.getHost(board).appendChild(dragFakeNodeG);\n            return;\n        }\n\n        pointerMove(event);\n    };\n\n    board.globalPointerUp = (event: PointerEvent) => {\n        const firstLevelElements = getFirstLevelElement(activeElements);\n        if (!board.options.readonly && firstLevelElements.length) {\n            firstLevelElements.push(...correspondingElements);\n            if (isDragging(board)) {\n                firstLevelElements.forEach(element => {\n                    removeActiveOnDragOrigin(element);\n                });\n            }\n            if (dropTarget) {\n                const targetPathRef = board.pathRef(targetPath);\n                const targetPreviousPathRef = Path.hasPrevious(targetPath) && board.pathRef(Path.previous(targetPath));\n                const targetElementPathRef = board.pathRef(PlaitBoard.findPath(board, dropTarget.target));\n                let abstractRefs = getValidAbstractRefs(board, firstLevelElements);\n                const normalElements = firstLevelElements\n                    .filter(element => !abstractRefs.some(refs => refs.abstract === element))\n                    .map(element => {\n                        if (AbstractNode.isAbstract(element)) {\n                            return adjustAbstractToNode(element);\n                        }\n                        return element;\n                    });\n\n                const hasPreviousNode = targetPath[targetPath.length - 1] !== 0;\n                if (hasPreviousNode) {\n                    const previousElement = PlaitNode.get(board, Path.previous(targetPath)) as MindElement;\n                    const correspondingAbstract = getCorrespondingAbstract(previousElement);\n                    const targetHasCorrespondAbstract =\n                        correspondingAbstract && correspondingAbstract.end !== targetPath[targetPath.length - 1] - 1;\n                    if (targetHasCorrespondAbstract) {\n                        const adjustedNode = abstractRefs.map(ref => {\n                            return adjustAbstractToNode(ref.abstract);\n                        });\n                        normalElements.push(...adjustedNode);\n                        abstractRefs = [];\n                    }\n                }\n\n                const effectedAbstracts = deleteElementHandleAbstract(board, firstLevelElements);\n                insertElementHandleAbstract(board, targetPath, normalElements.length, false, effectedAbstracts);\n                MindTransforms.setAbstractsByRefs(board, effectedAbstracts);\n\n                let refs = deleteElementsHandleRightNodeCount(board, firstLevelElements);\n                const parent = PlaitNode.get(board, Path.parent(targetPath)) as MindElement;\n                const shouldChangeRoot = isDropStandardRight(parent, dropTarget);\n                if (shouldChangeRoot && targetElementPathRef.current) {\n                    refs = insertElementHandleRightNodeCount(board, targetElementPathRef.current.slice(0, 1), normalElements.length, refs);\n                }\n\n                MindTransforms.setRightNodeCountByRefs(board, refs);\n                CoreTransforms.removeElements(board, firstLevelElements);\n\n                let insertPath = targetPathRef.current;\n                const parentPath = Path.parent(targetPathRef.current || targetPath);\n                if (!insertPath) {\n                    // When the insertion position and the selected node position are the same, the recorded previousPath is used\n                    const previousPath = targetPreviousPathRef && targetPreviousPathRef.unref();\n                    if (previousPath) {\n                        insertPath = Path.next(previousPath);\n                    } else {\n                        const parent = PlaitNode.get(board, parentPath);\n                        const children = getNonAbstractChildren(parent);\n                        insertPath = [...parentPath, children.length || 0];\n                    }\n                }\n\n                MindTransforms.insertNodes(board, normalElements, insertPath);\n\n                if (abstractRefs.length) {\n                    MindTransforms.insertAbstractNodes(board, abstractRefs, normalElements, insertPath);\n                }\n\n                if (\n                    targetElementPathRef.current &&\n                    targetPathRef.current &&\n                    Path.isAncestor(targetElementPathRef.current, targetPathRef.current) &&\n                    dropTarget.target.isCollapsed\n                ) {\n                    Transforms.setNode(board, { isCollapsed: false }, targetElementPathRef.current);\n                }\n                targetElementPathRef.unref();\n                targetPathRef.unref();\n\n                let setActiveElements: MindElement[] = [];\n                depthFirstRecursion((board as unknown) as MindElement, node => {\n                    const isSelected = activeElements.some(element => element.id === node.id);\n                    if (isSelected) {\n                        setActiveElements.push(node);\n                    }\n                });\n\n                Transforms.addSelectionWithTemporaryElements(board, setActiveElements);\n            }\n            setMindDragging(board, false);\n            activeElements = [];\n            dragFakeNodeG?.remove();\n            dragFakeNodeG = undefined;\n            fakeDropNodeG?.remove();\n            fakeDropNodeG = undefined;\n            dropTarget = null;\n        }\n        globalPointerUp(event);\n    };\n\n    return board;\n};\n", "import {\n    BOARD_TO_HOST,\n    PlaitBoard,\n    PlaitElement,\n    PlaitPlugin,\n    Point,\n    Transforms,\n    getSelectedElements,\n    isMainPointer,\n    toActivePointFromViewBoxPoint,\n    toHostPoint,\n    toViewBoxPoint\n} from '@plait/core';\nimport { AbstractNode, LayoutNode, MindLayoutType, isHorizontalLayout, isStandardLayout } from '@plait/layouts';\nimport { MindElement } from '../interfaces';\nimport { findLocationLeftIndex, getHitAbstractHandle, getLocationScope, handleTouchedAbstract } from '../utils/abstract/resize';\nimport { separateChildren } from '../utils/abstract/common';\nimport { AbstractHandlePosition, AbstractResizeState, PlaitAbstractBoard } from './with-abstract-resize.board';\nimport { MindQueries } from '../queries';\nimport { PlaitCommonElementRef } from '@plait/common';\nimport { NodeActiveGenerator } from '../generators/node-active.generator';\n\nexport const withAbstract: PlaitPlugin = (board: PlaitBoard) => {\n    const newBoard = board as PlaitBoard & PlaitAbstractBoard;\n\n    const { pointerDown, pointerMove, pointerUp } = board;\n    let activeAbstractElement: MindElement | undefined;\n    let abstractHandlePosition: AbstractHandlePosition | undefined;\n    let touchedAbstract: MindElement | undefined;\n    let startPoint: Point | undefined;\n    let newProperty: { end: number } | { start: number } | undefined;\n\n    board.pointerDown = (event: PointerEvent) => {\n        if (!isMainPointer(event) || PlaitBoard.isReadonly(board)) {\n            pointerDown(event);\n            return;\n        }\n\n        const activeAbstractElements = getSelectedElements(board).filter((element) => AbstractNode.isAbstract(element)) as MindElement[];\n        const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n\n        activeAbstractElement = activeAbstractElements.find((element) => {\n            abstractHandlePosition = getHitAbstractHandle(board, element as MindElement, point);\n            return abstractHandlePosition;\n        });\n\n        if (activeAbstractElement) {\n            if (newBoard?.onAbstractResize) {\n                newBoard.onAbstractResize(AbstractResizeState.start);\n            }\n            startPoint = point;\n            return;\n        }\n\n        pointerDown(event);\n    };\n\n    board.pointerMove = (event: PointerEvent) => {\n        getSelectedElements(board);\n        const endPoint = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n\n        touchedAbstract = handleTouchedAbstract(board, touchedAbstract, endPoint);\n\n        if (abstractHandlePosition && activeAbstractElement) {\n            const nodeLayout = MindQueries.getCorrectLayoutByElement(board, activeAbstractElement as MindElement) as MindLayoutType;\n            const isHorizontal = isHorizontalLayout(nodeLayout);\n            const parentElement = MindElement.getParent(activeAbstractElement);\n\n            let children = parentElement.children;\n\n            const parentLayout = MindQueries.getLayoutByElement(parentElement);\n            if (isStandardLayout(parentLayout)) {\n                const rightNodeCount = parentElement.rightNodeCount!;\n                const { leftChildren, rightChildren } = separateChildren(parentElement);\n                if ((activeAbstractElement as MindElement).end! < rightNodeCount) {\n                    children = rightChildren;\n                }\n                if ((activeAbstractElement as MindElement).start! >= rightNodeCount) {\n                    children = leftChildren;\n                }\n            }\n\n            if (newBoard?.onAbstractResize) {\n                newBoard.onAbstractResize(AbstractResizeState.resizing);\n            }\n\n            const resizingLocation = isHorizontal ? endPoint[1] : endPoint[0];\n            const parent = MindElement.getNode(parentElement) as unknown as LayoutNode;\n            const scope = getLocationScope(board, abstractHandlePosition, children, activeAbstractElement, parent, isHorizontal);\n            const location = Math.min(scope.max, Math.max(scope.min, resizingLocation));\n            let locationIndex = findLocationLeftIndex(board, children, location, isHorizontal);\n\n            const isPropertyUnchanged =\n                (abstractHandlePosition === AbstractHandlePosition.start &&\n                    locationIndex + 1 === (activeAbstractElement as MindElement).start!) ||\n                (abstractHandlePosition === AbstractHandlePosition.end && locationIndex === (activeAbstractElement as MindElement).end!);\n\n            if (isPropertyUnchanged) {\n                newProperty = undefined;\n            } else {\n                if (isStandardLayout(parent.layout)) {\n                    const rightNodeCount = parent.origin.rightNodeCount;\n                    let start = activeAbstractElement.start!;\n                    if (start >= rightNodeCount) {\n                        locationIndex += rightNodeCount;\n                    }\n                }\n\n                newProperty =\n                    abstractHandlePosition === AbstractHandlePosition.start ? { start: locationIndex + 1 } : { end: locationIndex };\n            }\n            const ref = PlaitElement.getElementRef<PlaitCommonElementRef>(activeAbstractElement);\n            const activeGenerator = ref.getGenerator<NodeActiveGenerator>(NodeActiveGenerator.key);\n            const activeLocation = toActivePointFromViewBoxPoint(board, [location, location]);\n            activeGenerator.updateAbstractOutline(\n                activeAbstractElement,\n                abstractHandlePosition,\n                isHorizontal ? activeLocation[1] : activeLocation[0]\n            );\n        }\n        pointerMove(event);\n    };\n\n    board.pointerUp = (event: PointerEvent) => {\n        startPoint = undefined;\n        abstractHandlePosition = undefined;\n        if (activeAbstractElement) {\n            if (newBoard?.onAbstractResize) {\n                newBoard.onAbstractResize(AbstractResizeState.end);\n            }\n\n            if (newProperty) {\n                const path = PlaitBoard.findPath(board, activeAbstractElement);\n                Transforms.setNode(board, newProperty, path);\n            } else {\n                const ref = PlaitElement.getElementRef<PlaitCommonElementRef>(activeAbstractElement);\n                const activeGenerator = ref.getGenerator<NodeActiveGenerator>(NodeActiveGenerator.key);\n                activeGenerator.updateAbstractOutline(activeAbstractElement);\n            }\n            activeAbstractElement = undefined;\n            return;\n        }\n        pointerUp(event);\n    };\n    return board;\n};\n", "import { PlaitBoard, PlaitOptionsBoard } from '@plait/core';\nimport { PlaitMindBoard } from './with-mind.board';\nimport { WithMindOptions } from '../interfaces/options';\nimport { WithMindPluginKey } from '../constants/default';\n\nexport const withMindExtend = (board: PlaitBoard) => {\n    const newBoard = board as PlaitBoard & PlaitMindBoard;\n\n    (board as PlaitOptionsBoard).setPluginOptions<WithMindOptions>(WithMindPluginKey, { spaceBetweenEmojis: 4, emojiPadding: 0 });\n\n    return newBoard;\n};\n", "import {\n    BoardTransforms,\n    PlaitBoard,\n    PlaitPointerType,\n    createG,\n    getSelectedElements,\n    throttleRAF,\n    toHostPoint,\n    toViewBoxPoint\n} from '@plait/core';\nimport { PlaitMindBoard } from './with-mind.board';\nimport { MindPointerType } from '../interfaces/pointer';\nimport { getRectangleByElement, getTopicRectangleByElement } from '../utils';\nimport { drawRoundRectangleByElement } from '../utils/draw/node-shape';\nimport { createEmptyMind } from '../utils/node/create-node';\nimport { MindElement } from '../interfaces';\nimport { BoardCreationMode, TextManage, isDndMode, isDrawingMode, setCreationMode } from '@plait/common';\nimport { MindTransforms } from '../transforms';\n\nconst DefaultHotkey = 'm';\n\nexport interface FakeCreateNodeRef {\n    g: SVGGElement;\n    nodeG: SVGGElement;\n    textManage: TextManage;\n}\n\nexport const withCreateMind = (board: PlaitBoard) => {\n    const newBoard = board as PlaitBoard & PlaitMindBoard;\n    const { keyDown, pointerDown, pointerMove, pointerUp } = board;\n    let fakeCreateNodeRef: FakeCreateNodeRef | null = null;\n    let emptyMind: MindElement | null = null;\n\n    newBoard.pointerDown = (event: PointerEvent) => {\n        const isMindPointer = PlaitBoard.isPointer<MindPointerType | PlaitPointerType>(board, MindPointerType.mind);\n        if (!PlaitBoard.isReadonly(board) && isDrawingMode(board) && isMindPointer) {\n            const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n            const emptyMind = createEmptyMind(newBoard, point);\n            MindTransforms.insertMind(board as PlaitMindBoard, emptyMind);\n            BoardTransforms.updatePointerType(board, PlaitPointerType.selection);\n            return;\n        }\n        pointerDown(event);\n    };\n\n    newBoard.pointerMove = (event: PointerEvent) => {\n        if (PlaitBoard.isReadonly(board)) {\n            pointerMove(event);\n            return;\n        }\n        const isMindPointer = PlaitBoard.isPointer<MindPointerType | PlaitPointerType>(board, MindPointerType.mind);\n        if (isDndMode(board) && isMindPointer) {\n            throttleRAF(board, 'with-mind-create', () => {\n                let movingPoint = PlaitBoard.getMovingPointInBoard(board);\n\n                if (movingPoint) {\n                    movingPoint = toViewBoxPoint(newBoard, toHostPoint(board, movingPoint[0], movingPoint[1]));\n                    emptyMind = createEmptyMind(newBoard, movingPoint);\n                    const nodeRectangle = getRectangleByElement(newBoard, emptyMind);\n                    const nodeG = drawRoundRectangleByElement(board, nodeRectangle, emptyMind);\n                    const topicRectangle = getTopicRectangleByElement(newBoard, nodeRectangle, emptyMind);\n                    if (!fakeCreateNodeRef) {\n                        const textManage = new TextManage(board, {\n                            getRectangle: () => {\n                                return topicRectangle;\n                            }\n                        });\n                        textManage.draw(emptyMind!.data.topic);\n                        fakeCreateNodeRef = {\n                            g: createG(),\n                            nodeG,\n                            textManage\n                        };\n                        fakeCreateNodeRef.g.classList.add('root');\n                        fakeCreateNodeRef.g.setAttribute('plait-mind-temporary', 'true');\n                        PlaitBoard.getHost(board).append(fakeCreateNodeRef.g);\n                        fakeCreateNodeRef.g.append(...[fakeCreateNodeRef.nodeG, textManage.g]);\n                    } else {\n                        fakeCreateNodeRef.textManage.updateRectangle(topicRectangle);\n                        fakeCreateNodeRef.nodeG.remove();\n                        fakeCreateNodeRef.nodeG = nodeG;\n                        fakeCreateNodeRef.g.append(nodeG);\n                        fakeCreateNodeRef.g.append(fakeCreateNodeRef.textManage.g);\n                    }\n                }\n            });\n        } else {\n            destroy();\n        }\n        pointerMove(event);\n    };\n\n    newBoard.pointerUp = (event: PointerEvent) => {\n        if (emptyMind) {\n            MindTransforms.insertMind(board as PlaitMindBoard, emptyMind);\n            BoardTransforms.updatePointerType(board, PlaitPointerType.selection);\n            emptyMind = null;\n            destroy();\n            return;\n        }\n        pointerUp(event);\n    };\n\n    board.keyDown = (event: KeyboardEvent) => {\n        if (PlaitBoard.isReadonly(board) || getSelectedElements(board).length > 0) {\n            keyDown(event);\n            return;\n        }\n        if (event.key === DefaultHotkey && !PlaitBoard.isPointer(board, MindPointerType.mind)) {\n            BoardTransforms.updatePointerType(board, MindPointerType.mind);\n            setCreationMode(board, BoardCreationMode.drawing);\n            event.preventDefault();\n            return;\n        }\n        keyDown(event);\n    };\n\n    function destroy() {\n        if (fakeCreateNodeRef) {\n            fakeCreateNodeRef.textManage.destroy();\n            fakeCreateNodeRef.g.remove();\n            fakeCreateNodeRef = null;\n        }\n    }\n\n    return newBoard;\n};\n", "import { PlaitBoard, Transforms, getSelectedElements } from '@plait/core';\nimport { MindElement, PlaitMind } from '../interfaces';\nimport { AbstractNode } from '@plait/layouts';\nimport { MindTransforms } from '../transforms';\nimport { editTopic } from '../utils/node/common';\nimport { PlaitMindBoard } from './with-mind.board';\nimport { isSpaceHotkey, isExpandHotkey, isTabHotkey, isEnterHotkey, isVirtualKey, isDelete, getFirstTextManage } from '@plait/common';\nimport { isHotkey } from 'is-hotkey';\n\nexport const withMindHotkey = (baseBoard: PlaitBoard) => {\n    const board = baseBoard as PlaitBoard & PlaitMindBoard;\n    const { keyDown, globalKeyDown } = board;\n\n    board.keyDown = (event: KeyboardEvent) => {\n        const selectedElements = getSelectedElements(board);\n        const isSingleSelection = selectedElements.length === 1;\n        const isSingleMindElement = selectedElements.length === 1 && MindElement.isMindElement(board, selectedElements[0]);\n        const targetElement = selectedElements[0] as MindElement;\n\n        if (isExpandHotkey(event) && isSingleMindElement && !PlaitMind.isMind(targetElement)) {\n            if (targetElement.children && targetElement.children.length > 0) {\n                Transforms.setNode(\n                    board,\n                    { isCollapsed: targetElement.isCollapsed ? false : true },\n                    PlaitBoard.findPath(board, targetElement)\n                );\n                return;\n            }\n        }\n\n        if (!PlaitBoard.isReadonly(board)) {\n            if (isTabHotkey(event) && isSingleMindElement) {\n                event.preventDefault();\n                MindTransforms.insertChildNode(board, targetElement);\n                return;\n            }\n\n            if (\n                isEnterHotkey(event) &&\n                isSingleMindElement &&\n                !PlaitMind.isMind(targetElement) &&\n                !AbstractNode.isAbstract(targetElement)\n            ) {\n                MindTransforms.insertSiblingNode(board, targetElement);\n                return;\n            }\n\n            if (\n                !isVirtualKey(event) &&\n                !isDelete(event) &&\n                !isSpaceHotkey(event) &&\n                isSingleSelection &&\n                MindElement.isMindElement(board, targetElement)\n            ) {\n                event.preventDefault();\n                editTopic(targetElement);\n                return;\n            }\n        }\n\n        keyDown(event);\n    };\n\n    board.globalKeyDown = (event: KeyboardEvent) => {\n        if (PlaitBoard.isFocus(board) && PlaitBoard.hasBeenTextEditing(board)) {\n            if (isHotkey('mod+z', event)) {\n                const { history } = board;\n                const { undos } = history;\n                const previousOp =  undos.length > 0 ? undos[undos.length - 1][0] : undefined;\n                if (previousOp && previousOp.type === 'insert_node' && MindElement.isMindElement(board, previousOp.node) && getFirstTextManage(previousOp.node).isEditing) {\n                    board.undo();\n                }\n            }\n        }\n        globalKeyDown(event);\n    };\n\n    return board;\n};\n", "import {\n    depthFirstRecursion,\n    getIsRecursionFunc,\n    isSelectedElement,\n    PlaitBoard,\n    PlaitElement,\n    RectangleClient,\n    throttleRAF,\n    toHostPoint,\n    toViewBoxPoint,\n    Transforms\n} from '@plait/core';\nimport { MindElement, PlaitMind } from '../interfaces';\nimport { findNewChildNodePath, insertMindElement, isHitMindElement } from '../utils';\nimport { PlaitCommonElementRef } from '@plait/common';\nimport { canHandleNodeMore, getCollapseAndAddCenterPoint, NodeMoreGenerator } from '../generators/node-more.generator';\nimport { NODE_MORE_ICON_DIAMETER } from '../constants/default';\nimport { PlaitMindBoard } from './with-mind.board';\n\nexport interface NodeMoreRef {\n    target: MindElement;\n    isHovered: boolean;\n    isHoveredCollapseArea: boolean;\n    isHoveredExpandArea: boolean;\n    isHoveredAddArea: boolean;\n}\n\nexport const withNodeMore = (board: PlaitBoard) => {\n    const { pointerMove, pointerLeave, pointerUp } = board;\n    let nodeMoreRef: NodeMoreRef | null = null;\n\n    board.pointerMove = (event: PointerEvent) => {\n        if (canHandleNodeMore(board)) {\n            throttleRAF(board, 'with-mind-node-hover-hit-test', () => {\n                // target has been deleted\n                if (nodeMoreRef && !PlaitElement.hasMounted(nodeMoreRef.target)) {\n                    nodeMoreRef = null;\n                }\n                const newNodeMoreRef = getNodeMoreRef(board, event.x, event.y);\n\n                if (nodeMoreRef && newNodeMoreRef && nodeMoreRef.target === newNodeMoreRef.target) {\n                    return;\n                }\n\n                if (nodeMoreRef) {\n                    toggleHoveredNodeCallback({\n                        target: nodeMoreRef.target,\n                        isHovered: false,\n                        isHoveredCollapseArea: false,\n                        isHoveredExpandArea: false,\n                        isHoveredAddArea: false\n                    });\n                }\n\n                if (newNodeMoreRef) {\n                    toggleHoveredNodeCallback(newNodeMoreRef);\n                    if (nodeMoreRef) {\n                        nodeMoreRef.target = newNodeMoreRef.target;\n                    } else {\n                        nodeMoreRef = newNodeMoreRef;\n                    }\n                } else {\n                    nodeMoreRef = null;\n                }\n            });\n        }\n        pointerMove(event);\n    };\n\n    board.pointerUp = (event: PointerEvent) => {\n        if (nodeMoreRef && (nodeMoreRef.isHoveredCollapseArea || nodeMoreRef.isHoveredExpandArea)) {\n            const isCollapsed = !nodeMoreRef.target.isCollapsed;\n            const newElement: Partial<MindElement> = { isCollapsed };\n            const path = PlaitBoard.findPath(board, nodeMoreRef.target);\n            Transforms.setNode(board, newElement, path);\n            setTimeout(() => {\n                const newNodeMoreRef = getNodeMoreRef(board, event.x, event.y);\n                if (newNodeMoreRef) {\n                    toggleHoveredNodeCallback(newNodeMoreRef);\n                    nodeMoreRef = newNodeMoreRef;\n                } else {\n                    nodeMoreRef = null;\n                }\n            }, 0);\n            return;\n        }\n        if (nodeMoreRef && nodeMoreRef.isHoveredAddArea && !PlaitBoard.isReadonly(board)) {\n            if (nodeMoreRef) {\n                const path = findNewChildNodePath(board, nodeMoreRef.target);\n                insertMindElement(board as PlaitMindBoard, nodeMoreRef.target, path);\n            }\n            return;\n        }\n        pointerUp(event);\n    };\n\n    const toggleHoveredNodeCallback = (ref: NodeMoreRef) => {\n        const elementRef = PlaitElement.getElementRef<PlaitCommonElementRef>(ref.target);\n        const nodeMoreGenerator = elementRef?.getGenerator<NodeMoreGenerator>(NodeMoreGenerator.key);\n        if (nodeMoreGenerator) {\n            const g = PlaitElement.getElementG(ref.target);\n            nodeMoreGenerator.processDrawing(ref.target, g, {\n                isHovered: ref.isHovered,\n                isHoveredCollapseArea: ref.isHoveredCollapseArea,\n                isHoveredExpandArea: ref.isHoveredExpandArea,\n                isSelected: isSelectedElement(board, ref.target),\n                isHoveredAddArea: ref.isHoveredAddArea,\n                isShowCollapseAnimation: (ref.isHovered || ref.isHoveredCollapseArea) && !isSelectedElement(board, ref.target),\n                isShowAddAnimation: (ref.isHovered || ref.isHoveredAddArea) && !isSelectedElement(board, ref.target)\n            });\n        }\n    };\n\n    board.pointerLeave = (event: PointerEvent) => {\n        if (nodeMoreRef) {\n            toggleHoveredNodeCallback({\n                target: nodeMoreRef.target,\n                isHovered: false,\n                isHoveredCollapseArea: false,\n                isHoveredExpandArea: false,\n                isHoveredAddArea: false\n            });\n        }\n        nodeMoreRef = null;\n        pointerLeave(event);\n    };\n\n    return board;\n};\n\nconst getNodeMoreRef = (board: PlaitBoard, x: number, y: number) => {\n    let target: MindElement | null = null;\n    let isHovered = false;\n    let isHoveredCollapseArea = false;\n    let isHoveredExpandArea = false;\n    let isHoveredAddArea = false;\n    const point = toViewBoxPoint(board, toHostPoint(board, x, y));\n    depthFirstRecursion(\n        board as unknown as MindElement,\n        (element) => {\n            if (target) {\n                return;\n            }\n            if (!MindElement.isMindElement(board, element)) {\n                return;\n            }\n            const isMind = PlaitMind.isMind(element);\n            const isHitElement = isHitMindElement(board, point, element);\n            let isHitCollapseOrExpand = false;\n            let isHitAdd = false;\n            const { collapseCenter, addCenter } = getCollapseAndAddCenterPoint(board, element);\n            const collapseOrExpandIconRectangle =\n                !isMind && RectangleClient.getRectangleByCenterPoint(collapseCenter, NODE_MORE_ICON_DIAMETER, NODE_MORE_ICON_DIAMETER);\n            isHitCollapseOrExpand =\n                collapseOrExpandIconRectangle &&\n                RectangleClient.isHit(RectangleClient.getRectangleByPoints([point, point]), collapseOrExpandIconRectangle);\n            const addIconRectangle = RectangleClient.getRectangleByCenterPoint(addCenter, NODE_MORE_ICON_DIAMETER, NODE_MORE_ICON_DIAMETER);\n            isHitAdd = RectangleClient.isHit(RectangleClient.getRectangleByPoints([point, point]), addIconRectangle);\n            if (isHitElement || isHitCollapseOrExpand || isHitAdd) {\n                isHovered = isHitElement;\n                if (element.children.length > 0) {\n                    if (element.isCollapsed) {\n                        isHoveredExpandArea = isHitCollapseOrExpand;\n                    } else {\n                        isHoveredCollapseArea = isHitCollapseOrExpand;\n                    }\n                }\n                isHoveredAddArea = isHitAdd;\n                target = element;\n            }\n        },\n        getIsRecursionFunc(board),\n        true\n    );\n    if (!target) {\n        return null;\n    }\n    return {\n        target,\n        isHovered,\n        isHoveredCollapseArea,\n        isHoveredExpandArea,\n        isHoveredAddArea\n    } as NodeMoreRef;\n};\n", "import {\n    PlaitBoard,\n    isMainPointer,\n    PlaitOptionsBoard,\n    hotkeys,\n    PlaitPointerType,\n    addSelectedElement,\n    Point,\n    getSelectedElements,\n    RectangleClient,\n    getHitElementByPoint,\n    temporaryDisableSelection,\n    WritableClipboardType,\n    toHostPoint,\n    toViewBoxPoint,\n    WritableClipboardContext,\n    createClipboardContext,\n    ClipboardData,\n    isContextmenu,\n    PlaitElement,\n    WritableClipboardOperationType\n} from '@plait/core';\nimport { MindElement } from '../interfaces';\nimport { ImageData } from '../interfaces/element-data';\nimport { addImageFocus, removeImageFocus } from '../utils/node/image';\nimport { isHitImage } from '../utils';\nimport { MindTransforms } from '../transforms';\nimport { acceptImageTypes, buildImage, getElementOfFocusedImage, ImageGenerator, PlaitCommonElementRef } from '@plait/common';\nimport { DEFAULT_MIND_IMAGE_WIDTH } from '../constants';\n\nexport const withNodeImage = (board: PlaitBoard) => {\n    const { keyDown, pointerUp, globalPointerUp, buildFragment, insertFragment, deleteFragment, afterChange } = board;\n\n    board.pointerUp = (event: PointerEvent) => {\n        const elementOfFocusedImage = getElementOfFocusedImage(board);\n        if (\n            elementOfFocusedImage &&\n            MindElement.isMindElement(board, elementOfFocusedImage) &&\n            !isContextmenu(event) &&\n            (PlaitBoard.isReadonly(board) || !isMainPointer(event) || !PlaitBoard.isPointer(board, PlaitPointerType.selection))\n        ) {\n            removeImageFocus(board, elementOfFocusedImage as MindElement<ImageData>);\n            pointerUp(event);\n            return;\n        }\n        if (PlaitBoard.isReadonly(board)) {\n            pointerUp(event);\n            return;\n        }\n        const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n        const hitElement = getHitElementByPoint(board, point);\n        const isHitImageResult =\n            hitElement &&\n            MindElement.isMindElement(board, hitElement) &&\n            MindElement.hasImage(hitElement) &&\n            isHitImage(board, hitElement as MindElement<ImageData>, point);\n        if (isHitImageResult && elementOfFocusedImage && hitElement === elementOfFocusedImage) {\n            temporaryDisableSelection(board as PlaitOptionsBoard);\n            pointerUp(event);\n            return;\n        }\n        if (elementOfFocusedImage && MindElement.isMindElement(board, elementOfFocusedImage)) {\n            removeImageFocus(board, elementOfFocusedImage as MindElement<ImageData>);\n        }\n        if (isHitImageResult && hitElement) {\n            temporaryDisableSelection(board as PlaitOptionsBoard);\n            addImageFocus(board, hitElement as MindElement<ImageData>);\n        }\n        pointerUp(event);\n    };\n\n    board.keyDown = (event: KeyboardEvent) => {\n        const selectedImageElement = getElementOfFocusedImage(board);\n        if (!PlaitBoard.isReadonly(board) && selectedImageElement && (hotkeys.isDeleteBackward(event) || hotkeys.isDeleteForward(event))) {\n            addSelectedElement(board, selectedImageElement);\n            MindTransforms.removeImage(board, selectedImageElement as MindElement<ImageData>);\n            return;\n        }\n        keyDown(event);\n    };\n\n    board.globalPointerUp = (event: PointerEvent) => {\n        if (PlaitBoard.isFocus(board)) {\n            const isInBoard = event.target instanceof Node && PlaitBoard.getBoardContainer(board).contains(event.target);\n            const selectedImageElement = getElementOfFocusedImage(board);\n            // Clear image selection when mouse board outside area\n            if (selectedImageElement && MindElement.isMindElement(board, selectedImageElement) && !isInBoard) {\n                removeImageFocus(board, selectedImageElement as MindElement<ImageData>);\n            }\n        }\n        globalPointerUp(event);\n    };\n\n    board.buildFragment = (\n        clipboardContext: WritableClipboardContext | null,\n        rectangle: RectangleClient | null,\n        operationType: WritableClipboardOperationType,\n        originData?: PlaitElement[]\n    ) => {\n        const selectedImageElement = getElementOfFocusedImage(board) as MindElement<ImageData>;\n        if (selectedImageElement) {\n            clipboardContext = createClipboardContext(WritableClipboardType.medias, [selectedImageElement.data.image], '');\n        }\n        return buildFragment(clipboardContext, rectangle, operationType, originData);\n    };\n\n    board.deleteFragment = (elements: PlaitElement[]) => {\n        const selectedImageElement = getElementOfFocusedImage(board);\n        if (selectedImageElement) {\n            MindTransforms.removeImage(board, selectedImageElement as MindElement<ImageData>);\n        }\n        deleteFragment(elements);\n    };\n\n    board.insertFragment = (clipboardData: ClipboardData | null, targetPoint: Point, operationType?: WritableClipboardOperationType) => {\n        const selectedElements = getSelectedElements(board);\n        const isSelectedImage = !!getElementOfFocusedImage(board);\n        const isSingleSelection = selectedElements.length === 1 && MindElement.isMindElement(board, selectedElements[0]);\n        if (isSelectedImage || isSingleSelection) {\n            if (clipboardData?.files?.length) {\n                const acceptImageArray = acceptImageTypes.map((type) => 'image/' + type);\n                const selectedElement = (selectedElements[0] || getElementOfFocusedImage(board)) as MindElement;\n                if (acceptImageArray.includes(clipboardData.files[0].type)) {\n                    const imageFile = clipboardData.files[0];\n                    buildImage(board, imageFile, DEFAULT_MIND_IMAGE_WIDTH, (imageItem) => {\n                        MindTransforms.setImage(board, selectedElement, imageItem);\n                    });\n                    return;\n                }\n            }\n            if (clipboardData?.medias?.length) {\n                const selectedElement = (selectedElements[0] || getElementOfFocusedImage(board)) as MindElement;\n                MindTransforms.setImage(board, selectedElement, clipboardData.medias[0]);\n                return;\n            }\n        }\n        insertFragment(clipboardData, targetPoint, operationType);\n    };\n\n    board.afterChange = () => {\n        afterChange();\n        const selectedImageElement = getElementOfFocusedImage(board);\n        if (selectedImageElement && MindElement.isMindElement(board, selectedImageElement)) {\n            const commonElementRef = PlaitElement.getElementRef<PlaitCommonElementRef>(selectedImageElement);\n            const imageGenerator = commonElementRef.getGenerator<ImageGenerator>(ImageGenerator.key);\n            imageGenerator.setFocus(selectedImageElement, true);\n        }\n    };\n\n    return board;\n};\n", "import {\n    Path,\n    PlaitBoard,\n    PlaitNode,\n    Point,\n    RectangleClient,\n    ResizeCursorClass,\n    distanceBetweenPointAndRectangle,\n    getSelectedElements\n} from '@plait/core';\nimport { MindElement } from '../interfaces/element';\nimport { getRectangleByNode } from '../utils/position/node';\nimport { NodeSpace } from '../utils/space/node-space';\nimport { PlaitMindBoard } from './with-mind.board';\nimport { MindTransforms } from '../transforms';\nimport { RESIZE_HANDLE_BUFFER_DISTANCE } from '../constants/default';\nimport { ResizeRef, ResizeState, TextManage, WithResizeOptions, getFirstTextManage, withResize } from '@plait/common';\n\ninterface TargetElementRef {\n    minWidth: number;\n    currentWidth: number;\n    path: Path;\n    textManage: TextManage;\n}\n\nexport const withNodeResize = (board: PlaitBoard) => {\n    let targetElementRef: TargetElementRef | null = null;\n    const options: WithResizeOptions<MindElement, null> = {\n        key: 'mind-node',\n        canResize: () => {\n            return true;\n        },\n        hitTest: (point: Point) => {\n            const newTargetElement = getSelectedTarget(board as PlaitMindBoard, point);\n            if (newTargetElement) {\n                return {\n                    element: newTargetElement,\n                    handle: null,\n                    cursorClass: ResizeCursorClass.ew\n                };\n            }\n            return null;\n        },\n        beforeResize: (resizeRef: ResizeRef<MindElement, null>) => {\n            targetElementRef = {\n                minWidth: NodeSpace.getNodeResizableMinWidth(board as PlaitMindBoard, resizeRef.element),\n                currentWidth: NodeSpace.getTopicDynamicWidth(board as PlaitMindBoard, resizeRef.element),\n                path: PlaitBoard.findPath(board, resizeRef.element),\n                textManage: getFirstTextManage(resizeRef.element)\n            };\n        },\n        onResize: (resizeRef: ResizeRef<MindElement, null>, resizeState: ResizeState) => {\n            let resizedWidth = targetElementRef!.currentWidth + Point.getOffsetX(resizeState.startPoint, resizeState.endPoint);\n            if (resizedWidth <= targetElementRef!.minWidth) {\n                resizedWidth = targetElementRef!.minWidth;\n            }\n            const newTarget = PlaitNode.get<MindElement>(board, targetElementRef!.path);\n            if (newTarget && NodeSpace.getNodeTopicMinWidth(board as PlaitMindBoard, newTarget) !== resizedWidth) {\n                targetElementRef!.textManage.updateRectangleWidth(resizedWidth);\n                const { height } = targetElementRef!.textManage.getSize(undefined, resizedWidth);\n                MindTransforms.setNodeManualWidth(board as PlaitMindBoard, newTarget, resizedWidth, height);\n            }\n        },\n        afterResize: (resizeRef: ResizeRef<MindElement, null>) => {\n            targetElementRef = null;\n        }\n    };\n    withResize<MindElement, null>(board, options);\n    return board;\n};\n\nexport const getSelectedTarget = (board: PlaitMindBoard, point: Point) => {\n    const selectedElements = getSelectedElements(board).filter((value) => MindElement.isMindElement(board, value)) as MindElement[];\n    if (selectedElements.length > 0) {\n        const target = selectedElements.find((value) => {\n            const rectangle = getResizeActiveRectangle(board, value);\n            return distanceBetweenPointAndRectangle(point[0], point[1], rectangle) <= 0;\n        });\n        return target ? target : null;\n    }\n    return null;\n};\n\nexport const getResizeActiveRectangle = (board: PlaitBoard, element: MindElement): RectangleClient => {\n    const node = MindElement.getNode(element);\n    const rectangle = getRectangleByNode(node);\n    return {\n        x: rectangle.x + rectangle.width - RESIZE_HANDLE_BUFFER_DISTANCE,\n        y: rectangle.y,\n        width: RESIZE_HANDLE_BUFFER_DISTANCE * 2,\n        height: rectangle.height\n    };\n};\n", "import { PlaitBoard, Point, PlaitNode, Path } from '@plait/core';\nimport { MindElement } from '../interfaces';\nimport { ImageData } from '../interfaces/element-data';\nimport { getHitImageResizeHandleDirection } from '../utils';\nimport {\n    ResizeHandle,\n    ResizeRef,\n    ResizeState,\n    WithResizeOptions,\n    addElementOfFocusedImage,\n    getElementOfFocusedImage,\n    withResize\n} from '@plait/common';\nimport { MindTransforms } from '../transforms';\n\nexport const withNodeImageResize = (board: PlaitBoard) => {\n    const options: WithResizeOptions<MindElement<ImageData>> = {\n        key: 'mind-node-image',\n        canResize: () => {\n            return true;\n        },\n        hitTest: (point: Point) => {\n            const elementOfFocusedImage = getElementOfFocusedImage(board);\n            const selectedMindElement =\n                elementOfFocusedImage && MindElement.isMindElement(board, elementOfFocusedImage) ? elementOfFocusedImage : undefined;\n            if (selectedMindElement) {\n                const result = getHitImageResizeHandleDirection(board, selectedMindElement as MindElement<ImageData>, point);\n                if (result) {\n                    return {\n                        element: selectedMindElement as MindElement<ImageData>,\n                        handle: result.handle as ResizeHandle,\n                        cursorClass: result.cursorClass\n                    };\n                }\n            }\n            return null;\n        },\n        onResize: (resizeRef: ResizeRef<MindElement<ImageData>>, resizeState: ResizeState) => {\n            const offsetX = Point.getOffsetX(resizeState.startPoint, resizeState.endPoint);\n            const originWidth = resizeRef.element.data.image.width;\n            const originHeight = resizeRef.element.data.image.height;\n            const path = resizeRef.path as Path;\n            let width = originWidth + offsetX;\n            if (width <= 100) {\n                width = 100;\n            }\n            const ratio = originWidth / originHeight;\n            const height = width / ratio;\n            const imageItem = { ...resizeRef.element.data.image, width, height };\n            MindTransforms.setImage(board, PlaitNode.get(board, path), imageItem);\n            addElementOfFocusedImage(board, PlaitNode.get(board, path));\n        }\n    };\n\n    withResize<MindElement<ImageData>>(board, options);\n\n    return board;\n};\n", "import { getSelectedElements, Path, PlaitBoard, PlaitElement, Point, Transforms, WritableClipboardOperationType } from '@plait/core';\nimport { MindElement, PlaitMind } from '../interfaces';\nimport { copyNewNode } from './mind';\nimport { getRectangleByNode } from './position/node';\nimport { AbstractNode, getNonAbstractChildren } from '@plait/layouts';\nimport { getRelativeStartEndByAbstractRef, getOverallAbstracts, getValidAbstractRefs } from './abstract/common';\nimport { createMindElement } from './node/create-node';\nimport { adjustAbstractToNode, adjustNodeToRoot, adjustRootToNode } from './node/adjust-node';\nimport { Element } from 'slate';\nimport { findNewChildNodePath } from './path';\nimport { PlaitMindBoard } from '../plugins/with-mind.board';\nimport { getFontSizeBySlateElement } from './space/node-space';\nimport { buildText } from '@plait/common';\nimport { getTopicSize } from './common';\n\nexport const buildClipboardData = (board: PlaitBoard, selectedElements: MindElement[], startPoint: Point) => {\n    let result: MindElement[] = [];\n\n    // get overall abstract\n    const overallAbstracts = getOverallAbstracts(board, selectedElements) as MindElement[];\n    // get valid abstract refs\n    const validAbstractRefs = getValidAbstractRefs(board, [...selectedElements, ...overallAbstracts]);\n\n    // keep correct order\n    const newSelectedElements = selectedElements.filter((value) => !validAbstractRefs.find((ref) => ref.abstract === value));\n    newSelectedElements.push(...validAbstractRefs.map((value) => value.abstract));\n\n    const selectedMindNodes = newSelectedElements.map((value) => MindElement.getNode(value));\n    newSelectedElements.forEach((element, index) => {\n        // handle relative location\n        const nodeRectangle = getRectangleByNode(selectedMindNodes[index]);\n        const points = [[nodeRectangle.x - startPoint[0], nodeRectangle.y - startPoint[1]]] as Point[];\n\n        // handle invalid abstract\n        const abstractRef = validAbstractRefs.find((ref) => ref.abstract === element);\n        if (AbstractNode.isAbstract(element) && abstractRef) {\n            const { start, end } = getRelativeStartEndByAbstractRef(abstractRef, newSelectedElements);\n            result.push({\n                ...element,\n                points,\n                start,\n                end\n            });\n        } else {\n            if (AbstractNode.isAbstract(element)) {\n                let newElement = { ...element, points } as MindElement;\n                delete newElement.start;\n                delete newElement.end;\n                result.push(newElement);\n            } else {\n                result.push({\n                    ...element,\n                    points: points\n                });\n            }\n        }\n    });\n    return result;\n};\n\nexport const insertClipboardData = (\n    board: PlaitMindBoard,\n    elements: PlaitElement[],\n    targetPoint: Point,\n    operationType?: WritableClipboardOperationType\n) => {\n    let newElement: MindElement, path: Path;\n    const selectedElements = getSelectedElements(board);\n    let newELements: PlaitElement[] = [];\n\n    const hasTargetParent = selectedElements.length === 1;\n    const targetParent = selectedElements[0];\n    const targetParentPath = targetParent && PlaitBoard.findPath(board, targetParent);\n    const nonAbstractChildrenLength = targetParent && getNonAbstractChildren(targetParent).length;\n\n    elements.forEach((item: PlaitElement, index: number) => {\n        newElement = copyNewNode(item as MindElement);\n        if (hasTargetParent && operationType !== WritableClipboardOperationType.duplicate) {\n            if (item.isRoot) {\n                newElement = adjustRootToNode(board, newElement);\n                const { width, height } = getTopicSizeByElement(board, newElement, targetParent as MindElement);\n                newElement.width = width;\n                newElement.height = height;\n            }\n            // handle abstract start and end\n            if (AbstractNode.isAbstract(newElement)) {\n                newElement.start = newElement.start + nonAbstractChildrenLength;\n                newElement.end = newElement.end + nonAbstractChildrenLength;\n            }\n            path = [...targetParentPath, nonAbstractChildrenLength + index];\n        } else {\n            const point: Point = [targetPoint[0] + item.points![0][0], targetPoint[1] + item.points![0][1]];\n            newElement.points = [point];\n            if (AbstractNode.isAbstract(item)) {\n                newElement = adjustAbstractToNode(newElement);\n            }\n            if (!item.isRoot) {\n                newElement = adjustNodeToRoot(board, newElement);\n                const { width, height } = getTopicSizeByElement(board, newElement);\n                newElement.width = width;\n                newElement.height = height;\n            }\n            path = [board.children.length];\n        }\n        newELements.push(newElement);\n        Transforms.insertNode(board, newElement, path);\n        return;\n    });\n    Transforms.addSelectionWithTemporaryElements(board, newELements);\n};\n\nexport const insertClipboardText = (board: PlaitMindBoard, targetParent: PlaitElement, text: string | Element) => {\n    const { width, height } = getTopicSize(board, false, PlaitMind.isMind(targetParent), buildText(text));\n    const newElement = createMindElement(text, Math.max(width, getFontSizeBySlateElement(text)), height, {});\n    Transforms.insertNode(board, newElement, findNewChildNodePath(board, targetParent));\n    Transforms.addSelectionWithTemporaryElements(board, [newElement]);\n};\n\nexport const getTopicSizeByElement = (board: PlaitBoard, element: MindElement, parentElement?: MindElement) => {\n    return getTopicSize(\n        board,\n        PlaitMind.isMind(element),\n        (parentElement && PlaitMind.isMind(parentElement)) || false,\n        element.data.topic,\n        element.manualWidth\n    );\n};\n", "import {\n    ClipboardData,\n    Path,\n    PlaitBoard,\n    PlaitElement,\n    PlaitNode,\n    Point,\n    RectangleClient,\n    WritableClipboardContext,\n    WritableClipboardOperationType,\n    WritableClipboardType,\n    addOrCreateClipboardContext,\n    addSelectedElement\n} from '@plait/core';\nimport { MindElement } from '../interfaces';\nimport { AbstractNode } from '@plait/layouts';\nimport { getFirstLevelElement } from '../utils/mind';\nimport { deleteElementsHandleRightNodeCount } from '../utils/node/right-node-count';\nimport { MindTransforms } from '../transforms';\nimport { deleteElementHandleAbstract } from '../utils/abstract/common';\nimport { getSelectedMindElements } from '../utils/node/common';\nimport { PlaitMindBoard } from './with-mind.board';\nimport { buildClipboardData, insertClipboardData, insertClipboardText } from '../utils/clipboard';\nimport { buildText, getElementsText } from '@plait/common';\n\nexport const withMindFragment = (baseBoard: PlaitBoard) => {\n    const board = baseBoard as PlaitBoard & PlaitMindBoard;\n    let firstLevelElements: MindElement[] | null;\n    const { getDeletedFragment, insertFragment, buildFragment, deleteFragment } = board;\n\n    board.getDeletedFragment = (data: PlaitElement[]) => {\n        const targetMindElements = getSelectedMindElements(board);\n        if (targetMindElements.length) {\n            firstLevelElements = getFirstLevelElement(targetMindElements).reverse();\n            const abstractRefs = deleteElementHandleAbstract(board, firstLevelElements);\n            MindTransforms.setAbstractsByRefs(board, abstractRefs);\n            const refs = deleteElementsHandleRightNodeCount(board, targetMindElements);\n            MindTransforms.setRightNodeCountByRefs(board, refs);\n            const deletableElements = getFirstLevelElement(targetMindElements);\n            data.push(...deletableElements);\n        }\n        return getDeletedFragment(data);\n    };\n\n    board.deleteFragment = (elements: PlaitElement[]) => {\n        deleteFragment(elements);\n        if (firstLevelElements) {\n            const nextSelected = getNextSelectedElement(board, firstLevelElements);\n            if (nextSelected) {\n                addSelectedElement(board, nextSelected);\n            }\n            firstLevelElements = null;\n        }\n    };\n\n    board.buildFragment = (\n        clipboardContext: WritableClipboardContext | null,\n        rectangle: RectangleClient | null,\n        operationType: WritableClipboardOperationType,\n        originData?: PlaitElement[]\n    ) => {\n        const targetMindElements = getSelectedMindElements(board, originData);\n        const firstLevelElements = getFirstLevelElement(targetMindElements);\n        if (firstLevelElements.length) {\n            const elements = buildClipboardData(board, firstLevelElements, rectangle ? [rectangle.x, rectangle.y] : [0, 0]);\n            const text = getElementsText(targetMindElements);\n            const addition: WritableClipboardContext = {\n                text,\n                type: WritableClipboardType.elements,\n                elements: elements\n            };\n            clipboardContext = addOrCreateClipboardContext(clipboardContext, addition);\n        }\n        return buildFragment(clipboardContext, rectangle, operationType, originData);\n    };\n\n    board.insertFragment = (clipboardData: ClipboardData | null, targetPoint: Point, operationType?: WritableClipboardOperationType) => {\n        if (clipboardData?.elements?.length) {\n            const mindElements = clipboardData.elements?.filter(value => MindElement.isMindElement(board, value));\n            if (mindElements && mindElements.length > 0) {\n                insertClipboardData(board, mindElements, targetPoint, operationType);\n            }\n        }\n        if (clipboardData?.text) {\n            const mindElements = getSelectedMindElements(board);\n            if (mindElements.length === 1) {\n                insertClipboardText(board, mindElements[0], buildText(clipboardData.text));\n                return;\n            }\n        }\n\n        insertFragment(clipboardData, targetPoint, operationType);\n    };\n\n    return board;\n};\n\nexport const getNextSelectedElement = (board: PlaitBoard, firstLevelElements: MindElement[]) => {\n    let activeElement: MindElement | undefined;\n    const firstLevelElement = firstLevelElements[0];\n    const firstLevelElementPath = PlaitBoard.findPath(board, firstLevelElement);\n\n    let nextSelectedPath = firstLevelElementPath;\n    if (Path.hasPrevious(firstLevelElementPath)) {\n        nextSelectedPath = Path.previous(firstLevelElementPath);\n    }\n\n    if (AbstractNode.isAbstract(firstLevelElement)) {\n        const parent = MindElement.getParent(firstLevelElement);\n        if (!firstLevelElements.includes(parent.children[firstLevelElement.start])) {\n            activeElement = parent.children[firstLevelElement.start];\n        }\n    }\n\n    try {\n        if (!activeElement) {\n            activeElement = PlaitNode.get<MindElement>(board, nextSelectedPath);\n        }\n    } catch (error) {}\n\n    const firstElement = firstLevelElements[0];\n    const firstElementParent = MindElement.findParent(firstElement);\n    const hasSameParent = firstLevelElements.every(element => {\n        return MindElement.findParent(element) === firstElementParent;\n    });\n    if (firstElementParent && hasSameParent && !activeElement) {\n        activeElement = firstElementParent;\n    }\n    return activeElement;\n};\n", "import { PlaitBoard } from '@plait/core';\nimport { RenderComponentRef } from '@plait/common';\nimport { EmojiData, EmojiItem } from '../interfaces/element-data';\nimport { MindElement } from '../interfaces/element';\n\nexport interface PlaitMindEmojiBoard {\n    renderEmoji: (container: Element | DocumentFragment, props: EmojiProps) => EmojiComponentRef;\n}\n\nexport const withEmoji = <T extends PlaitBoard = PlaitBoard>(board: T) => {\n    const newBoard = board as T & PlaitMindEmojiBoard;\n\n    newBoard.renderEmoji = (container: Element | DocumentFragment, props: EmojiProps) => {\n        throw new Error('No implementation for renderEmoji method.');\n    };\n    return newBoard;\n};\n\nexport type EmojiComponentRef = RenderComponentRef<EmojiProps>;\n\nexport interface EmojiProps {\n    board: PlaitBoard;\n    emojiItem: EmojiItem;\n    element: MindElement<EmojiData>;\n    fontSize: number;\n}\n", "import { isNullOrUndefined } from '@plait/core';\nimport { MindElement } from '../interfaces/element';\nimport { ParagraphElement } from '@plait/common';\n\nexport const isNormalizedData = (element: MindElement) => {\n    if (!element.data || !element.data.topic) {\n        return false;\n    }\n    return true;\n};\n\nexport const isNormalizedWidthAndHeight = (element: MindElement) => {\n    if (isNullOrUndefined(element.width) || isNullOrUndefined(element.height)) {\n        return false;\n    }\n    return true;\n};\n\nexport const fixMindElementData = (element: MindElement) => {\n    const emptyTopic = {\n        children: [\n            {\n                text: ''\n            }\n        ]\n    } as ParagraphElement;\n    if (!element.data) {\n        const data = {\n            topic: emptyTopic\n        };\n        element.data = data;\n    } else if (!element.data.topic) {\n        element.data.topic = emptyTopic;\n    }\n};\n\nexport const fixMindElementWidthAndHeight = (element: MindElement) => {\n    if (isNullOrUndefined(element.width)) {\n        element.width = 56;\n    }\n    if (isNullOrUndefined(element.height)) {\n        element.width = 20;\n    }\n};\n", "import {\n    PlaitBoard,\n    PlaitPluginElementContext,\n    RectangleClient,\n    Transforms,\n    Selection,\n    depthFirstRecursion,\n    PlaitElement,\n    getIsRecursionFunc,\n    Point,\n    toHostPoint,\n    toViewBoxPoint\n} from '@plait/core';\nimport { MindElement, PlaitMind } from '../interfaces';\nimport { PlaitMindComponent } from '../mind.component';\nimport { MindNodeComponent } from '../mind-node.component';\nimport { getRectangleByNode, isHitMindElement } from '../utils/position/node';\nimport { withNodeDnd } from './with-node-dnd';\nimport { editTopic } from '../utils/node/common';\nimport { withAbstract } from './with-abstract-resize';\nimport { withMindExtend } from './with-mind-extend';\nimport { withCreateMind } from './with-mind-create';\nimport { withMindHotkey } from './with-mind-hotkey';\nimport { withNodeMore } from './with-node-more';\nimport { withNodeImage } from './with-node-image';\nimport { PlaitMindBoard } from './with-mind.board';\nimport { withNodeResize } from './with-node-resize';\nimport { withNodeImageResize } from './with-node-image-resize';\nimport { withMindFragment } from './with-mind-fragment';\nimport { withEmoji } from '../emoji/with-emoji';\nimport { fixMindElementData, fixMindElementWidthAndHeight, isNormalizedData, isNormalizedWidthAndHeight } from '../utils/normalize';\n\nexport const withMind = (baseBoard: PlaitBoard) => {\n    const board = baseBoard as PlaitBoard & PlaitMindBoard;\n    const {\n        drawElement,\n        dblClick,\n        isRectangleHit,\n        isHit,\n        getRectangle,\n        isMovable,\n        isRecursion,\n        isAlign,\n        isImageBindingAllowed,\n        canAddToGroup,\n        canSetZIndex,\n        isExpanded,\n        getOneHitElement,\n        normalizeElement\n    } = board;\n\n    board.normalizeElement = (context: PlaitPluginElementContext) => {\n        if (PlaitMind.isMind(context.element)) {\n            depthFirstRecursion(context.element, (node) => {\n                if (!isNormalizedData(node)) {\n                    fixMindElementData(node);\n                }\n                if (!isNormalizedWidthAndHeight(node)) {\n                    fixMindElementWidthAndHeight(node);\n                }\n            });\n        }\n        normalizeElement(context);\n    };\n\n    board.drawElement = (context: PlaitPluginElementContext) => {\n        if (PlaitMind.isMind(context.element)) {\n            return PlaitMindComponent;\n        } else if (MindElement.isMindElement(board, context.element)) {\n            return MindNodeComponent;\n        }\n        return drawElement(context);\n    };\n\n    board.applyTheme = (element: PlaitElement) => {\n        const mindElement = element as MindElement;\n        const shouldClearProperty =\n            !PlaitBoard.isBoard(element) && (mindElement?.branchColor || mindElement?.fill || mindElement?.strokeColor);\n        if (PlaitMind.isMind(element) && shouldClearProperty) {\n            const path = PlaitBoard.findPath(board, element);\n            Transforms.setNode(board, { fill: null, strokeColor: null, branchColor: null }, path);\n        }\n    };\n\n    board.getRectangle = (element) => {\n        if (MindElement.isMindElement(board, element)) {\n            if (!PlaitElement.hasMounted(element)) {\n                console.error('mind element has not been mounted');\n            }\n            return getRectangleByNode(MindElement.getNode(element));\n        }\n        return getRectangle(element);\n    };\n\n    board.canAddToGroup = (element: PlaitElement) => {\n        if (MindElement.isMindElement(board, element) && !element.isRoot) {\n            return false;\n        }\n        return canAddToGroup(element);\n    };\n\n    board.canSetZIndex = (element: PlaitElement) => {\n        if (MindElement.isMindElement(board, element) && !element.isRoot) {\n            return false;\n        }\n        return canSetZIndex(element);\n    };\n\n    board.isRecursion = (element) => {\n        if (MindElement.isMindElement(board, element) && element.isCollapsed) {\n            return false;\n        }\n        return isRecursion(element);\n    };\n\n    board.isRectangleHit = (element, selection: Selection) => {\n        if (MindElement.isMindElement(board, element)) {\n            const client = getRectangleByNode(MindElement.getNode(element));\n            const isHit = RectangleClient.isHit(RectangleClient.getRectangleByPoints([selection.anchor, selection.focus]), client);\n            return isHit;\n        }\n        return isRectangleHit(element, selection);\n    };\n\n    board.isHit = (element, point: Point, isStrict?: boolean) => {\n        if (MindElement.isMindElement(board, element)) {\n            const client = getRectangleByNode(MindElement.getNode(element));\n            const isHit = RectangleClient.isHit(RectangleClient.getRectangleByPoints([point, point]), client);\n            return isHit;\n        }\n        return isHit(element, point, isStrict);\n    };\n\n    board.getOneHitElement = (elements) => {\n        const isAllMindElements = elements.every((item) => MindElement.isMindElement(board, item));\n        if (isAllMindElements) {\n            return elements[0];\n        }\n        return getOneHitElement(elements);\n    };\n\n    board.isMovable = (element) => {\n        if (PlaitMind.isMind(element) && element.isRoot) {\n            return true;\n        }\n        return isMovable(element);\n    };\n\n    board.isImageBindingAllowed = (element) => {\n        if (MindElement.isMindElement(board, element)) {\n            return true;\n        }\n        return isImageBindingAllowed(element);\n    };\n\n    board.isAlign = (element: PlaitElement) => {\n        if (PlaitMind.isMind(element) && element.isRoot) {\n            return true;\n        }\n        return isAlign(element);\n    };\n\n    board.isExpanded = (element: PlaitElement) => {\n        if (MindElement.isMindElement(board, element) && !PlaitMind.isMind(element)) {\n            return !element.isCollapsed;\n        }\n        return isExpanded(element);\n    };\n\n    board.dblClick = (event: MouseEvent) => {\n        if (PlaitBoard.isReadonly(board)) {\n            dblClick(event);\n            return;\n        }\n        const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n        board.children\n            .filter((value) => PlaitMind.isMind(value))\n            .forEach((mindMap) => {\n                depthFirstRecursion<MindElement>(\n                    mindMap as MindElement,\n                    (node) => {\n                        if (!PlaitBoard.hasBeenTextEditing(board) && isHitMindElement(board, point, node)) {\n                            editTopic(node);\n                        }\n                    },\n                    getIsRecursionFunc(board)\n                );\n            });\n        if (PlaitBoard.hasBeenTextEditing(board)) {\n            return;\n        }\n        dblClick(event);\n    };\n\n    return withEmoji(\n        withNodeResize(\n            withNodeImageResize(\n                withNodeImage(\n                    withNodeMore(withMindFragment(withMindHotkey(withMindExtend(withCreateMind(withAbstract(withNodeDnd(board)))))))\n                )\n            )\n        )\n    );\n};\n", "import { EmojiData, EmojiItem } from '../interfaces/element-data';\nimport { PlaitBoard } from '@plait/core';\nimport { MindElement } from '../interfaces';\n\nexport abstract class MindEmojiBaseComponent {\n    fontSize: number = 14;\n\n    emojiItem!: EmojiItem;\n\n    board!: PlaitBoard;\n\n    element!: MindElement<EmojiData>;\n\n    abstract nativeElement(): HTMLElement;\n}\n", "/*\n * Public API Surface of mind\n */\n\nexport * from './mind.component';\nexport * from './mind-node.component';\nexport * from './utils';\nexport * from './interfaces';\nexport * from './plugins/with-mind';\nexport * from './plugins/with-mind-extend';\nexport * from './constants';\nexport * from './queries/index';\nexport * from './transforms/index';\nexport * from './emoji';\nexport * from './plugins/with-mind.board';\nexport * from './plugins/with-abstract-resize.board';\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],
  "mappings": "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",
  "names": ["MindLayoutType", "LayoutType", "layout", "depthFirstRecursion", "ConnectingPosition", "abstract", "abstractHandle", "i", "separateYAxle", "child", "indent.separateXAxle", "indent.separateYAxle", "logic.separateYAxle", "logic.buildLayoutTree", "logic.setLayoutTreeResult", "LayoutDirection", "MindPointerType", "MindI18nKey", "value", "selectedElement", "layout", "getLayoutDirection", "Node", "element", "HorizontalPlacement", "VerticalPlacement", "layout", "placement", "parentCenterPoint", "AbstractHandlePosition", "AbstractResizeState", "node", "end", "start", "Path", "MindElementShape", "BranchShape", "_a", "element", "refs", "parent", "emptyMind", "firstLevelElements", "isHit"]
}
