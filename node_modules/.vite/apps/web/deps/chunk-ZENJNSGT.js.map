{
  "version": 3,
  "sources": ["../../../../packages/draw/src/interfaces/geometry.ts", "../../../../packages/draw/src/interfaces/swimlane.ts", "../../../../packages/draw/src/interfaces/table.ts", "../../../../packages/draw/src/constants/default.ts", "../../../../packages/draw/src/constants/geometry.ts", "../../../../packages/draw/src/constants/pointer.ts", "../../../../packages/draw/src/constants/image.ts", "../../../../packages/draw/src/constants/theme.ts", "../../../../packages/draw/src/constants/swimlane.ts", "../../../../packages/draw/src/constants/text.ts", "../../../../packages/draw/src/constants/line.ts", "../../../../packages/draw/src/generators/text.generator.ts", "../../../../packages/draw/src/utils/table-selected.ts", "../../../../packages/draw/src/utils/table.ts", "../../../../packages/draw/src/utils/memorize.ts", "../../../../packages/draw/src/utils/arrow-line/arrow-line-resize.ts", "../../../../packages/draw/src/utils/arrow-line/arrow-line-arrow.ts", "../../../../packages/draw/src/generators/arrow-line.generator.ts", "../../../../packages/draw/src/utils/arrow-line/arrow-line-basic.ts", "../../../../packages/draw/src/utils/position/arrow-line.ts", "../../../../packages/draw/src/utils/multi-text-geometry.ts", "../../../../packages/draw/src/generators/vector-line-generator.ts", "../../../../packages/draw/src/utils/vector-line.ts", "../../../../packages/draw/src/utils/polygon.ts", "../../../../packages/draw/src/engines/basic-shapes/cloud.ts", "../../../../packages/draw/src/utils/hit.ts", "../../../../packages/draw/src/utils/common.ts", "../../../../packages/draw/src/utils/style/stroke.ts", "../../../../packages/draw/src/generators/geometry-shape.generator.ts", "../../../../packages/draw/src/utils/line.ts", "../../../../packages/draw/src/utils/position/line.ts", "../../../../packages/draw/src/generators/line-active.generator.ts", "../../../../packages/draw/src/generators/arrow-line-auto-complete.generator.ts", "../../../../packages/draw/src/generators/single-text.generator.ts", "../../../../packages/draw/src/generators/table.generator.ts", "../../../../packages/draw/src/utils/shape.ts", "../../../../packages/draw/src/utils/uml.ts", "../../../../packages/draw/src/utils/geometry.ts", "../../../../packages/draw/src/utils/arrow-line/elbow.ts", "../../../../packages/draw/src/utils/selected.ts", "../../../../packages/draw/src/transforms/geometry.ts", "../../../../packages/draw/src/transforms/geometry-text.ts", "../../../../packages/draw/src/transforms/image.ts", "../../../../packages/draw/src/transforms/arrow-line.ts", "../../../../packages/draw/src/utils/swimlane.ts", "../../../../packages/draw/src/transforms/swimlane.ts", "../../../../packages/draw/src/transforms/multi-text-geometry-text.ts", "../../../../packages/draw/src/transforms/table-text.ts", "../../../../packages/draw/src/transforms/table.ts", "../../../../packages/draw/src/transforms/vector-line.ts", "../../../../packages/draw/src/transforms/common.ts", "../../../../packages/draw/src/transforms/index.ts", "../../../../packages/draw/src/utils/position/geometry.ts", "../../../../packages/draw/src/plugins/with-draw-resize.ts", "../../../../packages/draw/src/utils/snap-resizing.ts", "../../../../packages/draw/src/utils/clipboard.ts", "../../../../packages/draw/src/engines/basic-shapes/comment.ts", "../../../../packages/draw/src/engines/basic-shapes/polygon.ts", "../../../../packages/draw/src/engines/basic-shapes/cross.ts", "../../../../packages/draw/src/engines/basic-shapes/diamond.ts", "../../../../packages/draw/src/engines/basic-shapes/ellipse.ts", "../../../../packages/draw/src/engines/basic-shapes/hexagon.ts", "../../../../packages/draw/src/engines/basic-shapes/left-arrow.ts", "../../../../packages/draw/src/engines/basic-shapes/octagon.ts", "../../../../packages/draw/src/engines/basic-shapes/parallelogram.ts", "../../../../packages/draw/src/engines/basic-shapes/pentagon.ts", "../../../../packages/draw/src/engines/basic-shapes/pentagon-arrow.ts", "../../../../packages/draw/src/engines/basic-shapes/process-arrow.ts", "../../../../packages/draw/src/engines/basic-shapes/right-arrow.ts", "../../../../packages/draw/src/engines/basic-shapes/rectangle.ts", "../../../../packages/draw/src/engines/basic-shapes/round-rectangle.ts", "../../../../packages/draw/src/engines/basic-shapes/round-comment.ts", "../../../../packages/draw/src/engines/basic-shapes/trapezoid.ts", "../../../../packages/draw/src/engines/basic-shapes/triangle.ts", "../../../../packages/draw/src/engines/basic-shapes/two-way-arrow.ts", "../../../../packages/draw/src/engines/basic-shapes/star.ts", "../../../../packages/draw/src/engines/flowchart/terminal.ts", "../../../../packages/draw/src/engines/flowchart/manual-input.ts", "../../../../packages/draw/src/engines/flowchart/preparation.ts", "../../../../packages/draw/src/engines/flowchart/manual-loop.ts", "../../../../packages/draw/src/engines/flowchart/merge.ts", "../../../../packages/draw/src/engines/flowchart/delay.ts", "../../../../packages/draw/src/engines/flowchart/stored-data.ts", "../../../../packages/draw/src/engines/flowchart/predefined-process.ts", "../../../../packages/draw/src/engines/flowchart/off-page.ts", "../../../../packages/draw/src/engines/flowchart/or.ts", "../../../../packages/draw/src/engines/flowchart/summing-junction.ts", "../../../../packages/draw/src/engines/flowchart/document.ts", "../../../../packages/draw/src/engines/flowchart/multi-document.ts", "../../../../packages/draw/src/engines/flowchart/database.ts", "../../../../packages/draw/src/engines/flowchart/hard-disk.ts", "../../../../packages/draw/src/engines/flowchart/internal-storage.ts", "../../../../packages/draw/src/engines/flowchart/note-curly-left.ts", "../../../../packages/draw/src/engines/flowchart/note-curly-right.ts", "../../../../packages/draw/src/engines/flowchart/note-square.ts", "../../../../packages/draw/src/engines/flowchart/display.ts", "../../../../packages/draw/src/engines/table/table.ts", "../../../../packages/draw/src/engines/uml/actor.ts", "../../../../packages/draw/src/engines/uml/container.ts", "../../../../packages/draw/src/engines/uml/package.ts", "../../../../packages/draw/src/engines/uml/combined-fragment.ts", "../../../../packages/draw/src/engines/uml/deletion.ts", "../../../../packages/draw/src/engines/uml/activity-class.ts", "../../../../packages/draw/src/engines/uml/note.ts", "../../../../packages/draw/src/engines/uml/assembly.ts", "../../../../packages/draw/src/engines/uml/required-interface.ts", "../../../../packages/draw/src/engines/uml/provided-interface.ts", "../../../../packages/draw/src/engines/uml/component.ts", "../../../../packages/draw/src/engines/uml/component-box.ts", "../../../../packages/draw/src/engines/uml/template.ts", "../../../../packages/draw/src/engines/index.ts", "../../../../packages/draw/src/utils/arrow-line/arrow-line-common.ts", "../../../../packages/draw/src/interfaces/arrow-line.ts", "../../../../packages/draw/src/interfaces/element.ts", "../../../../packages/draw/src/interfaces/vector-line.ts", "../../../../packages/draw/src/interfaces/index.ts", "../../../../packages/draw/src/geometry.component.ts", "../../../../packages/draw/src/arrow-line.component.ts", "../../../../packages/draw/src/vector-line.component.ts", "../../../../packages/draw/src/plugins/with-draw-hotkey.ts", "../../../../packages/draw/src/plugins/with-geometry-create.ts", "../../../../packages/draw/src/plugins/with-draw-fragment.ts", "../../../../packages/draw/src/plugins/arrow-line/with-arrow-line-create.ts", "../../../../packages/draw/src/plugins/arrow-line/with-arrow-line-resize.ts", "../../../../packages/draw/src/plugins/arrow-line/with-arrow-line-bound-reaction.ts", "../../../../packages/draw/src/plugins/arrow-line/with-arrow-line-text.ts", "../../../../packages/draw/src/image.component.ts", "../../../../packages/draw/src/plugins/arrow-line/with-arrow-line-auto-complete.ts", "../../../../packages/draw/src/plugins/arrow-line/with-arrow-line-auto-complete-reaction.ts", "../../../../packages/draw/src/plugins/arrow-line/with-arrow-line-text-move.ts", "../../../../packages/draw/src/plugins/with-draw-rotate.ts", "../../../../packages/draw/src/table.component.ts", "../../../../packages/draw/src/plugins/with-table-resize.ts", "../../../../packages/draw/src/plugins/with-table.ts", "../../../../packages/draw/src/plugins/with-swimlane-create.ts", "../../../../packages/draw/src/plugins/with-swimlane.ts", "../../../../packages/draw/src/plugins/with-vector-line-create.ts", "../../../../packages/draw/src/plugins/with-vector-line-resize.ts", "../../../../packages/draw/src/plugins/with-draw.ts", "../../../../packages/draw/src/plait-draw.ts"],
  "sourcesContent": ["import { PlaitElement, Point } from '@plait/core';\nimport { DrawTextInfo } from '../generators/text.generator';\nimport { ParagraphElement, StrokeStyle } from '@plait/common';\n\nexport enum BasicShapes {\n    rectangle = 'rectangle',\n    ellipse = 'ellipse',\n    diamond = 'diamond',\n    roundRectangle = 'roundRectangle',\n    parallelogram = 'parallelogram',\n    text = 'text',\n    triangle = 'triangle',\n    leftArrow = 'leftArrow',\n    trapezoid = 'trapezoid',\n    rightArrow = 'rightArrow',\n    cross = 'cross',\n    star = 'star',\n    pentagon = 'pentagon',\n    hexagon = 'hexagon',\n    octagon = 'octagon',\n    pentagonArrow = 'pentagonArrow',\n    processArrow = 'processArrow',\n    twoWayArrow = 'twoWayArrow',\n    comment = 'comment',\n    roundComment = 'roundComment',\n    cloud = 'cloud'\n}\n\nexport enum FlowchartSymbols {\n    process = 'process',\n    decision = 'decision',\n    data = 'data',\n    connector = 'connector',\n    terminal = 'terminal',\n    manualInput = 'manualInput',\n    preparation = 'preparation',\n    manualLoop = 'manualLoop',\n    merge = 'merge',\n    delay = 'delay',\n    storedData = 'storedData',\n    or = 'or',\n    summingJunction = 'summingJunction',\n    predefinedProcess = 'predefinedProcess',\n    offPage = 'offPage',\n    document = 'document',\n    multiDocument = 'multiDocument',\n    database = 'database',\n    hardDisk = 'hardDisk',\n    internalStorage = 'internalStorage',\n    noteCurlyRight = 'noteCurlyRight',\n    noteCurlyLeft = 'noteCurlyLeft',\n    noteSquare = 'noteSquare',\n    display = 'display'\n}\n\nexport enum UMLSymbols {\n    actor = 'actor',\n    useCase = 'useCase',\n    container = 'container',\n    note = 'note',\n    simpleClass = 'simpleClass',\n    activityClass = 'activityClass',\n    branchMerge = 'branchMerge',\n    port = 'port',\n    package = 'package',\n    combinedFragment = 'combinedFragment',\n    class = 'class',\n    interface = 'interface',\n    object = 'object',\n    component = 'component',\n    componentBox = 'componentBox',\n    template = 'template',\n    activation = 'activation',\n    deletion = 'deletion',\n    assembly = 'assembly',\n    providedInterface = 'providedInterface',\n    requiredInterface = 'requiredInterface'\n}\n\nexport enum GeometryCommonTextKeys {\n    name = 'name',\n    content = 'content'\n}\n\nexport type GeometryShapes = BasicShapes | FlowchartSymbols | UMLSymbols;\n\nexport type SwimlaneDirection = 'horizontal' | 'vertical';\n\nexport interface PlaitBaseGeometry<T extends string = 'geometry', P extends Point[] = [Point, Point], S extends string = GeometryShapes>\n    extends PlaitElement {\n    type: T;\n    points: P;\n    shape: S;\n}\n\nexport interface PlaitCommonGeometry<T extends string = 'geometry', P extends Point[] = [Point, Point], S extends string = GeometryShapes>\n    extends PlaitBaseGeometry<T, P, S> {\n    // node style attributes\n    fill?: string;\n    strokeColor?: string;\n    strokeWidth?: number;\n    strokeStyle?: StrokeStyle;\n    angle?: number;\n    opacity?: number;\n}\n\nexport interface PlaitCustomGeometry<T extends string = string, P extends Point[] = Point[], S extends string = string>\n    extends PlaitBaseGeometry<T, P, S> {}\n\nexport interface PlaitMultipleTextGeometry extends PlaitCommonGeometry {\n    texts: DrawTextInfo[];\n}\n\nexport interface PlaitGeometry extends PlaitCommonGeometry {\n    text?: ParagraphElement;\n    textHeight?: number;\n}\n\nexport interface PlaitRectangle extends PlaitGeometry {\n    shape: BasicShapes.rectangle;\n}\n\nexport interface PlaitEllipse extends PlaitGeometry {\n    shape: BasicShapes.ellipse;\n}\n\nexport interface PlaitDiamond extends PlaitGeometry {\n    shape: BasicShapes.diamond;\n}\n\nexport const PlaitGeometry = {};\n", "import { PlaitBaseTable } from './table';\n\nexport enum SwimlaneSymbols {\n    swimlaneVertical = 'swimlaneVertical',\n    swimlaneHorizontal = 'swimlaneHorizontal'\n}\n\nexport enum SwimlaneDrawSymbols {\n    swimlaneVertical = 'swimlaneVertical',\n    swimlaneHorizontal = 'swimlaneHorizontal',\n    swimlaneVerticalWithHeader = 'swimlaneVerticalWithHeader',\n    swimlaneHorizontalWithHeader = 'swimlaneHorizontalWithHeader'\n}\n\nexport interface PlaitSwimlane extends PlaitBaseTable {\n    type: 'swimlane';\n    shape: SwimlaneSymbols;\n    header?: boolean;\n}\n\nexport interface PlaitSwimlaneVertical extends PlaitSwimlane {\n    shape: SwimlaneSymbols.swimlaneVertical;\n}\n\nexport interface PlaitSwimlaneHorizontal extends PlaitSwimlane {\n    shape: SwimlaneSymbols.swimlaneHorizontal;\n}\n", "import { PlaitBoard, PlaitElement, Point } from '@plait/core';\nimport { ParagraphElement } from '@plait/common';\nimport { DrawOptions } from './engine';\n\nexport enum TableSymbols {\n    table = 'table'\n}\n\nexport interface PlaitTableBoard extends PlaitBoard {\n    buildTable: (element: PlaitBaseTable) => PlaitBaseTable;\n}\n\nexport interface PlaitBaseTable extends PlaitElement {\n    id: string;\n    points: Point[];\n    rows: {\n        id: string;\n        height?: number;\n    }[];\n    columns: {\n        id: string;\n        width?: number;\n    }[];\n    cells: PlaitTableCell[];\n    groupId?: string;\n}\n\nexport interface PlaitTable extends PlaitBaseTable {\n    type: 'table';\n}\n\nexport interface PlaitTableCell {\n    id: string;\n    rowId: string;\n    columnId: string;\n    colspan?: number;\n    rowspan?: number;\n    text?: PlaitTableCellParagraph;\n    textHeight?: number;\n    fill?: string;\n}\n\nexport interface PlaitTableDrawOptions extends DrawOptions {\n    element: PlaitTable;\n}\n\nexport interface PlaitTableCellWithPoints extends PlaitTableCell {\n    points: [Point, Point];\n}\n\nexport interface PlaitTableCellParagraph extends ParagraphElement {\n    direction?: 'vertical' | 'horizontal';\n}\n\nexport const PlaitTableElement = {\n    isTable: (value: any): value is PlaitTable => {\n        return value.type === 'table';\n    },\n    isVerticalText: (value: PlaitTableCell): value is PlaitTableCell => {\n        return value.text?.direction === 'vertical';\n    }\n};\n", "export const WithDrawPluginKey = 'plait-draw-plugin-key';\n\nexport enum DrawI18nKey {\n    lineText = 'line-text',\n    geometryText = 'geometry-text'\n}", "import { ACTIVE_STROKE_WIDTH, DEFAULT_COLOR } from '@plait/core';\nimport { BasicShapes, FlowchartSymbols, GeometryShapes, GeometryCommonTextKeys, UMLSymbols } from '../interfaces';\nimport { Alignment, DEFAULT_FILL } from '@plait/common';\n\nexport const ShapeDefaultSpace = {\n    rectangleAndText: 4\n};\n\nexport const DefaultDrawStyle = {\n    strokeWidth: 2,\n    defaultRadius: 4,\n    strokeColor: '#000',\n    fill: DEFAULT_FILL\n};\n\nexport const DefaultDrawActiveStyle = {\n    strokeWidth: ACTIVE_STROKE_WIDTH,\n    selectionStrokeWidth: ACTIVE_STROKE_WIDTH\n};\n\nexport const DefaultBasicShapeProperty = {\n    width: 100,\n    height: 100,\n    strokeColor: DEFAULT_COLOR,\n    strokeWidth: 2\n};\n\nexport const DefaultPentagonArrowProperty = {\n    width: 120,\n    height: 50\n};\n\nexport const DefaultTwoWayArrowProperty = {\n    width: 138,\n    height: 80\n};\n\nexport const DefaultArrowProperty = {\n    width: 100,\n    height: 80\n};\n\nexport const DefaultCloudProperty = {\n    width: 120,\n    height: 100\n};\n\nexport const DefaultTextProperty = {\n    width: 36,\n    height: 20,\n    text: '文本'\n};\n\nexport const GeometryThreshold = {\n    defaultTextMaxWidth: 34 * 14\n};\n\nexport const DefaultConnectorProperty = {\n    width: 44,\n    height: 44\n};\n\nexport const DefaultFlowchartProperty = {\n    width: 120,\n    height: 60\n};\n\nexport const DefaultDataBaseProperty = {\n    width: 70,\n    height: 80\n};\n\nexport const DefaultInternalStorageProperty = {\n    width: 80,\n    height: 80\n};\n\nexport const DefaultDecisionProperty = {\n    width: 140,\n    height: 70\n};\n\nexport const DefaultDataProperty = {\n    width: 124,\n    height: 60\n};\n\nexport const DefaultDocumentProperty = {\n    width: 120,\n    height: 70\n};\n\nexport const DefaultNoteProperty = {\n    width: 160,\n    height: 100\n};\n\nexport const DefaultMultiDocumentProperty = {\n    width: 120,\n    height: 80\n};\n\nexport const DefaultManualInputProperty = {\n    width: 117,\n    height: 59\n};\n\nexport const DefaultMergeProperty = {\n    width: 47,\n    height: 33\n};\n\nexport const DefaultActorProperty = {\n    width: 68,\n    height: 100\n};\n\nexport const DefaultContainerProperty = {\n    width: 300,\n    height: 240\n};\n\nexport const DefaultPackageProperty = {\n    width: 210,\n    height: 150,\n    texts: [\n        {\n            id: GeometryCommonTextKeys.name,\n            text: '包名',\n            align: Alignment.left\n        },\n        {\n            id: GeometryCommonTextKeys.content,\n            text: '',\n            align: Alignment.left\n        }\n    ]\n};\n\nexport const DefaultActivationProperty = {\n    width: 18,\n    height: 80\n};\n\nexport const DefaultObjectProperty = {\n    width: 120,\n    height: 60\n};\n\nexport const DefaultComponentBoxProperty = {\n    width: 200,\n    height: 150\n};\n\nexport const DefaultDeletionProperty = {\n    width: 40,\n    height: 40\n};\n\nexport const DefaultPortProperty = {\n    width: 20,\n    height: 20\n};\n\nexport const DefaultRequiredInterfaceProperty = {\n    width: 70,\n    height: 56\n};\n\nexport const DefaultAssemblyProperty = {\n    width: 120,\n    height: 56\n};\n\nexport const DefaultProvidedInterfaceProperty = {\n    width: 70,\n    height: 34\n};\n\nexport const DefaultCombinedFragmentProperty = {\n    width: 400,\n    height: 280,\n    texts: [\n        {\n            id: GeometryCommonTextKeys.name,\n            text: 'Opt | Alt | Loop',\n            align: Alignment.left\n        },\n        {\n            id: GeometryCommonTextKeys.content,\n            text: '[Condition]',\n            align: Alignment.left\n        }\n    ]\n};\n\nexport const DefaultClassProperty = {\n    width: 230,\n    height: 180,\n    texts: [\n        { text: 'Class', align: Alignment.center },\n        {\n            text: '+ attribute1:type  defaultValue\\n+ attribute2:type\\n- attribute3:type',\n            align: Alignment.left\n        },\n        {\n            text: '+ operation1(params):returnType\\n- operation2(params)\\n- operation3()',\n            align: Alignment.left\n        }\n    ]\n};\n\nexport const DefaultInterfaceProperty = {\n    width: 230,\n    height: 140,\n    texts: [\n        { text: '<<interface>>\\nInterface', align: Alignment.center },\n        {\n            text: '+ operation1(params):returnType\\n- operation2(params)\\n- operation3()',\n            align: Alignment.left\n        }\n    ]\n};\n\nexport const DefaultBasicShapePropertyMap: Record<string, { width: number; height: number }> = {\n    [BasicShapes.pentagonArrow]: DefaultPentagonArrowProperty,\n    [BasicShapes.processArrow]: DefaultPentagonArrowProperty,\n    [BasicShapes.cloud]: DefaultCloudProperty,\n    [BasicShapes.twoWayArrow]: DefaultTwoWayArrowProperty,\n    [BasicShapes.leftArrow]: DefaultArrowProperty,\n    [BasicShapes.rightArrow]: DefaultArrowProperty\n};\n\nexport const DefaultFlowchartPropertyMap = {\n    [FlowchartSymbols.connector]: DefaultConnectorProperty,\n    [FlowchartSymbols.process]: DefaultFlowchartProperty,\n    [FlowchartSymbols.decision]: DefaultDecisionProperty,\n    [FlowchartSymbols.data]: DefaultDataProperty,\n    [FlowchartSymbols.terminal]: DefaultFlowchartProperty,\n    [FlowchartSymbols.manualInput]: DefaultManualInputProperty,\n    [FlowchartSymbols.preparation]: DefaultFlowchartProperty,\n    [FlowchartSymbols.manualLoop]: DefaultFlowchartProperty,\n    [FlowchartSymbols.merge]: DefaultMergeProperty,\n    [FlowchartSymbols.delay]: DefaultFlowchartProperty,\n    [FlowchartSymbols.storedData]: DefaultFlowchartProperty,\n    [FlowchartSymbols.or]: DefaultConnectorProperty,\n    [FlowchartSymbols.summingJunction]: DefaultConnectorProperty,\n    [FlowchartSymbols.predefinedProcess]: DefaultFlowchartProperty,\n    [FlowchartSymbols.offPage]: DefaultFlowchartProperty,\n    [FlowchartSymbols.document]: DefaultDocumentProperty,\n    [FlowchartSymbols.multiDocument]: DefaultMultiDocumentProperty,\n    [FlowchartSymbols.database]: DefaultDataBaseProperty,\n    [FlowchartSymbols.hardDisk]: DefaultFlowchartProperty,\n    [FlowchartSymbols.internalStorage]: DefaultInternalStorageProperty,\n    [FlowchartSymbols.noteCurlyLeft]: DefaultNoteProperty,\n    [FlowchartSymbols.noteCurlyRight]: DefaultNoteProperty,\n    [FlowchartSymbols.noteSquare]: DefaultNoteProperty,\n    [FlowchartSymbols.display]: DefaultFlowchartProperty\n};\n\nexport const DefaultUMLPropertyMap = {\n    [UMLSymbols.actor]: DefaultActorProperty,\n    [UMLSymbols.useCase]: DefaultDocumentProperty,\n    [UMLSymbols.container]: DefaultContainerProperty,\n    [UMLSymbols.note]: DefaultObjectProperty,\n    [UMLSymbols.package]: DefaultPackageProperty,\n    [UMLSymbols.combinedFragment]: DefaultCombinedFragmentProperty,\n    [UMLSymbols.class]: DefaultClassProperty,\n    [UMLSymbols.interface]: DefaultInterfaceProperty,\n    [UMLSymbols.activation]: DefaultActivationProperty,\n    [UMLSymbols.object]: DefaultObjectProperty,\n    [UMLSymbols.deletion]: DefaultDeletionProperty,\n    [UMLSymbols.activityClass]: DefaultObjectProperty,\n    [UMLSymbols.simpleClass]: DefaultObjectProperty,\n    [UMLSymbols.component]: DefaultMultiDocumentProperty,\n    [UMLSymbols.template]: DefaultMultiDocumentProperty,\n    [UMLSymbols.componentBox]: DefaultComponentBoxProperty,\n    [UMLSymbols.port]: DefaultPortProperty,\n    [UMLSymbols.branchMerge]: DefaultDeletionProperty,\n    [UMLSymbols.assembly]: DefaultAssemblyProperty,\n    [UMLSymbols.providedInterface]: DefaultProvidedInterfaceProperty,\n    [UMLSymbols.requiredInterface]: DefaultRequiredInterfaceProperty\n};\n\nexport const MultipleTextGeometryTextKeys: { [key in GeometryShapes]?: string[] } = {\n    [UMLSymbols.package]: Object.keys(GeometryCommonTextKeys),\n    [UMLSymbols.combinedFragment]: Object.keys(GeometryCommonTextKeys)\n};\n\nexport const LINE_HIT_GEOMETRY_BUFFER = 10;\n\nexport const LINE_SNAPPING_BUFFER = 6;\n\nexport const LINE_SNAPPING_CONNECTOR_BUFFER = 8;\n\nexport const GEOMETRY_WITHOUT_TEXT = [\n    FlowchartSymbols.or,\n    FlowchartSymbols.summingJunction,\n    UMLSymbols.activation,\n    UMLSymbols.deletion,\n    UMLSymbols.port,\n    UMLSymbols.branchMerge,\n    UMLSymbols.assembly,\n    UMLSymbols.providedInterface,\n    UMLSymbols.requiredInterface\n] as GeometryShapes[];\n\nexport const GEOMETRY_WITH_MULTIPLE_TEXT = [UMLSymbols.package, UMLSymbols.combinedFragment];\n\nexport const GEOMETRY_NOT_CLOSED = [\n    FlowchartSymbols.noteCurlyLeft,\n    FlowchartSymbols.noteCurlyRight,\n    FlowchartSymbols.noteSquare,\n    UMLSymbols.requiredInterface,\n    UMLSymbols.deletion\n] as GeometryShapes[];\n", "import {\n    BasicShapes,\n    FlowchartSymbols,\n    ArrowLineShape,\n    SwimlaneDrawSymbols,\n    TableSymbols,\n    UMLSymbols,\n    VectorLinePointerType,\n    SwimlaneSymbols\n} from '../interfaces';\n\nexport type DrawPointerType =\n    | BasicShapes\n    | ArrowLineShape\n    | FlowchartSymbols\n    | SwimlaneDrawSymbols\n    | TableSymbols\n    | UMLSymbols\n    | VectorLinePointerType;\n\nexport const getGeometryPointers = () => {\n    return [...Object.keys(BasicShapes), ...Object.keys(FlowchartSymbols), ...Object.keys(UMLSymbols)];\n};\n\nexport const getSwimlanePointers = () => {\n    return Object.keys(SwimlaneDrawSymbols);\n};\n\nexport const getSwimlaneShapes = () => {\n    return Object.keys(SwimlaneSymbols);\n};\n\nexport const getBasicPointers = () => {\n    return Object.keys(BasicShapes);\n};\n\nexport const getFlowchartPointers = () => {\n    return Object.keys(FlowchartSymbols);\n};\n\nexport const getUMLPointers = () => {\n    return Object.keys(UMLSymbols);\n};\n\nexport const getArrowLinePointers = () => {\n    return Object.keys(ArrowLineShape);\n};\n\nexport const getVectorLinePointers = () => {\n    return Object.keys(VectorLinePointerType);\n};\n", "export const DEFAULT_IMAGE_WIDTH = 1000;\n", "import { DEFAULT_COLOR, ThemeColorMode } from '@plait/core';\n\nexport const DrawThemeColors = {\n    [ThemeColorMode.default]: {\n        strokeColor: DEFAULT_COLOR,\n        fill: '#FFFFFF'\n    },\n    [ThemeColorMode.colorful]: {\n        strokeColor: '#06ADBF',\n        fill: '#CDEFF2'\n    },\n    [ThemeColorMode.soft]: {\n        strokeColor: '#6D89C1',\n        fill: '#DADFEB'\n    },\n    [ThemeColorMode.retro]: {\n        strokeColor: '#E9C358',\n        fill: '#F6EDCF'\n    },\n    [ThemeColorMode.dark]: {\n        strokeColor: '#FFFFFF',\n        fill: '#434343'\n    },\n    [ThemeColorMode.starry]: {\n        strokeColor: '#42ABE5',\n        fill: '#163F5A'\n    }\n};\n", "import { SwimlaneDrawSymbols } from '../interfaces/swimlane';\n\nexport const SWIMLANE_HEADER_SIZE = 42;\n\nexport const DefaultSwimlaneVerticalWithHeaderProperty = {\n    width: 580,\n    height: 524\n};\n\nexport const DefaultSwimlaneHorizontalWithHeaderProperty = {\n    width: 524,\n    height: 580\n};\n\nexport const DefaultSwimlaneVerticalProperty = {\n    width: 580,\n    height: 524\n};\n\nexport const DefaultSwimlaneHorizontalProperty = {\n    width: 524,\n    height: 580\n};\n\nexport const DefaultSwimlanePropertyMap: Record<string, { width: number; height: number }> = {\n    [SwimlaneDrawSymbols.swimlaneHorizontal]: DefaultSwimlaneHorizontalProperty,\n    [SwimlaneDrawSymbols.swimlaneVertical]: DefaultSwimlaneVerticalProperty,\n    [SwimlaneDrawSymbols.swimlaneHorizontalWithHeader]: DefaultSwimlaneHorizontalWithHeaderProperty,\n    [SwimlaneDrawSymbols.swimlaneVerticalWithHeader]: DefaultSwimlaneVerticalWithHeaderProperty\n};\n", "export const MIN_TEXT_WIDTH = 5;\n", "export const DefaultLineStyle = {\n    strokeWidth: 2,\n    strokeColor: '#000'\n};\n\nexport const LINE_TEXT_SPACE = 4;\n\nexport const LINE_AUTO_COMPLETE_DIAMETER = 6;\n\nexport const LINE_AUTO_COMPLETE_OPACITY = 1;\n\nexport const LINE_AUTO_COMPLETE_HOVERED_OPACITY = 1;\n\nexport const LINE_AUTO_COMPLETE_HOVERED_DIAMETER = 12;\n\nexport const LINE_ALIGN_TOLERANCE = 3;\n\nexport const LINE_TEXT = '文本';\n", "import {\n    ParagraphElement,\n    PlaitCommonElementRef,\n    TextManage,\n    TextManageChangeData,\n    TextPlugin,\n    WithTextPluginKey,\n    WithTextPluginOptions\n} from '@plait/common';\nimport { PlaitBoard, PlaitElement, PlaitOptionsBoard, RectangleClient } from '@plait/core';\nimport { getEngine } from '../engines';\nimport { DrawShapes, PlaitGeometry, TextRectangleOptions } from '../interfaces';\nimport { getTextKey, getTextRectangle } from '../utils';\n\nexport interface DrawTextInfo extends TextRectangleOptions {\n    text: ParagraphElement;\n    textHeight: number;\n}\n\nexport interface TextGeneratorOptions<T> {\n    onChange: (element: T, textChangeRef: TextManageChangeData, text: DrawTextInfo) => void;\n    getRenderRectangle?: (element: T, text: DrawTextInfo) => RectangleClient;\n    getMaxWidth?: () => number;\n}\n\n// TODO: 是否可以完全基于位置定位 TextManager，实现 line 和 多文本 geometry 统一\n// 一个元素有多个文本时，单纯通过位置无法获取 TextManage，因此这里单独通过 Map 保存关键字 key 和 TextManage 的对应关系\n// 1. 单文本元素 key 就是元素的 id\n// 2. 表格元素 key 是单元格的 id\n// 3. 符合 isMultipleTextGeometry 的元素，key 是元素 id + text.id （通常不是 id 而是文本位置的常量）\n// 4. arrow-line 和 vector-line 文本不依赖于 text.generator，基于 text 可以直接找到 TextManage\nexport const KEY_TO_TEXT_MANAGE: WeakMap<PlaitBoard, { [key: string]: TextManage }> = new WeakMap();\n\nexport const setTextManage = (board: PlaitBoard, element: PlaitElement, text: DrawTextInfo, textManage: TextManage) => {\n    const textManages = KEY_TO_TEXT_MANAGE.get(board)!;\n    return KEY_TO_TEXT_MANAGE.set(board, { ...textManages, [getTextKey(element, text)]: textManage });\n};\n\nexport const getTextManage = (board: PlaitBoard, element: PlaitElement | undefined, text: Pick<DrawTextInfo, 'id'>): TextManage => {\n    const textManages = KEY_TO_TEXT_MANAGE.get(board)!;\n    return textManages[getTextKey(element, text)];\n};\n\nexport const deleteTextManage = (board: PlaitBoard, key: string) => {\n    const textManages = KEY_TO_TEXT_MANAGE.get(board)!;\n    delete textManages[key];\n    KEY_TO_TEXT_MANAGE.set(board, textManages);\n};\n\nexport class TextGenerator<T extends PlaitElement = PlaitGeometry> {\n    protected board: PlaitBoard;\n\n    protected element: T;\n\n    protected texts: DrawTextInfo[];\n\n    protected options: TextGeneratorOptions<T>;\n\n    public textManages!: TextManage[];\n\n    get shape(): DrawShapes {\n        return this.element.shape || this.element.type;\n    }\n\n    constructor(board: PlaitBoard, element: T, texts: DrawTextInfo[], options: TextGeneratorOptions<T>) {\n        this.board = board;\n        this.texts = texts;\n        this.element = element;\n        this.options = options;\n    }\n\n    initialize() {\n        const textPlugins = ((this.board as PlaitOptionsBoard).getPluginOptions<WithTextPluginOptions>(WithTextPluginKey) || {})\n            .textPlugins;\n        this.textManages = this.texts.map(text => {\n            const textManage = this.createTextManage(text, textPlugins);\n            setTextManage(this.board, this.element, text, textManage);\n            return textManage;\n        });\n        const ref = PlaitElement.getElementRef<PlaitCommonElementRef>(this.element);\n        ref.initializeTextManage(this.textManages);\n    }\n\n    draw(elementG: SVGElement) {\n        const centerPoint = RectangleClient.getCenterPoint(this.board.getRectangle(this.element)!);\n        this.texts.forEach(drawShapeText => {\n            const textManage = getTextManage(this.board, this.element, drawShapeText);\n            if (drawShapeText.text && textManage) {\n                textManage.draw(drawShapeText.text);\n                elementG.append(textManage.g);\n                (this.element.angle || this.element.angle === 0) && textManage.updateAngle(centerPoint, this.element.angle);\n            }\n        });\n    }\n\n    update(element: T, previousDrawShapeTexts: DrawTextInfo[], currentDrawShapeTexts: DrawTextInfo[], elementG: SVGElement) {\n        this.element = element;\n\n        const centerPoint = RectangleClient.getCenterPoint(this.board.getRectangle(this.element)!);\n        const textPlugins = ((this.board as PlaitOptionsBoard).getPluginOptions<WithTextPluginOptions>(WithTextPluginKey) || {})\n            .textPlugins;\n        const removedTexts = previousDrawShapeTexts.filter(value => {\n            return !currentDrawShapeTexts.find(item => item.id === value.id);\n        });\n        if (removedTexts.length) {\n            removedTexts.forEach(item => {\n                const textManage = getTextManage(this.board, element, item);\n                const index = this.textManages.findIndex(value => value === textManage);\n                if (index > -1 && item.text && item.textHeight) {\n                    this.textManages.splice(index, 1);\n                }\n                textManage?.destroy();\n                deleteTextManage(this.board, item.id);\n            });\n        }\n        currentDrawShapeTexts.forEach(drawShapeText => {\n            if (drawShapeText.text) {\n                let textManage = getTextManage(this.board, this.element, drawShapeText);\n                if (!textManage) {\n                    textManage = this.createTextManage(drawShapeText, textPlugins);\n                    setTextManage(this.board, element, drawShapeText, textManage);\n                    textManage.draw(drawShapeText.text);\n                    elementG.append(textManage.g);\n                    this.textManages.push(textManage);\n                } else {\n                    textManage.updateText(drawShapeText.text);\n                    textManage.updateRectangle();\n                }\n                (this.element.angle || this.element.angle === 0) && textManage.updateAngle(centerPoint, this.element.angle);\n            }\n        });\n    }\n\n    private createTextManage(text: DrawTextInfo, textPlugins?: TextPlugin[]) {\n        const textManage = new TextManage(this.board, {\n            getRectangle: () => {\n                return this.getRectangle(text);\n            },\n            onChange: (data: TextManageChangeData) => {\n                return this.options.onChange(this.element, data, text);\n            },\n            getMaxWidth: () => {\n                return this.getMaxWidth(text);\n            },\n            getRenderRectangle: () => {\n                return this.options.getRenderRectangle ? this.options.getRenderRectangle(this.element, text) : this.getRectangle(text);\n            },\n            textPlugins\n        });\n        return textManage;\n    }\n\n    getRectangle(text: DrawTextInfo) {\n        const getRectangle = getEngine<T>(this.shape).getTextRectangle;\n        if (getRectangle) {\n            return getRectangle(this.element, text);\n        }\n        return getTextRectangle(this.element);\n    }\n\n    getMaxWidth(text: DrawTextInfo) {\n        return this.options.getMaxWidth ? this.options.getMaxWidth() : this.getRectangle(text).width;\n    }\n\n    destroy() {\n        const ref = PlaitElement.getElementRef<PlaitCommonElementRef>(this.element);\n        ref.destroyTextManage();\n        this.textManages = [];\n        this.texts.forEach(item => {\n            deleteTextManage(this.board, item.id);\n        });\n    }\n}\n", "import { PlaitBoard, getSelectedElements, PlaitElement } from '@plait/core';\nimport { PlaitTableCell, PlaitBaseTable, PlaitTable } from '../interfaces/table';\nimport { PlaitDrawElement } from '../interfaces';\n\nexport const isSingleSelectTable = (board: PlaitBoard) => {\n    const selectedElements = getSelectedElements(board);\n    return selectedElements && selectedElements.length === 1 && PlaitDrawElement.isElementByTable(selectedElements[0]);\n};\n\nexport const getSelectedTableElements = (board: PlaitBoard, elements?: PlaitElement[]) => {\n    const selectedElements = elements?.length ? elements : getSelectedElements(board);\n    return selectedElements.filter(value => PlaitDrawElement.isElementByTable(value)) as PlaitTable[];\n};\n\nexport const SELECTED_CELLS = new WeakMap<PlaitBaseTable, PlaitTableCell[]>();\n\nexport function getSelectedCells(element: PlaitBaseTable) {\n    return SELECTED_CELLS.get(element);\n}\n\nexport function setSelectedCells(element: PlaitBaseTable, cells: PlaitTableCell[]) {\n    return SELECTED_CELLS.set(element, cells);\n}\n\nexport function clearSelectedCells(element: PlaitBaseTable) {\n    return SELECTED_CELLS.delete(element);\n}\n", "import { idCreator, PlaitBoard, Point, RectangleClient } from '@plait/core';\nimport { PlaitBaseTable, PlaitTable, PlaitTableBoard, PlaitTableCell, PlaitTableCellWithPoints } from '../interfaces/table';\nimport { getTextManage } from '../generators/text.generator';\nimport { Alignment } from '@plait/common';\nimport { TEXT_DEFAULT_HEIGHT } from '@plait/text-plugins';\nimport { getSelectedCells, getSelectedTableElements, isSingleSelectTable } from './table-selected';\nimport { BaseEditor } from 'slate';\n\nexport function getCellsWithPoints(board: PlaitBoard, element: PlaitBaseTable): PlaitTableCellWithPoints[] {\n    const table = (board as PlaitTableBoard)?.buildTable(element);\n    if (!table || !table.points || !table.columns || !table.rows) {\n        throw new Error('can not get table cells points');\n    }\n    const rectangle = RectangleClient.getRectangleByPoints(table.points);\n    const columnsCount = table.columns.length;\n    const rowsCount = table.rows.length;\n    const cellWidths = calculateCellsSize(table.columns, rectangle.width, columnsCount, true);\n    const cellHeights = calculateCellsSize(table.rows, rectangle.height, rowsCount, false);\n    const cells: PlaitTableCellWithPoints[] = table.cells.map(cell => {\n        const rowIdx = table.rows.findIndex(row => row.id === cell.rowId);\n        const columnIdx = table.columns.findIndex(column => column.id === cell.columnId);\n\n        let cellTopLeftX = rectangle.x;\n        for (let i = 0; i < columnIdx; i++) {\n            cellTopLeftX += cellWidths[i];\n        }\n\n        let cellTopLeftY = rectangle.y;\n        for (let i = 0; i < rowIdx; i++) {\n            cellTopLeftY += cellHeights[i];\n        }\n\n        const cellWidth = calculateCellSize(cell, cellWidths, columnIdx, true);\n        const cellBottomRightX = cellTopLeftX + cellWidth;\n\n        const cellHeight = calculateCellSize(cell, cellHeights, rowIdx, false);\n        const cellBottomRightY = cellTopLeftY + cellHeight;\n\n        return {\n            ...cell,\n            points: [\n                [cellTopLeftX, cellTopLeftY],\n                [cellBottomRightX, cellBottomRightY]\n            ]\n        };\n    });\n\n    return cells;\n}\n\nexport function getCellWithPoints(board: PlaitBoard, table: PlaitBaseTable, cellId: string) {\n    try {\n        const cells = getCellsWithPoints(board as PlaitTableBoard, table);\n        const cellIndex = cells && table.cells.findIndex(item => item.id === cellId);\n        return cells[cellIndex];\n    } catch (error) {\n        throw new Error('can not get table cell points');\n    }\n}\n\nfunction calculateCellsSize(items: { id: string; [key: string]: any }[], tableSize: number, count: number, isWidth: boolean) {\n    const cellSizes: number[] = [];\n    const sizeType = isWidth ? 'width' : 'height';\n\n    // The remaining size of the table excluding cells with already set sizes.\n    let totalSizeRemaining = tableSize;\n\n    items.forEach((item, index) => {\n        if (item[sizeType]) {\n            cellSizes[index] = item[sizeType];\n            totalSizeRemaining -= item[sizeType];\n        }\n    });\n\n    // Divide the remaining size equally.\n    const remainingItemCount = count - cellSizes.filter(item => !!item).length;\n    const remainingCellSize = remainingItemCount > 0 ? totalSizeRemaining / remainingItemCount : 0;\n    for (let i = 0; i < count; i++) {\n        if (!cellSizes[i]) {\n            cellSizes[i] = remainingCellSize;\n        }\n    }\n    return cellSizes;\n}\n\nfunction calculateCellSize(cell: PlaitTableCell, sizes: number[], index: number, isWidth: boolean) {\n    const span = isWidth ? cell.colspan || 1 : cell.rowspan || 1;\n    let size = 0;\n    for (let i = 0; i < span; i++) {\n        const cellIndex = index + i;\n        size += sizes[cellIndex];\n    }\n    return size;\n}\n\nexport function getHitCell(board: PlaitTableBoard, element: PlaitBaseTable, point: Point) {\n    const table = board.buildTable(element);\n    const cells = getCellsWithPoints(board, table);\n    const rectangle = RectangleClient.getRectangleByPoints([point, point]);\n    const cell = cells.find(item => {\n        const cellRectangle = RectangleClient.getRectangleByPoints(item.points);\n        return RectangleClient.isHit(rectangle, cellRectangle);\n    });\n    if (cell) {\n        return table.cells.find(item => item.id === cell.id);\n    }\n    return null;\n}\n\nexport function editCell(board: PlaitBoard, cell: PlaitTableCell) {\n    const textManage = getTextManageByCell(board, cell);\n    textManage && textManage.edit();\n}\n\nexport function getTextManageByCell(board: PlaitBoard, cell: PlaitTableCell) {\n    return getTextManage(board, undefined, cell);\n}\n\nexport const updateColumns = (table: PlaitBaseTable, columnId: string, width: number, offset: number) => {\n    const columns = table.columns.map(item => (item.id === columnId ? { ...item, width } : item));\n    const points = [table.points[0], [table.points[1][0] + offset, table.points[1][1]]] as Point[];\n    return { columns, points };\n};\n\nexport const updateRows = (table: PlaitBaseTable, rowId: string, height: number, offset: number) => {\n    const rows = table.rows.map(item => (item.id === rowId ? { ...item, height } : item));\n    const points = [table.points[0], [table.points[1][0], table.points[1][1] + offset]] as Point[];\n    return { rows, points };\n};\n\nexport function updateCellIdsByRowOrColumn(cells: PlaitTableCell[], oldId: string, newId: string, type: 'row' | 'column') {\n    const id: 'rowId' | 'columnId' = `${type}Id`;\n    cells.forEach(item => {\n        if (item[id] === oldId) {\n            item[id] = newId;\n        }\n    });\n}\n\nexport function updateRowOrColumnIds(element: PlaitTable, type: 'row' | 'column') {\n    element[`${type}s`].forEach(item => {\n        const newId = idCreator();\n        updateCellIdsByRowOrColumn(element.cells, item.id, newId, type);\n        item.id = newId;\n    });\n}\n\nexport function updateCellIds(cells: PlaitTableCell[]) {\n    cells.forEach(item => {\n        const newId = idCreator();\n        item.id = newId;\n    });\n}\n\nexport function isCellIncludeText(cell: PlaitTableCell) {\n    return cell.text && cell.textHeight;\n}\n\nexport function getCellsRectangle(board: PlaitTableBoard, element: PlaitTable, cells: PlaitTableCell[]) {\n    const cellsWithPoints = getCellsWithPoints(board as PlaitTableBoard, element);\n    const points = cells.map(cell => {\n        const cellWithPoints = cellsWithPoints.find(item => item.id === cell.id);\n        return cellWithPoints!.points;\n    });\n    return RectangleClient.getRectangleByPoints(points);\n}\n\nexport const createCell = (rowId: string, columnId: string, text: string | null = null) => {\n    const cell: PlaitTableCell = {\n        id: idCreator(),\n        rowId,\n        columnId\n    };\n    if (text !== null) {\n        cell['textHeight'] = TEXT_DEFAULT_HEIGHT;\n        cell['text'] = {\n            children: [{ text }],\n            align: Alignment.center\n        };\n    }\n    return cell;\n};\n\nexport const getSelectedTableCellsEditor = (board: PlaitBoard): BaseEditor[] | undefined => {\n    if (isSingleSelectTable(board)) {\n        const elements = getSelectedTableElements(board);\n        const selectedCells = getSelectedCells(elements[0]);\n        const selectedCellsEditor = selectedCells?.map(cell => {\n            const textManage = getTextManageByCell(board, cell);\n            return textManage?.editor;\n        });\n        if (selectedCellsEditor?.length) {\n            return selectedCellsEditor as BaseEditor[];\n        }\n    }\n    return undefined;\n};\n", "import { PlaitBoard, PlaitElement } from '@plait/core';\nimport { BasicShapes, GeometryShapes, MemorizeKey, PlaitDrawElement } from '../interfaces';\nimport { getMemorizedLatest, memorizeLatest } from '@plait/common';\nimport { DrawPointerType } from '../constants';\nimport { BaseOperation, BaseSetNodeOperation, Node } from 'slate';\n\nconst SHAPE_MAX_LENGTH = 6;\nconst memorizedShape: WeakMap<PlaitBoard, GeometryShapes[]> = new WeakMap();\n\nexport const getMemorizeKey = (element: PlaitElement) => {\n    let key = '';\n    switch (true) {\n        case PlaitDrawElement.isText(element): {\n            key = MemorizeKey.text;\n            break;\n        }\n        case PlaitDrawElement.isBasicShape(element): {\n            key = MemorizeKey.basicShape;\n            break;\n        }\n        case PlaitDrawElement.isFlowchart(element): {\n            key = MemorizeKey.flowchart;\n            break;\n        }\n        case PlaitDrawElement.isArrowLine(element): {\n            key = MemorizeKey.arrowLine;\n            break;\n        }\n        case PlaitDrawElement.isUML(element): {\n            key = MemorizeKey.UML;\n        }\n    }\n    return key;\n};\n\nexport const getLineMemorizedLatest = () => {\n    const properties = getMemorizedLatest(MemorizeKey.arrowLine);\n    return { ...properties } || {};\n};\n\nexport const getMemorizedLatestByPointer = (pointer: DrawPointerType) => {\n    let memorizeKey = '';\n    if (PlaitDrawElement.isBasicShape({ shape: pointer })) {\n        memorizeKey = pointer === BasicShapes.text ? MemorizeKey.text : MemorizeKey.basicShape;\n    } else if (PlaitDrawElement.isUML({ shape: pointer })) {\n        memorizeKey = MemorizeKey.UML;\n    } else {\n        memorizeKey = MemorizeKey.flowchart;\n    }\n    const properties = { ...getMemorizedLatest(memorizeKey) } || {};\n    const textProperties = { ...properties.text } || {};\n    delete properties.text;\n    return { textProperties, geometryProperties: properties };\n};\n\nexport const memorizeLatestText = <T extends PlaitElement = PlaitDrawElement>(element: T, operations: BaseOperation[]) => {\n    const memorizeKey = getMemorizeKey(element);\n    let textMemory = getMemorizedLatest(memorizeKey)?.text || {};\n    const setNodeOperation = operations.find(operation => operation.type === 'set_node');\n    if (setNodeOperation) {\n        const { properties, newProperties } = setNodeOperation as BaseSetNodeOperation;\n        for (const key in newProperties) {\n            const value = newProperties[key as keyof Partial<Node>];\n            if (value == null) {\n                delete textMemory[key];\n            } else {\n                textMemory[key] = value;\n            }\n        }\n        for (const key in properties) {\n            if (!newProperties.hasOwnProperty(key)) {\n                delete textMemory[key];\n            }\n        }\n        memorizeLatest(memorizeKey, 'text', textMemory);\n    }\n};\n\nexport const memorizeLatestShape = (board: PlaitBoard, shape: GeometryShapes) => {\n    const shapes = memorizedShape.has(board) ? memorizedShape.get(board)! : [];\n    const shapeIndex = shapes.indexOf(shape);\n    if (shape === BasicShapes.text || shapeIndex === 0) {\n        return;\n    }\n    if (shapeIndex !== -1) {\n        shapes.splice(shapeIndex, 1);\n    } else {\n        if (shapes.length === SHAPE_MAX_LENGTH) {\n            shapes.pop();\n        }\n    }\n    shapes.unshift(shape);\n    memorizedShape.set(board, shapes);\n};\n\nexport const getMemorizedLatestShape = (board: PlaitBoard) => {\n    return memorizedShape.get(board);\n};\n", "import { ElbowLineRouteOptions, ResizeState, generateElbowLineRoute, removeDuplicatePoints, simplifyOrthogonalPoints } from '@plait/common';\nimport { PlaitBoard, Point, RectangleClient, createDebugGenerator } from '@plait/core';\nimport { LINE_ALIGN_TOLERANCE } from '../../constants/line';\nimport { getElbowLineRouteOptions, getArrowLineHandleRefPair } from './arrow-line-common';\nimport { PlaitArrowLine } from '../../interfaces';\n\nconst debugKey = 'debug:plait:line-mirror';\nconst debugGenerator = createDebugGenerator(debugKey);\n\nexport const alignPoints = (basePoint: Point, movingPoint: Point) => {\n    const newPoint: Point = [...movingPoint];\n    if (Point.isVertical(newPoint, basePoint, LINE_ALIGN_TOLERANCE)) {\n        newPoint[0] = basePoint[0];\n    }\n    if (Point.isHorizontal(newPoint, basePoint, LINE_ALIGN_TOLERANCE)) {\n        newPoint[1] = basePoint[1];\n    }\n    return newPoint;\n};\n\nexport function getResizedPreviousAndNextPoint(nextRenderPoints: Point[], sourcePoint: Point, targetPoint: Point, handleIndex: number) {\n    const referencePoint: { previous: Point | null; next: Point | null } = {\n        previous: null,\n        next: null\n    };\n\n    const startPoint = nextRenderPoints[handleIndex];\n    const endPoint = nextRenderPoints[handleIndex + 1];\n    const isHorizontal = Point.isHorizontal(startPoint, endPoint);\n    const isVertical = Point.isVertical(startPoint, endPoint);\n    const previousPoint = nextRenderPoints[handleIndex - 1] ?? nextRenderPoints[0];\n    const beforePreviousPoint = nextRenderPoints[handleIndex - 2] ?? sourcePoint;\n    if (\n        (isHorizontal && Point.isHorizontal(beforePreviousPoint, previousPoint)) ||\n        (isVertical && Point.isVertical(beforePreviousPoint, previousPoint))\n    ) {\n        referencePoint.previous = previousPoint;\n    }\n\n    const nextPoint = nextRenderPoints[handleIndex + 2] ?? nextRenderPoints[nextRenderPoints.length - 1];\n    const afterNextPoint = nextRenderPoints[handleIndex + 3] ?? targetPoint;\n    if ((isHorizontal && Point.isHorizontal(nextPoint, afterNextPoint)) || (isVertical && Point.isVertical(nextPoint, afterNextPoint))) {\n        referencePoint.next = nextPoint;\n    }\n    return referencePoint;\n}\n\nexport function alignElbowSegment(\n    startKeyPoint: Point,\n    endKeyPoint: Point,\n    resizeState: ResizeState,\n    resizedPreviousAndNextPoint: { previous: Point | null; next: Point | null }\n) {\n    let newStartPoint = startKeyPoint;\n    let newEndPoint = endKeyPoint;\n    if (Point.isHorizontal(startKeyPoint, endKeyPoint)) {\n        const offsetY = Point.getOffsetY(resizeState.startPoint, resizeState.endPoint);\n        let pointY = startKeyPoint[1] + offsetY;\n        if (resizedPreviousAndNextPoint.previous && Math.abs(resizedPreviousAndNextPoint.previous[1] - pointY) < LINE_ALIGN_TOLERANCE) {\n            pointY = resizedPreviousAndNextPoint.previous[1];\n        } else if (resizedPreviousAndNextPoint.next && Math.abs(resizedPreviousAndNextPoint.next[1] - pointY) < LINE_ALIGN_TOLERANCE) {\n            pointY = resizedPreviousAndNextPoint.next[1];\n        }\n        newStartPoint = [startKeyPoint[0], pointY];\n        newEndPoint = [endKeyPoint[0], pointY];\n    }\n    if (Point.isVertical(startKeyPoint, endKeyPoint)) {\n        const offsetX = Point.getOffsetX(resizeState.startPoint, resizeState.endPoint);\n        let pointX = startKeyPoint[0] + offsetX;\n        if (resizedPreviousAndNextPoint.previous && Math.abs(resizedPreviousAndNextPoint.previous[0] - pointX) < LINE_ALIGN_TOLERANCE) {\n            pointX = resizedPreviousAndNextPoint.previous[0];\n        } else if (resizedPreviousAndNextPoint.next && Math.abs(resizedPreviousAndNextPoint.next[0] - pointX) < LINE_ALIGN_TOLERANCE) {\n            pointX = resizedPreviousAndNextPoint.next[0];\n        }\n        newStartPoint = [pointX, startKeyPoint[1]];\n        newEndPoint = [pointX, endKeyPoint[1]];\n    }\n    return [newStartPoint, newEndPoint];\n}\n\nexport function getIndexAndDeleteCountByKeyPoint(\n    board: PlaitBoard,\n    element: PlaitArrowLine,\n    dataPoints: Point[],\n    nextRenderPoints: Point[],\n    handleIndex: number\n) {\n    let index: number | null = null;\n    let deleteCount: number | null = null;\n\n    const startKeyPoint = nextRenderPoints[handleIndex];\n    const endKeyPoint = nextRenderPoints[handleIndex + 1];\n    if (!startKeyPoint || !endKeyPoint) {\n        return {\n            index,\n            deleteCount\n        };\n    }\n    const midDataPoints = dataPoints.slice(1, -1);\n    const startIndex = midDataPoints.findIndex(item => Point.isEquals(item, startKeyPoint));\n    const endIndex = midDataPoints.findIndex(item => Point.isEquals(item, endKeyPoint));\n\n    if (Math.max(startIndex, endIndex) > -1) {\n        if (startIndex > -1 && endIndex > -1) {\n            return {\n                index: startIndex,\n                deleteCount: 2\n            };\n        }\n        if (startIndex > -1 && endIndex === -1) {\n            const isReplace =\n                startIndex < midDataPoints.length - 1 &&\n                Point.isAlign([midDataPoints[startIndex], midDataPoints[startIndex + 1], startKeyPoint, endKeyPoint]);\n            if (isReplace) {\n                return {\n                    index: startIndex,\n                    deleteCount: 2\n                };\n            }\n            return {\n                index: startIndex,\n                deleteCount: 1\n            };\n        }\n        if (startIndex === -1 && endIndex > -1) {\n            const isReplace =\n                endIndex > 0 && Point.isAlign([midDataPoints[endIndex], midDataPoints[endIndex - 1], startKeyPoint, endKeyPoint]);\n            if (isReplace) {\n                return {\n                    index: endIndex - 1,\n                    deleteCount: 2\n                };\n            }\n            return {\n                index: endIndex,\n                deleteCount: 1\n            };\n        }\n    } else {\n        for (let i = 0; i < midDataPoints.length - 1; i++) {\n            const currentPoint = midDataPoints[i];\n            const nextPoint = midDataPoints[i + 1];\n            if (Point.isAlign([currentPoint, nextPoint, startKeyPoint, endKeyPoint])) {\n                index = i;\n                deleteCount = 2;\n                break;\n            }\n            if (Point.isAlign([currentPoint, nextPoint, startKeyPoint])) {\n                index = Math.min(i + 1, midDataPoints.length - 1);\n                deleteCount = 1;\n                break;\n            }\n            if (Point.isAlign([currentPoint, nextPoint, endKeyPoint])) {\n                index = Math.max(i - 1, 0);\n                deleteCount = 1;\n                break;\n            }\n        }\n    }\n    if (index === null) {\n        deleteCount = 0;\n        if (midDataPoints.length > 0) {\n            const handleRefPair = getArrowLineHandleRefPair(board, element);\n            const params = getElbowLineRouteOptions(board, element as PlaitArrowLine, handleRefPair);\n            const keyPoints = removeDuplicatePoints(generateElbowLineRoute(params, board));\n            const nextKeyPoints = simplifyOrthogonalPoints(keyPoints.slice(1, keyPoints.length - 1));\n            const nextDataPoints = [nextRenderPoints[0], ...midDataPoints, nextRenderPoints[nextRenderPoints.length - 1]];\n            const mirrorDataPoints = getMirrorDataPoints(board, nextDataPoints, nextKeyPoints, params);\n            for (let i = handleIndex - 1; i >= 0; i--) {\n                const previousIndex = mirrorDataPoints.slice(1, -1).findIndex(item => Point.isEquals(item, nextRenderPoints[i]));\n                if (previousIndex > -1) {\n                    index = previousIndex + 1;\n                    break;\n                }\n            }\n            if (index === null) {\n                index = 0;\n                // When renderPoints is a straight line and dataPoints are not on the line,\n                // the default 'deleteCount' is set to midDataPoints.length.\n                if (Point.isAlign(nextRenderPoints)) {\n                    deleteCount = midDataPoints.length;\n                }\n            }\n        } else {\n            index = 0;\n        }\n    }\n\n    return {\n        index,\n        deleteCount\n    };\n}\n\nexport function getMirrorDataPoints(board: PlaitBoard, nextDataPoints: Point[], nextKeyPoints: Point[], params: ElbowLineRouteOptions) {\n    for (let index = 1; index < nextDataPoints.length - 2; index++) {\n        adjustByCustomPointStartIndex(board, index, nextDataPoints, nextKeyPoints, params);\n    }\n    return nextDataPoints;\n}\n\n/**\n * adjust based parallel segment\n */\nconst adjustByCustomPointStartIndex = (\n    board: PlaitBoard,\n    customPointStartIndex: number,\n    nextDataPoints: Point[],\n    nextKeyPoints: Point[],\n    params: ElbowLineRouteOptions\n) => {\n    const beforePoint = nextDataPoints[customPointStartIndex - 1];\n    const startPoint = nextDataPoints[customPointStartIndex];\n    const endPoint = nextDataPoints[customPointStartIndex + 1];\n    const afterPoint = nextDataPoints[customPointStartIndex + 2];\n    const beforeSegment = [beforePoint, startPoint];\n    const afterSegment = [endPoint, afterPoint];\n    const isStraightWithBefore = Point.isAlign(beforeSegment);\n    const isStraightWithAfter = Point.isAlign(afterSegment);\n    let isAdjustStart = false;\n    let isAdjustEnd = false;\n    if (!isStraightWithBefore || !isStraightWithAfter) {\n        const midKeyPointsWithBefore = getMidKeyPoints(nextKeyPoints, beforeSegment[0], beforeSegment[1]);\n        const midKeyPointsWithAfter = getMidKeyPoints(nextKeyPoints, afterSegment[0], afterSegment[1]);\n        const hasMidKeyPoints = midKeyPointsWithBefore.length > 0 && midKeyPointsWithAfter.length > 0;\n        isAdjustStart = !isStraightWithBefore && !hasMidKeyPoints;\n        isAdjustEnd = !isStraightWithAfter && !hasMidKeyPoints;\n    }\n    if (isAdjustStart || isAdjustEnd) {\n        const parallelSegment = [startPoint, endPoint] as [Point, Point];\n        const parallelSegments = findOrthogonalParallelSegments(parallelSegment, nextKeyPoints);\n        const mirrorSegments = findMirrorSegments(board, parallelSegment, parallelSegments, params.sourceRectangle, params.targetRectangle);\n        if (mirrorSegments.length === 1) {\n            const mirrorSegment = mirrorSegments[0];\n            if (isAdjustStart) {\n                nextDataPoints.splice(customPointStartIndex, 1, mirrorSegment[0]);\n            }\n            if (isAdjustEnd) {\n                nextDataPoints.splice(customPointStartIndex + 1, 1, mirrorSegment[1]);\n            }\n        } else {\n            const isHorizontal = Point.isHorizontal(startPoint, endPoint);\n            const adjustIndex = isHorizontal ? 0 : 1;\n            if (isAdjustStart) {\n                const newStartPoint = [startPoint[0], startPoint[1]] as Point;\n                newStartPoint[adjustIndex] = beforePoint[adjustIndex];\n                nextDataPoints.splice(customPointStartIndex, 1, newStartPoint);\n            }\n            if (isAdjustEnd) {\n                const newEndPoint = [endPoint[0], endPoint[1]] as Point;\n                newEndPoint[adjustIndex] = afterPoint[adjustIndex];\n                nextDataPoints.splice(customPointStartIndex + 1, 1, newEndPoint);\n            }\n        }\n    }\n};\n\nexport function isUpdatedHandleIndex(\n    board: PlaitBoard,\n    element: PlaitArrowLine,\n    dataPoints: Point[],\n    nextRenderPoints: Point[],\n    handleIndex: number\n) {\n    const { deleteCount } = getIndexAndDeleteCountByKeyPoint(board, element, dataPoints, nextRenderPoints, handleIndex);\n    if (deleteCount !== null && deleteCount > 1) {\n        return true;\n    }\n    return false;\n}\n\nexport function getMidKeyPoints(simplifiedNextKeyPoints: Point[], startPoint: Point, endPoint: Point) {\n    let midElbowPoints: Point[] = [];\n    let startPointIndex = -1;\n    let endPointIndex = -1;\n    for (let i = 0; i < simplifiedNextKeyPoints.length; i++) {\n        if (Point.isAlign([simplifiedNextKeyPoints[i], startPoint])) {\n            startPointIndex = i;\n        }\n        if (startPointIndex > -1 && Point.isAlign([simplifiedNextKeyPoints[i], endPoint])) {\n            endPointIndex = i;\n            break;\n        }\n    }\n    if (startPointIndex > -1 && endPointIndex > -1) {\n        midElbowPoints = simplifiedNextKeyPoints.slice(startPointIndex, endPointIndex + 1);\n    }\n    return midElbowPoints;\n}\n\nfunction findOrthogonalParallelSegments(segment: [Point, Point], keyPoints: Point[]): [Point, Point][] {\n    const isHorizontalSegment = Point.isHorizontal(segment[0], segment[1]);\n    const parallelSegments: [Point, Point][] = [];\n\n    for (let i = 0; i < keyPoints.length - 1; i++) {\n        const current = keyPoints[i];\n        const next = keyPoints[i + 1];\n        const isHorizontal = Point.isHorizontal(current, next, 0.1);\n        if (isHorizontalSegment && isHorizontal) {\n            parallelSegments.push([current, next]);\n        }\n        if (!isHorizontalSegment && !isHorizontal) {\n            parallelSegments.push([current, next]);\n        }\n    }\n\n    return parallelSegments;\n}\n\nfunction findMirrorSegments(\n    board: PlaitBoard,\n    segment: [Point, Point],\n    parallelSegments: [Point, Point][],\n    sourceRectangle: RectangleClient,\n    targetRectangle: RectangleClient\n) {\n    debugGenerator.isDebug() && debugGenerator.clear();\n\n    const mirrorSegments: [Point, Point][] = [];\n    for (let index = 0; index < parallelSegments.length; index++) {\n        const parallelPath = parallelSegments[index];\n        const startPoint = [segment[0][0], segment[0][1]] as Point;\n        const endPoint = [segment[1][0], segment[1][1]] as Point;\n        const isHorizontal = Point.isHorizontal(startPoint, endPoint);\n        const adjustDataIndex = isHorizontal ? 0 : 1;\n        startPoint[adjustDataIndex] = parallelPath[0][adjustDataIndex];\n        endPoint[adjustDataIndex] = parallelPath[1][adjustDataIndex];\n        const fakeRectangle = RectangleClient.getRectangleByPoints([startPoint, endPoint, ...parallelPath]);\n        const isValid = !RectangleClient.isHit(fakeRectangle, sourceRectangle) && !RectangleClient.isHit(fakeRectangle, targetRectangle);\n        if (isValid) {\n            mirrorSegments.push([startPoint, endPoint]);\n\n            debugGenerator.isDebug() && debugGenerator.drawPolygon(board, RectangleClient.getCornerPoints(fakeRectangle));\n        }\n    }\n    return mirrorSegments;\n}\n\nexport const hasIllegalElbowPoint = (midDataPoints: Point[]): boolean => {\n    if (midDataPoints.length === 1) {\n        return true;\n    }\n    return midDataPoints.some((item, index) => {\n        const beforePoint = midDataPoints[index - 1];\n        const afterPoint = midDataPoints[index + 1];\n        const beforeSegment = beforePoint && [beforePoint, item];\n        const afterSegment = afterPoint && [item, afterPoint];\n        const isStraightWithBefore = beforeSegment && Point.isAlign(beforeSegment);\n        const isStraightWithAfter = afterSegment && Point.isAlign(afterSegment);\n        if (index === 0) {\n            return !isStraightWithAfter;\n        }\n        if (index === midDataPoints.length - 1) {\n            return !isStraightWithBefore;\n        }\n        return !isStraightWithBefore && !isStraightWithAfter;\n    });\n};\n", "import { Point, arrowPoints, createG, createPath, distanceBetweenPointAndPoint, drawLinearPath, rotate } from '@plait/core';\nimport { ArrowLineMarkerType, PlaitArrowLine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { getExtendPoint, getUnitVectorByPointAndPoint } from '@plait/common';\nimport { getStrokeWidthByElement } from '../common';\n\ninterface ArrowOptions {\n    marker: ArrowLineMarkerType;\n    source: Point;\n    target: Point;\n    isSource: boolean;\n}\nconst ARROW_LENGTH = 20;\n\nexport const drawArrowLineArrow = (element: PlaitArrowLine, points: Point[], options: Options) => {\n    const arrowG = createG();\n    if (PlaitArrowLine.isSourceMark(element, ArrowLineMarkerType.none) && PlaitArrowLine.isTargetMark(element, ArrowLineMarkerType.none)) {\n        return null;\n    }\n    const strokeWidth = getStrokeWidthByElement(element);\n    const offset = (strokeWidth * strokeWidth) / 3;\n    if (points.length === 1) {\n        points = [points[0], [points[0][0] + 0.1, points[0][1]]];\n    }\n\n    if (!PlaitArrowLine.isSourceMark(element, ArrowLineMarkerType.none)) {\n        const source = getExtendPoint(points[0], points[1], ARROW_LENGTH + offset);\n        const sourceArrow = getArrow(element, { marker: element.source.marker, source, target: points[0], isSource: true }, options);\n        sourceArrow && arrowG.appendChild(sourceArrow);\n    }\n    if (!PlaitArrowLine.isTargetMark(element, ArrowLineMarkerType.none)) {\n        const source = getExtendPoint(points[points.length - 1], points[points.length - 2], ARROW_LENGTH + offset);\n        const arrow = getArrow(\n            element,\n            { marker: element.target.marker, source, target: points[points.length - 1], isSource: false },\n            options\n        );\n\n        arrow && arrowG.appendChild(arrow);\n    }\n    return arrowG;\n};\n\nconst getArrow = (element: PlaitArrowLine, arrowOptions: ArrowOptions, options: Options) => {\n    const { marker, target, source, isSource } = arrowOptions;\n    let targetArrow;\n    switch (marker) {\n        case ArrowLineMarkerType.openTriangle: {\n            targetArrow = drawOpenTriangle(element, source, target, options);\n            break;\n        }\n        case ArrowLineMarkerType.solidTriangle: {\n            targetArrow = drawSolidTriangle(source, target, options);\n            break;\n        }\n        case ArrowLineMarkerType.arrow: {\n            targetArrow = drawArrow(element, source, target, options);\n            break;\n        }\n        case ArrowLineMarkerType.sharpArrow: {\n            targetArrow = drawSharpArrow(source, target, options);\n            break;\n        }\n        case ArrowLineMarkerType.oneSideUp: {\n            targetArrow = drawOneSideArrow(source, target, isSource ? 'down' : 'up', options);\n            break;\n        }\n        case ArrowLineMarkerType.oneSideDown: {\n            targetArrow = drawOneSideArrow(source, target, isSource ? 'up' : 'down', options);\n            break;\n        }\n        case ArrowLineMarkerType.hollowTriangle: {\n            targetArrow = drawHollowTriangleArrow(source, target, options);\n            break;\n        }\n        case ArrowLineMarkerType.singleSlash: {\n            targetArrow = drawSingleSlash(source, target, isSource, options);\n            break;\n        }\n    }\n    return targetArrow;\n};\n\nconst drawSharpArrow = (source: Point, target: Point, options: Options) => {\n    const startPoint: Point = target;\n    const { pointLeft, pointRight } = arrowPoints(source, target, 20);\n    const g = createG();\n    const path = createPath();\n    let polylinePath = `M${pointRight[0]},${pointRight[1]}A25,25,20,0,1,${pointLeft[0]},${pointLeft[1]}L${startPoint[0]},${startPoint[1]}Z`;\n    path.setAttribute('d', polylinePath);\n    path.setAttribute('stroke', `${options?.stroke}`);\n    path.setAttribute('stroke-width', `${options?.strokeWidth}`);\n    path.setAttribute('fill', `${options?.stroke}`);\n    g.appendChild(path);\n    return g;\n};\n\nconst drawArrow = (element: PlaitArrowLine, source: Point, target: Point, options: Options) => {\n    const unitVector = getUnitVectorByPointAndPoint(source, target);\n    const strokeWidth = getStrokeWidthByElement(element);\n    const endPoint: Point = [target[0] + (strokeWidth * unitVector[0]) / 2, target[1] + (strokeWidth * unitVector[1]) / 2];\n    const distance = distanceBetweenPointAndPoint(...source, ...endPoint);\n    const middlePoint: Point = [\n        endPoint[0] - (((distance * 3) / 5 + strokeWidth) / 2) * unitVector[0],\n        endPoint[1] - (((distance * 3) / 5 + strokeWidth) / 2) * unitVector[1]\n    ];\n    const { pointLeft, pointRight } = arrowPoints(source, endPoint, 30);\n    const arrowG = drawLinearPath([pointLeft, endPoint, pointRight, middlePoint], { ...options, fill: options.stroke }, true);\n    const path = arrowG.querySelector('path');\n    path!.setAttribute('stroke-linejoin', 'round');\n    return arrowG;\n};\n\nconst drawSolidTriangle = (source: Point, target: Point, options: Options) => {\n    const endPoint: Point = target;\n    const { pointLeft, pointRight } = arrowPoints(source, endPoint, 30);\n    return drawLinearPath([pointLeft, endPoint, pointRight], { ...options, fill: options.stroke }, true);\n};\n\nconst drawOpenTriangle = (element: PlaitArrowLine, source: Point, target: Point, options: Options) => {\n    const unitVector = getUnitVectorByPointAndPoint(source, target);\n    const strokeWidth = getStrokeWidthByElement(element);\n    const endPoint: Point = [target[0] + (strokeWidth * unitVector[0]) / 2, target[1] + (strokeWidth * unitVector[1]) / 2];\n    const { pointLeft, pointRight } = arrowPoints(source, endPoint, 40);\n    return drawLinearPath([pointLeft, endPoint, pointRight], options);\n};\n\nconst drawOneSideArrow = (source: Point, target: Point, side: string, options: Options) => {\n    const { pointLeft, pointRight } = arrowPoints(source, target, 40);\n    return drawLinearPath([side === 'up' ? pointRight : pointLeft, target], options);\n};\n\nconst drawSingleSlash = (source: Point, target: Point, isSource: boolean, options: Options) => {\n    const length = distanceBetweenPointAndPoint(...source, ...target);\n    const middlePoint = getExtendPoint(target, source, length / 2);\n    const angle = isSource ? 120 : 60;\n    const start = rotate(...source, ...middlePoint, (angle * Math.PI) / 180) as Point;\n    const end = rotate(...target, ...middlePoint, (angle * Math.PI) / 180) as Point;\n    return drawLinearPath([start, end], options);\n};\n\nconst drawHollowTriangleArrow = (source: Point, target: Point, options: Options) => {\n    const { pointLeft, pointRight } = arrowPoints(source, target, 30);\n    return drawLinearPath([pointLeft, pointRight, target], { ...options, fill: 'white' }, true);\n};\n", "import { PlaitArrowLine } from '../interfaces';\nimport { Generator } from '@plait/common';\nimport { drawArrowLine } from '../utils/arrow-line/arrow-line-basic';\n\nexport class ArrowLineShapeGenerator extends Generator<PlaitArrowLine> {\n    canDraw(element: PlaitArrowLine): boolean {\n        return true;\n    }\n\n    draw(element: PlaitArrowLine) {\n        let lineG: SVGGElement | undefined;\n        lineG = drawArrowLine(this.board, element);\n        return lineG;\n    }\n}\n", "import {\n    Point,\n    idCreator,\n    PlaitBoard,\n    createG,\n    RectangleClient,\n    findElements,\n    PlaitElement,\n    drawLinearPath,\n    createMask,\n    createRect,\n    distanceBetweenPointAndPoint,\n    catmullRomFitting,\n    setStrokeLinecap\n} from '@plait/core';\nimport { pointsOnBezierCurves } from 'points-on-curve';\nimport {\n    getPointOnPolyline,\n    getPointByVectorComponent,\n    removeDuplicatePoints,\n    getExtendPoint,\n    getStrokeLineDash,\n    StrokeStyle\n} from '@plait/common';\nimport {\n    ArrowLineHandle,\n    ArrowLineMarkerType,\n    ArrowLineShape,\n    ArrowLineText,\n    PlaitArrowLine,\n    PlaitDrawElement,\n    PlaitShapeElement\n} from '../../interfaces';\nimport { getStrokeColorByElement, getStrokeStyleByElement } from '../style/stroke';\nimport { getEngine } from '../../engines';\nimport { getElementShape } from '../shape';\nimport { DefaultLineStyle, LINE_TEXT_SPACE } from '../../constants/line';\nimport { LINE_SNAPPING_CONNECTOR_BUFFER } from '../../constants';\nimport { getLineMemorizedLatest } from '../memorize';\nimport { alignPoints } from './arrow-line-resize';\nimport { getArrowLineHandleRefPair } from './arrow-line-common';\nimport { getElbowPoints } from './elbow';\nimport { drawArrowLineArrow } from './arrow-line-arrow';\nimport { getSnappingRef, getSnappingShape, getStrokeWidthByElement } from '../common';\nimport { ArrowLineShapeGenerator } from '../../generators/arrow-line.generator';\n\nexport const createArrowLineElement = (\n    shape: ArrowLineShape,\n    points: [Point, Point],\n    source: ArrowLineHandle,\n    target: ArrowLineHandle,\n    texts?: ArrowLineText[],\n    options?: Pick<PlaitArrowLine, 'strokeColor' | 'strokeWidth'>\n): PlaitArrowLine => {\n    return {\n        id: idCreator(),\n        type: 'arrow-line',\n        shape,\n        source,\n        texts: texts ? texts : [],\n        target,\n        opacity: 1,\n        points,\n        ...options\n    };\n};\n\nexport const getArrowLinePoints = (board: PlaitBoard, element: PlaitArrowLine) => {\n    switch (element.shape) {\n        case ArrowLineShape.elbow: {\n            return getElbowPoints(board, element);\n        }\n        case ArrowLineShape.curve: {\n            return getCurvePoints(board, element);\n        }\n        default: {\n            const points = PlaitArrowLine.getPoints(board, element);\n            const handleRefPair = getArrowLineHandleRefPair(board, element);\n            points[0] = handleRefPair.source.point;\n            points[points.length - 1] = handleRefPair.target.point;\n            return points;\n        }\n    }\n};\n\nexport const getCurvePoints = (board: PlaitBoard, element: PlaitArrowLine) => {\n    if (element.points.length === 2) {\n        const handleRefPair = getArrowLineHandleRefPair(board, element);\n        const { source, target } = handleRefPair;\n        const sourceBoundElement = handleRefPair.source.boundElement;\n        const targetBoundElement = handleRefPair.target.boundElement;\n        let curvePoints: Point[] = [source.point];\n        const sumDistance = distanceBetweenPointAndPoint(...source.point, ...target.point);\n        const offset = 12 + sumDistance / 3;\n        if (sourceBoundElement) {\n            curvePoints.push(getPointByVectorComponent(source.point, source.vector, offset));\n        }\n        if (targetBoundElement) {\n            curvePoints.push(getPointByVectorComponent(target.point, target.vector, offset));\n        }\n        const isSingleBound = (sourceBoundElement && !targetBoundElement) || (!sourceBoundElement && targetBoundElement);\n        if (isSingleBound) {\n            curvePoints.push(target.point);\n            const points = Q2C(curvePoints);\n            return pointsOnBezierCurves(points) as Point[];\n        }\n        if (!sourceBoundElement && !targetBoundElement) {\n            curvePoints.push(getPointByVectorComponent(source.point, source.vector, offset));\n            curvePoints.push(getPointByVectorComponent(target.point, target.vector, offset));\n        }\n        curvePoints.push(target.point);\n        return pointsOnBezierCurves(curvePoints) as Point[];\n    } else {\n        let dataPoints = PlaitArrowLine.getPoints(board, element);\n        dataPoints = removeDuplicatePoints(dataPoints);\n        const points = catmullRomFitting(dataPoints);\n        return pointsOnBezierCurves(points) as Point[];\n    }\n};\n\nexport const drawArrowLine = (board: PlaitBoard, element: PlaitArrowLine) => {\n    const strokeWidth = getStrokeWidthByElement(element);\n    const strokeColor = getStrokeColorByElement(board, element);\n    const strokeStyle = getStrokeStyleByElement(board, element);\n    const strokeLineDash = getStrokeLineDash(strokeStyle, strokeWidth);\n    const options = { stroke: strokeColor, strokeWidth, strokeLineDash };\n    const lineG = createG();\n    let points = getArrowLinePoints(board, element);\n    let line;\n    if (element.shape === ArrowLineShape.curve) {\n        line = PlaitBoard.getRoughSVG(board).curve(points, options);\n    } else {\n        line = drawLinearPath(points, options);\n    }\n    const id = idCreator();\n    line.setAttribute('mask', `url(#${id})`);\n    if (element.strokeStyle === StrokeStyle.dotted) {\n        setStrokeLinecap(line, 'round');\n    }\n    lineG.appendChild(line);\n\n    const { mask, maskTargetFillRect } = drawArrowLineMask(board, element as PlaitArrowLine, id);\n    lineG.appendChild(mask);\n    line.appendChild(maskTargetFillRect);\n    const arrow = drawArrowLineArrow(element as PlaitArrowLine, points, { stroke: strokeColor, strokeWidth });\n    arrow && lineG.appendChild(arrow);\n    return lineG;\n};\n\nexport const getHitConnection = (board: PlaitBoard, point: Point, hitElement: PlaitShapeElement): Point => {\n    const ref = getSnappingRef(board, hitElement, point);\n    const connectionPoint = ref.connectorPoint || ref.edgePoint;\n    return getHitConnectionFromConnectionPoint(connectionPoint, hitElement);\n};\n\nexport const getHitConnectionFromConnectionPoint = (connectionPoint: Point, hitElement: PlaitShapeElement): Point => {\n    let rectangle = RectangleClient.getRectangleByPoints(hitElement.points);\n    return [(connectionPoint[0] - rectangle.x) / rectangle.width, (connectionPoint[1] - rectangle.y) / rectangle.height];\n};\n\nexport const getHitConnectorPoint = (point: Point, hitElement: PlaitShapeElement) => {\n    const rectangle = RectangleClient.getRectangleByPoints(hitElement.points);\n    const shape = getElementShape(hitElement);\n    const connectorPoints = getEngine(shape).getConnectorPoints(rectangle);\n    return connectorPoints.find((connectorPoint) => {\n        return distanceBetweenPointAndPoint(...connectorPoint, ...point) <= LINE_SNAPPING_CONNECTOR_BUFFER;\n    });\n};\n\nexport const getArrowLineTextRectangle = (board: PlaitBoard, element: PlaitArrowLine, index: number): RectangleClient => {\n    const text = element.texts[index];\n    const elbowPoints = getArrowLinePoints(board, element);\n    const point = getPointOnPolyline(elbowPoints, text.position);\n    return {\n        x: point[0] - text.width! / 2,\n        y: point[1] - text.height! / 2,\n        width: text.width!,\n        height: text.height!\n    };\n};\n\nexport const getArrowLines = (board: PlaitBoard) => {\n    return findElements(board, {\n        match: (element: PlaitElement) => PlaitDrawElement.isArrowLine(element),\n        recursion: (element: PlaitElement) => PlaitDrawElement.isDrawElement(element)\n    }) as PlaitArrowLine[];\n};\n\n// quadratic Bezier to cubic Bezier\nexport const Q2C = (points: Point[]) => {\n    const result = [];\n    const numSegments = points.length / 3;\n    for (let i = 0; i < numSegments; i++) {\n        const start = points[i];\n        const qControl = points[i + 1];\n        const end = points[i + 2];\n        const startDistance = distanceBetweenPointAndPoint(...start, ...qControl);\n        const endDistance = distanceBetweenPointAndPoint(...end, ...qControl);\n        const cControl1 = getExtendPoint(start, qControl, (startDistance * 2) / 3);\n        const cControl2 = getExtendPoint(end, qControl, (endDistance * 2) / 3);\n        result.push(start, cControl1, cControl2, end);\n    }\n    return result;\n};\n\nexport const handleArrowLineCreating = (\n    board: PlaitBoard,\n    lineShape: ArrowLineShape,\n    sourcePoint: Point,\n    movingPoint: Point,\n    sourceElement: PlaitShapeElement | null,\n    lineShapeG: SVGGElement,\n    options?: Pick<PlaitArrowLine, 'strokeColor' | 'strokeWidth'>\n) => {\n    const hitElement = getSnappingShape(board, movingPoint);\n    const targetConnection = hitElement ? getHitConnection(board, movingPoint, hitElement) : undefined;\n    const sourceConnection = sourceElement ? getHitConnection(board, sourcePoint, sourceElement) : undefined;\n    const targetBoundId = hitElement ? hitElement.id : undefined;\n    const lineGenerator = new ArrowLineShapeGenerator(board);\n    const memorizedLatest = getLineMemorizedLatest();\n    let sourceMarker, targetMarker;\n    sourceMarker = memorizedLatest.source;\n    targetMarker = memorizedLatest.target;\n    sourceMarker && delete memorizedLatest.source;\n    targetMarker && delete memorizedLatest.target;\n    const temporaryLineElement = createArrowLineElement(\n        lineShape,\n        [sourcePoint, movingPoint],\n        { marker: sourceMarker || ArrowLineMarkerType.none, connection: sourceConnection, boundId: sourceElement?.id },\n        { marker: targetMarker || ArrowLineMarkerType.arrow, connection: targetConnection, boundId: targetBoundId },\n        [],\n        {\n            strokeWidth: DefaultLineStyle.strokeWidth,\n            ...memorizedLatest,\n            ...options\n        }\n    );\n    const linePoints = getArrowLinePoints(board, temporaryLineElement);\n    const otherPoint = linePoints[0];\n    temporaryLineElement.points[1] = alignPoints(otherPoint, movingPoint);\n    lineGenerator.processDrawing(temporaryLineElement, lineShapeG);\n    PlaitBoard.getElementTopHost(board).append(lineShapeG);\n    return temporaryLineElement;\n};\n\nfunction drawArrowLineMask(board: PlaitBoard, element: PlaitArrowLine, id: string) {\n    const mask = createMask();\n    mask.setAttribute('id', id);\n    const points = getArrowLinePoints(board, element);\n    let rectangle = RectangleClient.getRectangleByPoints(points);\n    rectangle = RectangleClient.getOutlineRectangle(rectangle, -30);\n    const maskFillRect = createRect(rectangle, {\n        fill: 'white'\n    });\n    mask.appendChild(maskFillRect);\n\n    const texts = element.texts;\n    texts.forEach((text, index) => {\n        let textRectangle = getArrowLineTextRectangle(board, element, index);\n        textRectangle = RectangleClient.inflate(textRectangle, LINE_TEXT_SPACE * 2);\n        const rect = createRect(textRectangle, {\n            fill: 'black'\n        });\n        mask.appendChild(rect);\n    });\n    // open line\n    const maskTargetFillRect = createRect(rectangle);\n    maskTargetFillRect.setAttribute('opacity', '0');\n    maskTargetFillRect.setAttribute('fill', 'none');\n    return { mask, maskTargetFillRect };\n}\n", "import { PlaitBoard, Point, RectangleClient } from '@plait/core';\nimport { PlaitArrowLine } from '../../interfaces';\nimport { getPointOnPolyline } from '@plait/common';\nimport { getArrowLinePoints } from '../arrow-line/arrow-line-basic';\n\nexport const getHitArrowLineTextIndex = (board: PlaitBoard, element: PlaitArrowLine, point: Point) => {\n    const texts = element.texts;\n    if (!texts.length) return -1;\n\n    const points = getArrowLinePoints(board, element);\n    return texts.findIndex(text => {\n        const center = getPointOnPolyline(points, text.position);\n        const rectangle = {\n            x: center[0] - text.width! / 2,\n            y: center[1] - text.height! / 2,\n            width: text.width!,\n            height: text.height!\n        };\n        return RectangleClient.isHit(rectangle, RectangleClient.getRectangleByPoints([point, point]));\n    });\n};\n", "import { PlaitElement, Point, RectangleClient, idCreator } from '@plait/core';\nimport { GeometryShapes, UMLSymbols, PlaitMultipleTextGeometry } from '../interfaces/geometry';\nimport { DefaultTextProperty, GEOMETRY_WITH_MULTIPLE_TEXT, MultipleTextGeometryTextKeys } from '../constants';\nimport { getEngine } from '../engines';\nimport { getMemorizedLatestByPointer } from './memorize';\nimport { DrawTextInfo } from '../generators/text.generator';\nimport { GeometryStyleOptions, getDefaultGeometryProperty } from './geometry';\nimport { PlaitDrawElement } from '../interfaces';\nimport { Alignment, buildText } from '@plait/common';\n\nexport const isMultipleTextShape = (shape: GeometryShapes) => {\n    return GEOMETRY_WITH_MULTIPLE_TEXT.includes(shape as UMLSymbols);\n};\n\nexport const isMultipleTextGeometry = (geometry: PlaitElement): geometry is PlaitMultipleTextGeometry => {\n    return PlaitDrawElement.isGeometry(geometry) && isMultipleTextShape(geometry.shape);\n};\n\nexport const getMultipleTextGeometryTextKeys = (shape: GeometryShapes) => {\n    return MultipleTextGeometryTextKeys[shape];\n};\n\nexport const createMultipleTextGeometryElement = (\n    shape: GeometryShapes,\n    points: [Point, Point],\n    options: GeometryStyleOptions = {}\n): PlaitMultipleTextGeometry => {\n    const id = idCreator();\n    const drawShapeTexts: DrawTextInfo[] = buildDefaultTextsByShape(shape);\n    return {\n        id,\n        type: 'geometry',\n        shape,\n        angle: 0,\n        opacity: 1,\n        texts: drawShapeTexts,\n        points,\n        ...options\n    };\n};\n\nexport const buildDefaultTextsByShape = (shape: GeometryShapes): DrawTextInfo[] => {\n    const memorizedLatest = getMemorizedLatestByPointer(shape);\n    const textProperties = { ...memorizedLatest.textProperties };\n    const alignment = textProperties?.align;\n    const textHeight = textProperties?.textHeight || DefaultTextProperty.height;\n    delete textProperties?.align;\n    delete textProperties?.textHeight;\n    const defaultTexts = (getDefaultGeometryProperty(shape) as any)?.texts || [];\n    const textKeys = getMultipleTextGeometryTextKeys(shape);\n    return (textKeys || []).map((textKey: string) => {\n        const text = defaultTexts?.find((item: { key: string }) => item?.key === textKey);\n        return {\n            id: textKey,\n            text: buildText(text?.text || '', alignment || text?.align || Alignment.center, textProperties),\n            textHeight: textHeight\n        };\n    });\n};\n\nexport const getHitMultipleGeometryText = (element: PlaitMultipleTextGeometry, point: Point) => {\n    const engine = getEngine<PlaitMultipleTextGeometry>(element.shape);\n    const rectangle = RectangleClient.getRectangleByPoints([point, point]);\n    let hitText;\n    if (engine.getTextRectangle) {\n        hitText = element.texts.find(text => {\n            const textRectangle = engine.getTextRectangle!(element, { id: text.id });\n            return RectangleClient.isHit(rectangle, textRectangle);\n        });\n    }\n    return hitText;\n};\n", "import { PlaitVectorLine } from '../interfaces';\nimport { Generator } from '@plait/common';\nimport { drawVectorLine } from '../utils';\n\nexport class VectorLineShapeGenerator extends Generator<PlaitVectorLine> {\n    canDraw(element: PlaitVectorLine): boolean {\n        return true;\n    }\n\n    draw(element: PlaitVectorLine) {\n        let lineG: SVGGElement | undefined;\n        lineG = drawVectorLine(this.board, element);\n        return lineG;\n    }\n}\n", "import { PlaitBoard, Point, catmullRomFitting, createG, drawLinearPath, idCreator, setStrokeLinecap } from '@plait/core';\nimport { PlaitVectorLine, VectorLineShape } from '../interfaces';\nimport { getLineMemorizedLatest } from './memorize';\nimport { DefaultLineStyle } from '../constants/line';\nimport { alignPoints } from './arrow-line';\nimport { getStrokeWidthByElement } from './common';\nimport { getFillByElement, getStrokeColorByElement, getStrokeStyleByElement } from './style';\nimport { VectorLineShapeGenerator } from '../generators/vector-line-generator';\nimport { pointsOnBezierCurves } from 'points-on-curve';\nimport { getStrokeLineDash, StrokeStyle } from '@plait/common';\n\nexport const getVectorLinePoints = (board: PlaitBoard, element: PlaitVectorLine) => {\n    switch (element.shape) {\n        case VectorLineShape.straight: {\n            return element.points;\n        }\n        case VectorLineShape.curve: {\n            if (element.points.length === 2) {\n                return pointsOnBezierCurves(element.points) as Point[];\n            } else {\n                let dataPoints = element.points;\n                const points = catmullRomFitting(dataPoints);\n                return pointsOnBezierCurves(points) as Point[];\n            }\n        }\n        default:\n            return null;\n    }\n};\n\nexport const createVectorLineElement = (\n    shape: VectorLineShape,\n    points: Point[],\n    options?: Pick<PlaitVectorLine, 'strokeColor' | 'strokeWidth' | 'fill'>\n): PlaitVectorLine => {\n    return {\n        id: idCreator(),\n        type: 'vector-line',\n        shape,\n        opacity: 1,\n        points,\n        ...options\n    };\n};\n\nexport const vectorLineCreating = (\n    board: PlaitBoard,\n    lineShape: VectorLineShape,\n    points: Point[],\n    movingPoint: Point,\n    lineShapeG: SVGGElement\n) => {\n    const lineGenerator = new VectorLineShapeGenerator(board);\n    const memorizedLatest = getLineMemorizedLatest();\n\n    const temporaryLineElement = createVectorLineElement(lineShape, [...points, movingPoint], {\n        strokeWidth: DefaultLineStyle.strokeWidth,\n        ...memorizedLatest\n    });\n    const otherPoint = points[points.length - 1];\n    temporaryLineElement.points[temporaryLineElement.points.length - 1] = alignPoints(otherPoint, movingPoint);\n    lineGenerator.processDrawing(temporaryLineElement, lineShapeG);\n    PlaitBoard.getElementTopHost(board).append(lineShapeG);\n    return temporaryLineElement;\n};\n\nexport const drawVectorLine = (board: PlaitBoard, element: PlaitVectorLine) => {\n    const strokeWidth = getStrokeWidthByElement(element);\n    const strokeColor = getStrokeColorByElement(board, element);\n    const strokeStyle = getStrokeStyleByElement(board, element);\n    const strokeLineDash = getStrokeLineDash(strokeStyle, strokeWidth);\n    const fill = getFillByElement(board, element);\n    const options = { stroke: strokeColor, strokeWidth, strokeLineDash, fill };\n    const lineG = createG();\n    let points = getVectorLinePoints(board, element)!;\n    const line = drawLinearPath(points, options);\n    const id = idCreator();\n    line.setAttribute('mask', `url(#${id})`);\n    if (element.strokeStyle === StrokeStyle.dotted) {\n        setStrokeLinecap(line, 'round');\n    }\n    lineG.appendChild(line);\n    return lineG;\n};\n", "import { getCrossingPointsBetweenPointAndSegment, isPointOnSegment } from '@plait/common';\nimport { Point } from '@plait/core';\n\nexport const getCenterPointsOnPolygon = (points: Point[]) => {\n    const centerPoints: Point[] = [];\n    for (let i = 0; i < points.length; i++) {\n        let j = i == points.length - 1 ? 0 : i + 1;\n        centerPoints.push([(points[i][0] + points[j][0]) / 2, (points[i][1] + points[j][1]) / 2]);\n    }\n    return centerPoints;\n};\n\nexport const getCrossingPointBetweenPointAndPolygon = (corners: Point[], point: Point) => {\n    const result: Point[] = [];\n    for (let index = 1; index <= corners.length; index++) {\n        let start = corners[index - 1];\n        let end = index === corners.length ? corners[0] : corners[index];\n        const crossingPoint = getCrossingPointsBetweenPointAndSegment(point, start, end);\n        result.push(...crossingPoint);\n    }\n    return result;\n};\n\nexport const getPolygonEdgeByConnectionPoint = (corners: Point[], point: Point) => {\n    for (let index = 1; index <= corners.length; index++) {\n        let start = corners[index - 1];\n        let end = index === corners.length ? corners[0] : corners[index];\n        if (isPointOnSegment(point, start, end)) {\n            return [start, end] as [Point, Point];\n        }\n    }\n    return null;\n};\n", "import { PlaitBoard, Point, PointOfRectangle, RectangleClient, SVGArcCommand, distanceBetweenPointAndPoint, setPathStrokeLinecap } from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { getPolygonEdgeByConnectionPoint } from '../../utils/polygon';\nimport { getStrokeWidthByElement } from '../../utils';\nimport { ShapeDefaultSpace } from '../../constants';\nimport { getNearestPointBetweenPointAndArc } from '@plait/core';\n\n\nexport function generateCloudPath(rectangle: RectangleClient): { startPoint: Point; arcCommands: SVGArcCommand[] } {\n    const divisionWidth = rectangle.width / 7;\n    const divisionHeight = rectangle.height / 3.2;\n    const xRadius = divisionWidth / 8.5;\n    const yRadius = divisionHeight / 20;\n\n    const startPoint = [rectangle.x + divisionWidth, rectangle.y + divisionHeight] as Point;\n\n    const arcCommands: SVGArcCommand[] = [\n        {\n            rx: xRadius,\n            ry: yRadius * 1.2,\n            xAxisRotation: 0,\n            largeArcFlag: 1,\n            sweepFlag: 1,\n            endX: rectangle.x + divisionWidth * 2,\n            endY: rectangle.y + divisionHeight / 2\n        },\n        {\n            rx: xRadius,\n            ry: yRadius,\n            xAxisRotation: 0,\n            largeArcFlag: 1,\n            sweepFlag: 1,\n            endX: rectangle.x + divisionWidth * 4.2,\n            endY: rectangle.y + divisionHeight / 2.2\n        },\n        {\n            rx: xRadius,\n            ry: yRadius,\n            xAxisRotation: 0,\n            largeArcFlag: 1,\n            sweepFlag: 1,\n            endX: rectangle.x + divisionWidth * 5.8,\n            endY: rectangle.y + divisionHeight\n        },\n        {\n            rx: xRadius,\n            ry: yRadius * 1.3,\n            xAxisRotation: 0,\n            largeArcFlag: 1,\n            sweepFlag: 1,\n            endX: rectangle.x + divisionWidth * 6,\n            endY: rectangle.y + divisionHeight * 2.2\n        },\n        {\n            rx: xRadius,\n            ry: yRadius * 1.2,\n            xAxisRotation: 0,\n            largeArcFlag: 1,\n            sweepFlag: 1,\n            endX: rectangle.x + divisionWidth * 5,\n            endY: rectangle.y + divisionHeight * 2.8\n        },\n        {\n            rx: xRadius,\n            ry: yRadius / 1.2,\n            xAxisRotation: 0,\n            largeArcFlag: 1,\n            sweepFlag: 1,\n            endX: rectangle.x + divisionWidth * 2.8,\n            endY: rectangle.y + divisionHeight * 2.8\n        },\n        {\n            rx: xRadius,\n            ry: yRadius,\n            xAxisRotation: 0,\n            largeArcFlag: 1,\n            sweepFlag: 1,\n            endX: rectangle.x + divisionWidth,\n            endY: rectangle.y + divisionHeight * 2.2\n        },\n        {\n            rx: xRadius,\n            ry: yRadius * 1.42,\n            xAxisRotation: 0,\n            largeArcFlag: 1,\n            sweepFlag: 1,\n            endX: rectangle.x + divisionWidth,\n            endY: rectangle.y + divisionHeight\n        }\n    ];\n\n    return { startPoint, arcCommands };\n}\n\nexport const CloudEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n        const { startPoint, arcCommands } = generateCloudPath(rectangle);\n\n        const pathData =\n            `M ${startPoint[0]} ${startPoint[1]} ` +\n            arcCommands\n                .map((command) => `A ${command.rx} ${command.ry} ${command.xAxisRotation} ${command.largeArcFlag} ${command.sweepFlag} ${command.endX} ${command.endY}`)\n                .join('\\n') +\n            ' Z';\n\n        const svgElement = rs.path(pathData, { ...options, fillStyle: 'solid' });\n        setPathStrokeLinecap(svgElement, 'round');\n        return svgElement;\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        const rangeRectangle = RectangleClient.getRectangleByPoints([point, point]);\n        return RectangleClient.isHit(rectangle, rangeRectangle);\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        const { startPoint, arcCommands } = generateCloudPath(rectangle);\n        let minDistance = Infinity;\n        let nearestPoint = point;\n\n        let currentStart = startPoint;\n        for (const arcCommand of arcCommands) {\n            const arcNearestPoint = getNearestPointBetweenPointAndArc(point, currentStart, arcCommand);\n            const distance = distanceBetweenPointAndPoint(point[0], point[1], arcNearestPoint[0], arcNearestPoint[1]);\n\n            if (distance < minDistance) {\n                minDistance = distance;\n                nearestPoint = arcNearestPoint;\n            }\n\n            currentStart = [arcCommand.endX, arcCommand.endY];\n        }\n\n        return nearestPoint;\n    },\n    getEdgeByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle): [Point, Point] | null {\n        const corners = CloudEngine.getCornerPoints(rectangle);\n        const point = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        return getPolygonEdgeByConnectionPoint(corners, point);\n    },\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    },\n    getTextRectangle(element: PlaitGeometry) {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const height = element.textHeight!;\n        const originWidth = elementRectangle.width - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth * 2;\n        const width = originWidth / 1.5;\n        return {\n            height,\n            width: width > 0 ? width : 0,\n            x: elementRectangle.x + ShapeDefaultSpace.rectangleAndText + strokeWidth + originWidth / 6,\n            y: elementRectangle.y + elementRectangle.height / 6 + ((elementRectangle.height * 4) / 6 - height) / 2\n        };\n    }\n};\n", "import {\n    PlaitElement,\n    RectangleClient,\n    Selection,\n    PlaitBoard,\n    isLineHitRectangle,\n    Point,\n    distanceBetweenPointAndSegments,\n    distanceBetweenPointAndPoint,\n    HIT_DISTANCE_BUFFER,\n    rotateAntiPointsByElement,\n    isPointInPolygon,\n    rotatePointsByAngle,\n    createDebugGenerator,\n    getNearestPointBetweenPointAndArc,\n    getEllipseArcCenter\n} from '@plait/core';\nimport {\n    BasicShapes,\n    GeometryShapes,\n    PlaitArrowLine,\n    PlaitCommonGeometry,\n    PlaitCustomGeometry,\n    PlaitDrawElement,\n    PlaitGeometry,\n    PlaitShapeElement,\n    PlaitVectorLine\n} from '../interfaces';\nimport { getNearestPoint } from './geometry';\nimport { getArrowLinePoints } from './arrow-line/arrow-line-basic';\nimport { getFillByElement } from './style/stroke';\nimport { getEngine } from '../engines';\nimport { getElementShape } from './shape';\nimport { getHitArrowLineTextIndex } from './position/arrow-line';\nimport { getTextRectangle, isClosedCustomGeometry, isClosedDrawElement, isClosedPoints, isDrawElementIncludeText } from './common';\nimport { isMultipleTextGeometry } from './multi-text-geometry';\nimport { getFirstTextEditor, isFilled, sortElementsByArea } from '@plait/common';\nimport { getVectorLinePoints } from './vector-line';\nimport { Editor, Element } from 'slate';\nimport { generateCloudPath } from '../engines/basic-shapes/cloud';\n\nexport const isTextExceedingBounds = (geometry: PlaitGeometry) => {\n    const client = RectangleClient.getRectangleByPoints(geometry.points);\n    if (geometry.textHeight && geometry.textHeight > client.height) {\n        return true;\n    }\n    return false;\n};\n\nexport const isHitArrowLineText = (board: PlaitBoard, element: PlaitArrowLine, point: Point) => {\n    return getHitArrowLineTextIndex(board, element, point) !== -1;\n};\n\nexport const isHitPolyLine = (pathPoints: Point[], point: Point) => {\n    const distance = distanceBetweenPointAndSegments(point, pathPoints);\n    return distance <= HIT_DISTANCE_BUFFER;\n};\n\nexport const isHitArrowLine = (board: PlaitBoard, element: PlaitArrowLine, point: Point) => {\n    const points = getArrowLinePoints(board, element);\n    const isHitText = isHitArrowLineText(board, element as PlaitArrowLine, point);\n    return isHitText || isHitPolyLine(points, point);\n};\n\nexport const isHitVectorLine = (board: PlaitBoard, element: PlaitVectorLine, point: Point) => {\n    const points = getVectorLinePoints(board, element)!;\n    if (isClosedPoints(element.points)) {\n        return isPointInPolygon(point, points) || isHitPolyLine(points, point);\n    } else {\n        return isHitPolyLine(points, point);\n    }\n};\n\nexport const isRectangleHitElementText = (element: PlaitCommonGeometry, rectangle: RectangleClient) => {\n    const engine = getEngine<PlaitCommonGeometry>(element.shape);\n    if (isMultipleTextGeometry(element)) {\n        const texts = element.texts;\n        return texts.some((item) => {\n            const textClient = engine.getTextRectangle!(element, { id: item.id });\n            return isRectangleHitRotatedPoints(rectangle, RectangleClient.getCornerPoints(textClient), element.angle);\n        });\n    } else {\n        const textClient = engine.getTextRectangle ? engine.getTextRectangle(element) : getTextRectangle(element);\n        return isRectangleHitRotatedPoints(rectangle, RectangleClient.getCornerPoints(textClient), element.angle);\n    }\n};\n\nexport const isHitElementText = (element: PlaitCommonGeometry, point: Point) => {\n    const engine = getEngine<PlaitCommonGeometry>(element.shape);\n    if (isMultipleTextGeometry(element)) {\n        const texts = element.texts;\n        return texts.some((item) => {\n            const textClient = engine.getTextRectangle!(element, { id: item.id });\n            return RectangleClient.isPointInRectangle(textClient, point);\n        });\n    } else {\n        const textClient = engine.getTextRectangle ? engine.getTextRectangle(element) : getTextRectangle(element);\n        return RectangleClient.isPointInRectangle(textClient, point);\n    }\n};\n\nexport const isEmptyTextElement = (element: PlaitCommonGeometry) => {\n    if (!isDrawElementIncludeText(element)) {\n        return true;\n    }\n    const editor = getFirstTextEditor(element);\n    return Editor.isEmpty(editor, editor.children[0] as Element);\n};\n\nexport const isRectangleHitDrawElement = (board: PlaitBoard, element: PlaitElement, selection: Selection) => {\n    const rangeRectangle = RectangleClient.getRectangleByPoints([selection.anchor, selection.focus]);\n    if (PlaitDrawElement.isGeometry(element)) {\n        const isHitElement = isRectangleHitRotatedElement(board, rangeRectangle, element);\n        if (isHitElement) {\n            return isHitElement;\n        }\n        return !isEmptyTextElement(element) && isRectangleHitElementText(element, rangeRectangle);\n    }\n\n    if (PlaitDrawElement.isImage(element)) {\n        return isRectangleHitRotatedElement(board, rangeRectangle, element);\n    }\n\n    if (PlaitDrawElement.isArrowLine(element)) {\n        const points = getArrowLinePoints(board, element);\n        return isLineHitRectangle(points, rangeRectangle);\n    }\n\n    if (PlaitDrawElement.isVectorLine(element)) {\n        const points = getVectorLinePoints(board, element)!;\n        return isLineHitRectangle(points, rangeRectangle);\n    }\n\n    return null;\n};\n\nexport const isRectangleHitRotatedElement = (\n    board: PlaitBoard,\n    rectangle: RectangleClient,\n    element: PlaitElement & { points: Point[] }\n) => {\n    const client = RectangleClient.getRectangleByPoints(element.points);\n    return isRectangleHitRotatedPoints(rectangle, RectangleClient.getCornerPoints(client), element.angle);\n};\n\nexport const isRectangleHitRotatedPoints = (rectangle: RectangleClient, points: Point[], angle: number | undefined) => {\n    let rotatedPoints = rotatePointsByAngle(points, angle) || points;\n    return isLineHitRectangle(rotatedPoints, rectangle);\n};\n\nexport const getHitDrawElement = (board: PlaitBoard, elements: (PlaitDrawElement | PlaitCustomGeometry)[]) => {\n    let firstFilledElement = getFirstFilledDrawElement(board, elements);\n    let endIndex = elements.length;\n    if (firstFilledElement) {\n        endIndex = elements.indexOf(firstFilledElement) + 1;\n    }\n    const newElements = elements.slice(0, endIndex);\n    const solidElements = getSolidElements(newElements);\n    if (solidElements) {\n        return solidElements[0];\n    }\n    const sortElements = sortElementsByArea(board, newElements, 'asc');\n    return sortElements[0];\n};\n\nexport const getFirstFilledDrawElement = (board: PlaitBoard, elements: (PlaitDrawElement | PlaitCustomGeometry)[]) => {\n    let filledElement: PlaitGeometry | PlaitCustomGeometry | null = null;\n    for (let i = 0; i < elements.length; i++) {\n        const element = elements[i];\n        if (isClosedCustomGeometry(board, element) || isClosedDrawElement(element)) {\n            const fill = getFillByElement(board, element);\n            if (isFilled(fill)) {\n                filledElement = element as PlaitGeometry;\n                break;\n            }\n        }\n    }\n    return filledElement;\n};\n\nexport const isFilledDrawElement = (board: PlaitBoard, element: PlaitDrawElement | PlaitCustomGeometry) => {\n    return getFirstFilledDrawElement(board, [element]) !== null;\n};\n\nexport const getSolidElements = (elements: PlaitElement[]) => {\n    const solidElements = elements.filter(\n        (item) => PlaitDrawElement.isText(item) || PlaitDrawElement.isLine(item) || PlaitDrawElement.isImage(item)\n    );\n    if (solidElements.length) {\n        return solidElements;\n    }\n    return null;\n};\n\nconst debugKey = 'debug:plait:hit:shape:edge:sample-points';\nconst debugGenerator = createDebugGenerator(debugKey);\nconst shapes: GeometryShapes[] = [BasicShapes.cloud];\n\nexport const isHitDrawElement = (board: PlaitBoard, element: PlaitElement, point: Point, isStrict: boolean = true) => {\n    const rectangle = board.getRectangle(element);\n    point = rotateAntiPointsByElement(board, point, element) || point;\n    if (PlaitDrawElement.isGeometry(element) && rectangle) {\n        if (debugGenerator.isDebug() && shapes.includes(element.shape)) {\n            debugGenerator.clear();\n            const { startPoint, arcCommands } = generateCloudPath(rectangle);\n            const points = [startPoint, ...arcCommands.map((arc) => [arc.endX, arc.endY])] as Point[];\n            debugGenerator.drawCircles(board, points, 5, false);\n            let minDistance = Infinity;\n            let nearestPoint = point;\n            let currentStart = startPoint;\n            for (const arc of arcCommands) {\n                const arcNearestPoint = getNearestPointBetweenPointAndArc(point, currentStart, arc);\n                const distance = distanceBetweenPointAndPoint(point[0], point[1], arcNearestPoint[0], arcNearestPoint[1]);\n                const { center } = getEllipseArcCenter(currentStart, arc);\n                debugGenerator.drawCircles(board, [center], 8, false, { fill: 'yellow' });\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    nearestPoint = arcNearestPoint;\n                }\n                currentStart = [arc.endX, arc.endY];\n            }\n            debugGenerator.drawCircles(board, [point], 12, false, { fill: 'black', stroke: 'black' });\n            debugGenerator.drawCircles(board, [nearestPoint], 12, false, { fill: 'green', stroke: 'green' });\n        }\n        if (isHitEdgeOfShape(board, element, point, HIT_DISTANCE_BUFFER)) {\n            return true;\n        }\n        const engine = getEngine(getElementShape(element));\n        if (PlaitDrawElement.isText(element)) {\n            const textClient = getTextRectangle(element);\n            return RectangleClient.isPointInRectangle(textClient, point);\n        }\n        if (!!isStrict && isEmptyTextElement(element) && !isFilledDrawElement(board, element)) {\n            return false;\n        }\n        const isHitText = isHitElementText(element, point);\n        return isHitText || engine.isInsidePoint(rectangle!, point);\n    }\n    if (PlaitDrawElement.isImage(element)) {\n        const client = RectangleClient.getRectangleByPoints(element.points);\n        return RectangleClient.isPointInRectangle(client, point);\n    }\n    if (PlaitDrawElement.isArrowLine(element)) {\n        return isHitArrowLine(board, element, point);\n    }\n\n    if (PlaitDrawElement.isVectorLine(element)) {\n        return isHitVectorLine(board, element, point);\n    }\n    return null;\n};\n\nexport const isHitEdgeOfShape = (board: PlaitBoard, element: PlaitShapeElement, point: Point, hitDistanceBuffer: number) => {\n    const nearestPoint = getNearestPoint(element, point);\n    const distance = distanceBetweenPointAndPoint(nearestPoint[0], nearestPoint[1], point[0], point[1]);\n    return distance <= hitDistanceBuffer;\n};\n\nexport const isInsideOfShape = (board: PlaitBoard, element: PlaitShapeElement, point: Point, hitDistanceBuffer: number) => {\n    const client = RectangleClient.inflate(RectangleClient.getRectangleByPoints(element.points), hitDistanceBuffer);\n    return getEngine(getElementShape(element)).isInsidePoint(client, point);\n};\n\nexport const isHitElementInside = (board: PlaitBoard, element: PlaitElement, point: Point) => {\n    const rectangle = board.getRectangle(element);\n    point = rotateAntiPointsByElement(board, point, element) || point;\n    if (PlaitDrawElement.isGeometry(element) && !PlaitDrawElement.isGeometryByTable(element)) {\n        const engine = getEngine(getElementShape(element));\n        const isHitInside = engine.isInsidePoint(rectangle!, point);\n        if (isHitInside) {\n            return isHitInside;\n        }\n        if (engine.getTextRectangle) {\n            const isHitText = isHitElementText(element, point);\n            if (isHitText) {\n                return isHitText;\n            }\n        }\n    }\n    if (PlaitDrawElement.isImage(element)) {\n        const client = RectangleClient.getRectangleByPoints(element.points);\n        return RectangleClient.isPointInRectangle(client, point);\n    }\n\n    if (PlaitDrawElement.isArrowLine(element)) {\n        return isHitArrowLine(board, element, point);\n    }\n\n    if (PlaitDrawElement.isVectorLine(element)) {\n        return isHitVectorLine(board, element, point);\n    }\n\n    return null;\n};\n", "import {\n    ACTIVE_STROKE_WIDTH,\n    addSelectedElement,\n    Ancestor,\n    BoardTransforms,\n    clearSelectedElement,\n    createG,\n    depthFirstRecursion,\n    drawCircle,\n    getI18nValue,\n    getIsRecursionFunc,\n    PlaitBoard,\n    PlaitElement,\n    PlaitPointerType,\n    Point,\n    RectangleClient,\n    rotateAntiPointsByElement,\n    SELECTION_BORDER_COLOR,\n    SELECTION_FILL_COLOR,\n    SNAPPING_STROKE_WIDTH,\n    Transforms\n} from '@plait/core';\nimport {\n    DefaultDrawStyle,\n    DefaultTextProperty,\n    DrawI18nKey,\n    LINE_HIT_GEOMETRY_BUFFER,\n    LINE_SNAPPING_BUFFER,\n    ShapeDefaultSpace\n} from '../constants';\nimport {\n    DrawOptions,\n    DrawShapes,\n    GeometryCommonTextKeys,\n    PlaitBaseGeometry,\n    PlaitCommonGeometry,\n    PlaitCustomGeometry,\n    PlaitDrawElement,\n    PlaitGeometry,\n    PlaitShapeElement\n} from '../interfaces';\nimport { Alignment, getTextEditorsByElement } from '@plait/common';\nimport { isCellIncludeText } from './table';\nimport { getEngine } from '../engines';\nimport { getElementShape } from './shape';\nimport { Options } from 'roughjs/bin/core';\nimport { PlaitBaseTable } from '../interfaces/table';\nimport { memorizeLatestShape } from './memorize';\nimport { isHitEdgeOfShape, isInsideOfShape } from './hit';\nimport { getHitConnectorPoint } from './arrow-line';\nimport { getNearestPoint, isGeometryClosed, isGeometryIncludeText, isSingleTextGeometry } from './geometry';\nimport { isMultipleTextGeometry } from './multi-text-geometry';\nimport { DrawTextInfo } from '../generators/text.generator';\n\nexport const getTextRectangle = <T extends PlaitElement = PlaitGeometry>(element: T) => {\n    const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n    const strokeWidth = getStrokeWidthByElement(element);\n    const height = element.textHeight!;\n    const width = elementRectangle.width - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth * 2;\n    return {\n        height,\n        width: width > 0 ? width : 0,\n        x: elementRectangle.x + ShapeDefaultSpace.rectangleAndText + strokeWidth,\n        y: elementRectangle.y + (elementRectangle.height - height) / 2\n    };\n};\n\nexport const getStrokeWidthByElement = (element: PlaitElement) => {\n    if (PlaitDrawElement.isText(element)) {\n        return 0;\n    }\n    const strokeWidth = element.strokeWidth || DefaultDrawStyle.strokeWidth;\n    return strokeWidth;\n};\n\nexport const insertElement = (board: PlaitBoard, element: PlaitBaseGeometry | PlaitBaseTable) => {\n    memorizeLatestShape(board, element.shape);\n    Transforms.insertNode(board, element, [board.children.length]);\n    clearSelectedElement(board);\n    addSelectedElement(board, element);\n    BoardTransforms.updatePointerType(board, PlaitPointerType.selection);\n};\n\nexport const isDrawElementIncludeText = (element: PlaitDrawElement) => {\n    if (PlaitDrawElement.isText(element)) {\n        return true;\n    }\n    if (PlaitDrawElement.isImage(element)) {\n        return false;\n    }\n    if (PlaitDrawElement.isGeometry(element)) {\n        return isGeometryIncludeText(element);\n    }\n    if (PlaitDrawElement.isArrowLine(element)) {\n        const editors = getTextEditorsByElement(element);\n        return editors.length > 0;\n    }\n    if (PlaitDrawElement.isElementByTable(element)) {\n        return element.cells.some((cell) => isCellIncludeText(cell));\n    }\n    return true;\n};\n\nexport const isDrawElementsIncludeText = (elements: PlaitDrawElement[]) => {\n    return elements.some((item) => {\n        return isDrawElementIncludeText(item);\n    });\n};\n\nexport const isClosedDrawElement = (element: PlaitElement) => {\n    if (PlaitDrawElement.isDrawElement(element)) {\n        if (PlaitDrawElement.isText(element) || PlaitDrawElement.isArrowLine(element) || PlaitDrawElement.isImage(element)) {\n            return false;\n        }\n        if (PlaitDrawElement.isVectorLine(element)) {\n            return isClosedPoints(element.points);\n        }\n        if (PlaitDrawElement.isGeometry(element)) {\n            return isGeometryClosed(element);\n        }\n        return true;\n    }\n    return false;\n};\n\nexport const isClosedCustomGeometry = (board: PlaitBoard, value: PlaitElement): value is PlaitCustomGeometry => {\n    return PlaitDrawElement.isCustomGeometryElement(board, value) && isClosedPoints(value.points);\n};\n\nexport const getSnappingShape = (board: PlaitBoard, point: Point): PlaitShapeElement | null => {\n    let hitElement: PlaitShapeElement | null = getHitShape(board, point);\n    if (hitElement) {\n        const ref = getSnappingRef(board, hitElement, point);\n        if (ref.isHitConnector || ref.isHitEdge) {\n            return hitElement;\n        }\n    }\n    return null;\n};\n\nexport const getSnappingRef = (board: PlaitBoard, hitElement: PlaitShapeElement, point: Point) => {\n    const rotatedPoint = rotateAntiPointsByElement(board, point, hitElement) || point;\n    const connectorPoint = getHitConnectorPoint(rotatedPoint, hitElement);\n    const edgePoint = getNearestPoint(hitElement, rotatedPoint);\n    const isHitEdge = isHitEdgeOfShape(board, hitElement, rotatedPoint, LINE_SNAPPING_BUFFER);\n    return { isHitEdge, isHitConnector: !!connectorPoint, connectorPoint, edgePoint };\n};\n\nexport const getHitShape = (board: PlaitBoard, point: Point, offset = LINE_HIT_GEOMETRY_BUFFER): PlaitShapeElement | null => {\n    let hitShape: PlaitShapeElement | null = null;\n    traverseDrawShapes(board, (element: PlaitShapeElement) => {\n        if (hitShape === null && isInsideOfShape(board, element, rotateAntiPointsByElement(board, point, element) || point, offset * 2)) {\n            hitShape = element;\n        }\n    });\n    return hitShape;\n};\n\nexport const traverseDrawShapes = (board: PlaitBoard, callback: (element: PlaitShapeElement) => void) => {\n    depthFirstRecursion<Ancestor>(\n        board,\n        (node) => {\n            if (!PlaitBoard.isBoard(node) && PlaitDrawElement.isShapeElement(node)) {\n                callback(node);\n            }\n        },\n        getIsRecursionFunc(board),\n        true\n    );\n};\n\nexport const drawShape = (\n    board: PlaitBoard,\n    outerRectangle: RectangleClient,\n    shape: DrawShapes,\n    roughOptions: Options,\n    drawOptions?: DrawOptions\n) => {\n    return getEngine(shape).draw(board, outerRectangle, roughOptions, drawOptions);\n};\n\nexport const drawBoundReaction = (\n    board: PlaitBoard,\n    element: PlaitShapeElement,\n    roughOptions: { hasMask: boolean; hasConnector: boolean } = { hasMask: true, hasConnector: true }\n) => {\n    const g = createG();\n    const rectangle = RectangleClient.getRectangleByPoints(element.points);\n    const activeRectangle = RectangleClient.inflate(rectangle, SNAPPING_STROKE_WIDTH);\n    const shape = getElementShape(element);\n    let drawOptions: DrawOptions | undefined;\n    if (PlaitDrawElement.isElementByTable(element)) {\n        drawOptions = { element };\n    }\n    const strokeG = drawShape(\n        board,\n        activeRectangle,\n        shape,\n        {\n            stroke: SELECTION_BORDER_COLOR,\n            strokeWidth: SNAPPING_STROKE_WIDTH\n        },\n        drawOptions\n    );\n    g.appendChild(strokeG);\n\n    if (roughOptions.hasMask) {\n        const maskG = drawShape(\n            board,\n            activeRectangle,\n            shape,\n            {\n                stroke: SELECTION_BORDER_COLOR,\n                strokeWidth: 0,\n                fill: isClosedDrawElement(element) ? SELECTION_FILL_COLOR : DefaultDrawStyle.fill,\n                fillStyle: 'solid'\n            },\n            drawOptions\n        );\n        g.appendChild(maskG);\n    }\n    if (roughOptions.hasConnector) {\n        const connectorPoints = getEngine(shape).getConnectorPoints(rectangle);\n        connectorPoints.forEach((point) => {\n            const circleG = drawCircle(PlaitBoard.getRoughSVG(board), point, 8, {\n                stroke: SELECTION_BORDER_COLOR,\n                strokeWidth: ACTIVE_STROKE_WIDTH,\n                fill: '#FFF',\n                fillStyle: 'solid'\n            });\n            g.appendChild(circleG);\n        });\n    }\n    return g;\n};\n\nexport const getTextKey = (element: PlaitElement | undefined, text: Pick<DrawTextInfo, 'id'>) => {\n    if (element && isMultipleTextGeometry(element)) {\n        return `${element.id}-${text.id}`;\n    } else {\n        return text.id;\n    }\n};\n\nexport const getGeometryAlign = (board: PlaitBoard, element: PlaitCommonGeometry | PlaitBaseTable) => {\n    if (isMultipleTextGeometry(element)) {\n        const drawShapeText = element.texts.find((item) => item.id.includes(GeometryCommonTextKeys.content));\n        return drawShapeText?.text.align || Alignment.center;\n    }\n    if (isSingleTextGeometry(element as PlaitCommonGeometry)) {\n        return (element as PlaitGeometry).text?.align || Alignment.center;\n    }\n\n    if (PlaitDrawElement.isElementByTable(element)) {\n        const firstTextCell = element.cells.find((item) => item.text);\n        return firstTextCell?.text?.align || Alignment.center;\n    }\n    return Alignment.center;\n};\n\nexport const isClosedPoints = (points: Point[]) => {\n    const startPoint = points[0];\n    const endPoint = points[points.length - 1];\n    return startPoint[0] === endPoint[0] && startPoint[1] === endPoint[1];\n};\n\nexport const getDefaultGeometryText = (board: PlaitBoard) => {\n    return getI18nValue(board, DrawI18nKey.geometryText, DefaultTextProperty.text);\n};\n", "import { PlaitDrawElement } from '../../interfaces';\nimport { DefaultDrawStyle } from '../../constants';\nimport { PlaitBoard, PlaitElement } from '@plait/core';\nimport { getDrawDefaultStrokeColor, getFlowchartDefaultFill } from '../geometry';\nimport { isClosedDrawElement } from '../common';\nimport { StrokeStyle } from '@plait/common';\n\nexport const getStrokeColorByElement = (board: PlaitBoard, element: PlaitElement) => {\n    const defaultColor = getDrawDefaultStrokeColor(board.theme.themeColorMode);\n    const strokeColor = element.strokeColor || defaultColor;\n    return strokeColor;\n};\n\nexport const getFillByElement = (board: PlaitBoard, element: PlaitElement) => {\n    const defaultFill =\n        PlaitDrawElement.isFlowchart(element) && isClosedDrawElement(element as PlaitDrawElement)\n            ? getFlowchartDefaultFill(board.theme.themeColorMode)\n            : DefaultDrawStyle.fill;\n    const fill = element.fill || defaultFill;\n    return fill;\n};\n\nexport const getStrokeStyleByElement = (board: PlaitBoard, element: PlaitElement) => {\n    return element.strokeStyle || StrokeStyle.solid;\n};\n", "import { BasicShapes, PlaitGeometry } from '../interfaces';\nimport { Generator, getStrokeLineDash } from '@plait/common';\nimport { getFillByElement, getStrokeColorByElement, getStrokeStyleByElement } from '../utils/style/stroke';\nimport { drawGeometry, getStrokeWidthByElement } from '../utils';\nimport { RectangleClient } from '@plait/core';\n\nexport interface ShapeData {}\n\nexport class GeometryShapeGenerator extends Generator<PlaitGeometry, ShapeData> {\n    canDraw(element: PlaitGeometry, data: ShapeData): boolean {\n        return true;\n    }\n\n    draw(element: PlaitGeometry, data: ShapeData) {\n        const rectangle = RectangleClient.getRectangleByPoints(element.points);\n        const shape = element.shape;\n        if (shape === BasicShapes.text) {\n            return;\n        }\n        const fill = getFillByElement(this.board, element);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const strokeColor = getStrokeColorByElement(this.board, element);\n        const strokeStyle = getStrokeStyleByElement(this.board, element);\n        const strokeLineDash = getStrokeLineDash(strokeStyle, strokeWidth);\n        return drawGeometry(this.board, RectangleClient.inflate(rectangle, -strokeWidth), shape, {\n            stroke: strokeColor,\n            strokeWidth,\n            fill,\n            strokeLineDash\n        });\n    }\n}\n", "import { PlaitBoard, Point, distanceBetweenPointAndPoint } from '@plait/core';\nimport { PlaitLine } from '../interfaces/line';\nimport { ArrowLineShape, PlaitArrowLine, PlaitDrawElement, PlaitVectorLine } from '../interfaces';\nimport {\n    getCurvePoints,\n    getElbowLineRouteOptions,\n    getElbowPoints,\n    getNextSourceAndTargetPoints,\n    isUseDefaultOrthogonalRoute\n} from './arrow-line';\nimport { getVectorLinePoints } from './vector-line';\n\nexport function getMiddlePoints(board: PlaitBoard, element: PlaitLine) {\n    const result: Point[] = [];\n    const shape = element.shape;\n    const hideBuffer = 10;\n    if (shape === ArrowLineShape.straight) {\n        const points = PlaitDrawElement.isArrowLine(element)\n            ? PlaitArrowLine.getPoints(board, element)\n            : (element as PlaitVectorLine).points;\n        for (let i = 0; i < points.length - 1; i++) {\n            const distance = distanceBetweenPointAndPoint(...points[i], ...points[i + 1]);\n            if (distance < hideBuffer) continue;\n            result.push([(points[i][0] + points[i + 1][0]) / 2, (points[i][1] + points[i + 1][1]) / 2]);\n        }\n    }\n    if (shape === ArrowLineShape.curve) {\n        const points = PlaitDrawElement.isArrowLine(element)\n            ? PlaitArrowLine.getPoints(board, element)\n            : (element as PlaitVectorLine).points;\n        const pointsOnBezier = PlaitDrawElement.isArrowLine(element)\n            ? getCurvePoints(board, element)\n            : getVectorLinePoints(board, element)!;\n        if (points.length === 2) {\n            const start = 0;\n            const endIndex = pointsOnBezier.length - 1;\n            const middleIndex = Math.round((start + endIndex) / 2);\n            result.push(pointsOnBezier[middleIndex]);\n        } else {\n            for (let i = 0; i < points.length - 1; i++) {\n                const startIndex = pointsOnBezier.findIndex(point => point[0] === points[i][0] && point[1] === points[i][1]);\n                const endIndex = pointsOnBezier.findIndex(point => point[0] === points[i + 1][0] && point[1] === points[i + 1][1]);\n                const middleIndex = Math.round((startIndex + endIndex) / 2);\n                const distance = distanceBetweenPointAndPoint(...points[i], ...points[i + 1]);\n                if (distance < hideBuffer) continue;\n                result.push(pointsOnBezier[middleIndex]);\n            }\n        }\n    }\n    if (shape === ArrowLineShape.elbow) {\n        const renderPoints = getElbowPoints(board, element);\n        const options = getElbowLineRouteOptions(board, element);\n        if (!isUseDefaultOrthogonalRoute(element, options)) {\n            const [nextSourcePoint, nextTargetPoint] = getNextSourceAndTargetPoints(board, element);\n            for (let i = 0; i < renderPoints.length - 1; i++) {\n                if (\n                    (i == 0 && Point.isEquals(renderPoints[i + 1], nextSourcePoint)) ||\n                    (i === renderPoints.length - 2 && Point.isEquals(renderPoints[renderPoints.length - 2], nextTargetPoint))\n                ) {\n                    continue;\n                }\n                const [currentX, currentY] = renderPoints[i];\n                const [nextX, nextY] = renderPoints[i + 1];\n                const middlePoint = [(currentX + nextX) / 2, (currentY + nextY) / 2] as Point;\n                result.push(middlePoint);\n            }\n        }\n    }\n    return result;\n}\n", "import { PlaitBoard, Point, RectangleClient } from '@plait/core';\nimport { ArrowLineShape, PlaitArrowLine, PlaitDrawElement } from '../../interfaces';\nimport { RESIZE_HANDLE_DIAMETER } from '@plait/common';\nimport { PlaitLine } from '../../interfaces/line';\nimport { getMiddlePoints } from '../line';\n\nexport enum LineResizeHandle {\n    'source' = 'source',\n    'target' = 'target',\n    'addHandle' = 'addHandle'\n}\n\nexport const getHitLineResizeHandleRef = (board: PlaitBoard, element: PlaitLine, point: Point) => {\n    let dataPoints = PlaitDrawElement.isArrowLine(element) ? PlaitArrowLine.getPoints(board, element) : element.points;\n    const index = getHitPointIndex(dataPoints, point);\n    if (index !== -1) {\n        const handleIndex = index;\n        if (index === 0) {\n            return { handle: LineResizeHandle.source, handleIndex };\n        }\n        if (index === dataPoints.length - 1) {\n            return { handle: LineResizeHandle.target, handleIndex };\n        }\n        // elbow line, data points only verify source connection point and target connection point\n        if (element.shape !== ArrowLineShape.elbow) {\n            return { handleIndex };\n        }\n    }\n    const middlePoints = getMiddlePoints(board, element);\n    const indexOfMiddlePoints = getHitPointIndex(middlePoints, point);\n    if (indexOfMiddlePoints !== -1) {\n        return {\n            handle: LineResizeHandle.addHandle,\n            handleIndex: indexOfMiddlePoints\n        };\n    }\n    return undefined;\n};\n\nexport function getHitPointIndex(points: Point[], movingPoint: Point) {\n    const rectangles = points.map(point => {\n        return {\n            x: point[0] - RESIZE_HANDLE_DIAMETER / 2,\n            y: point[1] - RESIZE_HANDLE_DIAMETER / 2,\n            width: RESIZE_HANDLE_DIAMETER,\n            height: RESIZE_HANDLE_DIAMETER\n        };\n    });\n    const rectangle = rectangles.find(rectangle => {\n        return RectangleClient.isHit(RectangleClient.getRectangleByPoints([movingPoint, movingPoint]), rectangle);\n    });\n    return rectangle ? rectangles.indexOf(rectangle) : -1;\n}\n", "import {\n    PlaitBoard,\n    Point,\n    SELECTION_RECTANGLE_CLASS_NAME,\n    createG,\n    drawRectangle,\n    getSelectedElements,\n    toActivePointFromViewBoxPoint,\n    toActiveRectangleFromViewBoxRectangle\n} from '@plait/core';\nimport { ArrowLineShape, PlaitArrowLine, PlaitDrawElement } from '../interfaces';\nimport { Generator, PRIMARY_COLOR, drawFillPrimaryHandle, drawPrimaryHandle } from '@plait/common';\nimport { getMiddlePoints } from '../utils/line';\nimport { getNextRenderPoints } from '../utils/arrow-line/elbow';\nimport { isUpdatedHandleIndex } from '../utils/arrow-line';\nimport { getHitPointIndex } from '../utils/position/line';\nimport { DefaultDrawActiveStyle } from '../constants';\nimport { PlaitLine } from '../interfaces/line';\n\nexport interface ActiveData {\n    selected: boolean;\n    linePoints: Point[];\n}\n\nexport class LineActiveGenerator extends Generator<PlaitLine, ActiveData> {\n    onlySelectedCurrentLine = false;\n\n    constructor(protected board: PlaitBoard, options: { active: boolean } = { active: true }) {\n        super(board, options);\n    }\n\n    canDraw(element: PlaitLine, data: ActiveData): boolean {\n        if (data.selected) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    draw(element: PlaitLine, data: ActiveData): SVGGElement {\n        const activeG = createG();\n        const selectedElements = getSelectedElements(this.board);\n        this.onlySelectedCurrentLine = selectedElements.length === 1;\n        if (this.onlySelectedCurrentLine) {\n            activeG.classList.add(SELECTION_RECTANGLE_CLASS_NAME);\n            const points = PlaitDrawElement.isArrowLine(element) ? PlaitArrowLine.getPoints(this.board, element) : element.points;\n            let updatePoints = [...points];\n            let elbowNextRenderPoints: Point[] = [];\n            if (element.shape === ArrowLineShape.elbow) {\n                updatePoints = points.slice(0, 1).concat(points.slice(-1));\n                elbowNextRenderPoints = getNextRenderPoints(this.board, element, data.linePoints);\n            }\n            const activePoints = updatePoints.map((point) => toActivePointFromViewBoxPoint(this.board, point));\n            activePoints.forEach((point) => {\n                const updateHandle = drawPrimaryHandle(this.board, point);\n                activeG.appendChild(updateHandle);\n            });\n            const middlePoints = getMiddlePoints(this.board, element);\n            const activeMiddlePoints = middlePoints.map((point) => toActivePointFromViewBoxPoint(this.board, point));\n            if (!PlaitBoard.hasBeenTextEditing(this.board)) {\n                for (let i = 0; i < activeMiddlePoints.length; i++) {\n                    const point = activeMiddlePoints[i];\n                    if (element.shape === ArrowLineShape.elbow && elbowNextRenderPoints.length) {\n                        const handleIndex = getHitPointIndex(activeMiddlePoints, point);\n                        const isUpdateHandleIndex = isUpdatedHandleIndex(\n                            this.board,\n                            element,\n                            [...points],\n                            elbowNextRenderPoints,\n                            handleIndex\n                        );\n                        if (isUpdateHandleIndex) {\n                            const updateHandle = drawPrimaryHandle(this.board, point);\n                            activeG.appendChild(updateHandle);\n                            continue;\n                        }\n                    }\n                    const circle = drawFillPrimaryHandle(this.board, point);\n                    activeG.appendChild(circle);\n                }\n            }\n        } else {\n            const rectangle = this.board.getRectangle(element);\n            if (rectangle) {\n                const activeRectangle = toActiveRectangleFromViewBoxRectangle(this.board, rectangle);\n                let opacity = '0.5';\n                if (activeRectangle.height === 0 || activeRectangle.width === 0) {\n                    opacity = '0.8';\n                }\n                const strokeG = drawRectangle(this.board, activeRectangle, {\n                    stroke: PRIMARY_COLOR,\n                    strokeWidth: DefaultDrawActiveStyle.selectionStrokeWidth\n                });\n                strokeG.style.opacity = opacity;\n                activeG.appendChild(strokeG);\n            }\n        }\n        return activeG;\n    }\n\n    needUpdate() {\n        const selectedElements = getSelectedElements(this.board);\n        const onlySelectedCurrentLine = selectedElements.length === 1;\n        return onlySelectedCurrentLine !== this.onlySelectedCurrentLine;\n    }\n}\n", "import { PlaitBoard, rgbaToHEX, createG, drawCircle, getSelectedElements, isSelectionMoving } from '@plait/core';\nimport { PlaitGeometry, PlaitShapeElement } from '../interfaces';\nimport { ActiveGeneratorExtraData, Generator, PRIMARY_COLOR } from '@plait/common';\nimport { getAutoCompletePoints } from '../utils';\nimport { LINE_AUTO_COMPLETE_DIAMETER, LINE_AUTO_COMPLETE_OPACITY } from '../constants/line';\n\nexport class ArrowLineAutoCompleteGenerator<T extends PlaitShapeElement = PlaitGeometry> extends Generator<T, ActiveGeneratorExtraData> {\n    static key = 'line-auto-complete-generator';\n\n    autoCompleteG!: SVGGElement;\n    hoverElement: SVGGElement | null = null;\n\n    constructor(public board: PlaitBoard) {\n        super(board, { active: true });\n    }\n\n    canDraw(element: PlaitShapeElement, data: ActiveGeneratorExtraData): boolean {\n        const selectedElements = getSelectedElements(this.board);\n        if (data.selected && selectedElements.length === 1 && !isSelectionMoving(this.board)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    draw(element: T, data: ActiveGeneratorExtraData): SVGGElement {\n        this.autoCompleteG = createG();\n        const middlePoints = getAutoCompletePoints(this.board, element, true);\n        middlePoints.forEach((point, index) => {\n            const circle = drawCircle(PlaitBoard.getRoughSVG(this.board), point, LINE_AUTO_COMPLETE_DIAMETER, {\n                stroke: 'none',\n                fill: rgbaToHEX(PRIMARY_COLOR, LINE_AUTO_COMPLETE_OPACITY),\n                fillStyle: 'solid'\n            });\n            circle.classList.add(`line-auto-complete-${index}`);\n            this.autoCompleteG.appendChild(circle);\n        });\n        return this.autoCompleteG;\n    }\n\n    removeAutoCompleteG(index: number) {\n        this.hoverElement = this.autoCompleteG.querySelector(`.line-auto-complete-${index}`);\n        this.hoverElement!.style.visibility = 'hidden';\n    }\n\n    recoverAutoCompleteG() {\n        if (this.hoverElement) {\n            this.hoverElement.style.visibility = 'visible';\n            this.hoverElement = null;\n        }\n    }\n}\n", "import { PlaitBoard, PlaitElement } from '@plait/core';\nimport { PlaitCommonGeometry, PlaitGeometry } from '../interfaces';\nimport { DrawTextInfo, TextGenerator, TextGeneratorOptions } from './text.generator';\nimport { isMultipleTextGeometry } from '../utils';\nimport { ParagraphElement } from '@plait/common';\n\nexport class SingleTextGenerator<T extends PlaitElement = PlaitGeometry> extends TextGenerator<T> {\n    get textManage() {\n        return this.textManages[0];\n    }\n\n    constructor(board: PlaitBoard, element: T, text: ParagraphElement, options: TextGeneratorOptions<T>) {\n        super(board, element, [{ id: element.id, text: text, textHeight: element.textHeight }], options);\n    }\n\n    update(element: T, previousDrawShapeTexts: DrawTextInfo[], currentDrawShapeTexts: DrawTextInfo[], elementG: SVGElement): void;\n    update(element: T, previousText: ParagraphElement, currentText: ParagraphElement, elementG: SVGElement): void;\n    update(\n        element: T,\n        previousText: ParagraphElement | DrawTextInfo[],\n        currentText: ParagraphElement | DrawTextInfo[],\n        elementG: SVGElement\n    ) {\n        if (!isMultipleTextGeometry((element as unknown) as PlaitCommonGeometry)) {\n            super.update(\n                element,\n                [{ text: previousText as ParagraphElement, id: element.id, textHeight: element.textHeight }],\n                [{ text: currentText as ParagraphElement, id: element.id, textHeight: element.textHeight }],\n                elementG\n            );\n        }\n    }\n}\n", "import { TableSymbols } from '../interfaces';\nimport { Generator, getStrokeLineDash } from '@plait/common';\nimport { PlaitElement, RectangleClient } from '@plait/core';\nimport { PlaitBaseTable } from '../interfaces/table';\nimport { getEngine } from '../engines';\nimport { getStrokeColorByElement, getStrokeStyleByElement, getStrokeWidthByElement } from '../utils';\n\nexport interface TableData {}\n\nexport class TableGenerator<T extends PlaitElement = PlaitBaseTable> extends Generator<T, TableData> {\n    canDraw(element: T, data: TableData): boolean {\n        return true;\n    }\n\n    draw(element: T, data: TableData) {\n        const rectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const strokeColor = getStrokeColorByElement(this.board, element);\n        const strokeStyle = getStrokeStyleByElement(this.board, element);\n        const strokeLineDash = getStrokeLineDash(strokeStyle, strokeWidth);\n        return getEngine(TableSymbols.table).draw(\n            this.board,\n            rectangle,\n            {\n                strokeWidth,\n                stroke: strokeColor,\n                strokeLineDash\n            },\n            {\n                element: element\n            }\n        );\n    }\n}\n", "import { PlaitBoard } from '@plait/core';\nimport { BasicShapes, PlaitDrawElement, PlaitGeometry, PlaitShapeElement, TableSymbols } from '../interfaces';\nimport { DrawPointerType } from '../constants/pointer';\nimport { GeometryShapeGenerator, TableGenerator } from '../generators';\n\nexport const getElementShape = (value: PlaitShapeElement) => {\n    if (PlaitDrawElement.isImage(value)) {\n        return BasicShapes.rectangle;\n    }\n    if (PlaitDrawElement.isTable(value)) {\n        return TableSymbols.table;\n    }\n    return value.shape;\n};\n\nexport const getGeometryGeneratorByShape = (board: PlaitBoard, shape: DrawPointerType) => {\n    if (PlaitDrawElement.isUMLClassOrInterface({ shape: shape })) {\n        return new TableGenerator<PlaitGeometry>(board);\n    } else {\n        return new GeometryShapeGenerator(board);\n    }\n};\n", "import { PlaitBoard, Point, idCreator } from '@plait/core';\nimport { DefaultBasicShapeProperty } from '../constants';\nimport { GeometryShapes, UMLSymbols, PlaitCommonGeometry } from '../interfaces';\nimport { getMemorizedLatestByPointer } from './memorize';\nimport { GeometryStyleOptions, getDefaultGeometryProperty, getTextShapeProperty } from './geometry';\nimport { PlaitTableCell } from '../interfaces/table';\nimport { getDefaultGeometryText } from './common';\n\nexport const createUMLClassOrInterfaceGeometryElement = (board: PlaitBoard, shape: GeometryShapes, points: [Point, Point]) => {\n    const memorizedLatest = getMemorizedLatestByPointer(shape);\n    const element = {\n        id: idCreator(),\n        type: 'geometry',\n        angle: 0,\n        opacity: 1,\n        points,\n        strokeWidth: DefaultBasicShapeProperty.strokeWidth,\n        ...(memorizedLatest.geometryProperties as GeometryStyleOptions)\n    };\n    let rows: { id: string; height?: number }[];\n    let columns: { id: string; height?: number }[];\n    if (shape === UMLSymbols.class) {\n        rows = [\n            {\n                id: idCreator(),\n                height: 30\n            },\n            {\n                id: idCreator()\n            },\n            {\n                id: idCreator()\n            }\n        ];\n        columns = [\n            {\n                id: idCreator()\n            }\n        ];\n    } else {\n        rows = [\n            {\n                id: idCreator(),\n                height: 50\n            },\n            {\n                id: idCreator()\n            }\n        ];\n        columns = [\n            {\n                id: idCreator()\n            }\n        ];\n    }\n    return {\n        ...element,\n        shape,\n        rows,\n        columns,\n        cells: buildTableCellsForGeometry(board, rows, columns, shape)\n    } as unknown as PlaitCommonGeometry;\n};\n\nconst buildTableCellsForGeometry = (\n    board: PlaitBoard,\n    rows: {\n        id: string;\n        height?: number;\n    }[],\n    columns: {\n        id: string;\n        height?: number;\n    }[],\n    shape: GeometryShapes\n): PlaitTableCell[] => {\n    const memorizedLatest = getMemorizedLatestByPointer(shape);\n    const cellCount = rows.length * columns.length;\n    const defaultTexts = (getDefaultGeometryProperty(shape) as any)?.texts || [];\n    const textHeights = defaultTexts.map((textItem: { text: string }) => {\n        return getTextShapeProperty(board, textItem.text || getDefaultGeometryText(board), memorizedLatest.textProperties['font-size'])\n            .height;\n    });\n    return new Array(cellCount).fill('').map((item, index) => {\n        const rowIndex = Math.floor(index / columns.length);\n        const columnIndex = index % columns.length;\n        return {\n            id: idCreator(),\n            rowId: rows[rowIndex].id,\n            columnId: columns[columnIndex].id,\n            textHeight: textHeights[index],\n            text: {\n                children: [\n                    {\n                        text: defaultTexts[index].text\n                    }\n                ],\n                align: defaultTexts[index].align\n            }\n        };\n    });\n};\n", "import {\n    PlaitBoard,\n    PlaitElement,\n    Point,\n    RectangleClient,\n    ThemeColorMode,\n    getSelectedElements,\n    idCreator,\n    toActiveRectangleFromViewBoxRectangle\n} from '@plait/core';\nimport { GeometryShapes, BasicShapes, PlaitGeometry, FlowchartSymbols, UMLSymbols } from '../interfaces/geometry';\nimport { Element } from 'slate';\nimport {\n    DefaultBasicShapeProperty,\n    DefaultBasicShapePropertyMap,\n    DefaultFlowchartPropertyMap,\n    DefaultTextProperty,\n    DefaultUMLPropertyMap,\n    DrawPointerType,\n    DrawThemeColors,\n    GEOMETRY_NOT_CLOSED,\n    GEOMETRY_WITHOUT_TEXT,\n    ShapeDefaultSpace,\n    getFlowchartPointers,\n    getUMLPointers\n} from '../constants';\nimport {\n    ActiveGenerator,\n    Alignment,\n    CustomText,\n    DEFAULT_FONT_FAMILY,\n    PlaitCommonElementRef,\n    RESIZE_HANDLE_DIAMETER,\n    buildText,\n    getFirstTextManage,\n    measureElement\n} from '@plait/common';\nimport { Options } from 'roughjs/bin/core';\nimport { getEngine } from '../engines';\nimport { getElementShape } from './shape';\nimport { PlaitDrawElement, PlaitShapeElement } from '../interfaces';\nimport { getMemorizedLatestByPointer } from './memorize';\nimport { DrawTextInfo, getTextManage } from '../generators/text.generator';\nimport { createUMLClassOrInterfaceGeometryElement } from './uml';\nimport { createMultipleTextGeometryElement, isMultipleTextGeometry, isMultipleTextShape } from './multi-text-geometry';\nimport { DEFAULT_FONT_SIZE } from '@plait/text-plugins';\n\nexport type GeometryStyleOptions = Pick<PlaitGeometry, 'fill' | 'strokeColor' | 'strokeWidth'>;\n\nexport type TextProperties = Partial<CustomText> & { align?: Alignment; textHeight?: number };\n\nexport const createGeometryElement = (\n    shape: GeometryShapes,\n    points: [Point, Point],\n    text: string | Element,\n    options: GeometryStyleOptions = {},\n    textProperties: TextProperties = {}\n): PlaitGeometry => {\n    if (GEOMETRY_WITHOUT_TEXT.includes(shape)) {\n        return createGeometryElementWithoutText(shape, points, options);\n    } else {\n        return createGeometryElementWithText(shape, points, text, options, textProperties);\n    }\n};\n\nexport const createGeometryElementWithText = (\n    shape: GeometryShapes,\n    points: [Point, Point],\n    text: string | Element,\n    options: GeometryStyleOptions = {},\n    textProperties: TextProperties = {}\n): PlaitGeometry => {\n    let textOptions = {};\n    let alignment: undefined | Alignment = Alignment.center;\n    let textHeight = DefaultTextProperty.height;\n    if (shape === BasicShapes.text) {\n        textOptions = { autoSize: true };\n        alignment = undefined;\n    }\n    textProperties = { ...textProperties };\n    textProperties?.align && (alignment = textProperties?.align);\n    textProperties?.textHeight && (textHeight = textProperties?.textHeight);\n    delete textProperties?.align;\n    delete textProperties?.textHeight;\n\n    return {\n        id: idCreator(),\n        type: 'geometry',\n        shape,\n        angle: 0,\n        opacity: 1,\n        textHeight,\n        text: buildText(text, alignment, textProperties),\n        points,\n        ...textOptions,\n        ...options\n    };\n};\n\nexport const createGeometryElementWithoutText = (\n    shape: GeometryShapes,\n    points: [Point, Point],\n    options: GeometryStyleOptions = {}\n): PlaitGeometry => {\n    return {\n        id: idCreator(),\n        type: 'geometry',\n        shape,\n        angle: 0,\n        opacity: 1,\n        points,\n        ...options\n    };\n};\n\nexport const drawGeometry = (board: PlaitBoard, outerRectangle: RectangleClient, shape: GeometryShapes, roughOptions: Options) => {\n    return getEngine(shape).draw(board, outerRectangle, roughOptions);\n};\n\nexport const getNearestPoint = (element: PlaitShapeElement, point: Point) => {\n    const rectangle = RectangleClient.getRectangleByPoints(element.points);\n    const shape = getElementShape(element);\n    return getEngine(shape).getNearestPoint(rectangle, point);\n};\n\nexport const getCenterPointsOnPolygon = (points: Point[]) => {\n    const centerPoint: Point[] = [];\n    for (let i = 0; i < points.length; i++) {\n        let j = i == points.length - 1 ? 0 : i + 1;\n        centerPoint.push([(points[i][0] + points[j][0]) / 2, (points[i][1] + points[j][1]) / 2]);\n    }\n    return centerPoint;\n};\n\nexport const getDefaultFlowchartProperty = (symbol: FlowchartSymbols) => {\n    return DefaultFlowchartPropertyMap[symbol];\n};\n\nexport const getDefaultBasicShapeProperty = (shape: BasicShapes) => {\n    return DefaultBasicShapePropertyMap[shape] || DefaultBasicShapeProperty;\n};\n\nexport const getDefaultUMLProperty = (shape: UMLSymbols) => {\n    return DefaultUMLPropertyMap[shape];\n};\n\nexport const getAutoCompletePoints = (board: PlaitBoard, element: PlaitShapeElement, isToActive = false) => {\n    const AutoCompleteMargin = (12 + RESIZE_HANDLE_DIAMETER / 2) * 2;\n    const rectangle = RectangleClient.getRectangleByPoints(element.points);\n    const activeRectangle = toActiveRectangleFromViewBoxRectangle(board, rectangle);\n    const targetRectangle = isToActive ? activeRectangle : rectangle;\n    return RectangleClient.getEdgeCenterPoints(RectangleClient.inflate(targetRectangle, AutoCompleteMargin));\n};\n\nexport const getHitIndexOfAutoCompletePoint = (movingPoint: Point, points: Point[]) => {\n    return points.findIndex((point) => {\n        const movingRectangle = RectangleClient.getRectangleByPoints([movingPoint]);\n        let rectangle = RectangleClient.getRectangleByPoints([point]);\n        rectangle = RectangleClient.inflate(rectangle, RESIZE_HANDLE_DIAMETER);\n        return RectangleClient.isHit(movingRectangle, rectangle);\n    });\n};\n\nexport const getDrawDefaultStrokeColor = (theme: ThemeColorMode) => {\n    return DrawThemeColors[theme].strokeColor;\n};\n\nexport const getFlowchartDefaultFill = (theme: ThemeColorMode) => {\n    return DrawThemeColors[theme].fill;\n};\n\nexport const getTextShapeProperty = (board: PlaitBoard, text: string | Element, fontSize?: number | string) => {\n    fontSize = fontSize ? Number(fontSize) : DEFAULT_FONT_SIZE;\n    const textSize = measureElement(board, buildText(text), { fontSize, fontFamily: DEFAULT_FONT_FAMILY });\n    return {\n        width: textSize.width + ShapeDefaultSpace.rectangleAndText * 2,\n        height: textSize.height\n    };\n};\n\nexport const getDefaultGeometryPoints = (pointer: DrawPointerType, centerPoint: Point) => {\n    const property = getDefaultGeometryProperty(pointer);\n    return RectangleClient.getPoints(RectangleClient.getRectangleByCenterPoint(centerPoint, property.width, property.height));\n};\n\nexport const getDefaultGeometryProperty = (pointer: DrawPointerType) => {\n    const isFlowChart = getFlowchartPointers().includes(pointer);\n    const isUML = getUMLPointers().includes(pointer);\n    if (isFlowChart) {\n        return getDefaultFlowchartProperty(pointer as FlowchartSymbols);\n    } else if (isUML) {\n        return getDefaultUMLProperty(pointer as UMLSymbols);\n    } else {\n        return getDefaultBasicShapeProperty(pointer as BasicShapes);\n    }\n};\n\nexport const getDefaultTextPoints = (board: PlaitBoard, centerPoint: Point, fontSize?: number | string) => {\n    const property = getTextShapeProperty(board, DefaultTextProperty.text, fontSize);\n    return RectangleClient.getPoints(RectangleClient.getRectangleByCenterPoint(centerPoint, property.width, property.height));\n};\n\nexport const createTextElement = (board: PlaitBoard, points: [Point, Point], text: string | Element, textHeight?: number) => {\n    const memorizedLatest = getMemorizedLatestByPointer(BasicShapes.text);\n    textHeight = textHeight ? textHeight : RectangleClient.getRectangleByPoints(points).height;\n    return createGeometryElement(BasicShapes.text, points, text, memorizedLatest.geometryProperties as GeometryStyleOptions, {\n        ...memorizedLatest.textProperties,\n        textHeight\n    });\n};\n\nexport const createDefaultGeometry = (board: PlaitBoard, points: [Point, Point], shape: GeometryShapes) => {\n    const memorizedLatest = getMemorizedLatestByPointer(shape);\n    const textHeight = getTextShapeProperty(board, DefaultTextProperty.text, memorizedLatest.textProperties['font-size']).height;\n    if (PlaitDrawElement.isUMLClassOrInterface({ shape })) {\n        return createUMLClassOrInterfaceGeometryElement(board, shape, points);\n    }\n    if (isMultipleTextShape(shape)) {\n        return createMultipleTextGeometryElement(shape, points, {\n            strokeWidth: DefaultBasicShapeProperty.strokeWidth,\n            ...(memorizedLatest.geometryProperties as GeometryStyleOptions)\n        });\n    } else {\n        return createGeometryElement(\n            shape,\n            points,\n            '',\n            {\n                strokeWidth: DefaultBasicShapeProperty.strokeWidth,\n                ...(memorizedLatest.geometryProperties as GeometryStyleOptions)\n            },\n            { ...memorizedLatest.textProperties, textHeight }\n        );\n    }\n};\n\nexport const editText = (board: PlaitBoard, element: PlaitGeometry, text?: DrawTextInfo) => {\n    const textManage = text ? getTextManage(board, element, text) : getFirstTextManage(element);\n    if (textManage) {\n        textManage.edit(() => {});\n    }\n};\n\nexport const isGeometryIncludeText = (element: PlaitGeometry) => {\n    return isSingleTextGeometry(element) || isMultipleTextGeometry(element);\n};\n\nexport const isSingleTextShape = (shape: GeometryShapes) => {\n    return !GEOMETRY_WITHOUT_TEXT.includes(shape) && !isMultipleTextShape(shape);\n};\n\nexport const isSingleTextGeometry = (element: PlaitGeometry) => {\n    return PlaitDrawElement.isGeometry(element) && isSingleTextShape(element.shape);\n};\n\nexport const isGeometryClosed = (element: PlaitGeometry) => {\n    return !GEOMETRY_NOT_CLOSED.includes(element.shape);\n};\n", "import { Point, PlaitBoard, getElementById, RectangleClient, Vector, rotatePoints, rotatePointsByElement } from '@plait/core';\nimport {\n    getPoints,\n    getPointByVectorComponent,\n    removeDuplicatePoints,\n    generateElbowLineRoute,\n    simplifyOrthogonalPoints,\n    isSourceAndTargetIntersect,\n    DEFAULT_ROUTE_MARGIN,\n    ElbowLineRouteOptions\n} from '@plait/common';\nimport { BasicShapes, ArrowLineHandleRefPair, PlaitGeometry, PlaitArrowLine } from '../../interfaces';\nimport { createGeometryElement } from '../geometry';\nimport { getElbowLineRouteOptions, getArrowLineHandleRefPair } from './arrow-line-common';\nimport { getMidKeyPoints, getMirrorDataPoints, hasIllegalElbowPoint } from './arrow-line-resize';\nimport { getStrokeWidthByElement } from '../common';\n\nexport const isSelfLoop = (element: PlaitArrowLine) => {\n    return element.source.boundId && element.source.boundId === element.target.boundId;\n};\n\nexport const isUseDefaultOrthogonalRoute = (element: PlaitArrowLine, options: ElbowLineRouteOptions) => {\n    return isSourceAndTargetIntersect(options) && !isSelfLoop(element);\n};\n\nexport const getElbowPoints = (board: PlaitBoard, element: PlaitArrowLine) => {\n    const handleRefPair = getArrowLineHandleRefPair(board, element);\n    const params = getElbowLineRouteOptions(board, element, handleRefPair);\n    // console.log(params, 'params');\n    if (isUseDefaultOrthogonalRoute(element, params)) {\n        return simplifyOrthogonalPoints(\n            getPoints(\n                handleRefPair.source.point,\n                handleRefPair.source.direction,\n                handleRefPair.target.point,\n                handleRefPair.target.direction,\n                DEFAULT_ROUTE_MARGIN\n            )\n        );\n    }\n    const keyPoints = removeDuplicatePoints(generateElbowLineRoute(params, board));\n    const nextKeyPoints = keyPoints.slice(1, keyPoints.length - 1);\n    if (element.points.length === 2) {\n        return simplifyOrthogonalPoints(keyPoints);\n    } else {\n        const simplifiedNextKeyPoints = simplifyOrthogonalPoints(nextKeyPoints);\n        const dataPoints = removeDuplicatePoints(PlaitArrowLine.getPoints(board, element));\n        const midDataPoints = dataPoints.slice(1, -1);\n        if (hasIllegalElbowPoint(midDataPoints)) {\n            return simplifyOrthogonalPoints(keyPoints);\n        }\n        const nextDataPoints = [simplifiedNextKeyPoints[0], ...midDataPoints, simplifiedNextKeyPoints[simplifiedNextKeyPoints.length - 1]];\n        const mirrorDataPoints = getMirrorDataPoints(board, nextDataPoints, simplifiedNextKeyPoints, params);\n        // console.log(mirrorDataPoints, 'mirrorDataPoints');\n        const renderPoints: Point[] = [keyPoints[0]];\n        for (let index = 0; index < mirrorDataPoints.length - 1; index++) {\n            let currentPoint = mirrorDataPoints[index];\n            let nextPoint = mirrorDataPoints[index + 1];\n            const isStraight = Point.isAlign([currentPoint, nextPoint]);\n            if (!isStraight) {\n                const midKeyPoints = getMidKeyPoints(simplifiedNextKeyPoints, currentPoint, nextPoint);\n                if (midKeyPoints.length) {\n                    renderPoints.push(currentPoint);\n                    renderPoints.push(...midKeyPoints);\n                } else {\n                    renderPoints.push(currentPoint);\n                    console.log('unknown data points');\n                }\n            } else {\n                renderPoints.push(currentPoint);\n            }\n        }\n        renderPoints.push(keyPoints[keyPoints.length - 2], keyPoints[keyPoints.length - 1]);\n        // Remove the middle point to avoid the situation where the starting and ending positions are drawn back, such as when sourcePoint is between nextSourcePoint and the first key point.\n        // Issue\n        //                           keyPoint2\n        //                                |\n        //                                |\n        // nextPoint---sourcePoint---keyPoint1\n        // The correct rendering should be (nextPoint should be filtered out):\n        //                           keyPoint2\n        //                                |\n        //                                |\n        //             sourcePoint---keyPoint1\n        const ret = simplifyOrthogonalPoints(renderPoints);\n        return ret;\n    }\n};\n\nexport const getNextSourceAndTargetPoints = (board: PlaitBoard, element: PlaitArrowLine) => {\n    const options = getElbowLineRouteOptions(board, element);\n    return [options.nextSourcePoint, options.nextTargetPoint];\n};\n\nexport const getSourceAndTargetRectangle = (board: PlaitBoard, element: PlaitArrowLine, handleRefPair: ArrowLineHandleRefPair) => {\n    let sourceElement = element.source.boundId ? getElementById<PlaitGeometry>(board, element.source.boundId) : undefined;\n    let targetElement = element.target.boundId ? getElementById<PlaitGeometry>(board, element.target.boundId) : undefined;\n    if (!sourceElement) {\n        const source = handleRefPair.source;\n        sourceElement = createFakeElement(source.point, source.vector);\n    }\n    if (!targetElement) {\n        const target = handleRefPair.target;\n        targetElement = createFakeElement(target.point, target.vector);\n    }\n\n    let sourceRectangle = RectangleClient.getRectangleByPoints(sourceElement.points);\n    const rotatedSourceCornerPoints =\n        rotatePointsByElement(RectangleClient.getCornerPoints(sourceRectangle), sourceElement) ||\n        RectangleClient.getCornerPoints(sourceRectangle);\n    sourceRectangle = RectangleClient.getRectangleByPoints(rotatedSourceCornerPoints);\n    sourceRectangle = RectangleClient.inflate(sourceRectangle, getStrokeWidthByElement(sourceElement) * 2);\n\n    let targetRectangle = RectangleClient.getRectangleByPoints(targetElement.points);\n    const rotatedTargetCornerPoints =\n        rotatePointsByElement(RectangleClient.getCornerPoints(targetRectangle), targetElement) ||\n        RectangleClient.getCornerPoints(targetRectangle);\n    targetRectangle = RectangleClient.getRectangleByPoints(rotatedTargetCornerPoints);\n    targetRectangle = RectangleClient.inflate(targetRectangle, getStrokeWidthByElement(targetElement) * 2);\n\n    return {\n        sourceRectangle,\n        targetRectangle\n    };\n};\n\nconst createFakeElement = (startPoint: Point, vector: Vector) => {\n    const point = getPointByVectorComponent(startPoint, vector, -25);\n    const points = RectangleClient.getPoints(RectangleClient.getRectangleByCenterPoint(point, 50, 50));\n    return createGeometryElement(BasicShapes.rectangle, points, '');\n};\n\nexport function getNextRenderPoints(board: PlaitBoard, element: PlaitArrowLine, renderPoints?: Point[]) {\n    let newRenderKeyPoints = renderPoints ?? getElbowPoints(board, element);\n    const [nextSourcePoint, nextTargetPoint] = getNextSourceAndTargetPoints(board, element);\n    newRenderKeyPoints.splice(0, 1, nextSourcePoint);\n    newRenderKeyPoints.splice(-1, 1, nextTargetPoint);\n    return removeDuplicatePoints(newRenderKeyPoints);\n}\n", "import { PlaitBoard, PlaitElement, getSelectedElements } from '@plait/core';\nimport { PlaitArrowLine, PlaitCustomGeometry, PlaitDrawElement, PlaitGeometry, PlaitSwimlane, PlaitVectorLine } from '../interfaces';\nimport { PlaitImage } from '../interfaces/image';\n\nexport const getSelectedDrawElements = (board: PlaitBoard, elements?: PlaitElement[]) => {\n    const selectedElements = elements?.length ? elements : getSelectedElements(board);\n    return selectedElements.filter(value => PlaitDrawElement.isDrawElement(value)) as PlaitDrawElement[];\n};\n\nexport const getSelectedGeometryElements = (board: PlaitBoard) => {\n    const selectedElements = getSelectedElements(board).filter(value => PlaitDrawElement.isGeometry(value)) as PlaitGeometry[];\n    return selectedElements;\n};\n\nexport const getSelectedCustomGeometryElements = (board: PlaitBoard) => {\n    const selectedElements = getSelectedElements(board).filter(value =>\n        PlaitDrawElement.isCustomGeometryElement(board, value)\n    ) as PlaitCustomGeometry[];\n    return selectedElements;\n};\n\nexport const getSelectedArrowLineElements = (board: PlaitBoard) => {\n    const selectedElements = getSelectedElements(board).filter(value => PlaitDrawElement.isArrowLine(value)) as PlaitArrowLine[];\n    return selectedElements;\n};\n\nexport const getSelectedVectorLineElements = (board: PlaitBoard) => {\n    const selectedElements = getSelectedElements(board).filter(value => PlaitDrawElement.isVectorLine(value)) as PlaitVectorLine[];\n    return selectedElements;\n};\n\nexport const getSelectedImageElements = (board: PlaitBoard) => {\n    const selectedElements = getSelectedElements(board).filter(value => PlaitDrawElement.isImage(value)) as PlaitImage[];\n    return selectedElements;\n};\n\nexport const isSingleSelectSwimlane = (board: PlaitBoard) => {\n    const selectedElements = getSelectedElements(board);\n    return selectedElements && selectedElements.length === 1 && PlaitDrawElement.isSwimlane(selectedElements[0]);\n};\n\nexport const isSingleSelectLine = (board: PlaitBoard) => {\n    const selectedElements = getSelectedElements(board);\n    return selectedElements && selectedElements.length === 1 && PlaitDrawElement.isLine(selectedElements[0]);\n};\n\nexport const getSelectedSwimlane = (board: PlaitBoard): PlaitSwimlane => {\n    const selectedElements = getSelectedElements(board);\n    return selectedElements.find(item => PlaitDrawElement.isSwimlane(item)) as PlaitSwimlane;\n};\n", "import { PlaitBoard, Transforms, Point, Path, PlaitNode, getSelectedElements } from '@plait/core';\nimport { PlaitDrawElement, GeometryShapes, PlaitText, BasicShapes, PlaitArrowLine } from '../interfaces';\nimport {\n    collectArrowLineUpdatedRefsByGeometry,\n    createDefaultGeometry,\n    createTextElement,\n    getMemorizedLatestByPointer,\n    getTextShapeProperty,\n    insertElement\n} from '../utils';\nimport { Element } from 'slate';\nimport { normalizeShapePoints } from '@plait/common';\nimport { DrawTransforms } from '.';\n\nexport const insertGeometry = (board: PlaitBoard, points: [Point, Point], shape: GeometryShapes) => {\n    const newElement = createDefaultGeometry(board, points, shape);\n    insertElement(board, newElement);\n    return newElement;\n};\n\nexport const insertText = (board: PlaitBoard, point: Point, text: string | Element) => {\n    const memorizedLatest = getMemorizedLatestByPointer(BasicShapes.text);\n    const property = getTextShapeProperty(board, text, memorizedLatest.textProperties['font-size']);\n    const points: [Point, Point] = [point, [point[0] + property.width, point[1] + property.height]];\n    const newElement = createTextElement(board, points, text);\n    insertElement(board, newElement);\n};\n\nexport const resizeGeometry = (board: PlaitBoard, points: [Point, Point], textHeight: number, path: Path) => {\n    const normalizePoints = normalizeShapePoints(points);\n    const element = PlaitNode.get(board, path);\n    const newProperties = { points: normalizePoints, textHeight };\n    if (PlaitDrawElement.isText(element) && element.autoSize) {\n        (newProperties as Partial<PlaitText>).autoSize = false;\n    }\n    Transforms.setNode(board, newProperties, path);\n};\n\nexport const switchGeometryShape = (board: PlaitBoard, shape: GeometryShapes) => {\n    const selectedElements = getSelectedElements(board);\n    const refs: { property: Partial<PlaitArrowLine>; path: Path }[] = [];\n    selectedElements.forEach(item => {\n        if (PlaitDrawElement.isGeometry(item) && !PlaitDrawElement.isText(item)) {\n            const path = PlaitBoard.findPath(board, item);\n            Transforms.setNode(board, { shape }, path);\n            collectArrowLineUpdatedRefsByGeometry(board, { ...item, shape }, refs);\n        }\n    });\n    if (refs.length) {\n        refs.forEach(ref => {\n            DrawTransforms.resizeArrowLine(board, ref.property, ref.path);\n        });\n    }\n};\n", "import { PlaitBoard, Point, Transforms, hasValidAngle, RectangleClient } from '@plait/core';\nimport { Element } from 'slate';\nimport { PlaitGeometry, PlaitText } from '../interfaces';\nimport { ShapeDefaultSpace } from '../constants';\nimport { Alignment, getFirstTextEditor, resetPointsAfterResize } from '@plait/common';\nimport { AlignEditor } from '@plait/text-plugins';\nimport { MIN_TEXT_WIDTH } from '../constants/text';\n\nconst normalizePoints = (board: PlaitBoard, element: PlaitGeometry, width: number, textHeight: number) => {\n    let points = element.points;\n    let autoSize = (element as PlaitText).autoSize;\n    const defaultSpace = ShapeDefaultSpace.rectangleAndText;\n\n    if (autoSize) {\n        const newWidth = width < MIN_TEXT_WIDTH ? MIN_TEXT_WIDTH : width;\n        const editor = getFirstTextEditor(element);\n        if (AlignEditor.isActive(editor, Alignment.right)) {\n            points = [\n                [points[1][0] - (newWidth + defaultSpace * 2), points[0][1]],\n                [points[1][0], points[0][1] + textHeight]\n            ];\n        } else if (AlignEditor.isActive(editor, Alignment.center)) {\n            const oldWidth = Math.abs(points[0][0] - points[1][0]);\n            const offset = (newWidth - oldWidth) / 2;\n            points = [\n                [points[0][0] - offset - defaultSpace, points[0][1]],\n                [points[1][0] + offset + defaultSpace, points[0][1] + textHeight]\n            ];\n        } else {\n            points = [points[0], [points[0][0] + newWidth + defaultSpace * 2, points[0][1] + textHeight]];\n        }\n        if (hasValidAngle(element)) {\n            points = resetPointsAfterResize(\n                RectangleClient.getRectangleByPoints(element.points),\n                RectangleClient.getRectangleByPoints(points),\n                RectangleClient.getCenterPoint(RectangleClient.getRectangleByPoints(element.points)),\n                RectangleClient.getCenterPoint(RectangleClient.getRectangleByPoints(points)),\n                element.angle!\n            );\n        }\n    }\n\n    return { points };\n};\n\nexport const setText = (board: PlaitBoard, element: PlaitGeometry, text: Element, width: number, textHeight: number) => {\n    const newElement = {\n        text,\n        textHeight,\n        ...normalizePoints(board, element, width, textHeight)\n    };\n\n    const path = board.children.findIndex(child => child === element);\n\n    Transforms.setNode(board, newElement, [path]);\n};\n\nexport const setTextSize = (board: PlaitBoard, element: PlaitGeometry, textWidth: number, textHeight: number) => {\n    if ((element as PlaitText).autoSize) {\n        const newElement = {\n            textHeight,\n            ...normalizePoints(board, element, textWidth, textHeight)\n        };\n        const isPointsEqual =\n            Point.isEquals(element.points[0], newElement.points[0]) && Point.isEquals(element.points[1], newElement.points[1]);\n        const isTextHeightEqual = Math.round(textHeight) === Math.round(element.textHeight!);\n        if (!isPointsEqual || !isTextHeightEqual) {\n            const path = board.children.findIndex(child => child === element);\n            Transforms.setNode(board, newElement, [path]);\n        }\n    }\n};\n", "import { CommonImageItem } from '@plait/common';\nimport { PlaitBoard, Point, Transforms, idCreator, toHostPoint, toViewBoxPoint } from '@plait/core';\n\nexport const insertImage = (board: PlaitBoard, imageItem: CommonImageItem, startPoint?: Point) => {\n    const { width, height, url } = imageItem;\n    const viewportWidth = PlaitBoard.getBoardContainer(board).clientWidth;\n    const viewportHeight = PlaitBoard.getBoardContainer(board).clientHeight;\n    const point = toViewBoxPoint(board, toHostPoint(board, viewportWidth / 2, viewportHeight / 2));\n    const points: Point[] = startPoint\n        ? [startPoint, [startPoint[0] + width, startPoint[1] + height]]\n        : [\n              [point[0] - width / 2, point[1] - height / 2],\n              [point[0] + width / 2, point[1] + height / 2]\n          ];\n    const imageElement = {\n        id: idCreator(),\n        type: 'image',\n        points,\n        url\n    };\n    Transforms.insertNode(board, imageElement, [board.children.length]);\n    Transforms.addSelectionWithTemporaryElements(board, [imageElement]);\n};\n\nexport const createImage = (startPoint: Point, imageItem: CommonImageItem) => {\n    const { width, height, url } = imageItem;\n    const points: Point[] = [startPoint, [startPoint[0] + width, startPoint[1] + height]];\n    const imageElement = {\n        id: idCreator(),\n        type: 'image',\n        points,\n        url\n    };\n    return imageElement;\n};\n", "import { Path, PlaitBoard, PlaitElement, PointOfRectangle, Transforms, findElements } from '@plait/core';\nimport {\n    ArrowLineHandle,\n    ArrowLineHandleKey,\n    ArrowLineMarkerType,\n    ArrowLineText,\n    MemorizeKey,\n    PlaitArrowLine,\n    PlaitShapeElement\n} from '../interfaces';\nimport { memorizeLatest } from '@plait/common';\nimport { getSelectedArrowLineElements } from '../utils/selected';\nimport { getHitConnection } from '../utils/arrow-line/arrow-line-basic';\n\nexport const resizeArrowLine = (board: PlaitBoard, options: Partial<PlaitArrowLine>, path: Path) => {\n    Transforms.setNode(board, options, path);\n};\n\nexport const setArrowLineTexts = (board: PlaitBoard, element: PlaitArrowLine, texts: ArrowLineText[]) => {\n    const path = PlaitBoard.findPath(board, element);\n    Transforms.setNode(board, { texts }, path);\n};\n\nexport const removeArrowLineText = (board: PlaitBoard, element: PlaitArrowLine, index: number) => {\n    const path = PlaitBoard.findPath(board, element);\n    const texts = element.texts?.length ? [...element.texts] : [];\n    const newTexts = [...texts];\n    newTexts.splice(index, 1);\n    Transforms.setNode(board, { texts: newTexts }, path);\n};\n\nexport const setArrowLineMark = (board: PlaitBoard, handleKey: ArrowLineHandleKey, marker: ArrowLineMarkerType) => {\n    memorizeLatest(MemorizeKey.arrowLine, handleKey, marker);\n    const selectedElements = getSelectedArrowLineElements(board);\n    selectedElements.forEach((element: PlaitArrowLine) => {\n        const path = PlaitBoard.findPath(board, element);\n        let handle = handleKey === ArrowLineHandleKey.source ? element.source : element.target;\n        handle = { ...handle, marker };\n        Transforms.setNode(board, { [handleKey]: handle }, path);\n    });\n};\n\nexport const setArrowLineShape = (board: PlaitBoard, newProperties: Partial<PlaitArrowLine>) => {\n    const elements = getSelectedArrowLineElements(board);\n    elements.map(element => {\n        const _properties = { ...newProperties };\n        if (element.shape === newProperties.shape) {\n            return;\n        }\n        const path = PlaitBoard.findPath(board, element);\n        Transforms.setNode(board, _properties, path);\n    });\n};\n\nexport const connectArrowLineToDraw = (\n    board: PlaitBoard,\n    lineElement: PlaitArrowLine,\n    handle: ArrowLineHandleKey,\n    geometryElement: PlaitShapeElement\n) => {\n    const linePoints = PlaitArrowLine.getPoints(board, lineElement);\n    const point = handle === ArrowLineHandleKey.source ? linePoints[0] : linePoints[linePoints.length - 1];\n    const connection: PointOfRectangle = getHitConnection(board, point, geometryElement);\n    if (connection) {\n        let source: ArrowLineHandle = lineElement.source;\n        let target: ArrowLineHandle = lineElement.target;\n        if (handle === ArrowLineHandleKey.source) {\n            source = {\n                ...source,\n                boundId: geometryElement.id,\n                connection\n            };\n        } else {\n            target = {\n                ...target,\n                boundId: geometryElement.id,\n                connection\n            };\n        }\n        const path = PlaitBoard.findPath(board, lineElement);\n        resizeArrowLine(board, { source, target }, path);\n    }\n};\n", "import { idCreator, PlaitBoard, Point, RectangleClient } from '@plait/core';\nimport { DefaultSwimlanePropertyMap, getSwimlanePointers, getSwimlaneShapes, SWIMLANE_HEADER_SIZE } from '../constants';\nimport { PlaitDrawElement, PlaitSwimlane, PlaitTableCell, SwimlaneDrawSymbols, SwimlaneSymbols } from '../interfaces';\nimport { createCell } from './table';\n\nexport function buildSwimlaneTable(element: PlaitSwimlane) {\n    const swimlaneElement = { ...element };\n    if (PlaitDrawElement.isHorizontalSwimlane(element)) {\n        swimlaneElement.cells = element.cells.map((item, index) => {\n            if (index === 0 && element.header) {\n                item = {\n                    ...element.cells[0],\n                    rowspan: element.rows.length\n                };\n            }\n            if (item.text && item.textHeight && !item.text.direction) {\n                item = {\n                    ...item,\n                    text: {\n                        ...item.text,\n                        direction: 'vertical'\n                    }\n                };\n            }\n            return item;\n        });\n\n        return swimlaneElement;\n    }\n    if (element.header) {\n        swimlaneElement.cells = [\n            {\n                ...element.cells[0],\n                colspan: element.columns.length\n            },\n            ...element.cells.slice(1, element.cells.length)\n        ];\n    }\n    return swimlaneElement;\n}\n\nexport const getDefaultSwimlanePoints = (pointer: SwimlaneDrawSymbols, centerPoint: Point) => {\n    const property = DefaultSwimlanePropertyMap[pointer];\n    return RectangleClient.getPoints(RectangleClient.getRectangleByCenterPoint(centerPoint, property.width, property.height));\n};\n\nexport const createDefaultSwimlane = (shape: SwimlaneDrawSymbols, points: [Point, Point]) => {\n    const header = isSwimlaneWithHeader(shape);\n    const dataShape = adjustSwimlaneShape(shape);\n    const width = points[1][0] - points[0][0];\n    const height = points[1][1] - points[0][1];\n    const rows = createDefaultRowsOrColumns(dataShape, 'row', header, height);\n    const columns = createDefaultRowsOrColumns(dataShape, 'column', header, width);\n    const swimlane = {\n        id: idCreator(),\n        type: 'swimlane',\n        shape: dataShape,\n        points,\n        rows,\n        columns,\n        header,\n        cells: createDefaultCells(dataShape, rows, columns, header)\n    } as PlaitSwimlane;\n    return swimlane;\n};\n\nexport const createDefaultRowsOrColumns = (shape: SwimlaneSymbols, type: 'row' | 'column', header: boolean, size: number) => {\n    const createItems = (count: number) => new Array(count).fill('').map(() => ({ id: idCreator() }));\n    let data = createItems(3);\n    if (\n        (type === 'row' && shape === SwimlaneSymbols.swimlaneVertical) ||\n        (type === 'column' && shape === SwimlaneSymbols.swimlaneHorizontal)\n    ) {\n        data = header ? data : createItems(2);\n        const dimension = type === 'row' ? 'height' : 'width';\n        let defaultSize = SWIMLANE_HEADER_SIZE;\n        if (size < SWIMLANE_HEADER_SIZE * data.length) {\n            defaultSize = Math.min((size / data.length / SWIMLANE_HEADER_SIZE) * SWIMLANE_HEADER_SIZE, SWIMLANE_HEADER_SIZE);\n        }\n        data = data.map((item, index) => {\n            if (index === 0 || (index === 1 && header)) {\n                return {\n                    ...item,\n                    [dimension]: defaultSize\n                };\n            }\n            return item;\n        });\n    }\n\n    return data;\n};\n\nexport const createDefaultCells = (\n    shape: SwimlaneSymbols,\n    rows: { id: string; height?: number }[],\n    columns: { id: string; width?: number }[],\n    header: boolean\n) => {\n    let headerCell: PlaitTableCell[] = [];\n    let startIndex = 0;\n    if (header) {\n        headerCell = [createCell(rows[0].id, columns[0].id, 'New Swimlane')];\n        startIndex = 1;\n    }\n    const cells = new Array(6).fill('').map((_, index) => {\n        if (index < 3) {\n            const rowId = shape === SwimlaneSymbols.swimlaneVertical ? rows[startIndex].id : rows[index].id;\n            const columnId = shape === SwimlaneSymbols.swimlaneVertical ? columns[index].id : columns[startIndex].id;\n            return createCell(rowId, columnId, header ? 'Lane' : 'New Swimlane');\n        }\n        const rowId = shape === SwimlaneSymbols.swimlaneVertical ? rows[startIndex + 1].id : rows[index - 3].id;\n        const columnId = shape === SwimlaneSymbols.swimlaneVertical ? columns[index - 3].id : columns[startIndex + 1].id;\n        return createCell(rowId, columnId);\n    });\n    return [...headerCell, ...cells];\n};\n\nexport const getSwimlaneCount = (swimlane: PlaitSwimlane) => {\n    if (PlaitDrawElement.isHorizontalSwimlane(swimlane)) {\n        return swimlane.rows.length;\n    }\n    if (PlaitDrawElement.isVerticalSwimlane(swimlane)) {\n        return swimlane.columns.length;\n    }\n    return 0;\n};\n\nexport const isSwimlaneWithHeader = (shape: SwimlaneDrawSymbols) => {\n    return [SwimlaneDrawSymbols.swimlaneHorizontalWithHeader, SwimlaneDrawSymbols.swimlaneVerticalWithHeader].includes(shape);\n};\n\nexport const isSwimlaneShape = (shape: SwimlaneSymbols) => {\n    return getSwimlaneShapes().includes(shape);\n};\n\nexport const adjustSwimlaneShape = (shape: SwimlaneDrawSymbols): SwimlaneSymbols => {\n    return [SwimlaneDrawSymbols.swimlaneHorizontalWithHeader, SwimlaneDrawSymbols.swimlaneHorizontal].includes(shape)\n        ? SwimlaneSymbols.swimlaneHorizontal\n        : SwimlaneSymbols.swimlaneVertical;\n};\n\nexport const isSwimlanePointers = (board: PlaitBoard, pointer: string = board.pointer) => {\n    return getSwimlanePointers().includes(pointer);\n};\n", "import { idCreator, Path, PlaitBoard, Point, RectangleClient, Transforms } from '@plait/core';\nimport { PlaitDrawElement, PlaitSwimlane } from '../interfaces';\nimport { PlaitBaseTable, PlaitTableCell } from '../interfaces/table';\nimport { getCellWithPoints } from '../utils/table';\nimport { getSwimlaneCount } from '../utils/swimlane';\nimport { Alignment } from '@plait/common';\n\nexport const updateSwimlaneCount = (board: PlaitBoard, swimlane: PlaitSwimlane, count: number) => {\n    if (count > 0 && PlaitDrawElement.isSwimlane(swimlane)) {\n        const currentCount = getSwimlaneCount(swimlane);\n        if (PlaitDrawElement.isHorizontalSwimlane(swimlane)) {\n            if (count > currentCount) {\n                addSwimlaneRow(board, swimlane, swimlane.rows.length, count - currentCount);\n            } else {\n                const deleteIndex = swimlane.rows.length - (currentCount - count);\n                removeSwimlaneRow(board, swimlane, deleteIndex, currentCount - count);\n            }\n        }\n        if (PlaitDrawElement.isVerticalSwimlane(swimlane)) {\n            if (count > currentCount) {\n                addSwimlaneColumn(board, swimlane, swimlane.columns.length, count - currentCount);\n            } else {\n                const deleteIndex = swimlane.columns.length - (currentCount - count);\n                removeSwimlaneColumn(board, swimlane, deleteIndex, currentCount - count);\n            }\n        }\n    }\n};\n\nexport const addSwimlaneRow = (board: PlaitBoard, swimlane: PlaitSwimlane, index: number, count: number = 1) => {\n    if (PlaitDrawElement.isHorizontalSwimlane(swimlane)) {\n        const newRows = [...swimlane.rows];\n        const addRows: { id: string }[] = [];\n        for (let i = 0; i < count; i++) {\n            addRows.push({ id: idCreator() });\n        }\n        newRows.splice(index, 0, ...addRows);\n        const newCells = [...swimlane.cells];\n        addRows.forEach(item => {\n            newCells.push(...createNewSwimlaneCells(swimlane, item.id, 'column'));\n        });\n        const lastCellPoints = getCellWithPoints(board, swimlane, swimlane.cells[swimlane.cells.length - 1].id).points;\n        const lastRowHeight = RectangleClient.getRectangleByPoints(lastCellPoints).height;\n        const newPoints: Point[] = [swimlane.points[0], [swimlane.points[1][0], swimlane.points[1][1] + lastRowHeight * count]];\n        updateSwimlane(board, swimlane, swimlane.columns, newRows, newCells, newPoints);\n    }\n};\n\nexport const addSwimlaneColumn = (board: PlaitBoard, swimlane: PlaitSwimlane, index: number, count: number = 1) => {\n    if (PlaitDrawElement.isVerticalSwimlane(swimlane)) {\n        const newColumns = [...swimlane.columns];\n        const addColumns: { id: string }[] = [];\n        for (let i = 0; i < count; i++) {\n            addColumns.push({ id: idCreator() });\n        }\n        newColumns.splice(index, 0, ...addColumns);\n        const newCells = [...swimlane.cells];\n        addColumns.forEach(item => {\n            newCells.push(...createNewSwimlaneCells(swimlane, item.id, 'row'));\n        });\n        const lastCellPoints = getCellWithPoints(board, swimlane, swimlane.cells[swimlane.cells.length - 1].id).points;\n        const lastColumnWidth = RectangleClient.getRectangleByPoints(lastCellPoints).width;\n        const newPoints: Point[] = [swimlane.points[0], [swimlane.points[1][0] + lastColumnWidth * count, swimlane.points[1][1]]];\n        updateSwimlane(board, swimlane, newColumns, swimlane.rows, newCells, newPoints);\n    }\n};\n\nexport const removeSwimlaneRow = (board: PlaitBoard, swimlane: PlaitSwimlane, index: number, count: number = 1) => {\n    if (PlaitDrawElement.isHorizontalSwimlane(swimlane)) {\n        if (count > swimlane.rows.length) {\n            return;\n        }\n        const newRows = [...swimlane.rows];\n        newRows.splice(index, count);\n        if (newRows.length === 0) {\n            const path = PlaitBoard.findPath(board, swimlane);\n            Transforms.removeNode(board, path);\n        } else {\n            let newCells = [...swimlane.cells];\n            const removeRows = [];\n            for (let i = index; i < count + index; i++) {\n                const removeRow = swimlane.rows[i];\n                removeRows.push(removeRow);\n                newCells = newCells.filter(item => item.rowId !== removeRow.id);\n            }\n            let removeRowHeight = 0;\n            removeRows.forEach(row => {\n                if (!row.height) {\n                    const rowCell = swimlane.cells.find(item => item.rowId === row.id)!;\n                    const cellPoints = getCellWithPoints(board, swimlane, rowCell.id).points;\n                    removeRowHeight += RectangleClient.getRectangleByPoints(cellPoints).height;\n                } else {\n                    removeRowHeight += row.height;\n                }\n            });\n\n            const newPoints: Point[] = [swimlane.points[0], [swimlane.points[1][0], swimlane.points[1][1] - removeRowHeight]];\n            updateSwimlane(board, swimlane, swimlane.columns, newRows, newCells, newPoints);\n        }\n    }\n};\n\nexport const removeSwimlaneColumn = (board: PlaitBoard, swimlane: PlaitSwimlane, index: number, count: number = 1) => {\n    if (PlaitDrawElement.isVerticalSwimlane(swimlane)) {\n        if (count > swimlane.columns.length) {\n            return;\n        }\n        const newColumns = [...swimlane.columns];\n        newColumns.splice(index, count);\n        if (newColumns.length === 0) {\n            const path = PlaitBoard.findPath(board, swimlane);\n            Transforms.removeNode(board, path);\n        } else {\n            let newCells = [...swimlane.cells];\n            const removeColumns = [];\n            for (let i = index; i < count + index; i++) {\n                const removeColumn = swimlane.columns[i];\n                removeColumns.push(removeColumn);\n                newCells = newCells.filter(item => item.columnId !== removeColumn.id);\n            }\n            let removeColumnWidth = 0;\n            removeColumns.forEach(column => {\n                if (!column.width) {\n                    const rowCell = swimlane.cells.find(item => item.columnId === column.id)!;\n                    const cellPoints = getCellWithPoints(board, swimlane, rowCell.id).points;\n                    removeColumnWidth += RectangleClient.getRectangleByPoints(cellPoints).width;\n                } else {\n                    removeColumnWidth += column.width;\n                }\n            });\n            const newPoints: Point[] = [swimlane.points[0], [swimlane.points[1][0] - removeColumnWidth, swimlane.points[1][1]]];\n            updateSwimlane(board, swimlane, newColumns, swimlane.rows, newCells, newPoints);\n        }\n    }\n};\n\nconst createNewSwimlaneCells = (swimlane: PlaitSwimlane, newId: string, type: 'row' | 'column'): PlaitTableCell[] => {\n    const cells: PlaitTableCell[] = swimlane[`${type}s`].map(item => ({\n        id: idCreator(),\n        rowId: type === 'row' ? item.id : newId,\n        columnId: type === 'row' ? newId : item.id\n    }));\n    if (swimlane.header) {\n        cells.shift();\n    }\n    cells[0] = {\n        ...cells[0],\n        text: {\n            children: [{ text: swimlane.header ? 'Lane' : 'New Swimlane' }],\n            align: Alignment.center,\n            direction: type === 'row' ? undefined : 'vertical'\n        },\n        textHeight: 20\n    };\n    return cells;\n};\n\nconst updateSwimlane = (\n    board: PlaitBoard,\n    swimlane: PlaitSwimlane,\n    newColumns: { id: string; width?: number }[],\n    newRows: { id: string; height?: number }[],\n    newCells: PlaitTableCell[],\n    newPoints: Point[]\n) => {\n    const path = PlaitBoard.findPath(board, swimlane);\n    Transforms.setNode(\n        board,\n        {\n            columns: newColumns,\n            rows: newRows,\n            cells: newCells,\n            points: newPoints\n        },\n        path\n    );\n};\n", "import { PlaitBoard, Transforms } from '@plait/core';\nimport { PlaitMultipleTextGeometry } from '../interfaces';\nimport { DrawTextInfo } from '../generators/text.generator';\n\nexport const setDrawTexts = (board: PlaitBoard, element: PlaitMultipleTextGeometry, text: DrawTextInfo) => {\n    const newTexts = element.texts?.map(item => {\n        if (item.id === text.id) {\n            return { ...item, ...text };\n        }\n        return item;\n    });\n    const newElement = {\n        texts: newTexts\n    };\n    const path = board.children.findIndex(child => child === element);\n    Transforms.setNode(board, newElement, [path]);\n};\n", "import { Path, PlaitBoard, PlaitNode, RectangleClient, Transforms } from '@plait/core';\nimport { ShapeDefaultSpace } from '../constants';\nimport { Element } from 'slate';\nimport { PlaitBaseTable, PlaitTableCell, PlaitTableElement } from '../interfaces/table';\nimport { getCellWithPoints, updateColumns, updateRows } from '../utils/table';\n\nexport const setTableText = (board: PlaitBoard, path: Path, cellId: string, text: Element, textHeight: number) => {\n    const table = PlaitNode.get(board, path) as PlaitBaseTable;\n    const cell = getCellWithPoints(board, table, cellId);\n    const cellIndex = table.cells.findIndex(item => item.id === cell.id);\n    let rows = [...table.rows];\n    let columns = [...table.columns];\n    let cells = [...table.cells];\n    let points = [...table.points];\n    const { width: cellWidth, height: cellHeight } = RectangleClient.getRectangleByPoints(cell.points);\n    const defaultSpace = ShapeDefaultSpace.rectangleAndText;\n    if (PlaitTableElement.isVerticalText(cell as PlaitTableCell)) {\n        const columnIdx = table.columns.findIndex(column => column.id === cell.columnId);\n        if (textHeight > cellWidth) {\n            const newColumnWidth = textHeight + defaultSpace * 2;\n            const offset = newColumnWidth - cellWidth;\n            const result = updateColumns(table, table.columns[columnIdx].id, newColumnWidth, offset);\n            points = result.points;\n            columns = result.columns;\n        }\n    } else {\n        const rowIdx = table.rows.findIndex(row => row.id === cell.rowId);\n        const tableRow = table.rows[rowIdx];\n        const compareHeight = tableRow.height ?? Math.max(cellHeight, cell.textHeight || 0);\n        if (textHeight > compareHeight) {\n            const newRowHeight = textHeight + defaultSpace * 2;\n            const offset = newRowHeight - compareHeight;\n            const result = updateRows(table, table.rows[rowIdx].id, newRowHeight, offset);\n            points = result.points;\n            rows = result.rows;\n        }\n    }\n    cells[cellIndex] = {\n        ...cells[cellIndex],\n        textHeight: textHeight,\n        text\n    };\n\n    Transforms.setNode(board, { rows, columns, cells, points }, path);\n};\n", "import { Path, PlaitBoard, Transforms } from '@plait/core';\nimport { PlaitBaseTable, PlaitTableCell } from '../interfaces';\nimport { getSelectedCells } from '../utils';\n\nexport const setTableFill = (board: PlaitBoard, element: PlaitBaseTable, fill: string | null, path: Path) => {\n    const selectedCells = getSelectedCells(element);\n    let newCells = element.cells;\n    if (selectedCells?.length) {\n        newCells = element.cells.map(cell => {\n            if (selectedCells.map(item => item.id).includes(cell.id)) {\n                return getNewCell(cell, fill);\n            }\n            return cell;\n        });\n    } else {\n        newCells = element.cells.map(cell => {\n            if (cell.text && cell.textHeight) {\n                return getNewCell(cell, fill);\n            }\n            return cell;\n        });\n    }\n    Transforms.setNode(board, { cells: newCells }, path);\n};\n\nconst getNewCell = (cell: PlaitTableCell, fill: string | null) => {\n    const newCell = {\n        ...cell\n    };\n    if (fill) {\n        newCell.fill = fill;\n    } else {\n        delete newCell.fill;\n    }\n    return newCell;\n};\n", "import { PlaitBoard, Transforms } from '@plait/core';\nimport { PlaitVectorLine } from '../interfaces';\nimport { getSelectedVectorLineElements } from '../utils';\n\nexport const setVectorLineShape = (board: PlaitBoard, newProperties: Partial<PlaitVectorLine>) => {\n    const elements = getSelectedVectorLineElements(board);\n    elements.map(element => {\n        if (element.shape === newProperties.shape) {\n            return;\n        }\n        const path = PlaitBoard.findPath(board, element);\n        Transforms.setNode(board, { ...newProperties }, path);\n    });\n};\n", "import { getDirectionByVector, getPointByVectorComponent } from '@plait/common';\nimport { PlaitBoard, Vector, Direction, RectangleClient, Point } from '@plait/core';\nimport { createDefaultSwimlane, insertElement } from '../utils';\nimport { insertGeometry } from './geometry';\nimport { BasicShapes, FlowchartSymbols, GeometryShapes, SwimlaneDrawSymbols, UMLSymbols } from '../interfaces';\nimport {\n    DefaultBasicShapeProperty,\n    DefaultBasicShapePropertyMap,\n    DefaultFlowchartPropertyMap,\n    DefaultSwimlanePropertyMap,\n    DefaultUMLPropertyMap,\n    getSwimlanePointers\n} from '../constants';\n\nexport const insertDrawByVector = (board: PlaitBoard, point: Point, shape: GeometryShapes | SwimlaneDrawSymbols, vector: Vector) => {\n    const swimlanePointers = getSwimlanePointers();\n    const isSwimlanePointer = swimlanePointers.includes(shape);\n    let shapeProperty =\n        DefaultFlowchartPropertyMap[shape as FlowchartSymbols] ||\n        DefaultBasicShapePropertyMap[shape as BasicShapes] ||\n        DefaultUMLPropertyMap[shape as UMLSymbols] ||\n        DefaultBasicShapeProperty;\n    if (isSwimlanePointer) {\n        shapeProperty = DefaultSwimlanePropertyMap[shape];\n    }\n    const direction = getDirectionByVector(vector);\n    if (direction) {\n        let offset = 0;\n        if ([Direction.left, Direction.right].includes(direction)) {\n            offset = -shapeProperty.width / 2;\n        } else {\n            offset = -shapeProperty.height / 2;\n        }\n        const vectorPoint = getPointByVectorComponent(point, vector, offset);\n        const points = RectangleClient.getPoints(\n            RectangleClient.getRectangleByCenterPoint(vectorPoint, shapeProperty.width, shapeProperty.height)\n        );\n        if (isSwimlanePointer) {\n            const swimlane = createDefaultSwimlane(shape as SwimlaneDrawSymbols, points);\n            insertElement(board, swimlane);\n            return swimlane;\n        }\n        return insertGeometry(board, points, shape as GeometryShapes);\n    }\n    return null;\n};\n", "import { insertText, insertGeometry, resizeGeometry, switchGeometryShape } from './geometry';\nimport { setText, setTextSize } from './geometry-text';\nimport { insertImage } from './image';\nimport {\n    connectArrowLineToDraw,\n    removeArrowLineText,\n    resizeArrowLine,\n    setArrowLineMark,\n    setArrowLineShape,\n    setArrowLineTexts\n} from './arrow-line';\nimport { addSwimlaneColumn, addSwimlaneRow, removeSwimlaneColumn, removeSwimlaneRow, updateSwimlaneCount } from './swimlane';\nimport { setDrawTexts } from './multi-text-geometry-text';\nimport { setTableText } from './table-text';\nimport { setTableFill } from './table';\nimport { setVectorLineShape } from './vector-line';\nimport { insertDrawByVector } from './common';\n\nexport const DrawTransforms = {\n    setText,\n    setDrawTexts,\n    insertGeometry,\n    resizeGeometry,\n    insertText,\n    setTextSize,\n    resizeArrowLine,\n    setArrowLineTexts,\n    removeArrowLineText,\n    setArrowLineMark,\n    setArrowLineShape,\n    setVectorLineShape,\n    insertImage,\n    connectArrowLineToDraw,\n    switchGeometryShape,\n    setTableText,\n    addSwimlaneRow,\n    addSwimlaneColumn,\n    removeSwimlaneRow,\n    removeSwimlaneColumn,\n    updateSwimlaneCount,\n    setTableFill,\n    insertDrawByVector\n};\n", "import {\n    Ancestor,\n    PlaitBoard,\n    Point,\n    RectangleClient,\n    depthFirstRecursion,\n    getIsRecursionFunc,\n    rotatePoints,\n    rotateAntiPointsByElement,\n    ResizeCursorClass\n} from '@plait/core';\nimport {\n    RESIZE_HANDLE_DIAMETER,\n    getRectangleResizeHandleRefs,\n    getRotatedResizeCursorClassByAngle,\n    ROTATE_HANDLE_SIZE,\n    ROTATE_HANDLE_DISTANCE_TO_ELEMENT,\n    ResizeHandle\n} from '@plait/common';\nimport { PlaitDrawElement, PlaitGeometry, PlaitShapeElement } from '../../interfaces';\nimport { isHitEdgeOfShape, isInsideOfShape } from '../hit';\nimport { LINE_HIT_GEOMETRY_BUFFER, LINE_SNAPPING_BUFFER } from '../../constants/geometry';\nimport { getNearestPoint } from '../geometry';\nimport { getHitConnectorPoint } from '../arrow-line/arrow-line-basic';\nimport { getHitShape } from '../common';\n\nexport interface ResizeHandleRef {\n    rectangle: RectangleClient;\n    handle: ResizeHandle;\n    cursorClass: ResizeCursorClass;\n}\n\nexport const getHitRectangleResizeHandleRef = (\n    board: PlaitBoard,\n    rectangle: RectangleClient,\n    point: Point,\n    angle: number = 0\n): ResizeHandleRef | undefined => {\n    const centerPoint = RectangleClient.getCenterPoint(rectangle);\n    const resizeHandleRefs = getRectangleResizeHandleRefs(rectangle, RESIZE_HANDLE_DIAMETER);\n    if (angle) {\n        const rotatedPoint = rotatePoints([point], centerPoint, -angle)[0];\n        let result = resizeHandleRefs.find(resizeHandleRef => {\n            return RectangleClient.isHit(RectangleClient.getRectangleByPoints([rotatedPoint, rotatedPoint]), resizeHandleRef.rectangle);\n        });\n        if (result) {\n            result.cursorClass = getRotatedResizeCursorClassByAngle(result.cursorClass, angle);\n        }\n        return result;\n    } else {\n        return resizeHandleRefs.find(resizeHandleRef => {\n            return RectangleClient.isHit(RectangleClient.getRectangleByPoints([point, point]), resizeHandleRef.rectangle);\n        });\n    }\n};\n\nexport const getRotateHandleRectangle = (rectangle: RectangleClient) => {\n    return {\n        x: rectangle.x - ROTATE_HANDLE_DISTANCE_TO_ELEMENT - ROTATE_HANDLE_SIZE,\n        y: rectangle.y + rectangle.height + ROTATE_HANDLE_DISTANCE_TO_ELEMENT,\n        width: ROTATE_HANDLE_SIZE,\n        height: ROTATE_HANDLE_SIZE\n    };\n};\n", "import {\n    ResizeRef,\n    ResizeState,\n    WithResizeOptions,\n    drawHandle,\n    getFirstTextManage,\n    getIndexByResizeHandle,\n    getResizeHandlePointByIndex,\n    getSymmetricHandleIndex,\n    isCornerHandle,\n    withResize,\n    resetPointsAfterResize,\n    normalizeShapePoints\n} from '@plait/common';\nimport {\n    PlaitBoard,\n    Point,\n    RectangleClient,\n    Transforms,\n    createG,\n    getRectangleByElements,\n    getSelectedElements,\n    isSelectionMoving,\n    getSelectionAngle,\n    rotatePoints,\n    rotatedDataPoints,\n    createDebugGenerator,\n    hasValidAngle,\n    isAxisChangedByAngle,\n    drawRectangle,\n    ACTIVE_STROKE_WIDTH,\n    SELECTION_BORDER_COLOR,\n    Path,\n    toActiveRectangleFromViewBoxRectangle\n} from '@plait/core';\nimport { PlaitDrawElement } from '../interfaces';\nimport { DrawTransforms } from '../transforms';\nimport { getHitRectangleResizeHandleRef } from '../utils/position/geometry';\nimport { getSnapResizingRefOptions, getSnapResizingRef } from '../utils/snap-resizing';\nimport { isGeometryIncludeText, isSingleSelectLine, isSingleSelectSwimlane } from '../utils';\n\nconst debugKey = 'debug:plait:resize-for-rotation';\nconst debugGenerator = createDebugGenerator(debugKey);\n\nexport interface BulkRotationRef {\n    angle: number;\n    offsetX: number;\n    offsetY: number;\n    newCenterPoint: Point;\n}\n\nexport function withDrawResize(board: PlaitBoard) {\n    const { afterChange, drawSelectionRectangle } = board;\n    let snapG: SVGGElement | null;\n    let handleG: SVGGElement | null;\n    let needCustomActiveRectangle = false;\n    let resizeActivePoints: Point[] | null = null;\n\n    const canResize = () => {\n        const elements = getSelectedElements(board);\n        return (\n            elements.length >= 1 &&\n            elements.every(\n                (el) =>\n                    (PlaitDrawElement.isDrawElement(el) || (PlaitDrawElement.isCustomGeometryElement(board, el) && el.points.length > 1)) &&\n                    !isSingleSelectLine(board) &&\n                    !isSingleSelectSwimlane(board)\n            )\n        );\n    };\n\n    const options: WithResizeOptions<PlaitDrawElement[]> = {\n        key: 'draw-elements',\n        canResize,\n        hitTest: (point: Point) => {\n            const elements = getSelectedElements(board) as PlaitDrawElement[];\n            const boundingRectangle = getRectangleByElements(board, elements, false);\n            const angle = getSelectionAngle(elements);\n            const handleRef = getHitRectangleResizeHandleRef(board, boundingRectangle, point, angle);\n            if (handleRef) {\n                return {\n                    element: [...elements],\n                    rectangle: boundingRectangle,\n                    handle: handleRef.handle,\n                    cursorClass: handleRef.cursorClass\n                };\n            }\n            return null;\n        },\n        onResize: (resizeRef: ResizeRef<PlaitDrawElement[]>, resizeState: ResizeState) => {\n            snapG?.remove();\n            debugGenerator.isDebug() && debugGenerator.clear();\n            const isFromCorner = isCornerHandle(board, resizeRef.handle);\n            const isAspectRatio = resizeState.isShift || (resizeRef.element.length === 1 && PlaitDrawElement.isImage(resizeRef.element[0]));\n            const centerPoint = RectangleClient.getCenterPoint(resizeRef.rectangle!);\n            const handleIndex = getIndexByResizeHandle(resizeRef.handle);\n            const { originPoint, handlePoint } = getResizeOriginPointAndHandlePoint(board, handleIndex, resizeRef.rectangle!);\n            const angle = getSelectionAngle(resizeRef.element);\n            let bulkRotationRef: BulkRotationRef | undefined;\n            if (angle) {\n                bulkRotationRef = {\n                    angle: angle,\n                    offsetX: 0,\n                    offsetY: 0,\n                    newCenterPoint: [0, 0]\n                };\n                const [rotatedStartPoint, rotateEndPoint] = rotatePoints(\n                    [resizeState.startPoint, resizeState.endPoint],\n                    centerPoint,\n                    -bulkRotationRef.angle\n                );\n                resizeState.startPoint = rotatedStartPoint;\n                resizeState.endPoint = rotateEndPoint;\n            }\n            const resizeSnapRefOptions = getSnapResizingRefOptions(\n                board,\n                resizeRef,\n                resizeState,\n                {\n                    originPoint,\n                    handlePoint\n                },\n                isAspectRatio,\n                isFromCorner\n            );\n            const resizeSnapRef = getSnapResizingRef(board, resizeRef.element, resizeSnapRefOptions);\n            resizeActivePoints = resizeSnapRef.activePoints;\n            snapG = resizeSnapRef.snapG;\n            PlaitBoard.getElementTopHost(board).append(snapG);\n\n            if (bulkRotationRef) {\n                const boundingBoxCornerPoints = RectangleClient.getPoints(resizeRef.rectangle!);\n                const resizedBoundingBoxCornerPoints = boundingBoxCornerPoints.map((p) => {\n                    return movePointByZoomAndOriginPoint(p, originPoint, resizeSnapRef.xZoom, resizeSnapRef.yZoom);\n                });\n                const newBoundingBox = RectangleClient.getRectangleByPoints(resizedBoundingBoxCornerPoints);\n\n                debugGenerator.isDebug() && debugGenerator.drawRectangle(board, newBoundingBox, { stroke: 'blue' });\n\n                const newBoundingBoxCenter = RectangleClient.getCenterPoint(newBoundingBox);\n                const adjustedNewBoundingBoxPoints = resetPointsAfterResize(\n                    RectangleClient.getRectangleByPoints(boundingBoxCornerPoints),\n                    RectangleClient.getRectangleByPoints(resizedBoundingBoxCornerPoints),\n                    centerPoint,\n                    newBoundingBoxCenter,\n                    bulkRotationRef.angle\n                );\n                const newCenter = RectangleClient.getCenterPoint(RectangleClient.getRectangleByPoints(adjustedNewBoundingBoxPoints));\n                bulkRotationRef = Object.assign(bulkRotationRef, {\n                    offsetX: newCenter[0] - newBoundingBoxCenter[0],\n                    offsetY: newCenter[1] - newBoundingBoxCenter[1],\n                    newCenterPoint: newCenter\n                });\n\n                debugGenerator.isDebug() && debugGenerator.drawRectangle(board, adjustedNewBoundingBoxPoints);\n            }\n\n            resizeRef.element.forEach((target) => {\n                const path = PlaitBoard.findPath(board, target);\n                let points;\n                if (bulkRotationRef) {\n                    const reversedPoints = rotatedDataPoints(target.points, centerPoint, -bulkRotationRef.angle);\n                    points = reversedPoints.map((p: Point) => {\n                        return movePointByZoomAndOriginPoint(p, originPoint, resizeSnapRef.xZoom, resizeSnapRef.yZoom);\n                    }) as [Point, Point];\n                    const adjustTargetPoints = points.map((p) => [\n                        p[0] + bulkRotationRef!.offsetX,\n                        p[1] + bulkRotationRef!.offsetY\n                    ]) as Point[];\n                    points = rotatedDataPoints(adjustTargetPoints, bulkRotationRef.newCenterPoint, bulkRotationRef.angle) as [Point, Point];\n                } else {\n                    if (hasValidAngle(target)) {\n                        needCustomActiveRectangle = true;\n                    }\n                    if (hasValidAngle(target) && isAxisChangedByAngle(target.angle!)) {\n                        points = getResizePointsByOtherwiseAxis(\n                            board,\n                            target.points,\n                            originPoint,\n                            resizeSnapRef.xZoom,\n                            resizeSnapRef.yZoom\n                        );\n                    } else {\n                        points = target.points.map((p) => {\n                            return movePointByZoomAndOriginPoint(p, originPoint, resizeSnapRef.xZoom, resizeSnapRef.yZoom);\n                        });\n                    }\n                }\n\n                if (PlaitDrawElement.isGeometry(target)) {\n                    if (PlaitDrawElement.isGeometry(target) && isGeometryIncludeText(target)) {\n                        const { height: textHeight } = getFirstTextManage(target).getSize();\n                        DrawTransforms.resizeGeometry(board, points as [Point, Point], textHeight, path);\n                    } else {\n                        points = normalizeShapePoints(points as [Point, Point]);\n                        Transforms.setNode(board, { points }, path);\n                    }\n                } else if (\n                    PlaitDrawElement.isLine(target) ||\n                    PlaitDrawElement.isCustomGeometryElement(board, target) ||\n                    PlaitDrawElement.isVectorLine(target)\n                ) {\n                    Transforms.setNode(board, { points }, path);\n                } else if (PlaitDrawElement.isImage(target)) {\n                    if (isAspectRatio) {\n                        Transforms.setNode(board, { points }, path);\n                    } else {\n                        // The image element does not follow the resize, but moves based on the center point.\n                        const targetRectangle = RectangleClient.getRectangleByPoints(target.points);\n                        const centerPoint = RectangleClient.getCenterPoint(targetRectangle);\n                        const newCenterPoint = movePointByZoomAndOriginPoint(\n                            centerPoint,\n                            originPoint,\n                            resizeSnapRef.xZoom,\n                            resizeSnapRef.yZoom\n                        );\n                        const newTargetRectangle = RectangleClient.getRectangleByCenterPoint(\n                            newCenterPoint,\n                            targetRectangle.width,\n                            targetRectangle.height\n                        );\n                        Transforms.setNode(board, { points: RectangleClient.getPoints(newTargetRectangle) }, path);\n                    }\n                }\n            });\n        },\n        afterResize: (resizeRef: ResizeRef<PlaitDrawElement[]>) => {\n            snapG?.remove();\n            snapG = null;\n            if (needCustomActiveRectangle) {\n                needCustomActiveRectangle = false;\n                resizeActivePoints = null;\n                const selectedElements = getSelectedElements(board);\n                Transforms.addSelectionWithTemporaryElements(board, selectedElements);\n            }\n        }\n    };\n\n    withResize<PlaitDrawElement[]>(board, options);\n\n    board.afterChange = () => {\n        afterChange();\n        if (handleG) {\n            handleG.remove();\n            handleG = null;\n        }\n        const selectedElements = getSelectedElements(board);\n        if (canResize() && !isSelectionMoving(board) && selectedElements.length > 1) {\n            handleG = generatorResizeHandles(board, resizeActivePoints!, needCustomActiveRectangle);\n            PlaitBoard.getActiveHost(board).append(handleG);\n        }\n    };\n\n    board.drawSelectionRectangle = () => {\n        if (needCustomActiveRectangle) {\n            const rectangle = RectangleClient.getRectangleByPoints(resizeActivePoints!);\n            const activeRectangle = toActiveRectangleFromViewBoxRectangle(board, rectangle);\n            return drawRectangle(board, RectangleClient.inflate(activeRectangle, ACTIVE_STROKE_WIDTH), {\n                stroke: SELECTION_BORDER_COLOR,\n                strokeWidth: ACTIVE_STROKE_WIDTH\n            });\n        }\n        return drawSelectionRectangle();\n    };\n\n    return board;\n}\n\nexport const getResizeOriginPointAndHandlePoint = (board: PlaitBoard, handleIndex: number, rectangle: RectangleClient) => {\n    const symmetricHandleIndex = getSymmetricHandleIndex(board, handleIndex);\n    const originPoint = getResizeHandlePointByIndex(rectangle as RectangleClient, symmetricHandleIndex);\n    const handlePoint = getResizeHandlePointByIndex(rectangle as RectangleClient, handleIndex);\n    return {\n        originPoint,\n        handlePoint\n    };\n};\n\nexport const getResizeZoom = (\n    resizeStartAndEnd: [Point, Point],\n    resizeOriginPoint: Point,\n    resizeHandlePoint: Point,\n    isFromCorner: boolean,\n    isAspectRatio: boolean\n) => {\n    const [startPoint, endPoint] = resizeStartAndEnd;\n    let xZoom = 0;\n    let yZoom = 0;\n    if (isFromCorner) {\n        if (isAspectRatio) {\n            let normalizedOffsetX = Point.getOffsetX(startPoint, endPoint);\n            xZoom = normalizedOffsetX / (resizeHandlePoint[0] - resizeOriginPoint[0]);\n            yZoom = xZoom;\n        } else {\n            let normalizedOffsetX = Point.getOffsetX(startPoint, endPoint);\n            let normalizedOffsetY = Point.getOffsetY(startPoint, endPoint);\n            xZoom = normalizedOffsetX / (resizeHandlePoint[0] - resizeOriginPoint[0]);\n            yZoom = normalizedOffsetY / (resizeHandlePoint[1] - resizeOriginPoint[1]);\n        }\n    } else {\n        const isHorizontal = Point.isHorizontal(resizeOriginPoint, resizeHandlePoint, 0.1) || false;\n        let normalizedOffset = isHorizontal ? Point.getOffsetX(startPoint, endPoint) : Point.getOffsetY(startPoint, endPoint);\n        let benchmarkOffset = isHorizontal ? resizeHandlePoint[0] - resizeOriginPoint[0] : resizeHandlePoint[1] - resizeOriginPoint[1];\n        const zoom = normalizedOffset / benchmarkOffset;\n        if (isAspectRatio) {\n            xZoom = zoom;\n            yZoom = zoom;\n        } else {\n            if (isHorizontal) {\n                xZoom = zoom;\n            } else {\n                yZoom = zoom;\n            }\n        }\n    }\n    return { xZoom, yZoom };\n};\n\nexport const movePointByZoomAndOriginPoint = (p: Point, resizeOriginPoint: Point, xZoom: number, yZoom: number) => {\n    const offsetX = (p[0] - resizeOriginPoint[0]) * xZoom;\n    const offsetY = (p[1] - resizeOriginPoint[1]) * yZoom;\n    return [p[0] + offsetX, p[1] + offsetY] as Point;\n};\n\n/**\n * 1. Rotate 90°\n * 2. Scale based on the rotated points\n * 3. Reverse rotate the scaled points by 90°\n */\nexport const getResizePointsByOtherwiseAxis = (\n    board: PlaitBoard,\n    points: Point[],\n    resizeOriginPoint: Point,\n    xZoom: number,\n    yZoom: number\n) => {\n    const currentRectangle = RectangleClient.getRectangleByPoints(points);\n    debugGenerator.isDebug() && debugGenerator.drawRectangle(board, currentRectangle, { stroke: 'black' });\n    let resultPoints = points;\n    resultPoints = rotatePoints(resultPoints, RectangleClient.getCenterPoint(currentRectangle), (1 / 2) * Math.PI);\n    debugGenerator.isDebug() && debugGenerator.drawRectangle(board, resultPoints, { stroke: 'blue' });\n    resultPoints = resultPoints.map((p) => {\n        return movePointByZoomAndOriginPoint(p, resizeOriginPoint, xZoom, yZoom);\n    });\n    debugGenerator.isDebug() && debugGenerator.drawRectangle(board, resultPoints);\n    const newRectangle = RectangleClient.getRectangleByPoints(resultPoints);\n    return rotatePoints(resultPoints, RectangleClient.getCenterPoint(newRectangle), -(1 / 2) * Math.PI);\n};\n\nexport const generatorResizeHandles = (board: PlaitBoard, resizeActivePoints?: Point[], needCustomActiveRectangle?: boolean) => {\n    const handleG = createG();\n    const elements = getSelectedElements(board) as PlaitDrawElement[];\n    const boundingRectangle = needCustomActiveRectangle\n        ? RectangleClient.getRectangleByPoints(resizeActivePoints!)\n        : getRectangleByElements(board, elements, false);\n    const boundingActiveRectangle = toActiveRectangleFromViewBoxRectangle(board, boundingRectangle);\n    let corners = RectangleClient.getCornerPoints(boundingActiveRectangle);\n    const angle = getSelectionAngle(elements);\n    if (angle) {\n        const centerPoint = RectangleClient.getCenterPoint(boundingActiveRectangle);\n        corners = rotatePoints(corners, centerPoint, angle) as [Point, Point, Point, Point];\n    }\n    corners.forEach((corner) => {\n        const g = drawHandle(board, corner);\n        handleG.append(g);\n    });\n    return handleG;\n};\n", "import {\n    ResizeRef,\n    ResizeState,\n    getDirectionFactorByDirectionComponent,\n    getUnitVectorByPointAndPoint,\n    resetPointsAfterResize\n} from '@plait/common';\nimport {\n    DirectionFactors,\n    PlaitBoard,\n    PlaitElement,\n    Point,\n    RectangleClient,\n    createDebugGenerator,\n    createG,\n    getSelectionAngle,\n    getRectangleByAngle,\n    getRectangleByElements,\n    SnapDelta,\n    SnapRef,\n    getSnapRectangles,\n    SNAP_TOLERANCE,\n    drawSolidLines,\n    drawPointSnapLines,\n    getTripleAxis,\n    getMinPointDelta\n} from '@plait/core';\nimport { getResizeZoom, movePointByZoomAndOriginPoint } from '../plugins/with-draw-resize';\nimport { PlaitCustomGeometry, PlaitDrawElement } from '../interfaces';\n\nconst debugKey = 'debug:plait:point-for-geometry';\nexport const debugGenerator = createDebugGenerator(debugKey);\n\nexport interface ResizeSnapRef extends SnapRef {\n    xZoom: number;\n    yZoom: number;\n    activePoints: Point[];\n}\n\nexport interface ResizeSnapOptions {\n    resizePoints: Point[];\n    activeRectangle: RectangleClient;\n    directionFactors: DirectionFactors;\n    isFromCorner: boolean;\n    isAspectRatio: boolean;\n    resizeOriginPoint?: Point[];\n    originPoint?: Point;\n    handlePoint?: Point;\n    isCreate?: boolean;\n}\n\nconst EQUAL_SPACING = 10;\n\nexport function getSnapResizingRefOptions(\n    board: PlaitBoard,\n    resizeRef: ResizeRef<PlaitDrawElement | PlaitCustomGeometry | (PlaitDrawElement | PlaitCustomGeometry)[]>,\n    resizeState: ResizeState,\n    resizeOriginPointAndHandlePoint: {\n        originPoint: Point;\n        handlePoint: Point;\n    },\n    isAspectRatio: boolean,\n    isFromCorner: boolean\n): ResizeSnapOptions {\n    const { originPoint, handlePoint } = resizeOriginPointAndHandlePoint;\n    const resizePoints: [Point, Point] = [resizeState.startPoint, resizeState.endPoint];\n    const { xZoom, yZoom } = getResizeZoom(resizePoints, originPoint, handlePoint, isFromCorner, isAspectRatio);\n\n    let activeElements: PlaitElement[];\n    let resizeOriginPoint: Point[] = [];\n    if (Array.isArray(resizeRef.element)) {\n        activeElements = resizeRef.element;\n        const rectangle = getRectangleByElements(board, resizeRef.element, false);\n        resizeOriginPoint = RectangleClient.getPoints(rectangle);\n    } else {\n        activeElements = [resizeRef.element];\n        resizeOriginPoint = resizeRef.element.points;\n    }\n\n    const points = resizeOriginPoint.map(p => {\n        return movePointByZoomAndOriginPoint(p, originPoint, xZoom, yZoom);\n    }) as [Point, Point];\n    const rectangle = RectangleClient.getRectangleByPoints(points);\n    const activeRectangle = getRectangleByAngle(rectangle, getSelectionAngle(activeElements));\n    const resizeHandlePoint = movePointByZoomAndOriginPoint(handlePoint, originPoint, xZoom, yZoom);\n    const [x, y] = getUnitVectorByPointAndPoint(originPoint, resizeHandlePoint);\n    return {\n        resizePoints,\n        resizeOriginPoint,\n        activeRectangle,\n        originPoint,\n        handlePoint,\n        directionFactors: [getDirectionFactorByDirectionComponent(x), getDirectionFactorByDirectionComponent(y)],\n        isAspectRatio,\n        isFromCorner\n    };\n}\n\nexport function getSnapResizingRef(board: PlaitBoard, activeElements: PlaitElement[], resizeSnapOptions: ResizeSnapOptions): ResizeSnapRef {\n    const snapG = createG();\n    const snapRectangles = getSnapRectangles(board, activeElements);\n    let snapLineDelta = getIsometricLineDelta(snapRectangles, resizeSnapOptions);\n    if (snapLineDelta.deltaX === 0 && snapLineDelta.deltaY === 0) {\n        snapLineDelta = getSnapPointDelta(snapRectangles, resizeSnapOptions);\n    }\n    const angle = getSelectionAngle(activeElements);\n    const activePointAndZoom = getActivePointAndZoom(snapLineDelta, resizeSnapOptions, angle);\n    const isometricLinesG = drawIsometricSnapLines(board, activePointAndZoom.activePoints, snapRectangles, resizeSnapOptions, angle);\n    const pointLinesG = drawResizingPointSnapLines(board, activePointAndZoom.activePoints, snapRectangles, resizeSnapOptions, angle);\n    snapG.append(isometricLinesG, pointLinesG);\n    return { ...activePointAndZoom, ...snapLineDelta, snapG };\n}\n\nfunction getSnapPointDelta(snapRectangles: RectangleClient[], resizeSnapOptions: ResizeSnapOptions) {\n    let pointLineDelta: SnapDelta = {\n        deltaX: 0,\n        deltaY: 0\n    };\n    const { isAspectRatio, activeRectangle, directionFactors } = resizeSnapOptions;\n    const drawHorizontal = directionFactors[0] !== 0 || isAspectRatio;\n    const drawVertical = directionFactors[1] !== 0 || isAspectRatio;\n\n    if (drawHorizontal) {\n        const xSnapAxis = getTripleAxis(activeRectangle, true);\n        const pointX = directionFactors[0] === -1 ? xSnapAxis[0] : xSnapAxis[2];\n        const deltaX = getMinPointDelta(snapRectangles, pointX, true);\n        if (Math.abs(deltaX) < SNAP_TOLERANCE) {\n            pointLineDelta.deltaX = deltaX;\n            if (pointLineDelta.deltaX !== 0 && isAspectRatio) {\n                pointLineDelta.deltaY = pointLineDelta.deltaX / (activeRectangle.width / activeRectangle.height);\n                return pointLineDelta;\n            }\n        }\n    }\n\n    if (drawVertical) {\n        const ySnapAxis = getTripleAxis(activeRectangle, false);\n        const pointY = directionFactors[1] === -1 ? ySnapAxis[0] : ySnapAxis[2];\n        const deltaY = getMinPointDelta(snapRectangles, pointY, false);\n        if (Math.abs(deltaY) < SNAP_TOLERANCE) {\n            pointLineDelta.deltaY = deltaY;\n            if (pointLineDelta.deltaY !== 0 && isAspectRatio) {\n                pointLineDelta.deltaX = pointLineDelta.deltaY * (activeRectangle.width / activeRectangle.height);\n                return pointLineDelta;\n            }\n        }\n    }\n\n    return pointLineDelta;\n}\n\nfunction getActivePointAndZoom(resizeSnapDelta: SnapDelta, resizeSnapOptions: ResizeSnapOptions, angle: number) {\n    const { deltaX, deltaY } = resizeSnapDelta;\n    const { resizePoints, isCreate } = resizeSnapOptions;\n    const newResizePoints: [Point, Point] = [resizePoints[0], [resizePoints[1][0] + deltaX, resizePoints[1][1] + deltaY]];\n    let activePoints = newResizePoints;\n    let xZoom = 0;\n    let yZoom = 0;\n    if (!isCreate) {\n        const { originPoint, handlePoint, isFromCorner, isAspectRatio, resizeOriginPoint } = resizeSnapOptions;\n        const resizeZoom = getResizeZoom(newResizePoints, originPoint!, handlePoint!, isFromCorner, isAspectRatio);\n        xZoom = resizeZoom.xZoom;\n        yZoom = resizeZoom.yZoom;\n        activePoints = resizeOriginPoint!.map(p => {\n            return movePointByZoomAndOriginPoint(p, originPoint!, xZoom, yZoom);\n        }) as [Point, Point];\n        if (angle) {\n            activePoints = resetPointsAfterResize(\n                RectangleClient.getRectangleByPoints(resizeOriginPoint!),\n                RectangleClient.getRectangleByPoints(activePoints),\n                RectangleClient.getCenterPoint(RectangleClient.getRectangleByPoints(resizeOriginPoint!)),\n                RectangleClient.getCenterPoint(RectangleClient.getRectangleByPoints(activePoints)),\n                angle\n            );\n        }\n    }\n\n    return {\n        xZoom,\n        yZoom,\n        activePoints\n    };\n}\n\nfunction getIsometricLineDelta(snapRectangles: RectangleClient[], resizeSnapOptions: ResizeSnapOptions) {\n    let isometricLineDelta: SnapDelta = {\n        deltaX: 0,\n        deltaY: 0\n    };\n    const { isAspectRatio, activeRectangle } = resizeSnapOptions;\n    const widthSnapRectangle = snapRectangles.find(item => Math.abs(item.width - activeRectangle.width) < SNAP_TOLERANCE);\n    if (widthSnapRectangle) {\n        const deltaWidth = widthSnapRectangle.width - activeRectangle.width;\n        isometricLineDelta.deltaX = deltaWidth * resizeSnapOptions.directionFactors[0];\n        if (isAspectRatio) {\n            const deltaHeight = deltaWidth / (activeRectangle.width / activeRectangle.height);\n            isometricLineDelta.deltaY = deltaHeight * resizeSnapOptions.directionFactors[1];\n            return isometricLineDelta;\n        }\n    }\n    const heightSnapRectangle = snapRectangles.find(item => Math.abs(item.height - activeRectangle.height) < SNAP_TOLERANCE);\n    if (heightSnapRectangle) {\n        const deltaHeight = heightSnapRectangle.height - activeRectangle.height;\n        isometricLineDelta.deltaY = deltaHeight * resizeSnapOptions.directionFactors[1];\n        if (isAspectRatio) {\n            const deltaWidth = deltaHeight * (activeRectangle.width / activeRectangle.height);\n            isometricLineDelta.deltaX = deltaWidth * resizeSnapOptions.directionFactors[0];\n            return isometricLineDelta;\n        }\n    }\n    return isometricLineDelta;\n}\n\nfunction getIsometricLinePoints(rectangle: RectangleClient, isHorizontal: boolean): Point[] {\n    return isHorizontal\n        ? [\n              [rectangle.x, rectangle.y - EQUAL_SPACING],\n              [rectangle.x + rectangle.width, rectangle.y - EQUAL_SPACING]\n          ]\n        : [\n              [rectangle.x - EQUAL_SPACING, rectangle.y],\n              [rectangle.x - EQUAL_SPACING, rectangle.y + rectangle.height]\n          ];\n}\n\nfunction drawResizingPointSnapLines(\n    board: PlaitBoard,\n    activePoints: Point[],\n    snapRectangles: RectangleClient[],\n    resizeSnapOptions: ResizeSnapOptions,\n    angle: number\n) {\n    debugGenerator.isDebug() && debugGenerator.clear();\n    const rectangle = RectangleClient.getRectangleByPoints(activePoints);\n    const activeRectangle = getRectangleByAngle(rectangle, angle);\n    const { isAspectRatio, directionFactors } = resizeSnapOptions;\n    const drawHorizontal = directionFactors[0] !== 0 || isAspectRatio;\n    const drawVertical = directionFactors[1] !== 0 || isAspectRatio;\n    return drawPointSnapLines(board, activeRectangle, snapRectangles, drawHorizontal, drawVertical);\n}\n\nfunction drawIsometricSnapLines(\n    board: PlaitBoard,\n    activePoints: Point[],\n    snapRectangles: RectangleClient[],\n    resizeSnapOptions: ResizeSnapOptions,\n    angle: number\n) {\n    let widthIsometricPoints = [];\n    let heightIsometricPoints = [];\n\n    const drawHorizontalLine = resizeSnapOptions.directionFactors[0] !== 0 || resizeSnapOptions.isAspectRatio;\n    const drawVerticalLine = resizeSnapOptions.directionFactors[1] !== 0 || resizeSnapOptions.isAspectRatio;\n    const rectangle = RectangleClient.getRectangleByPoints(activePoints);\n    const activeRectangle = getRectangleByAngle(rectangle, angle);\n    for (let snapRectangle of snapRectangles) {\n        if (activeRectangle.width === snapRectangle.width && drawHorizontalLine) {\n            widthIsometricPoints.push(getIsometricLinePoints(snapRectangle, true));\n        }\n        if (activeRectangle.height === snapRectangle.height && drawVerticalLine) {\n            heightIsometricPoints.push(getIsometricLinePoints(snapRectangle, false));\n        }\n    }\n    if (widthIsometricPoints.length && drawHorizontalLine) {\n        widthIsometricPoints.push(getIsometricLinePoints(activeRectangle, true));\n    }\n    if (heightIsometricPoints.length && drawVerticalLine) {\n        heightIsometricPoints.push(getIsometricLinePoints(activeRectangle, false));\n    }\n\n    const isometricLines = [...widthIsometricPoints, ...heightIsometricPoints];\n    return drawSolidLines(board, isometricLines);\n}\n", "import { PlaitBoard, PlaitElement, Point, Transforms, getElementById, idCreator } from '@plait/core';\nimport { buildClipboardData as basicBuildClipboard, insertClipboardData as basicInsertClipboard } from '@plait/common';\nimport { PlaitArrowLine, PlaitDrawElement, PlaitGeometry } from '../interfaces';\nimport { getConnectionPoint } from './arrow-line/arrow-line-common';\nimport { PlaitTable } from '../interfaces/table';\nimport { updateCellIds, updateRowOrColumnIds } from './table';\n\nexport const buildClipboardData = (board: PlaitBoard, elements: PlaitDrawElement[], startPoint: Point) => {\n    return basicBuildClipboard(board, elements, startPoint, (element: PlaitElement) => {\n        if (PlaitDrawElement.isArrowLine(element)) {\n            let source = { ...element.source };\n            let target = { ...element.target };\n            let points = [...element.points];\n            if (element.source.boundId) {\n                points[0] = getConnectionPoint(getElementById<PlaitGeometry>(board, element.source.boundId)!, element.source.connection!);\n                if (!getElementById(board, element.source.boundId, elements)) {\n                    delete source.boundId;\n                    delete source.connection;\n                }\n            }\n            if (element.target.boundId) {\n                points[points.length - 1] = getConnectionPoint(\n                    getElementById<PlaitGeometry>(board, element.target.boundId)!,\n                    element.target.connection!\n                );\n                if (!getElementById(board, element.target.boundId, elements)) {\n                    delete target.boundId;\n                    delete target.connection;\n                }\n            }\n            points = points.map(point => [point[0] - startPoint[0], point[1] - startPoint[1]]);\n            return { ...element, points, source, target } as PlaitArrowLine;\n        }\n        return undefined;\n    });\n};\n\nexport const insertClipboardData = (board: PlaitBoard, elements: PlaitDrawElement[], startPoint: Point) => {\n    basicInsertClipboard(board, elements, startPoint, (element: PlaitElement, idsMap: Record<string, string>) => {\n        if (PlaitDrawElement.isArrowLine(element)) {\n            if (element.source.boundId) {\n                const boundElement = elements.find(item => [element.source.boundId, idsMap[element.source.boundId!]].includes(item.id));\n                if (boundElement) {\n                    element.source.boundId = idsMap[element.source.boundId];\n                }\n            }\n            if (element.target.boundId) {\n                const boundElement = elements.find(item => [element.target.boundId, idsMap[element.target.boundId!]].includes(item.id));\n                if (boundElement) {\n                    element.target.boundId = idsMap[element.target.boundId];\n                }\n            }\n        }\n        if (PlaitDrawElement.isElementByTable(element)) {\n            updateRowOrColumnIds(element as PlaitTable, 'row');\n            updateRowOrColumnIds(element as PlaitTable, 'column');\n            updateCellIds(element.cells);\n        }\n    });\n};\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    getNearestPointBetweenPointAndSegments,\n    isPointInPolygon,\n    setStrokeLinecap\n} from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { ShapeDefaultSpace } from '../../constants';\nimport { getStrokeWidthByElement } from '../../utils';\nimport { getPolygonEdgeByConnectionPoint } from '../../utils/polygon';\n\nconst heightRatio = 3 / 4;\n\nexport const CommentEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const points = getCommentPoints(rectangle);\n        const rs = PlaitBoard.getRoughSVG(board);\n        const polygon = rs.polygon(points, { ...options, fillStyle: 'solid' });\n        setStrokeLinecap(polygon, 'round');\n        return polygon;\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        const parallelogramPoints = getCommentPoints(rectangle);\n        return isPointInPolygon(point, parallelogramPoints);\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return getCommentPoints(rectangle);\n    },\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        return getNearestPointBetweenPointAndSegments(point, getCommentPoints(rectangle));\n    },\n    getEdgeByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle): [Point, Point] | null {\n        const corners = getCommentPoints(rectangle);\n        const point = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        return getPolygonEdgeByConnectionPoint(corners, point);\n    },\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    },\n    getTextRectangle(element: PlaitGeometry) {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const height = element.textHeight!;\n        const width = elementRectangle.width - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth * 2;\n        return {\n            height,\n            width: width > 0 ? width : 0,\n            x: elementRectangle.x + ShapeDefaultSpace.rectangleAndText + strokeWidth,\n            y: elementRectangle.y + (elementRectangle.height * heightRatio - height) / 2\n        };\n    }\n};\n\nexport const getCommentPoints = (rectangle: RectangleClient): Point[] => {\n    return [\n        [rectangle.x, rectangle.y],\n        [rectangle.x + rectangle.width, rectangle.y],\n        [rectangle.x + rectangle.width, rectangle.y + rectangle.height * heightRatio],\n        [rectangle.x + (rectangle.width * 3) / 5, rectangle.y + rectangle.height * heightRatio],\n        [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height],\n        [rectangle.x + (rectangle.width * 2) / 5, rectangle.y + rectangle.height * heightRatio],\n        [rectangle.x, rectangle.y + rectangle.height * heightRatio]\n    ];\n};\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    distanceBetweenPointAndPoint,\n    getNearestPointBetweenPointAndSegments,\n    isPointInPolygon,\n    setStrokeLinecap\n} from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { getCrossingPointBetweenPointAndPolygon, getPolygonEdgeByConnectionPoint } from '../../utils/polygon';\n\nexport interface CreateOptions {\n    getPolygonPoints: (rectangle: RectangleClient) => Point[];\n    getConnectorPoints?: (rectangle: RectangleClient) => Point[];\n    getTextRectangle?: (element: PlaitGeometry) => RectangleClient;\n}\n\nexport function createPolygonEngine(options: CreateOptions): ShapeEngine {\n    const getPoints = options.getPolygonPoints;\n    const engine: ShapeEngine = {\n        draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n            const points = getPoints(rectangle);\n            const rs = PlaitBoard.getRoughSVG(board);\n            const polygon = rs.polygon(points, { ...options, fillStyle: 'solid' });\n            setStrokeLinecap(polygon, 'round');\n            return polygon;\n        },\n        isInsidePoint(rectangle: RectangleClient, point: Point) {\n            const points = getPoints(rectangle);\n            return isPointInPolygon(point, points);\n        },\n        getCornerPoints(rectangle: RectangleClient) {\n            return getPoints(rectangle);\n        },\n        getNearestPoint(rectangle: RectangleClient, point: Point) {\n            return getNearestPointBetweenPointAndSegments(point, getPoints(rectangle));\n        },\n        getNearestCrossingPoint(rectangle: RectangleClient, point: Point) {\n            const corners = getPoints(rectangle);\n            const crossingPoints = getCrossingPointBetweenPointAndPolygon(corners, point);\n            let nearestPoint = crossingPoints[0];\n            let nearestDistance = distanceBetweenPointAndPoint(point[0], point[1], nearestPoint[0], nearestPoint[1]);\n            crossingPoints\n                .filter((v, index) => index > 0)\n                .forEach(crossingPoint => {\n                    let distance = distanceBetweenPointAndPoint(point[0], point[1], crossingPoint[0], crossingPoint[1]);\n                    if (distance < nearestDistance) {\n                        nearestDistance = distance;\n                        nearestPoint = crossingPoint;\n                    }\n                });\n\n            return nearestPoint;\n        },\n        getEdgeByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle): [Point, Point] | null {\n            const corners = getPoints(rectangle);\n            const point = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n            return getPolygonEdgeByConnectionPoint(corners, point);\n        },\n        getConnectorPoints(rectangle: RectangleClient) {\n            if (options.getConnectorPoints) {\n                return options.getConnectorPoints(rectangle);\n            }\n            return getPoints(rectangle);\n        }\n    };\n    if (options.getTextRectangle) {\n        engine.getTextRectangle = options.getTextRectangle;\n    }\n    return engine;\n}\n", "import { Point, RectangleClient } from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { createPolygonEngine } from './polygon';\nimport { getTextRectangle } from '../../utils';\nexport const getCrossPoints = (rectangle: RectangleClient): Point[] => {\n    return [\n        [rectangle.x + rectangle.width / 4, rectangle.y],\n        [rectangle.x + (rectangle.width * 3) / 4, rectangle.y],\n        [rectangle.x + (rectangle.width * 3) / 4, rectangle.y + rectangle.height / 4],\n        [rectangle.x + rectangle.width, rectangle.y + rectangle.height / 4],\n        [rectangle.x + rectangle.width, rectangle.y + (rectangle.height * 3) / 4],\n        [rectangle.x + (rectangle.width * 3) / 4, rectangle.y + (rectangle.height * 3) / 4],\n        [rectangle.x + (rectangle.width * 3) / 4, rectangle.y + rectangle.height],\n        [rectangle.x + rectangle.width / 4, rectangle.y + rectangle.height],\n        [rectangle.x + rectangle.width / 4, rectangle.y + (rectangle.height * 3) / 4],\n        [rectangle.x, rectangle.y + (rectangle.height * 3) / 4],\n        [rectangle.x, rectangle.y + rectangle.height / 4],\n        [rectangle.x + rectangle.width / 4, rectangle.y + rectangle.height / 4]\n    ];\n};\n\nexport const CrossEngine: ShapeEngine = createPolygonEngine({\n    getPolygonPoints: getCrossPoints,\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    },\n    getTextRectangle(element: PlaitGeometry) {\n        const rectangle = getTextRectangle(element);\n        const width = rectangle.width;\n        rectangle.width = rectangle.width / 2;\n        rectangle.x += width / 4;\n        return rectangle;\n    }\n});\n", "import { RectangleClient } from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { createPolygonEngine } from './polygon';\nimport { getTextRectangle } from '../../utils';\n\nexport const DiamondEngine: ShapeEngine = createPolygonEngine({\n    getPolygonPoints: RectangleClient.getEdgeCenterPoints,\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    },\n    getTextRectangle(element: PlaitGeometry) {\n        const rectangle = getTextRectangle(element);\n        rectangle.width = rectangle.width / 2;\n        rectangle.x += rectangle.width / 2;\n        return rectangle;\n    }\n});\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    getEllipseTangentSlope,\n    getVectorFromPointAndSlope,\n    isPointInEllipse,\n    getNearestPointBetweenPointAndEllipse,\n    setStrokeLinecap\n} from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { getTextRectangle } from '../../utils';\n\nexport interface CreateEllipseOptions {\n    draw?: (board: PlaitBoard, rectangle: RectangleClient, options: Options) => SVGGElement;\n    getTextRectangle?: (element: PlaitGeometry) => RectangleClient;\n}\n\nexport function createEllipseEngine(createOptions?: CreateEllipseOptions): ShapeEngine {\n    const engine: ShapeEngine = {\n        draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n            const centerPoint = [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height / 2];\n            const rs = PlaitBoard.getRoughSVG(board);\n            const shape = rs.ellipse(centerPoint[0], centerPoint[1], rectangle.width, rectangle.height, { ...options, fillStyle: 'solid' });\n            setStrokeLinecap(shape, 'round');\n            return shape;\n        },\n        isInsidePoint(rectangle: RectangleClient, point: Point) {\n            const centerPoint: Point = [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height / 2];\n            return isPointInEllipse(point, centerPoint, rectangle.width / 2, rectangle.height / 2);\n        },\n        getCornerPoints(rectangle: RectangleClient) {\n            return RectangleClient.getEdgeCenterPoints(rectangle);\n        },\n        getNearestPoint(rectangle: RectangleClient, point: Point) {\n            const centerPoint: Point = [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height / 2];\n            return getNearestPointBetweenPointAndEllipse(point, centerPoint, rectangle.width / 2, rectangle.height / 2);\n        },\n        getTangentVectorByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle) {\n            const connectionPoint = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n            const centerPoint: Point = [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height / 2];\n            const point = [connectionPoint[0] - centerPoint[0], -(connectionPoint[1] - centerPoint[1])];\n            const a = rectangle.width / 2;\n            const b = rectangle.height / 2;\n            const slope = getEllipseTangentSlope(point[0], point[1], a, b) as any;\n            const vector = getVectorFromPointAndSlope(point[0], point[1], slope);\n            return vector;\n        },\n        getConnectorPoints(rectangle: RectangleClient) {\n            return RectangleClient.getEdgeCenterPoints(rectangle);\n        },\n        getTextRectangle(element: PlaitGeometry) {\n            const rectangle = getTextRectangle(element);\n            const width = rectangle.width;\n            rectangle.width = (rectangle.width * 3) / 4;\n            rectangle.x += width / 8;\n            return rectangle;\n        }\n    };\n\n    if (createOptions?.draw) {\n        engine.draw = createOptions.draw;\n    }\n    if (createOptions?.getTextRectangle) {\n        engine.getTextRectangle = createOptions.getTextRectangle;\n    }\n\n    return engine;\n}\n\nexport const EllipseEngine: ShapeEngine = createEllipseEngine();\n", "import { Point, RectangleClient } from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { createPolygonEngine } from './polygon';\nimport { getTextRectangle } from '../../utils';\n\nexport const getHexagonPoints = (rectangle: RectangleClient): Point[] => {\n    return [\n        [rectangle.x + rectangle.width / 4, rectangle.y],\n        [rectangle.x + (rectangle.width * 3) / 4, rectangle.y],\n        [rectangle.x + rectangle.width, rectangle.y + rectangle.height / 2],\n        [rectangle.x + (rectangle.width * 3) / 4, rectangle.y + rectangle.height],\n        [rectangle.x + rectangle.width / 4, rectangle.y + rectangle.height],\n        [rectangle.x, rectangle.y + rectangle.height / 2]\n    ];\n};\n\nexport const HexagonEngine: ShapeEngine = createPolygonEngine({\n    getPolygonPoints: getHexagonPoints,\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    },\n    getTextRectangle(element: PlaitGeometry) {\n        const rectangle = getTextRectangle(element);\n        const width = rectangle.width;\n        rectangle.width = (rectangle.width * 3) / 4;\n        rectangle.x += width / 8;\n        return rectangle;\n    }\n});\n", "import { Point, RectangleClient } from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { createPolygonEngine } from './polygon';\nimport { getTextRectangle } from '../../utils';\n\nexport const getLeftArrowPoints = (rectangle: RectangleClient): Point[] => {\n    return [\n        [rectangle.x, rectangle.y + rectangle.height / 2],\n        [rectangle.x + rectangle.width * 0.32, rectangle.y],\n        [rectangle.x + rectangle.width * 0.32, rectangle.y + rectangle.height * 0.2],\n        [rectangle.x + rectangle.width, rectangle.y + rectangle.height * 0.2],\n        [rectangle.x + rectangle.width, rectangle.y + rectangle.height * 0.8],\n        [rectangle.x + rectangle.width * 0.32, rectangle.y + rectangle.height * 0.8],\n        [rectangle.x + rectangle.width * 0.32, rectangle.y + rectangle.height]\n    ];\n};\n\nexport const LeftArrowEngine: ShapeEngine = createPolygonEngine({\n    getPolygonPoints: getLeftArrowPoints,\n    getConnectorPoints: (rectangle: RectangleClient) => {\n        return [\n            [rectangle.x, rectangle.y + rectangle.height / 2],\n            [rectangle.x + rectangle.width, rectangle.y + rectangle.height / 2]\n        ];\n    },\n    getTextRectangle(element: PlaitGeometry) {\n        const rectangle = getTextRectangle(element);\n        const width = rectangle.width;\n        rectangle.width = rectangle.width * (1 - 0.32);\n        rectangle.x += width * 0.32;\n        return rectangle;\n    }\n});\n", "import { Point, RectangleClient } from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { createPolygonEngine } from './polygon';\nimport { getTextRectangle } from '../../utils';\n\nexport const getOctagonPoints = (rectangle: RectangleClient): Point[] => {\n    return [\n        [rectangle.x + (rectangle.width * 3) / 10, rectangle.y],\n        [rectangle.x + (rectangle.width * 7) / 10, rectangle.y],\n        [rectangle.x + rectangle.width, rectangle.y + (rectangle.height * 3) / 10],\n        [rectangle.x + rectangle.width, rectangle.y + (rectangle.height * 7) / 10],\n        [rectangle.x + (rectangle.width * 7) / 10, rectangle.y + rectangle.height],\n        [rectangle.x + (rectangle.width * 3) / 10, rectangle.y + rectangle.height],\n        [rectangle.x, rectangle.y + (rectangle.height * 7) / 10],\n        [rectangle.x, rectangle.y + (rectangle.height * 3) / 10]\n    ];\n};\n\nexport const OctagonEngine: ShapeEngine = createPolygonEngine({\n    getPolygonPoints: getOctagonPoints,\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    },\n    getTextRectangle(element: PlaitGeometry) {\n        const rectangle = getTextRectangle(element);\n        const width = rectangle.width;\n        rectangle.width = (rectangle.width * 3) / 4;\n        rectangle.x += width / 8;\n        return rectangle;\n    }\n});\n", "import { Point, RectangleClient } from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { createPolygonEngine } from './polygon';\nimport { getCenterPointsOnPolygon } from '../../utils/polygon';\nimport { getTextRectangle } from '../../utils';\n\nexport const getParallelogramPoints = (rectangle: RectangleClient): Point[] => {\n    return [\n        [rectangle.x + rectangle.width / 4, rectangle.y],\n        [rectangle.x + rectangle.width, rectangle.y],\n        [rectangle.x + (rectangle.width * 3) / 4, rectangle.y + rectangle.height],\n        [rectangle.x, rectangle.y + rectangle.height]\n    ];\n};\nexport const ParallelogramEngine: ShapeEngine = createPolygonEngine({\n    getPolygonPoints: getParallelogramPoints,\n    getConnectorPoints: (rectangle: RectangleClient) => {\n        const cornerPoints = getParallelogramPoints(rectangle);\n        return getCenterPointsOnPolygon(cornerPoints);\n    },\n    getTextRectangle(element: PlaitGeometry) {\n        const rectangle = getTextRectangle(element);\n        const width = rectangle.width;\n        rectangle.width = rectangle.width / 2;\n        rectangle.x += width / 4;\n        return rectangle;\n    }\n});\n", "import { Point, RectangleClient } from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { createPolygonEngine } from './polygon';\nimport { getStrokeWidthByElement } from '../../utils';\nimport { ShapeDefaultSpace } from '../../constants';\n\nexport const getPentagonPoints = (rectangle: RectangleClient): Point[] => {\n    return [\n        [rectangle.x + rectangle.width / 2, rectangle.y],\n        [rectangle.x + rectangle.width, rectangle.y + (rectangle.height * 2) / 5],\n        [rectangle.x + (rectangle.width * 4) / 5, rectangle.y + rectangle.height],\n        [rectangle.x + rectangle.width / 5, rectangle.y + rectangle.height],\n        [rectangle.x, rectangle.y + (rectangle.height * 2) / 5]\n    ];\n};\n\nexport const PentagonEngine: ShapeEngine = createPolygonEngine({\n    getPolygonPoints: getPentagonPoints,\n    getTextRectangle(element: PlaitGeometry) {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const height = element.textHeight!;\n        const originWidth = elementRectangle.width - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth * 2;\n        const width = (originWidth * 3) / 5;\n        return {\n            height,\n            width: width > 0 ? width : 0,\n            x: elementRectangle.x + ShapeDefaultSpace.rectangleAndText + strokeWidth + originWidth / 5,\n            y: elementRectangle.y + elementRectangle.height / 5 + ((elementRectangle.height * 4) / 5 - height) / 2\n        };\n    }\n});\n", "import { Point, RectangleClient } from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { createPolygonEngine } from './polygon';\nimport { getTextRectangle } from '../../utils';\n\nexport const getPentagonArrowPoints = (rectangle: RectangleClient): Point[] => {\n    const wider = rectangle.width > rectangle.height / 2;\n    return [\n        [rectangle.x, rectangle.y],\n        [rectangle.x + (wider ? rectangle.width - rectangle.height / 2 : 0), rectangle.y],\n        [rectangle.x + rectangle.width, rectangle.y + rectangle.height / 2],\n        [rectangle.x + (wider ? rectangle.width - rectangle.height / 2 : 0), rectangle.y + rectangle.height],\n        [rectangle.x, rectangle.y + rectangle.height]\n    ];\n};\n\nexport const PentagonArrowEngine: ShapeEngine = createPolygonEngine({\n    getPolygonPoints: getPentagonArrowPoints,\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    },\n    getTextRectangle(element: PlaitGeometry) {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const rectangle = getTextRectangle(element);\n        const wider = elementRectangle.width > elementRectangle.height / 2 + 20;\n        rectangle.width = wider ? elementRectangle.width - elementRectangle.height / 2 : rectangle.width;\n        return rectangle;\n    }\n});\n", "import { Point, RectangleClient } from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { createPolygonEngine } from './polygon';\nimport { getTextRectangle } from '../../utils';\n\nexport const getProcessArrowPoints = (rectangle: RectangleClient): Point[] => {\n    const wider = rectangle.width > rectangle.height / 2;\n    return [\n        [rectangle.x, rectangle.y],\n        [rectangle.x + (wider ? rectangle.width - rectangle.height / 2 : 0), rectangle.y],\n        [rectangle.x + rectangle.width, rectangle.y + rectangle.height / 2],\n        [rectangle.x + (wider ? rectangle.width - rectangle.height / 2 : 0), rectangle.y + rectangle.height],\n        [rectangle.x, rectangle.y + rectangle.height],\n        [rectangle.x + (wider ? rectangle.height / 2 : rectangle.width), rectangle.y + rectangle.height / 2]\n    ];\n};\n\nexport const ProcessArrowEngine: ShapeEngine = createPolygonEngine({\n    getPolygonPoints: getProcessArrowPoints,\n    getTextRectangle(element: PlaitGeometry) {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const rectangle = getTextRectangle(element);\n        const wider = elementRectangle.width > elementRectangle.height + 20;\n        rectangle.width = wider ? elementRectangle.width - elementRectangle.height : rectangle.width;\n        rectangle.x = wider ? elementRectangle.x + elementRectangle.height / 2:  rectangle.x;\n        return rectangle;\n    }\n});\n", "import { Point, RectangleClient } from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { createPolygonEngine } from './polygon';\nimport { getTextRectangle } from '../../utils';\n\nexport const getRightArrowPoints = (rectangle: RectangleClient): Point[] => {\n    return [\n        [rectangle.x, rectangle.y + rectangle.height * 0.2],\n        [rectangle.x + rectangle.width * 0.68, rectangle.y + rectangle.height * 0.2],\n        [rectangle.x + rectangle.width * 0.68, rectangle.y],\n        [rectangle.x + rectangle.width, rectangle.y + rectangle.height / 2],\n        [rectangle.x + rectangle.width * 0.68, rectangle.y + rectangle.height],\n        [rectangle.x + rectangle.width * 0.68, rectangle.y + rectangle.height * 0.8],\n        [rectangle.x, rectangle.y + rectangle.height * 0.8]\n    ];\n};\n\nexport const RightArrowEngine: ShapeEngine = createPolygonEngine({\n    getPolygonPoints: getRightArrowPoints,\n    getConnectorPoints: (rectangle: RectangleClient) => {\n        return [\n            [rectangle.x, rectangle.y + rectangle.height / 2],\n            [rectangle.x + rectangle.width, rectangle.y + rectangle.height / 2]\n        ];\n    },\n    getTextRectangle(element: PlaitGeometry) {\n        const rectangle = getTextRectangle(element);\n        rectangle.width = rectangle.width * 0.68;\n        return rectangle;\n    }\n});\n", "import { PlaitBoard, Point, PointOfRectangle, RectangleClient, drawRectangle, getNearestPointBetweenPointAndSegments } from '@plait/core';\nimport { ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { getPolygonEdgeByConnectionPoint } from '../../utils/polygon';\n\nexport const RectangleEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        return drawRectangle(board, rectangle, { ...options, fillStyle: 'solid' });\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        const rangeRectangle = RectangleClient.getRectangleByPoints([point, point]);\n        return RectangleClient.isHit(rectangle, rangeRectangle);\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        return getNearestPointBetweenPointAndSegments(point, RectangleEngine.getCornerPoints(rectangle));\n    },\n    getEdgeByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle): [Point, Point] | null {\n        const corners = RectangleEngine.getCornerPoints(rectangle);\n        const point = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        return getPolygonEdgeByConnectionPoint(corners, point);\n    },\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    }\n};\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    drawRoundRectangle,\n    getNearestPointBetweenPointAndSegments,\n    isPointInRoundRectangle,\n    getNearestPointBetweenPointAndEllipse\n} from '@plait/core';\nimport { ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { RectangleEngine } from './rectangle';\nimport { getPolygonEdgeByConnectionPoint } from '../../utils/polygon';\n\nexport const RoundRectangleEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        return drawRoundRectangle(\n            PlaitBoard.getRoughSVG(board),\n            rectangle.x,\n            rectangle.y,\n            rectangle.x + rectangle.width,\n            rectangle.y + rectangle.height,\n            { ...options, fillStyle: 'solid' },\n            false,\n            getRoundRectangleRadius(rectangle)\n        );\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        return isPointInRoundRectangle(point, rectangle, getRoundRectangleRadius(rectangle));\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        return getNearestPointBetweenPointAndRoundRectangle(point, rectangle, getRoundRectangleRadius(rectangle));\n    },\n    getEdgeByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle): [Point, Point] | null {\n        const corners = RectangleEngine.getCornerPoints(rectangle);\n        const point = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        return getPolygonEdgeByConnectionPoint(corners, point);\n    },\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    }\n};\n\nexport const getRoundRectangleRadius = (rectangle: RectangleClient) => {\n    return Math.min(rectangle.width * 0.1, rectangle.height * 0.1);\n};\n\nexport function getNearestPointBetweenPointAndRoundRectangle(point: Point, rectangle: RectangleClient, radius: number) {\n    const { x: rectX, y: rectY, width, height } = rectangle;\n    const cornerPoints = RectangleClient.getCornerPoints(rectangle);\n    let result = getNearestPointBetweenPointAndSegments(point, cornerPoints);\n    let circleCenter: Point | null = null;\n\n    const inLeftTop = point[0] >= rectX && point[0] <= rectX + radius && point[1] >= rectY && point[1] <= rectY + radius;\n    if (inLeftTop) {\n        circleCenter = [rectX + radius, rectY + radius];\n    }\n    const inLeftBottom =\n        point[0] >= rectX && point[0] <= rectX + radius && point[1] >= rectY + height && point[1] <= rectY + height - radius;\n    if (inLeftBottom) {\n        circleCenter = [rectX + radius, rectY + height - radius];\n    }\n    const inRightTop = point[0] >= rectX + width - radius && point[0] <= rectX + width && point[1] >= rectY && point[1] <= rectY + radius;\n    if (inRightTop) {\n        circleCenter = [rectX + width - radius, rectY + radius];\n    }\n    const inRightBottom =\n        point[0] >= rectX + width - radius &&\n        point[0] <= rectX + width &&\n        point[1] >= rectY + height - radius &&\n        point[1] <= rectY + height;\n    if (inRightBottom) {\n        circleCenter = [rectX + width - radius, rectY + height - radius];\n    }\n    if (circleCenter) {\n        result = getNearestPointBetweenPointAndEllipse(point, circleCenter, radius, radius);\n    }\n    return result;\n}\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    getNearestPointBetweenPointAndSegments,\n    isPointInPolygon,\n    isPointInRoundRectangle,\n    setStrokeLinecap\n} from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { ShapeDefaultSpace } from '../../constants';\nimport { getRoundRectangleRadius } from './round-rectangle';\nimport { getPolygonEdgeByConnectionPoint } from '../../utils/polygon';\nimport { getStrokeWidthByElement } from '../../utils/common';\n\nconst heightRatio = 3 / 4;\n\nexport const RoundCommentEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n        const x1 = rectangle.x;\n        const y1 = rectangle.y;\n        const x2 = rectangle.x + rectangle.width;\n        const y2 = rectangle.y + rectangle.height * heightRatio;\n        const radius = getRoundRectangleRadius(rectangle);\n\n        const point1 = [x1 + radius, y1];\n        const point2 = [x2 - radius, y1];\n        const point3 = [x2, y1 + radius];\n        const point4 = [x2, y2 - radius];\n        const point5 = [x2 - radius, y2];\n        const point6 = [x1 + radius, y2];\n        const point7 = [x1, y2 - radius];\n        const point8 = [x1, y1 + radius];\n\n        const point9 = [x1 + rectangle.width / 4, y2];\n        const point10 = [x1 + rectangle.width / 4, rectangle.y + rectangle.height];\n        const point11 = [x1 + rectangle.width / 2, y2];\n\n        const shape = rs.path(\n            `M${point2[0]} ${point2[1]} A ${radius} ${radius}, 0, 0, 1, ${point3[0]} ${point3[1]} L ${point4[0]} ${point4[1]} A ${radius} ${radius}, 0, 0, 1, ${point5[0]} ${point5[1]} L    ${point11[0]} ${point11[1]}  ${point10[0]} ${point10[1]}   ${point9[0]} ${point9[1]}   ${point6[0]} ${point6[1]} A ${radius} ${radius}, 0, 0, 1, ${point7[0]} ${point7[1]} L ${point8[0]} ${point8[1]} A ${radius} ${radius}, 0, 0, 1, ${point1[0]} ${point1[1]} Z`,\n            { ...options, fillStyle: 'solid' }\n        );\n        setStrokeLinecap(shape, 'round');\n        return shape;\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        const points: Point[] = [\n            [rectangle.x + rectangle.width / 4, rectangle.y + (rectangle.height * 3) / 4],\n            [rectangle.x + rectangle.width / 4, rectangle.y + rectangle.height],\n            [rectangle.x + rectangle.width / 2, rectangle.y + (rectangle.height * 3) / 4]\n        ];\n        rectangle.height = (rectangle.height * 3) / 4;\n        return isPointInPolygon(point, points) || isPointInRoundRectangle(point, rectangle, getRoundRectangleRadius(rectangle));\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return getRoundCommentPoints(rectangle);\n    },\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        return getNearestPointBetweenPointAndSegments(point, getRoundCommentPoints(rectangle));\n    },\n    getEdgeByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle): [Point, Point] | null {\n        const corners = getRoundCommentPoints(rectangle);\n        const point = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        return getPolygonEdgeByConnectionPoint(corners, point);\n    },\n    getConnectorPoints(rectangle: RectangleClient) {\n        return [\n            [rectangle.x + rectangle.width / 2, rectangle.y],\n            [rectangle.x + rectangle.width, rectangle.y + rectangle.height / 2],\n            [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height * heightRatio],\n            [rectangle.x, rectangle.y + rectangle.height / 2]\n        ];\n    },\n    getTextRectangle(element: PlaitGeometry) {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const height = element.textHeight!;\n        const width = elementRectangle.width - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth * 2;\n        return {\n            height,\n            width: width > 0 ? width : 0,\n            x: elementRectangle.x + ShapeDefaultSpace.rectangleAndText + strokeWidth,\n            y: elementRectangle.y + (elementRectangle.height * heightRatio - height) / 2\n        };\n    }\n};\n\nexport const getRoundCommentPoints = (rectangle: RectangleClient): Point[] => {\n    return [\n        [rectangle.x, rectangle.y],\n        [rectangle.x + rectangle.width, rectangle.y],\n        [rectangle.x + rectangle.width, rectangle.y + rectangle.height * heightRatio],\n        [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height * heightRatio],\n        [rectangle.x + rectangle.width / 4, rectangle.y + rectangle.height],\n        [rectangle.x + rectangle.width / 4, rectangle.y + rectangle.height * heightRatio],\n        [rectangle.x, rectangle.y + rectangle.height * heightRatio]\n    ];\n};\n", "import { Point, RectangleClient } from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { createPolygonEngine } from './polygon';\nimport { getCenterPointsOnPolygon } from '../../utils/polygon';\nimport { getTextRectangle } from '../../utils';\n\nexport const getTrapezoidPoints = (rectangle: RectangleClient): Point[] => {\n    return [\n        [rectangle.x + rectangle.width * 0.15, rectangle.y],\n        [rectangle.x + rectangle.width * 0.85, rectangle.y],\n        [rectangle.x + rectangle.width, rectangle.y + rectangle.height],\n        [rectangle.x, rectangle.y + rectangle.height]\n    ];\n};\n\nexport const TrapezoidEngine: ShapeEngine = createPolygonEngine({\n    getPolygonPoints: getTrapezoidPoints,\n    getConnectorPoints(rectangle: RectangleClient) {\n        const points = getTrapezoidPoints(rectangle);\n        return getCenterPointsOnPolygon(points);\n    },\n    getTextRectangle(element: PlaitGeometry) {\n        const rectangle = getTextRectangle(element);\n        const width = rectangle.width;\n        rectangle.width = (rectangle.width * 3) / 4;\n        rectangle.x += width / 8;\n        return rectangle;\n    }\n});\n", "import { Point, RectangleClient } from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { createPolygonEngine } from './polygon';\nimport { ShapeDefaultSpace } from '../../constants';\nimport { getCenterPointsOnPolygon } from '../../utils/polygon';\nimport { getStrokeWidthByElement } from '../../utils';\n\nexport const getTrianglePoints = (rectangle: RectangleClient): Point[] => {\n    return [\n        [rectangle.x + rectangle.width / 2, rectangle.y],\n        [rectangle.x + rectangle.width, rectangle.y + rectangle.height],\n        [rectangle.x, rectangle.y + rectangle.height]\n    ];\n};\n\nexport const TriangleEngine: ShapeEngine = createPolygonEngine({\n    getPolygonPoints: getTrianglePoints,\n    getConnectorPoints(rectangle: RectangleClient) {\n        const cornerPoints = getTrianglePoints(rectangle);\n        const lineCenterPoints = getCenterPointsOnPolygon(cornerPoints);\n        return [...lineCenterPoints, ...cornerPoints];\n    },\n    getTextRectangle(element: PlaitGeometry) {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const height = element.textHeight!;\n        const originWidth = elementRectangle.width - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth * 2;\n        const width = (originWidth * 2) / 3;\n        return {\n            height,\n            width: width > 0 ? width : 0,\n            x: elementRectangle.x + ShapeDefaultSpace.rectangleAndText + strokeWidth + originWidth / 6,\n            y: elementRectangle.y + (elementRectangle.height * 3) / 5 + ((elementRectangle.height * 2) / 5 - height) / 2\n        };\n    }\n});\n", "import { Point, RectangleClient } from '@plait/core';\nimport { ShapeEngine } from '../../interfaces';\nimport { createPolygonEngine } from './polygon';\n\nexport const getTwoWayArrowPoints = (rectangle: RectangleClient): Point[] => {\n    return [\n        [rectangle.x, rectangle.y + rectangle.height / 2],\n        [rectangle.x + (rectangle.width * 8) / 25, rectangle.y],\n        [rectangle.x + (rectangle.width * 8) / 25, rectangle.y + rectangle.height / 5],\n        [rectangle.x + (rectangle.width * 17) / 25, rectangle.y + rectangle.height / 5],\n        [rectangle.x + (rectangle.width * 17) / 25, rectangle.y],\n        [rectangle.x + rectangle.width, rectangle.y + rectangle.height / 2],\n        [rectangle.x + (rectangle.width * 17) / 25, rectangle.y + rectangle.height],\n        [rectangle.x + (rectangle.width * 17) / 25, rectangle.y + (rectangle.height * 4) / 5],\n        [rectangle.x + (rectangle.width * 8) / 25, rectangle.y + (rectangle.height * 4) / 5],\n        [rectangle.x + (rectangle.width * 8) / 25, rectangle.y + rectangle.height]\n    ];\n};\n\nexport const TwoWayArrowEngine: ShapeEngine = createPolygonEngine({\n    getPolygonPoints: getTwoWayArrowPoints,\n    getConnectorPoints: (rectangle: RectangleClient) => {\n        return [\n            [rectangle.x, rectangle.y + rectangle.height / 2],\n            [rectangle.x + rectangle.width, rectangle.y + rectangle.height / 2]\n        ];\n    }\n});\n", "import { Point, RectangleClient } from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { createPolygonEngine } from './polygon';\nimport { getStrokeWidthByElement } from '../../utils';\nimport { ShapeDefaultSpace } from '../../constants';\n\nexport const getStarPoints = (rectangle: RectangleClient): Point[] => {\n    return [\n        [rectangle.x + rectangle.width / 2, rectangle.y + (rectangle.height * 75) / 91],\n        [rectangle.x + (rectangle.width * 18.61) / 96, rectangle.y + rectangle.height],\n        [rectangle.x + (rectangle.width * 24.2235871) / 96, rectangle.y + (rectangle.height * 57.7254249) / 91],\n        [rectangle.x, rectangle.y + (rectangle.height * 34.5491503) / 91],\n        [rectangle.x + (rectangle.width * 33.3053687) / 96, rectangle.y + (rectangle.height * 29.7745751) / 91],\n        [rectangle.x + rectangle.width / 2, rectangle.y],\n        [rectangle.x + (rectangle.width * 62.6946313) / 96, rectangle.y + (rectangle.height * 29.7745751) / 91],\n        [rectangle.x + rectangle.width, rectangle.y + (rectangle.height * 34.5491503) / 91],\n        [rectangle.x + (rectangle.width * 71.7764129) / 96, rectangle.y + (rectangle.height * 57.7254249) / 91],\n        [rectangle.x + (rectangle.width * 77.3892626) / 96, rectangle.y + rectangle.height]\n    ];\n};\n\nexport const StarEngine: ShapeEngine = createPolygonEngine({\n    getPolygonPoints: getStarPoints,\n    getConnectorPoints: (rectangle: RectangleClient) => {\n        const points = getStarPoints(rectangle);\n        return [points[1], points[3], points[5], points[7], points[9]];\n    },\n    getTextRectangle(element: PlaitGeometry) {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const height = element.textHeight!;\n        const originWidth = elementRectangle.width - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth * 2;\n        const width = originWidth / 2;\n        return {\n            height,\n            width: width > 0 ? width : 0,\n            x: elementRectangle.x + ShapeDefaultSpace.rectangleAndText + strokeWidth + originWidth / 4,\n            y: elementRectangle.y + (elementRectangle.height * 1) / 6 + ((elementRectangle.height * 4) / 5 - height) / 2\n        };\n    }\n});\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    drawRoundRectangle,\n    getEllipseTangentSlope,\n    getNearestPointBetweenPointAndSegments,\n    getVectorFromPointAndSlope,\n    isPointInRoundRectangle,\n    getNearestPointBetweenPointAndEllipse\n} from '@plait/core';\nimport { ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\n\nexport const TerminalEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        return drawRoundRectangle(\n            PlaitBoard.getRoughSVG(board),\n            rectangle.x,\n            rectangle.y,\n            rectangle.x + rectangle.width,\n            rectangle.y + rectangle.height,\n            { ...options, fillStyle: 'solid' },\n            false,\n            getStartEndRadius(rectangle)\n        );\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        return isPointInRoundRectangle(point, rectangle, getStartEndRadius(rectangle));\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        return getNearestPointBetweenPointAndRoundRectangle(point, rectangle, getStartEndRadius(rectangle));\n    },\n    getTangentVectorByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle) {\n        const connectionPoint = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        const radius = getStartEndRadius(rectangle);\n        const center = getBoundCenterOfRoundRectangle(rectangle, radius, connectionPoint);\n        if (center) {\n            const point = [connectionPoint[0] - center[0], -(connectionPoint[1] - center[1])];\n            const a = radius;\n            const b = radius;\n            const slope = getEllipseTangentSlope(point[0], point[1], a, b) as any;\n            return getVectorFromPointAndSlope(point[0], point[1], slope);\n        }\n        return null;\n    },\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    }\n};\n\nexport const getStartEndRadius = (rectangle: RectangleClient) => {\n    return Math.min(rectangle.width / 2, rectangle.height / 2);\n};\n\nexport function getNearestPointBetweenPointAndRoundRectangle(point: Point, rectangle: RectangleClient, radius: number) {\n    let result: Point | null = null;\n    let boundCenter: Point | null = getBoundCenterOfRoundRectangle(rectangle, radius, point);\n    if (boundCenter) {\n        result = getNearestPointBetweenPointAndEllipse(point, boundCenter, radius, radius);\n    } else {\n        const cornerPoints = RectangleClient.getCornerPoints(rectangle);\n        result = getNearestPointBetweenPointAndSegments(point, cornerPoints);\n    }\n    return result;\n}\n\nexport function getBoundCenterOfRoundRectangle(rectangle: RectangleClient, radius: number, point: Point) {\n    const { x, y, width, height } = rectangle;\n    let center: Point | null = null;\n    const inLeftTop = point[0] >= x && point[0] <= x + radius && point[1] >= y && point[1] <= y + radius;\n    if (inLeftTop) {\n        center = [x + radius, y + radius];\n    }\n    const inLeftBottom = point[0] >= x && point[0] <= x + radius && point[1] >= y + height - radius && point[1] <= y + height;\n    if (inLeftBottom) {\n        center = [x + radius, y + height - radius];\n    }\n    const inRightTop = point[0] >= x + width - radius && point[0] <= x + width && point[1] >= y && point[1] <= y + radius;\n    if (inRightTop) {\n        center = [x + width - radius, y + radius];\n    }\n    const inRightBottom =\n        point[0] >= x + width - radius && point[0] <= x + width && point[1] >= y + height - radius && point[1] <= y + height;\n    if (inRightBottom) {\n        center = [x + width - radius, y + height - radius];\n    }\n    return center;\n}\n", "import { Point, RectangleClient } from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { createPolygonEngine } from '../basic-shapes/polygon';\nimport { ShapeDefaultSpace } from '../../constants';\nimport { getCenterPointsOnPolygon } from '../../utils/polygon';\nimport { getStrokeWidthByElement } from '../../utils';\n\nexport const getManualInputPoints = (rectangle: RectangleClient): Point[] => {\n    return [\n        [rectangle.x, rectangle.y + rectangle.height / 4],\n        [rectangle.x + rectangle.width, rectangle.y],\n        [rectangle.x + rectangle.width, rectangle.y + rectangle.height],\n        [rectangle.x, rectangle.y + rectangle.height]\n    ];\n};\n\nexport const ManualInputEngine: ShapeEngine = createPolygonEngine({\n    getPolygonPoints: getManualInputPoints,\n    getConnectorPoints: (rectangle: RectangleClient) => {\n        const cornerPoints = getManualInputPoints(rectangle);\n        return getCenterPointsOnPolygon(cornerPoints);\n    },\n    getTextRectangle: (element: PlaitGeometry) => {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const height = element.textHeight!;\n        const width = elementRectangle.width - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth * 2;\n        return {\n            height,\n            width: width > 0 ? width : 0,\n            x: elementRectangle.x + ShapeDefaultSpace.rectangleAndText + strokeWidth,\n            y: elementRectangle.y + elementRectangle.height / 4 + ((elementRectangle.height * 3) / 4 - height) / 2\n        };\n    }\n});\n", "import { Point, RectangleClient } from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { createPolygonEngine } from '../basic-shapes/polygon';\nimport { getTextRectangle } from '../../utils';\n\nexport const getPreparationPoints = (rectangle: RectangleClient): Point[] => {\n    return [\n        [rectangle.x, rectangle.y + rectangle.height / 2],\n        [rectangle.x + rectangle.width / 6, rectangle.y],\n        [rectangle.x + (rectangle.width * 5) / 6, rectangle.y],\n        [rectangle.x + rectangle.width, rectangle.y + rectangle.height / 2],\n        [rectangle.x + (rectangle.width * 5) / 6, rectangle.y + rectangle.height],\n        [rectangle.x + rectangle.width / 6, rectangle.y + rectangle.height]\n    ];\n};\n\nexport const PreparationEngine: ShapeEngine = createPolygonEngine({\n    getPolygonPoints: getPreparationPoints,\n    getConnectorPoints: (rectangle: RectangleClient) => {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    },\n    getTextRectangle(element: PlaitGeometry) {\n        const rectangle = getTextRectangle(element);\n        const width = rectangle.width;\n        rectangle.width = (rectangle.width * 2) / 3;\n        rectangle.x += width / 6;\n        return rectangle;\n    }\n});\n", "import { Point, RectangleClient } from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { createPolygonEngine } from '../basic-shapes/polygon';\nimport { getCenterPointsOnPolygon } from '../../utils/polygon';\nimport { getTextRectangle } from '../../utils';\n\nexport const getManualLoopPoints = (rectangle: RectangleClient): Point[] => {\n    return [\n        [rectangle.x, rectangle.y],\n        [rectangle.x + rectangle.width, rectangle.y],\n        [rectangle.x + (rectangle.width * 7) / 8, rectangle.y + rectangle.height],\n        [rectangle.x + rectangle.width / 8, rectangle.y + rectangle.height]\n    ];\n};\nexport const ManualLoopEngine: ShapeEngine = createPolygonEngine({\n    getPolygonPoints: getManualLoopPoints,\n    getConnectorPoints: (rectangle: RectangleClient) => {\n        const cornerPoints = getManualLoopPoints(rectangle);\n        return getCenterPointsOnPolygon(cornerPoints);\n    },\n    getTextRectangle(element: PlaitGeometry) {\n        const rectangle = getTextRectangle(element);\n        const width = rectangle.width;\n        rectangle.width = (rectangle.width * 3) / 4;\n        rectangle.x += width / 8;\n        return rectangle;\n    }\n});\n", "import { Point, RectangleClient } from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { createPolygonEngine } from '../basic-shapes/polygon';\nimport { getStrokeWidthByElement } from '../../utils';\nimport { ShapeDefaultSpace } from '../../constants';\nimport { getCenterPointsOnPolygon } from '../../utils/polygon';\n\nexport const getMergePoints = (rectangle: RectangleClient): Point[] => {\n    return [\n        [rectangle.x, rectangle.y],\n        [rectangle.x + rectangle.width, rectangle.y],\n        [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height]\n    ];\n};\n\nexport const MergeEngine: ShapeEngine = createPolygonEngine({\n    getPolygonPoints: getMergePoints,\n    getConnectorPoints: (rectangle: RectangleClient) => {\n        const cornerPoints = getMergePoints(rectangle);\n        const lineCenterPoints = getCenterPointsOnPolygon(cornerPoints);\n        return [...lineCenterPoints, ...cornerPoints];\n    },\n    getTextRectangle(element: PlaitGeometry) {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const height = element.textHeight!;\n        const originWidth = elementRectangle.width - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth * 2;\n        const width = (originWidth * 2) / 3;\n        return {\n            height,\n            width: width > 0 ? width : 0,\n            x: elementRectangle.x + ShapeDefaultSpace.rectangleAndText + strokeWidth + originWidth / 6,\n            y: elementRectangle.y + ((elementRectangle.height * 2) / 3 - height) / 2\n        };\n    }\n});\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    getEllipseTangentSlope,\n    getNearestPointBetweenPointAndSegments,\n    getVectorFromPointAndSlope,\n    isPointInEllipse,\n    setStrokeLinecap,\n    getNearestPointBetweenPointAndEllipse\n} from '@plait/core';\nimport { ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { RectangleEngine } from '../basic-shapes/rectangle';\n\nexport const DelayEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n        const shape = rs.path(\n            `M${rectangle.x} ${rectangle.y} L${rectangle.x + (rectangle.width * 3) / 4} ${rectangle.y} A  ${rectangle.width /\n                4} ${rectangle.height / 2}, 0, 0, 1,${rectangle.x + (rectangle.width * 3) / 4} ${rectangle.y + rectangle.height} L${\n                rectangle.x\n            } ${rectangle.y + rectangle.height} Z`,\n            { ...options, fillStyle: 'solid' }\n        );\n        setStrokeLinecap(shape, 'round');\n\n        return shape;\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        //split shape to rectangle and a half ellipse\n        const rangeRectangle = RectangleClient.getRectangleByPoints([point, point]);\n        const isInRectangle = RectangleClient.isHit(\n            {\n                ...rectangle,\n                width: (rectangle.width * 3) / 4\n            },\n            rangeRectangle\n        );\n        const isInEllipse = isPointInEllipse(\n            point,\n            [rectangle.x + (rectangle.width * 3) / 4, rectangle.y + rectangle.height / 2],\n            rectangle.width / 4,\n            rectangle.height / 2\n        );\n        return isInRectangle || isInEllipse;\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        const nearestPoint = getNearestPointBetweenPointAndSegments(point, RectangleEngine.getCornerPoints(rectangle));\n        if (nearestPoint[0] > rectangle.x + (rectangle.width * 3) / 4) {\n            return getNearestPointBetweenPointAndEllipse(\n                point,\n                [rectangle.x + (rectangle.width * 3) / 4, rectangle.y + rectangle.height / 2],\n                rectangle.width / 4,\n                rectangle.height / 2\n            );\n        }\n        return nearestPoint;\n    },\n    getTangentVectorByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle) {\n        const connectionPoint = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        const centerPoint: Point = [rectangle.x + (rectangle.width * 3) / 4, rectangle.y + rectangle.height / 2];\n        const point = [connectionPoint[0] - centerPoint[0], -(connectionPoint[1] - centerPoint[1])];\n        const a = rectangle.width / 4;\n        const b = rectangle.height / 2;\n        const slope = getEllipseTangentSlope(point[0], point[1], a, b) as any;\n        return getVectorFromPointAndSlope(point[0], point[1], slope);\n    },\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    }\n};\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    Vector,\n    getEllipseTangentSlope,\n    getNearestPointBetweenPointAndSegments,\n    getVectorFromPointAndSlope,\n    isPointInEllipse,\n    setStrokeLinecap,\n    getNearestPointBetweenPointAndEllipse\n} from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { RectangleEngine } from '../basic-shapes/rectangle';\nimport { getTextRectangle } from '../../utils';\n\nexport const StoredDataEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n        const shape = rs.path(\n            `M${rectangle.x + rectangle.width / 10} ${rectangle.y} L${rectangle.x + rectangle.width} ${rectangle.y} A  ${rectangle.width /\n                10} ${rectangle.height / 2}, 0, 0, 0,${rectangle.x + rectangle.width} ${rectangle.y + rectangle.height} L${rectangle.x +\n                rectangle.width / 10} ${rectangle.y + rectangle.height}A  ${rectangle.width / 10} ${rectangle.height /\n                2}, 0, 0, 1,${rectangle.x + rectangle.width / 10} ${rectangle.y}`,\n            { ...options, fillStyle: 'solid' }\n        );\n        setStrokeLinecap(shape, 'round');\n        return shape;\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        //split shape to rectangle and a half ellipse\n        const rangeRectangle = RectangleClient.getRectangleByPoints([point, point]);\n        const isInRectangle = RectangleClient.isHit(\n            {\n                ...rectangle,\n                x: rectangle.x + rectangle.width / 10,\n                width: (rectangle.width * 9) / 10\n            },\n            rangeRectangle\n        );\n\n        const isInFrontEllipse = isPointInEllipse(\n            point,\n            [rectangle.x + rectangle.width / 10, rectangle.y + rectangle.height / 2],\n            rectangle.width / 10,\n            rectangle.height / 2\n        );\n\n        const notInBackEllipse = !isPointInEllipse(\n            point,\n            [rectangle.x + rectangle.width, rectangle.y + rectangle.height / 2],\n            rectangle.width / 10,\n            rectangle.height / 2\n        );\n        return (isInRectangle && notInBackEllipse) || isInFrontEllipse;\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        const nearestPoint = getNearestPointBetweenPointAndSegments(point, RectangleEngine.getCornerPoints(rectangle));\n        if (nearestPoint[0] < rectangle.x + rectangle.width / 10) {\n            const centerPoint = [rectangle.x + rectangle.width / 10, rectangle.y + rectangle.height / 2] as Point;\n            const nearestPoint = getNearestPointBetweenPointAndEllipse(point, centerPoint, rectangle.width / 10, rectangle.height / 2);\n            if (nearestPoint[0] > centerPoint[0]) {\n                nearestPoint[0] = centerPoint[0] * 2 - nearestPoint[0];\n            }\n            return nearestPoint;\n        }\n        if (nearestPoint[0] > rectangle.x + (rectangle.width * 9) / 10) {\n            const centerPoint = [rectangle.x + rectangle.width, rectangle.y + rectangle.height / 2] as Point;\n            const nearestPoint = getNearestPointBetweenPointAndEllipse(point, centerPoint, rectangle.width / 10, rectangle.height / 2);\n            if (nearestPoint[0] > centerPoint[0]) {\n                nearestPoint[0] = centerPoint[0] * 2 - nearestPoint[0];\n            }\n            return nearestPoint;\n        }\n        return nearestPoint;\n    },\n    getTangentVectorByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle) {\n        const connectionPoint = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        let centerPoint = [rectangle.x + rectangle.width / 10, rectangle.y + rectangle.height / 2];\n        let a = rectangle.width / 10;\n        let b = rectangle.height / 2;\n        const isBackEllipse = connectionPoint[0] > rectangle.x + (rectangle.width * 9) / 10 && connectionPoint[1] > rectangle.y;\n        if (isBackEllipse) {\n            centerPoint = [rectangle.x + rectangle.width, rectangle.y + rectangle.height / 2];\n        }\n        const point = [connectionPoint[0] - centerPoint[0], -(connectionPoint[1] - centerPoint[1])];\n        const slope = getEllipseTangentSlope(point[0], point[1], a, b) as any;\n        const vector = getVectorFromPointAndSlope(point[0], point[1], slope);\n        return isBackEllipse ? (vector.map(num => -num) as Vector) : vector;\n    },\n    getConnectorPoints(rectangle: RectangleClient) {\n        return [\n            [rectangle.x + rectangle.width / 2, rectangle.y],\n            [rectangle.x + (rectangle.width * 9) / 10, rectangle.y + rectangle.height / 2],\n            [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height],\n            [rectangle.x, rectangle.y + rectangle.height / 2]\n        ];\n    },\n    getTextRectangle(element: PlaitGeometry) {\n        const rectangle = getTextRectangle(element);\n        const width = rectangle.width;\n        rectangle.width = (rectangle.width * 3) / 4;\n        rectangle.x += width / 8;\n        return rectangle;\n    }\n};\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    getNearestPointBetweenPointAndSegments,\n    setStrokeLinecap\n} from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { RectangleEngine } from '../basic-shapes/rectangle';\nimport { getPolygonEdgeByConnectionPoint } from '../../utils/polygon';\nimport { getStrokeWidthByElement } from '../../utils';\nimport { ShapeDefaultSpace } from '../../constants';\n\nexport const PredefinedProcessEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n        const shape = rs.path(\n            `M${rectangle.x} ${rectangle.y} H${rectangle.x + rectangle.width} V${rectangle.y + rectangle.height} H${\n                rectangle.x\n            } Z M${rectangle.x + rectangle.width * 0.06} ${rectangle.y} L${rectangle.x + rectangle.width * 0.06} ${rectangle.y +\n                rectangle.height} M${rectangle.x + rectangle.width - rectangle.width * 0.06} ${rectangle.y} L${rectangle.x +\n                rectangle.width -\n                rectangle.width * 0.06} ${rectangle.y + rectangle.height}`,\n            { ...options, fillStyle: 'solid' }\n        );\n        setStrokeLinecap(shape, 'round');\n\n        return shape;\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        const rangeRectangle = RectangleClient.getRectangleByPoints([point, point]);\n        return RectangleClient.isHit(rectangle, rangeRectangle);\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        return getNearestPointBetweenPointAndSegments(point, RectangleEngine.getCornerPoints(rectangle));\n    },\n    getEdgeByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle): [Point, Point] | null {\n        const corners = RectangleEngine.getCornerPoints(rectangle);\n        const point = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        return getPolygonEdgeByConnectionPoint(corners, point);\n    },\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    },\n\n    getTextRectangle: (element: PlaitGeometry) => {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const height = element.textHeight!;\n        const width = elementRectangle.width - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth * 2 - elementRectangle.width * 0.06 * 2;\n        return {\n            height,\n            width: width > 0 ? width : 0,\n            x: elementRectangle.x + ShapeDefaultSpace.rectangleAndText + strokeWidth + elementRectangle.width * 0.06,\n            y: elementRectangle.y + (elementRectangle.height - height) / 2\n        };\n    }\n};\n", "import { Point, RectangleClient } from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { createPolygonEngine } from '../basic-shapes/polygon';\nimport { ShapeDefaultSpace } from '../../constants';\nimport { getStrokeWidthByElement } from '../../utils';\n\nexport const getOffPagePoints = (rectangle: RectangleClient): Point[] => {\n    return [\n        [rectangle.x, rectangle.y],\n        [rectangle.x + rectangle.width, rectangle.y],\n        [rectangle.x + rectangle.width, rectangle.y + rectangle.height / 2],\n        [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height],\n        [rectangle.x, rectangle.y + rectangle.height / 2]\n    ];\n};\n\nexport const OffPageEngine: ShapeEngine = createPolygonEngine({\n    getPolygonPoints: getOffPagePoints,\n    getConnectorPoints: (rectangle: RectangleClient) => {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    },\n    getTextRectangle: (element: PlaitGeometry) => {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const height = element.textHeight!;\n        const width = elementRectangle.width - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth * 2;\n        return {\n            width: width > 0 ? width : 0,\n            height: height,\n            x: elementRectangle.x + ShapeDefaultSpace.rectangleAndText + strokeWidth,\n            y: elementRectangle.y + (elementRectangle.height - elementRectangle.height / 2 - height) / 2\n        };\n    }\n});\n", "import { PlaitBoard, RectangleClient, setStrokeLinecap } from '@plait/core';\nimport { ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { createEllipseEngine } from '../basic-shapes/ellipse';\n\nexport const OrEngine: ShapeEngine = createEllipseEngine({\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n        const rx = rectangle.width / 2;\n        const ry = rectangle.height / 2;\n        const startPoint = [rectangle.x + rectangle.width, rectangle.y + rectangle.height / 2];\n        const shape = rs.path(\n            `M${startPoint[0]} ${startPoint[1]}\n        A${rx},${ry} 0 1,1 ${startPoint[0]} ${startPoint[1] - 0.01}\n        M${rectangle.x} ${rectangle.y + rectangle.height / 2}\n        L${rectangle.x + rectangle.width} ${rectangle.y + rectangle.height / 2}\n        M${rectangle.x + rectangle.width / 2} ${rectangle.y}\n        L${rectangle.x + rectangle.width / 2} ${rectangle.y + rectangle.height}\n        `,\n            { ...options, fillStyle: 'solid' }\n        );\n        setStrokeLinecap(shape, 'round');\n        return shape;\n    }\n});\n", "import { PlaitBoard, RectangleClient, getCrossingPointsBetweenEllipseAndSegment, setStrokeLinecap } from '@plait/core';\nimport { ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { createEllipseEngine } from '../basic-shapes/ellipse';\n\nexport const SummingJunctionEngine: ShapeEngine = createEllipseEngine({\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n        const rx = rectangle.width / 2;\n        const ry = rectangle.height / 2;\n        const startPoint = [rectangle.x + rectangle.width, rectangle.y + rectangle.height / 2];\n        const centerPoint = [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height / 2];\n        const line1Points = getCrossingPointsBetweenEllipseAndSegment(\n            [rectangle.x, rectangle.y],\n            [rectangle.x + rectangle.width, rectangle.y + rectangle.height],\n            centerPoint[0],\n            centerPoint[1],\n            rx,\n            ry\n        );\n        const line2Points = getCrossingPointsBetweenEllipseAndSegment(\n            [rectangle.x + rectangle.width, rectangle.y],\n            [rectangle.x, rectangle.y + rectangle.height],\n            centerPoint[0],\n            centerPoint[1],\n            rx,\n            ry\n        );\n\n        const shape = rs.path(\n            `M${startPoint[0]} ${startPoint[1]}\n        A${rx},${ry} 0 1,1 ${startPoint[0]} ${startPoint[1] - 0.01}\n        M${line1Points[0][0]} ${line1Points[0][1]}\n        L${line1Points[1][0]} ${line1Points[1][1]}\n        M${line2Points[0][0]} ${line2Points[0][1]}\n        L${line2Points[1][0]} ${line2Points[1][1]}\n        `,\n            { ...options, fillStyle: 'solid' }\n        );\n\n        setStrokeLinecap(shape, 'round');\n        return shape;\n    }\n});\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    catmullRomFitting,\n    getNearestPointBetweenPointAndSegments,\n    setStrokeLinecap\n} from '@plait/core';\nimport { getUnitVectorByPointAndPoint } from '@plait/common';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { RectangleEngine } from '../basic-shapes/rectangle';\nimport { getStrokeWidthByElement } from '../../utils';\nimport { ShapeDefaultSpace } from '../../constants';\nimport { pointsOnBezierCurves } from 'points-on-curve';\n\nexport const DocumentEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n        const shape = rs.path(\n            `M${rectangle.x} ${rectangle.y + rectangle.height - rectangle.height / 9} V${rectangle.y} H${rectangle.x +\n                rectangle.width} V${rectangle.y + rectangle.height - rectangle.height / 9}\n            Q${rectangle.x + rectangle.width - rectangle.width / 4} ${rectangle.y +\n                rectangle.height -\n                (rectangle.height / 9) * 3}, ${rectangle.x + rectangle.width / 2} ${rectangle.y +\n                rectangle.height -\n                rectangle.height / 9} T${rectangle.x} ${rectangle.y + rectangle.height - rectangle.height / 9}           \n            `,\n            { ...options, fillStyle: 'solid' }\n        );\n        setStrokeLinecap(shape, 'round');\n        return shape;\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        const rangeRectangle = RectangleClient.getRectangleByPoints([point, point]);\n        return RectangleClient.isHit(rectangle, rangeRectangle);\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        let nearestPoint = getNearestPointBetweenPointAndSegments(point, RectangleEngine.getCornerPoints(rectangle));\n        let curvePoints = catmullRomFitting([\n            [rectangle.x, rectangle.y + rectangle.height - rectangle.height / 9],\n            [rectangle.x + rectangle.width / 4, rectangle.y + rectangle.height],\n            [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height - rectangle.height / 9],\n            [rectangle.x + (rectangle.width / 4) * 3, rectangle.y + rectangle.height - (rectangle.height / 9) * 2],\n            [rectangle.x + rectangle.width, rectangle.y + rectangle.height - rectangle.height / 9]\n        ]);\n        curvePoints = pointsOnBezierCurves(curvePoints) as Point[];\n        if (nearestPoint[1] > rectangle.y + rectangle.height - rectangle.height / 9) {\n            if (nearestPoint[0] === rectangle.x + rectangle.width / 2) {\n                nearestPoint[1] = rectangle.y + rectangle.height - rectangle.height / 9;\n                return nearestPoint;\n            }\n            nearestPoint = getNearestPointBetweenPointAndSegments(point, curvePoints, false);\n        }\n\n        return nearestPoint;\n    },\n\n    getConnectorPoints(rectangle: RectangleClient) {\n        return [\n            [rectangle.x + rectangle.width / 2, rectangle.y],\n            [rectangle.x + rectangle.width, rectangle.y + rectangle.height / 2],\n            [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height - rectangle.height / 9],\n            [rectangle.x, rectangle.y + rectangle.height / 2]\n        ];\n    },\n\n    getTangentVectorByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle) {\n        const connectionPoint = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        if (connectionPoint[0] > rectangle.x && connectionPoint[0] < rectangle.x + rectangle.width / 4) {\n            return getUnitVectorByPointAndPoint([rectangle.x + rectangle.width / 4, rectangle.y + rectangle.height], connectionPoint);\n        }\n\n        if (connectionPoint[0] > rectangle.x + rectangle.width / 4 && connectionPoint[0] < rectangle.x + (rectangle.width / 4) * 3) {\n            return getUnitVectorByPointAndPoint(\n                [rectangle.x + (rectangle.width / 4) * 3, rectangle.y + rectangle.height - rectangle.height / 9],\n                [rectangle.x + rectangle.width / 4, rectangle.y + rectangle.height]\n            );\n        }\n\n        if (connectionPoint[0] > rectangle.x + (rectangle.width / 4) * 3) {\n            return getUnitVectorByPointAndPoint(\n                [rectangle.x + rectangle.width, rectangle.y + rectangle.height - rectangle.height / 9],\n                connectionPoint\n            );\n        }\n        return getUnitVectorByPointAndPoint(connectionPoint, [rectangle.x + rectangle.width / 4, rectangle.y + rectangle.height]);\n    },\n\n    getTextRectangle: (element: PlaitGeometry) => {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const height = element.textHeight!;\n        const width = elementRectangle.width - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth * 2 - elementRectangle.width * 0.06 * 2;\n        return {\n            height,\n            width: width > 0 ? width : 0,\n            x: elementRectangle.x + ShapeDefaultSpace.rectangleAndText + strokeWidth + elementRectangle.width * 0.06,\n            y: elementRectangle.y + (elementRectangle.height - height) / 2\n        };\n    }\n};\n", "import {\n    Direction,\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    catmullRomFitting,\n    distanceBetweenPointAndPoint,\n    getNearestPointBetweenPointAndSegments,\n    setStrokeLinecap\n} from '@plait/core';\nimport { getDirectionByPointOfRectangle, getDirectionFactor, getUnitVectorByPointAndPoint } from '@plait/common';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { getStrokeWidthByElement } from '../../utils';\nimport { ShapeDefaultSpace } from '../../constants';\nimport { pointsOnBezierCurves } from 'points-on-curve';\nimport { getCrossingPointBetweenPointAndPolygon } from '../../utils/polygon';\n\nexport const getMultiDocumentPoints = (rectangle: RectangleClient): Point[] => {\n    const linePoints: Point[] = [\n        [rectangle.x, rectangle.y + 10],\n        [rectangle.x + 5, rectangle.y + 10],\n        [rectangle.x + 5, rectangle.y + 5],\n        [rectangle.x + 10, rectangle.y + 5],\n        [rectangle.x + 10, rectangle.y],\n        [rectangle.x + rectangle.width, rectangle.y],\n        [rectangle.x + rectangle.width, rectangle.y + rectangle.height - rectangle.height / 9 - 10 - 3],\n        [rectangle.x + rectangle.width - 5, rectangle.y + rectangle.height - rectangle.height / 9 - 10 - 3 - 4],\n        [rectangle.x + rectangle.width - 5, rectangle.y + rectangle.height - rectangle.height / 9 - 5 - 3],\n        [rectangle.x + rectangle.width - 10, rectangle.y + rectangle.height - rectangle.height / 9 - 5 - 3 - 4],\n        [rectangle.x + rectangle.width - 10, rectangle.y + rectangle.height - rectangle.height / 9]\n    ];\n\n    let curvePoints = catmullRomFitting([\n        [rectangle.x + rectangle.width - 10, rectangle.y + rectangle.height - rectangle.height / 9],\n        [rectangle.x + rectangle.width - 10 - (rectangle.width - 10) / 4, rectangle.y + rectangle.height - (rectangle.height / 9) * 2],\n        [rectangle.x + (rectangle.width - 10) / 2, rectangle.y + rectangle.height - rectangle.height / 9],\n        [rectangle.x + (rectangle.width - 10) / 4, rectangle.y + rectangle.height],\n        [rectangle.x, rectangle.y + rectangle.height - rectangle.height / 9]\n    ]);\n\n    curvePoints = pointsOnBezierCurves(curvePoints) as Point[];\n    return [...linePoints, ...curvePoints];\n};\n\nexport const MultiDocumentEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n        const shape = rs.path(\n            `M${rectangle.x} ${rectangle.y + rectangle.height - rectangle.height / 9} V${rectangle.y + 10} H${rectangle.x +\n                5} V${rectangle.y + 5} H${rectangle.x + 10} V${rectangle.y} H${rectangle.x + rectangle.width} V${rectangle.y +\n                rectangle.height -\n                rectangle.height / 9 -\n                10 -\n                3} L${rectangle.x + rectangle.width - 5} ${rectangle.y +\n                rectangle.height -\n                rectangle.height / 9 -\n                10 -\n                3 -\n                4} V${rectangle.y + rectangle.height - rectangle.height / 9 - 5 - 3}\n                 L${rectangle.x + rectangle.width - 10} ${rectangle.y +\n                rectangle.height -\n                rectangle.height / 9 -\n                5 -\n                3 -\n                4} V${rectangle.y + rectangle.height - rectangle.height / 9}\n                \n             Q${rectangle.x + rectangle.width - 10 - (rectangle.width - 10) / 4} ${rectangle.y +\n                rectangle.height -\n                (rectangle.height / 9) * 3}, ${rectangle.x + (rectangle.width - 10) / 2} ${rectangle.y +\n                rectangle.height -\n                rectangle.height / 9} T${rectangle.x} ${rectangle.y + rectangle.height - rectangle.height / 9}\n              \n                M${rectangle.x + 5} ${rectangle.y + 10} H${rectangle.x + rectangle.width - 10} V${rectangle.y +\n                rectangle.height -\n                rectangle.height / 9} \n                    \n                M${rectangle.x + 10} ${rectangle.y + 5} H${rectangle.x + rectangle.width - 5} V${rectangle.y +\n                rectangle.height -\n                rectangle.height / 9 -\n                10 -\n                3}\n            `,\n            { ...options, fillStyle: 'solid' }\n        );\n        setStrokeLinecap(shape, 'round');\n        return shape;\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        const rangeRectangle = RectangleClient.getRectangleByPoints([point, point]);\n        return RectangleClient.isHit(rectangle, rangeRectangle);\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        return getNearestPointBetweenPointAndSegments(point, getMultiDocumentPoints(rectangle), false);\n    },\n\n    getConnectorPoints(rectangle: RectangleClient) {\n        let curvePoints = catmullRomFitting([\n            [rectangle.x, rectangle.y + rectangle.height - rectangle.height / 9],\n            [rectangle.x + (rectangle.width - 10) / 4, rectangle.y + rectangle.height],\n            [rectangle.x + (rectangle.width - 10) / 2, rectangle.y + rectangle.height - rectangle.height / 9],\n            [rectangle.x + ((rectangle.width - 10) / 4) * 3, rectangle.y + rectangle.height - (rectangle.height / 9) * 2],\n            [rectangle.x + rectangle.width - 10, rectangle.y + rectangle.height - rectangle.height / 9]\n        ]);\n        curvePoints = pointsOnBezierCurves(curvePoints) as Point[];\n        const crossingPoint = getNearestPointBetweenPointAndSegments(\n            [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height],\n            curvePoints\n        );\n        return [\n            [rectangle.x + rectangle.width / 2, rectangle.y],\n            [rectangle.x + rectangle.width, rectangle.y + rectangle.height / 2],\n            [crossingPoint[0], crossingPoint[1]],\n            [rectangle.x, rectangle.y + rectangle.height / 2]\n        ];\n    },\n\n    getNearestCrossingPoint(rectangle: RectangleClient, point: Point) {\n        const crossingPoints = getCrossingPointBetweenPointAndPolygon(getMultiDocumentPoints(rectangle), point);\n        let nearestPoint = crossingPoints[0];\n        let nearestDistance = distanceBetweenPointAndPoint(point[0], point[1], nearestPoint[0], nearestPoint[1]);\n        crossingPoints\n            .filter((v, index) => index > 0)\n            .forEach(crossingPoint => {\n                let distance = distanceBetweenPointAndPoint(point[0], point[1], crossingPoint[0], crossingPoint[1]);\n                if (distance < nearestDistance) {\n                    nearestDistance = distance;\n                    nearestPoint = crossingPoint;\n                }\n            });\n\n        return nearestPoint;\n    },\n\n    getTangentVectorByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle) {\n        const connectionPoint = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        if (connectionPoint[0] > rectangle.x && connectionPoint[0] < rectangle.x + (rectangle.width - 10) / 4) {\n            return getUnitVectorByPointAndPoint(\n                [rectangle.x + (rectangle.width - 10) / 4, rectangle.y + rectangle.height],\n                connectionPoint\n            );\n        }\n        if (\n            connectionPoint[0] > rectangle.x + (rectangle.width - 10) / 4 &&\n            connectionPoint[0] < rectangle.x + ((rectangle.width - 10) / 4) * 3\n        ) {\n            return getUnitVectorByPointAndPoint(\n                [rectangle.x + ((rectangle.width - 10) / 4) * 3, rectangle.y + rectangle.height - rectangle.height / 9],\n                [rectangle.x + (rectangle.width - 10) / 4, rectangle.y + rectangle.height]\n            );\n        }\n\n        if (\n            connectionPoint[0] > rectangle.x + ((rectangle.width - 10) / 4) * 3 &&\n            connectionPoint[0] < rectangle.x + rectangle.width - 10\n        ) {\n            return getUnitVectorByPointAndPoint(\n                [rectangle.x + (rectangle.width - 10), rectangle.y + rectangle.height - rectangle.height / 9],\n                connectionPoint\n            );\n        }\n        const direction = getDirectionByPointOfRectangle(pointOfRectangle) || Direction.bottom;\n        const factor = getDirectionFactor(direction!);\n        return [factor.x, factor.y];\n    },\n\n    getTextRectangle: (element: PlaitGeometry) => {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const height = element.textHeight!;\n        const width = elementRectangle.width - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth * 2 - elementRectangle.width * 0.06 * 2;\n        return {\n            height,\n            width: width > 0 ? width - 10 : 0,\n            x: elementRectangle.x + ShapeDefaultSpace.rectangleAndText + strokeWidth + elementRectangle.width * 0.06,\n            y: elementRectangle.y + (elementRectangle.height - height) / 2\n        };\n    }\n};\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    getEllipseTangentSlope,\n    getNearestPointBetweenPointAndEllipse,\n    getNearestPointBetweenPointAndSegments,\n    getVectorFromPointAndSlope,\n    isPointInEllipse,\n    setStrokeLinecap\n} from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { ShapeDefaultSpace } from '../../constants';\nimport { Options } from 'roughjs/bin/core';\nimport { RectangleEngine } from '../basic-shapes/rectangle';\nimport { getStrokeWidthByElement } from '../../utils';\n\nexport const DatabaseEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n        const shape = rs.path(\n            `M${rectangle.x} ${rectangle.y + rectangle.height * 0.15}  \n            A${rectangle.width / 2} ${rectangle.height * 0.15}, 0, 0, 0,${rectangle.x + rectangle.width} ${rectangle.y +\n                rectangle.height * 0.15} \n            A${rectangle.width / 2} ${rectangle.height * 0.15}, 0, 0, 0,${rectangle.x} ${rectangle.y + rectangle.height * 0.15} \n            V${rectangle.y + rectangle.height - rectangle.height * 0.15}\n            A${rectangle.width / 2} ${rectangle.height * 0.15}, 0, 0, 0, ${rectangle.x + rectangle.width} ${rectangle.y +\n                rectangle.height -\n                rectangle.height * 0.15}\n            V${rectangle.y + rectangle.height * 0.15}`,\n            { ...options, fillStyle: 'solid' }\n        );\n        setStrokeLinecap(shape, 'round');\n        return shape;\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        const rangeRectangle = RectangleClient.getRectangleByPoints([point, point]);\n        const isInRectangle = RectangleClient.isHit(\n            {\n                ...rectangle,\n                y: rectangle.y + rectangle.height * 0.15,\n                height: rectangle.height - rectangle.height * 0.3\n            },\n            rangeRectangle\n        );\n\n        const isInTopEllipse = isPointInEllipse(\n            point,\n            [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height * 0.15],\n            rectangle.width / 2,\n            rectangle.height * 0.15\n        );\n\n        const isInBottomEllipse = isPointInEllipse(\n            point,\n            [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height - rectangle.height * 0.15],\n            rectangle.width / 2,\n            rectangle.height * 0.15\n        );\n        return isInRectangle || isInTopEllipse || isInBottomEllipse;\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        const nearestPoint = getNearestPointBetweenPointAndSegments(point, RectangleEngine.getCornerPoints(rectangle));\n        if (nearestPoint[1] < rectangle.y + rectangle.height * 0.15) {\n            const centerPoint = [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height * 0.15] as Point;\n            const nearestPoint = getNearestPointBetweenPointAndEllipse(point, centerPoint, rectangle.width / 2, rectangle.height * 0.15);\n            if (nearestPoint[1] > centerPoint[1]) {\n                nearestPoint[1] = centerPoint[1] * 2 - nearestPoint[1];\n            }\n            return nearestPoint;\n        }\n        if (nearestPoint[1] > rectangle.y + rectangle.height - rectangle.height * 0.15) {\n            const centerPoint = [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height - rectangle.height * 0.15] as Point;\n            const nearestPoint = getNearestPointBetweenPointAndEllipse(point, centerPoint, rectangle.width / 2, rectangle.height * 0.15);\n            if (nearestPoint[1] < centerPoint[1]) {\n                nearestPoint[1] = centerPoint[0] * 2 - nearestPoint[1];\n            }\n            return nearestPoint;\n        }\n        return nearestPoint;\n    },\n\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    },\n\n    getTangentVectorByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle) {\n        const connectionPoint = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        let centerPoint = [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height - rectangle.height * 0.15];\n        let a = rectangle.width / 2;\n        let b = rectangle.height * 0.15;\n        const isInTopEllipse = connectionPoint[1] < rectangle.y + rectangle.height * 0.15 && connectionPoint[0] > rectangle.x;\n        if (isInTopEllipse) {\n            centerPoint = [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height * 0.15];\n        }\n        const point = [connectionPoint[0] - centerPoint[0], -(connectionPoint[1] - centerPoint[1])];\n        const slope = getEllipseTangentSlope(point[0], point[1], a, b) as any;\n        const vector = getVectorFromPointAndSlope(point[0], point[1], slope);\n        return vector;\n    },\n\n    getTextRectangle: (element: PlaitGeometry) => {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const height = element.textHeight!;\n        const width = elementRectangle.width - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth * 2;\n        return {\n            height,\n            width: width > 0 ? width : 0,\n            x: elementRectangle.x + ShapeDefaultSpace.rectangleAndText + strokeWidth,\n            y: elementRectangle.y + elementRectangle.height * 0.3 + (elementRectangle.height - elementRectangle.height * 0.45 - height) / 2\n        };\n    }\n};\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    getEllipseTangentSlope,\n    getNearestPointBetweenPointAndEllipse,\n    getNearestPointBetweenPointAndSegments,\n    getVectorFromPointAndSlope,\n    isPointInEllipse,\n    setStrokeLinecap\n} from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { ShapeDefaultSpace } from '../../constants';\nimport { Options } from 'roughjs/bin/core';\nimport { RectangleEngine } from '../basic-shapes/rectangle';\nimport { getStrokeWidthByElement } from '../../utils';\n\nexport const HardDiskEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n        const shape = rs.path(\n            `M${rectangle.x + rectangle.width - rectangle.width * 0.15} ${rectangle.y}  \n            A${rectangle.width * 0.15} ${rectangle.height / 2}, 0, 0, 0,${rectangle.x +\n                rectangle.width -\n                rectangle.width * 0.15} ${rectangle.y + rectangle.height} \n            A${rectangle.width * 0.15} ${rectangle.height / 2}, 0, 0, 0,${rectangle.x + rectangle.width - rectangle.width * 0.15} ${\n                rectangle.y\n            } \n            H${rectangle.x + rectangle.width * 0.15}\n            A${rectangle.width * 0.15} ${rectangle.height / 2}, 0, 0, 0, ${rectangle.x + rectangle.width * 0.15} ${rectangle.y +\n                rectangle.height}\n            H${rectangle.x + rectangle.width - rectangle.width * 0.15}`,\n            { ...options, fillStyle: 'solid' }\n        );\n        setStrokeLinecap(shape, 'round');\n        return shape;\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        const rangeRectangle = RectangleClient.getRectangleByPoints([point, point]);\n        const isInRectangle = RectangleClient.isHit(\n            {\n                ...rectangle,\n                x: rectangle.x + rectangle.width * 0.15,\n                width: rectangle.width - rectangle.width * 0.3\n            },\n            rangeRectangle\n        );\n\n        const isInLeftEllipse = isPointInEllipse(\n            point,\n            [rectangle.x + rectangle.width * 0.15, rectangle.y + rectangle.height / 2],\n            rectangle.width * 0.15,\n            rectangle.height / 2\n        );\n\n        const isInRightEllipse = isPointInEllipse(\n            point,\n            [rectangle.x + rectangle.width - rectangle.width * 0.15, rectangle.y + rectangle.height / 2],\n            rectangle.width * 0.15,\n            rectangle.height / 2\n        );\n        return isInRectangle || isInLeftEllipse || isInRightEllipse;\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        const nearestPoint = getNearestPointBetweenPointAndSegments(point, RectangleEngine.getCornerPoints(rectangle));\n        if (nearestPoint[0] < rectangle.x + rectangle.width * 0.15) {\n            const centerPoint = [rectangle.x + rectangle.width * 0.15, rectangle.y + rectangle.height / 2] as Point;\n            const nearestPoint = getNearestPointBetweenPointAndEllipse(point, centerPoint, rectangle.width * 0.15, rectangle.height / 2);\n            if (nearestPoint[0] > centerPoint[0]) {\n                nearestPoint[0] = centerPoint[0] * 2 - nearestPoint[0];\n            }\n            return nearestPoint;\n        }\n        if (nearestPoint[0] > rectangle.x + rectangle.width - rectangle.width * 0.15) {\n            const centerPoint = [rectangle.x + rectangle.width - rectangle.width * 0.15, rectangle.y + rectangle.height / 2] as Point;\n            const nearestPoint = getNearestPointBetweenPointAndEllipse(point, centerPoint, rectangle.width * 0.15, rectangle.height / 2);\n            if (nearestPoint[0] < centerPoint[0]) {\n                nearestPoint[0] = centerPoint[0] * 2 - nearestPoint[0];\n            }\n            return nearestPoint;\n        }\n        return nearestPoint;\n    },\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    },\n\n    getTangentVectorByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle) {\n        const connectionPoint = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        let centerPoint = [rectangle.x + rectangle.width * 0.15, rectangle.y + rectangle.height / 2];\n        let a = rectangle.width * 0.15;\n        let b = rectangle.height / 2;\n        const isInRightEllipse =\n            connectionPoint[0] > rectangle.x + rectangle.width - rectangle.width * 0.15 && connectionPoint[1] > rectangle.y;\n        if (isInRightEllipse) {\n            centerPoint = [rectangle.x + rectangle.width - rectangle.width * 0.15, rectangle.y + rectangle.height / 2];\n        }\n        const point = [connectionPoint[0] - centerPoint[0], -(connectionPoint[1] - centerPoint[1])];\n        const slope = getEllipseTangentSlope(point[0], point[1], a, b) as any;\n        const vector = getVectorFromPointAndSlope(point[0], point[1], slope);\n        return vector;\n    },\n\n    getTextRectangle: (element: PlaitGeometry) => {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const height = element.textHeight!;\n        const width = elementRectangle.width - elementRectangle.width * 0.45 - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth * 2;\n        return {\n            height,\n            width: width > 0 ? width : 0,\n            x: elementRectangle.x + elementRectangle.width * 0.15 + ShapeDefaultSpace.rectangleAndText + strokeWidth,\n            y: elementRectangle.y + (elementRectangle.height - height) / 2\n        };\n    }\n};\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    getNearestPointBetweenPointAndSegments,\n    setStrokeLinecap\n} from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { ShapeDefaultSpace } from '../../constants';\nimport { Options } from 'roughjs/bin/core';\nimport { RectangleEngine } from '../basic-shapes/rectangle';\nimport { getPolygonEdgeByConnectionPoint } from '../../utils/polygon';\nimport { getStrokeWidthByElement } from '../../utils';\n\nexport const InternalStorageEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n        const shape = rs.path(\n            `M${rectangle.x} ${rectangle.y} h${rectangle.width} v${rectangle.height} h${-rectangle.width} v${-rectangle.height}\n            M${rectangle.x} ${rectangle.y + rectangle.height / 10} h${rectangle.width}\n            M${rectangle.x + rectangle.width / 10} ${rectangle.y} v${rectangle.height}\n            `,\n            { ...options, fillStyle: 'solid' }\n        );\n        setStrokeLinecap(shape, 'round');\n        return shape;\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        const rangeRectangle = RectangleClient.getRectangleByPoints([point, point]);\n        return RectangleClient.isHit(rectangle, rangeRectangle);\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        return getNearestPointBetweenPointAndSegments(point, RectangleEngine.getCornerPoints(rectangle));\n    },\n    getEdgeByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle): [Point, Point] | null {\n        const corners = RectangleEngine.getCornerPoints(rectangle);\n        const point = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        return getPolygonEdgeByConnectionPoint(corners, point);\n    },\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    },\n    getTextRectangle: (element: PlaitGeometry) => {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const height = element.textHeight!;\n        const width = elementRectangle.width - elementRectangle.width * 0.1 - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth * 2;\n        return {\n            height,\n            width: width > 0 ? width : 0,\n            x: elementRectangle.x + elementRectangle.width * 0.1 + ShapeDefaultSpace.rectangleAndText + strokeWidth,\n            y: elementRectangle.y + elementRectangle.height * 0.1 + (elementRectangle.height - elementRectangle.height * 0.1 - height) / 2\n        };\n    }\n};\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    distanceBetweenPointAndPoint,\n    getNearestPointBetweenPointAndSegments,\n    setStrokeLinecap\n} from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { ShapeDefaultSpace } from '../../constants';\nimport { Options } from 'roughjs/bin/core';\nimport { RectangleEngine } from '../basic-shapes/rectangle';\nimport { getPolygonEdgeByConnectionPoint } from '../../utils/polygon';\nimport { getStrokeWidthByElement } from '../../utils';\nimport { pointsOnBezierCurves } from 'points-on-curve';\n\ninterface NoteCurlyLeftPathData {\n    startPoint: Point;\n    upperCurve: {\n        controlPoint1: Point;\n        controlPoint2: Point;\n        endPoint: Point;\n    };\n    lowerCurve: {\n        controlPoint1: Point;\n        controlPoint2: Point;\n        endPoint: Point;\n    };\n}\n\nfunction generateNoteCurlyLeftPath(rectangle: RectangleClient): NoteCurlyLeftPathData {\n    const curlyWidth = rectangle.width * 0.09;\n    const rightX = rectangle.x + rectangle.width;\n    const centerY = rectangle.y + rectangle.height / 2;\n\n    return {\n        startPoint: [rightX, rectangle.y],\n        upperCurve: {\n            controlPoint1: [rightX - curlyWidth, rectangle.y],\n            controlPoint2: [rightX, centerY],\n            endPoint: [rightX - curlyWidth, centerY]\n        },\n        lowerCurve: {\n            controlPoint1: [rightX, centerY],\n            controlPoint2: [rightX - curlyWidth, rectangle.y + rectangle.height],\n            endPoint: [rightX, rectangle.y + rectangle.height]\n        }\n    };\n}\n\nexport const NoteCurlyLeftEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n        const { startPoint, upperCurve, lowerCurve } = generateNoteCurlyLeftPath(rectangle);\n\n        const pathData = [\n            `M${startPoint[0]} ${startPoint[1]}`,\n            `C${upperCurve.controlPoint1[0]} ${upperCurve.controlPoint1[1]},\n            ${upperCurve.controlPoint2[0]} ${upperCurve.controlPoint2[1]},\n            ${upperCurve.endPoint[0]} ${upperCurve.endPoint[1]}`,\n            `C${lowerCurve.controlPoint1[0]} ${lowerCurve.controlPoint1[1]},\n            ${lowerCurve.controlPoint2[0]} ${lowerCurve.controlPoint2[1]},\n            ${lowerCurve.endPoint[0]} ${lowerCurve.endPoint[1]}`\n        ].join(' ');\n\n        const shape = rs.path(pathData, { ...options, fillStyle: 'solid', fill: 'transparent' });\n        setStrokeLinecap(shape, 'round');\n        return shape;\n    },\n\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        const { startPoint, upperCurve, lowerCurve } = generateNoteCurlyLeftPath(rectangle);\n\n        const upperBezierPoints = pointsOnBezierCurves(\n            [startPoint, upperCurve.controlPoint1, upperCurve.controlPoint2, upperCurve.endPoint],\n            0.001\n        );\n\n        const lowerBezierPoints = pointsOnBezierCurves(\n            [upperCurve.endPoint, lowerCurve.controlPoint1, lowerCurve.controlPoint2, lowerCurve.endPoint],\n            0.001\n        );\n\n        const allPoints = [...upperBezierPoints, ...lowerBezierPoints];\n\n        let minDistance = Infinity;\n        let nearestPoint = point;\n\n        for (const curvePoint of allPoints) {\n            const distance = distanceBetweenPointAndPoint(point[0], point[1], curvePoint[0], curvePoint[1]);\n            if (distance < minDistance) {\n                minDistance = distance;\n                nearestPoint = [...curvePoint];\n            }\n        }\n\n        return nearestPoint;\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        const rangeRectangle = RectangleClient.getRectangleByPoints([point, point]);\n        return RectangleClient.isHit(rectangle, rangeRectangle);\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n    getEdgeByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle): [Point, Point] | null {\n        const corners = RectangleEngine.getCornerPoints(rectangle);\n        const point = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        return getPolygonEdgeByConnectionPoint(corners, point);\n    },\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    },\n    getTextRectangle: (element: PlaitGeometry) => {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const height = element.textHeight!;\n        const width = elementRectangle.width - elementRectangle.width * 0.09 - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth * 2;\n        return {\n            height,\n            width: width > 0 ? width : 0,\n            x: elementRectangle.x + ShapeDefaultSpace.rectangleAndText + strokeWidth,\n            y: elementRectangle.y + (elementRectangle.height - height) / 2\n        };\n    }\n};\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    distanceBetweenPointAndPoint,\n    getNearestPointBetweenPointAndSegments,\n    setStrokeLinecap\n} from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { ShapeDefaultSpace } from '../../constants';\nimport { Options } from 'roughjs/bin/core';\nimport { RectangleEngine } from '../basic-shapes/rectangle';\nimport { getPolygonEdgeByConnectionPoint } from '../../utils/polygon';\nimport { getStrokeWidthByElement } from '../../utils';\nimport { pointsOnBezierCurves } from 'points-on-curve';\n\ninterface NoteCurlyRightPathData {\n    startPoint: Point;\n    upperCurve: {\n        controlPoint1: Point;\n        controlPoint2: Point;\n        endPoint: Point;\n    };\n    lowerCurve: {\n        controlPoint1: Point;\n        controlPoint2: Point;\n        endPoint: Point;\n    };\n}\n\nfunction generateNoteCurlyRightPath(rectangle: RectangleClient): NoteCurlyRightPathData {\n    const curlyWidth = rectangle.width * 0.09;\n    const centerY = rectangle.y + rectangle.height / 2;\n\n    return {\n        startPoint: [rectangle.x, rectangle.y],\n        upperCurve: {\n            controlPoint1: [rectangle.x + curlyWidth, rectangle.y],\n            controlPoint2: [rectangle.x, centerY],\n            endPoint: [rectangle.x + curlyWidth, centerY]\n        },\n        lowerCurve: {\n            controlPoint1: [rectangle.x, centerY],\n            controlPoint2: [rectangle.x + curlyWidth, rectangle.y + rectangle.height],\n            endPoint: [rectangle.x, rectangle.y + rectangle.height]\n        }\n    };\n}\n\nexport const NoteCurlyRightEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n        const { startPoint, upperCurve, lowerCurve } = generateNoteCurlyRightPath(rectangle);\n\n        const pathData = [\n            `M${startPoint[0]} ${startPoint[1]}`,\n            `C${upperCurve.controlPoint1[0]} ${upperCurve.controlPoint1[1]},\n            ${upperCurve.controlPoint2[0]} ${upperCurve.controlPoint2[1]},\n            ${upperCurve.endPoint[0]} ${upperCurve.endPoint[1]}`,\n            `C${lowerCurve.controlPoint1[0]} ${lowerCurve.controlPoint1[1]},\n            ${lowerCurve.controlPoint2[0]} ${lowerCurve.controlPoint2[1]},\n            ${lowerCurve.endPoint[0]} ${lowerCurve.endPoint[1]}`\n        ].join(' ');\n\n        const shape = rs.path(pathData, { ...options, fillStyle: 'solid', fill: 'transparent' });\n        setStrokeLinecap(shape, 'round');\n        return shape;\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        const rangeRectangle = RectangleClient.getRectangleByPoints([point, point]);\n        return RectangleClient.isHit(rectangle, rangeRectangle);\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        const { startPoint, upperCurve, lowerCurve } = generateNoteCurlyRightPath(rectangle);\n\n        // 生成上部贝塞尔曲线的点\n        const upperBezierPoints = pointsOnBezierCurves(\n            [startPoint, upperCurve.controlPoint1, upperCurve.controlPoint2, upperCurve.endPoint],\n            0.001\n        );\n\n        // 生成下部贝塞尔曲线的点\n        const lowerBezierPoints = pointsOnBezierCurves(\n            [upperCurve.endPoint, lowerCurve.controlPoint1, lowerCurve.controlPoint2, lowerCurve.endPoint],\n            0.001\n        );\n\n        // 合并所有点\n        const allPoints = [...upperBezierPoints, ...lowerBezierPoints];\n\n        // 找到最近的点\n        let minDistance = Infinity;\n        let nearestPoint = [...point] as Point;\n\n        for (const curvePoint of allPoints) {\n            const distance = distanceBetweenPointAndPoint(point[0], point[1], curvePoint[0], curvePoint[1]);\n            if (distance < minDistance) {\n                minDistance = distance;\n                nearestPoint = [...curvePoint];\n            }\n        }\n\n        return nearestPoint;\n    },\n    getEdgeByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle): [Point, Point] | null {\n        const corners = RectangleEngine.getCornerPoints(rectangle);\n        const point = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        return getPolygonEdgeByConnectionPoint(corners, point);\n    },\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    },\n    getTextRectangle: (element: PlaitGeometry) => {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const height = element.textHeight!;\n        const width = elementRectangle.width - elementRectangle.width * 0.09 - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth * 2;\n        return {\n            height,\n            width: width > 0 ? width : 0,\n            x: elementRectangle.x + elementRectangle.width * 0.09 + ShapeDefaultSpace.rectangleAndText + strokeWidth,\n            y: elementRectangle.y + (elementRectangle.height - height) / 2\n        };\n    }\n};\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    getNearestPointBetweenPointAndSegments,\n    setStrokeLinecap\n} from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { RectangleEngine } from '../basic-shapes/rectangle';\nimport { getPolygonEdgeByConnectionPoint } from '../../utils/polygon';\nimport { getStrokeWidthByElement } from '../../utils';\nimport { ShapeDefaultSpace } from '../../constants';\n\nexport const NoteSquareEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n        const shape = rs.path(\n            `M${rectangle.x + rectangle.width * 0.075} ${rectangle.y + rectangle.height} H${rectangle.x} V${rectangle.y} H${rectangle.x +\n                rectangle.width * 0.075}\n           `,\n            { ...options, fillStyle: 'solid', fill: 'transparent' }\n        );\n        setStrokeLinecap(shape, 'round');\n        return shape;\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        const rangeRectangle = RectangleClient.getRectangleByPoints([point, point]);\n        return RectangleClient.isHit(rectangle, rangeRectangle);\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        return getNearestPointBetweenPointAndSegments(point, RectangleEngine.getCornerPoints(rectangle));\n    },\n    getEdgeByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle): [Point, Point] | null {\n        const corners = RectangleEngine.getCornerPoints(rectangle);\n        const point = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        return getPolygonEdgeByConnectionPoint(corners, point);\n    },\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    },\n    getTextRectangle: (element: PlaitGeometry) => {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const height = element.textHeight!;\n        const width = elementRectangle.width - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth * 2;\n        return {\n            height,\n            width: width > 0 ? width : 0,\n            x: elementRectangle.x + ShapeDefaultSpace.rectangleAndText + strokeWidth,\n            y: elementRectangle.y + (elementRectangle.height - height) / 2\n        };\n    }\n};\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    getEllipseTangentSlope,\n    getNearestPointBetweenPointAndEllipse,\n    getNearestPointBetweenPointAndSegments,\n    getVectorFromPointAndSlope,\n    isPointInEllipse,\n    isPointInPolygon,\n    setStrokeLinecap\n} from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { getStrokeWidthByElement } from '../../utils';\n\nexport const getDisplayPoints = (rectangle: RectangleClient): Point[] => {\n    return [\n        [rectangle.x, rectangle.y + rectangle.height / 2],\n        [rectangle.x + rectangle.width * 0.15, rectangle.y],\n        [rectangle.x + rectangle.width, rectangle.y],\n        [rectangle.x + rectangle.width, rectangle.y + rectangle.height],\n        [rectangle.x + rectangle.width * 0.15, rectangle.y + rectangle.height]\n    ];\n};\n\nexport const DisplayEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n        const shape = rs.path(\n            `M${rectangle.x + rectangle.width * 0.15} ${rectangle.y} \n            H${rectangle.x + rectangle.width - rectangle.width * 0.1} \n            A ${rectangle.width * 0.1} ${rectangle.height / 2}, 0, 0, 1,${rectangle.x +\n                rectangle.width -\n                rectangle.width * 0.1} ${rectangle.y + rectangle.height}\n            H${rectangle.x + rectangle.width * 0.15}\n            L${rectangle.x} ${rectangle.y + rectangle.height / 2}\n            Z\n            `,\n            { ...options, fillStyle: 'solid' }\n        );\n        setStrokeLinecap(shape, 'round');\n\n        return shape;\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        const polygonPoints: Point[] = [\n            [rectangle.x, rectangle.y + rectangle.height / 2],\n            [rectangle.x + rectangle.width * 0.15, rectangle.y],\n            [rectangle.x + rectangle.width - rectangle.width * 0.1, rectangle.y],\n            [rectangle.x + rectangle.width - rectangle.width * 0.1, rectangle.y + rectangle.height],\n            [rectangle.x + rectangle.width * 0.15, rectangle.y + rectangle.height]\n        ];\n        const isInPolygon = isPointInPolygon(point, polygonPoints);\n        const isInEllipse = isPointInEllipse(\n            point,\n            [rectangle.x + rectangle.width - rectangle.width * 0.1, rectangle.y + rectangle.height / 2],\n            rectangle.width * 0.1,\n            rectangle.height / 2\n        );\n        return isInPolygon || isInEllipse;\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        const nearestPoint = getNearestPointBetweenPointAndSegments(point, getDisplayPoints(rectangle));\n        if (nearestPoint[0] > rectangle.x + rectangle.width - rectangle.width * 0.1) {\n            return getNearestPointBetweenPointAndEllipse(\n                point,\n                [rectangle.x + rectangle.width - rectangle.width * 0.1, rectangle.y + rectangle.height / 2],\n                rectangle.width * 0.1,\n                rectangle.height / 2\n            );\n        }\n        return nearestPoint;\n    },\n    getTangentVectorByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle) {\n        const connectionPoint = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        const centerPoint: Point = [rectangle.x + rectangle.width - rectangle.width * 0.1, rectangle.y + rectangle.height / 2];\n        const point = [connectionPoint[0] - centerPoint[0], -(connectionPoint[1] - centerPoint[1])];\n        const a = rectangle.width * 0.1;\n        const b = rectangle.height / 2;\n        const slope = getEllipseTangentSlope(point[0], point[1], a, b) as any;\n        return getVectorFromPointAndSlope(point[0], point[1], slope);\n    },\n\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    },\n    getTextRectangle: (element: PlaitGeometry) => {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const height = element.textHeight!;\n        const width = elementRectangle.width - strokeWidth * 2 - elementRectangle.width * 0.25;\n        return {\n            width: width > 0 ? width : 0,\n            height: height,\n            x: elementRectangle.x + strokeWidth + elementRectangle.width * 0.15,\n            y: elementRectangle.y + (elementRectangle.height - height) / 2\n        };\n    }\n};\n", "import { PlaitBoard, RectangleClient, Point, createG, drawLine, setStrokeLinecap, drawRectangle, ACTIVE_STROKE_WIDTH } from '@plait/core';\nimport { Options } from 'roughjs/bin/core';\nimport { getCellsWithPoints, getCellWithPoints } from '../../utils/table';\nimport { ShapeEngine } from '../../interfaces';\nimport { DrawTextInfo } from '../../generators/text.generator';\nimport { PlaitTable, PlaitTableCellWithPoints, PlaitTableDrawOptions, PlaitTableElement } from '../../interfaces/table';\nimport { getStrokeWidthByElement } from '../../utils';\nimport { ShapeDefaultSpace } from '../../constants';\nimport { getNearestPointBetweenPointAndRoundRectangle, getRoundRectangleRadius } from '../basic-shapes/round-rectangle';\n\nexport const TableEngine: ShapeEngine<PlaitTable, PlaitTableDrawOptions, DrawTextInfo> = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, roughOptions: Options, options?: PlaitTableDrawOptions) {\n        const g = createG();\n        try {\n            const pointCells = getCellsWithPoints(board, { ...options?.element } as PlaitTable);\n            if (pointCells) {\n                const rs = PlaitBoard.getRoughSVG(board);\n                const { x, y, width, height } = rectangle;\n                const tableTopBorder = drawLine(rs, [x, y], [x + width, y], roughOptions);\n                const tableLeftBorder = drawLine(rs, [x, y], [x, y + height], roughOptions);\n                g.append(tableTopBorder, tableLeftBorder);\n                pointCells.forEach(cell => {\n                    const rectangle = RectangleClient.getRectangleByPoints(cell.points!);\n                    const { x, y, width, height } = rectangle;\n                    const cellRectangle = drawRectangle(\n                        board,\n                        {\n                            x: x + ACTIVE_STROKE_WIDTH,\n                            y: y + ACTIVE_STROKE_WIDTH,\n                            width: width - ACTIVE_STROKE_WIDTH * 2,\n                            height: height - ACTIVE_STROKE_WIDTH * 2\n                        },\n                        { fill: cell.fill, fillStyle: 'solid', strokeWidth: 0 }\n                    );\n                    const cellRightBorder = drawLine(rs, [x + width, y], [x + width, y + height], roughOptions);\n                    const cellBottomBorder = drawLine(rs, [x, y + height], [x + width, y + height], roughOptions);\n                    g.append(cellRectangle, cellRightBorder, cellBottomBorder);\n                });\n                setStrokeLinecap(g, 'round');\n            }\n        } catch (error) {\n            console.error(error);\n        }\n        return g;\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        const rangeRectangle = RectangleClient.getRectangleByPoints([point, point]);\n        return RectangleClient.isHit(rectangle, rangeRectangle);\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        return getNearestPointBetweenPointAndRoundRectangle(point, rectangle, getRoundRectangleRadius(rectangle));\n    },\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    },\n    getTextRectangle(element: PlaitTable, options?: DrawTextInfo) {\n        try {\n            if (options && options.id) {\n                const cell = getCellWithPoints(options?.board!, element, options!.id);\n                if (cell) {\n                    if (PlaitTableElement.isVerticalText(cell)) {\n                        return getVerticalTextRectangle(cell);\n                    } else {\n                        return getHorizontalTextRectangle(cell);\n                    }\n                }\n            }\n        } catch (error) {\n            console.error(error);\n        }\n        return {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        };\n    }\n};\n\nexport function getVerticalTextRectangle(cell: PlaitTableCellWithPoints) {\n    const cellRectangle = RectangleClient.getRectangleByPoints(cell.points);\n    const strokeWidth = getStrokeWidthByElement(cell);\n    const height = cell.textHeight || 0;\n    const width = cellRectangle.height - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth * 2;\n    return {\n        width: width > 0 ? width : 0,\n        height,\n        x: cellRectangle.x - width / 2 + cellRectangle.width / 2,\n        y: cellRectangle.y + (cellRectangle.height - height) / 2\n    };\n}\n\nexport function getHorizontalTextRectangle(cell: PlaitTableCellWithPoints) {\n    const cellRectangle = RectangleClient.getRectangleByPoints(cell.points);\n    const strokeWidth = getStrokeWidthByElement(cell);\n    const height = cell.textHeight || 0;\n    const width = cellRectangle.width - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth * 2;\n    return {\n        height,\n        width: width > 0 ? width : 0,\n        x: cellRectangle.x + ShapeDefaultSpace.rectangleAndText + strokeWidth,\n        y: cellRectangle.y + (cellRectangle.height - height) / 2\n    };\n}\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    SVGArcCommand,\n    W,\n    distanceBetweenPointAndPoint,\n    getEllipseTangentSlope,\n    getNearestPointBetweenPointAndDiscreteSegments,\n    getNearestPointBetweenPointAndEllipse,\n    getNearestPointBetweenPointAndSegment,\n    getNearestPointBetweenPointAndSegments,\n    getVectorFromPointAndSlope,\n    setStrokeLinecap\n} from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { getPolygonEdgeByConnectionPoint } from '../../utils/polygon';\nimport { RectangleEngine } from '../basic-shapes/rectangle';\nimport { getUnitVectorByPointAndPoint, rotateVector } from '@plait/common';\n\ninterface ActorPathData {\n    headArcCommand: SVGArcCommand;\n    bodyLine: [Point, Point];\n    armsLine: [Point, Point];\n    leftLegLine: [Point, Point];\n    rightLegLine: [Point, Point];\n}\n\nfunction generateActorPath(rectangle: RectangleClient): ActorPathData {\n    const centerX = rectangle.x + rectangle.width / 2;\n    const headRadius = { width: rectangle.width / 3 / 2, height: rectangle.height / 4 / 2 };\n    const centerY = rectangle.y + rectangle.height / 4 / 2;\n\n    return {\n        headArcCommand: {\n            rx: headRadius.width,\n            ry: headRadius.height,\n            xAxisRotation: 0,\n            largeArcFlag: 0,\n            sweepFlag: 1,\n            endX: centerX,\n            endY: rectangle.y\n        },\n        bodyLine: [\n            [centerX, rectangle.y + rectangle.height / 4],\n            [centerX, rectangle.y + (rectangle.height / 4) * 3]\n        ],\n        armsLine: [\n            [rectangle.x, rectangle.y + rectangle.height / 2],\n            [rectangle.x + rectangle.width, rectangle.y + rectangle.height / 2]\n        ],\n        leftLegLine: [\n            [centerX, rectangle.y + (rectangle.height / 4) * 3],\n            [rectangle.x + rectangle.width / 12, rectangle.y + rectangle.height]\n        ],\n        rightLegLine: [\n            [centerX, rectangle.y + (rectangle.height / 4) * 3],\n            [rectangle.x + (rectangle.width / 12) * 11, rectangle.y + rectangle.height]\n        ]\n    };\n}\n\nexport const ActorEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n        const { headArcCommand, bodyLine, armsLine, leftLegLine, rightLegLine } = generateActorPath(rectangle);\n\n        const pathData = [\n            // 头部（从中间开始画）\n            `M${bodyLine[0][0]} ${bodyLine[0][1]}`,\n            `A${headArcCommand.rx} ${headArcCommand.ry} ${headArcCommand.xAxisRotation} ${headArcCommand.largeArcFlag} ${headArcCommand.sweepFlag} ${headArcCommand.endX} ${headArcCommand.endY}`,\n            `A${headArcCommand.rx} ${headArcCommand.ry} ${headArcCommand.xAxisRotation} ${headArcCommand.largeArcFlag} ${headArcCommand.sweepFlag} ${bodyLine[0][0]} ${bodyLine[0][1]}`,\n            // 身体\n            `V${bodyLine[1][1]}`,\n            // 手臂\n            `M${armsLine[0][0]} ${armsLine[0][1]} H${armsLine[1][0]}`,\n            // 腿\n            `M${leftLegLine[0][0]} ${leftLegLine[0][1]} L${leftLegLine[1][0]} ${leftLegLine[1][1]}`,\n            `M${rightLegLine[0][0]} ${rightLegLine[0][1]} L${rightLegLine[1][0]} ${rightLegLine[1][1]}`\n        ].join(' ');\n\n        const shape = rs.path(pathData, { ...options, fillStyle: 'solid' });\n        setStrokeLinecap(shape, 'round');\n        return shape;\n    },\n\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        const { headArcCommand, bodyLine, armsLine, leftLegLine, rightLegLine } = generateActorPath(rectangle);\n\n        // 检查头部椭圆\n        const headCenter: Point = [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height / 4 / 2];\n        const nearestPointForHead = getNearestPointBetweenPointAndEllipse(point, headCenter, headArcCommand.rx, headArcCommand.ry);\n        const distanceForHead = distanceBetweenPointAndPoint(...point, ...nearestPointForHead);\n\n        // 检查所有线段\n        const allSegments = [bodyLine, armsLine, leftLegLine, rightLegLine];\n        const nearestPointForLines = getNearestPointBetweenPointAndDiscreteSegments(point, allSegments);\n        const distanceForLines = distanceBetweenPointAndPoint(...point, ...nearestPointForLines);\n\n        return distanceForHead < distanceForLines ? nearestPointForHead : nearestPointForLines;\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        const rangeRectangle = RectangleClient.getRectangleByPoints([point, point]);\n        return RectangleClient.isHit(rectangle, rangeRectangle);\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    },\n    getTangentVectorByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle) {\n        const connectionPoint = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        if (connectionPoint[1] >= rectangle.y && connectionPoint[1] <= rectangle.y + rectangle.height / 4) {\n            const centerPoint: Point = [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height / 4 / 2];\n            const point = [connectionPoint[0] - centerPoint[0], -(connectionPoint[1] - centerPoint[1])];\n            const a = rectangle.width / 2;\n            const b = rectangle.height / 2;\n            const slope = getEllipseTangentSlope(point[0], point[1], a, b) as any;\n            const vector = getVectorFromPointAndSlope(point[0], point[1], slope);\n            return vector;\n        }\n\n        if (connectionPoint[1] >= rectangle.y + rectangle.height / 4 && connectionPoint[1] < rectangle.y + (rectangle.height / 4) * 3) {\n            if (connectionPoint[0] < rectangle.x + rectangle.width / 2) {\n                return rotateVector(\n                    getUnitVectorByPointAndPoint([rectangle.x, rectangle.y + rectangle.height / 2], connectionPoint),\n                    -(Math.PI / 2)\n                );\n            } else {\n                return rotateVector(\n                    getUnitVectorByPointAndPoint([rectangle.x + rectangle.width, rectangle.y + rectangle.height / 2], connectionPoint),\n                    -(Math.PI / 2)\n                );\n            }\n        }\n\n        if (connectionPoint[1] >= rectangle.y + (rectangle.height / 4) * 3) {\n            if (connectionPoint[0] < rectangle.x + rectangle.width / 2) {\n                return getUnitVectorByPointAndPoint(connectionPoint, [rectangle.x + rectangle.width / 12, rectangle.y + rectangle.height]);\n            } else {\n                return getUnitVectorByPointAndPoint(\n                    [rectangle.x + (rectangle.width / 12) * 11, rectangle.y + rectangle.height],\n                    connectionPoint\n                );\n            }\n        }\n\n        return getUnitVectorByPointAndPoint(connectionPoint, [rectangle.x + rectangle.width / 4, rectangle.y + rectangle.height]);\n    },\n    getTextRectangle: (element: PlaitGeometry) => {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const height = element.textHeight!;\n        const width = elementRectangle.width + 40;\n        return {\n            height,\n            width: width > 0 ? width : 0,\n            x: elementRectangle.x - 20,\n            y: elementRectangle.y + elementRectangle.height + 4\n        };\n    }\n};\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    getNearestPointBetweenPointAndSegments,\n    setStrokeLinecap\n} from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { getPolygonEdgeByConnectionPoint } from '../../utils/polygon';\nimport { RectangleEngine } from '../basic-shapes/rectangle';\nimport { getStrokeWidthByElement } from '../../utils';\nimport { ShapeDefaultSpace } from '../../constants';\n\nexport const ContainerEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n        const shape = rs.path(\n            `M${rectangle.x} ${rectangle.y} H${rectangle.x + rectangle.width} V${rectangle.y + rectangle.height} H${\n                rectangle.x\n            } Z M${rectangle.x + 40} ${rectangle.y} L${rectangle.x + 40} ${rectangle.y + rectangle.height} `,\n            { ...options, fillStyle: 'solid' }\n        );\n        setStrokeLinecap(shape, 'round');\n\n        return shape;\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        const rangeRectangle = RectangleClient.getRectangleByPoints([point, point]);\n        return RectangleClient.isHit(rectangle, rangeRectangle);\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        return getNearestPointBetweenPointAndSegments(point, RectangleEngine.getCornerPoints(rectangle));\n    },\n    getEdgeByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle): [Point, Point] | null {\n        const corners = RectangleEngine.getCornerPoints(rectangle);\n        const point = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        return getPolygonEdgeByConnectionPoint(corners, point);\n    },\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    },\n    getTextRectangle(element: PlaitGeometry) {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const height = element.textHeight!;\n        const width = 40 - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth * 2;\n        return {\n            height,\n            width: width > 0 ? width : 0,\n            x: elementRectangle.x + ShapeDefaultSpace.rectangleAndText + strokeWidth,\n            y: elementRectangle.y + (elementRectangle.height - height) / 2\n        };\n    }\n};\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    getNearestPointBetweenPointAndDiscreteSegments,\n    getNearestPointBetweenPointAndSegments,\n    setStrokeLinecap\n} from '@plait/core';\nimport { getUnitVectorByPointAndPoint } from '@plait/common';\nimport { DrawOptions, GeometryCommonTextKeys, PlaitMultipleTextGeometry, ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { RectangleEngine } from '../basic-shapes/rectangle';\nimport { getStrokeWidthByElement } from '../../utils';\nimport { ShapeDefaultSpace } from '../../constants';\nimport { DrawTextInfo } from '../../generators/text.generator';\n\ninterface PackagePathData {\n    headerHeight: number;\n    points: {\n        leftTop: Point;\n        topStart: Point;\n        topEnd: Point;\n        cornerPoint: Point;\n        rightTop: Point;\n        rightBottom: Point;\n        leftBottom: Point;\n        leftMiddle: Point;\n        middlePoint: Point;\n    };\n}\n\nfunction generatePackagePath(rectangle: RectangleClient): PackagePathData {\n    const headerHeight = 25;\n    const topWidth = rectangle.width * 0.7;\n    const cornerX = rectangle.x + rectangle.width * 0.8;\n    \n    return {\n        headerHeight,\n        points: {\n            leftTop: [rectangle.x, rectangle.y + headerHeight],\n            topStart: [rectangle.x, rectangle.y],\n            topEnd: [rectangle.x + topWidth, rectangle.y],\n            cornerPoint: [cornerX, rectangle.y + headerHeight],\n            rightTop: [rectangle.x + rectangle.width, rectangle.y + headerHeight],\n            rightBottom: [rectangle.x + rectangle.width, rectangle.y + rectangle.height],\n            leftBottom: [rectangle.x, rectangle.y + rectangle.height],\n            leftMiddle: [rectangle.x, rectangle.y + headerHeight],\n            middlePoint: [cornerX, rectangle.y + headerHeight]\n        }\n    };\n}\n\nexport const PackageEngine: ShapeEngine<PlaitMultipleTextGeometry, DrawOptions, DrawTextInfo> = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n        const { points } = generatePackagePath(rectangle);\n        \n        const pathData = [\n            `M${points.leftTop[0]} ${points.leftTop[1]}`,\n            `V${points.topStart[1]}`,\n            `H${points.topEnd[0]}`,\n            `L${points.cornerPoint[0]} ${points.cornerPoint[1]}`,\n            `H${points.rightTop[0]}`,\n            `V${points.rightBottom[1]}`,\n            `H${points.leftBottom[0]}`,\n            `V${points.leftMiddle[1]}`,\n            `H${points.middlePoint[0]}`\n        ].join(' ');\n\n        const shape = rs.path(pathData, { ...options, fillStyle: 'solid' });\n        setStrokeLinecap(shape, 'round');\n        return shape;\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        const rangeRectangle = RectangleClient.getRectangleByPoints([point, point]);\n        return RectangleClient.isHit(rectangle, rangeRectangle);\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        const { points } = generatePackagePath(rectangle);\n        \n        const segments: [Point, Point][] = [\n            // 左边竖线\n            [points.topStart, points.leftTop],\n            [points.leftTop, points.leftBottom],\n            // 底边\n            [points.leftBottom, points.rightBottom],\n            // 右边竖线\n            [points.rightBottom, points.rightTop],\n            // 顶部折线\n            [points.topStart, points.topEnd],\n            [points.topEnd, points.cornerPoint],\n            [points.cornerPoint, points.rightTop],\n            // 中间横线\n            [points.leftMiddle, points.middlePoint]\n        ];\n\n        return getNearestPointBetweenPointAndDiscreteSegments(point, segments);\n    },\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    },\n    getTangentVectorByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle) {\n        const connectionPoint = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        if (connectionPoint[0] > rectangle.x + rectangle.width * 0.7 && connectionPoint[1] < rectangle.y + 25) {\n            return getUnitVectorByPointAndPoint([rectangle.x + rectangle.width * 0.7, rectangle.y], connectionPoint);\n        }\n        return getUnitVectorByPointAndPoint([rectangle.x + rectangle.width * 0.8, rectangle.y + 25], connectionPoint);\n    },\n    getTextRectangle(element: PlaitMultipleTextGeometry, options?: DrawTextInfo) {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const textHeight = element.texts?.find(item => item.id === options?.id)?.textHeight!;\n        if (options?.id === GeometryCommonTextKeys.name) {\n            const width = elementRectangle.width * 0.7 - ShapeDefaultSpace.rectangleAndText - strokeWidth;\n            return {\n                height: textHeight,\n                width: width > 0 ? width : 0,\n                x: elementRectangle.x + ShapeDefaultSpace.rectangleAndText + strokeWidth,\n                y: elementRectangle.y + (25 - textHeight) / 2\n            };\n        }\n        if (options?.id === GeometryCommonTextKeys.content) {\n            const width = elementRectangle.width - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth * 2;\n            return {\n                height: textHeight,\n                width: width > 0 ? width : 0,\n                x: elementRectangle.x + ShapeDefaultSpace.rectangleAndText + strokeWidth,\n                y: elementRectangle.y + 25 + (elementRectangle.height - 25 - textHeight) / 2\n            };\n        }\n        return elementRectangle;\n    }\n};\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    getNearestPointBetweenPointAndSegments,\n    setStrokeLinecap\n} from '@plait/core';\nimport { DrawOptions, GeometryCommonTextKeys, PlaitMultipleTextGeometry, ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { getPolygonEdgeByConnectionPoint } from '../../utils/polygon';\nimport { RectangleEngine } from '../basic-shapes/rectangle';\nimport { getStrokeWidthByElement } from '../../utils';\nimport { ShapeDefaultSpace } from '../../constants';\nimport { DrawTextInfo } from '../../generators/text.generator';\n\nexport const CombinedFragmentEngine: ShapeEngine<PlaitMultipleTextGeometry, DrawOptions, DrawTextInfo> = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n        const shape = rs.path(\n            `M${rectangle.x} ${rectangle.y + 25} \n            V${rectangle.y}\n            H${rectangle.x + rectangle.width} \n            V${rectangle.y + rectangle.height}\n            H${rectangle.x}\n            V${rectangle.y + 25}\n            H${rectangle.x + rectangle.width / 3 - 8}\n            L${rectangle.x + rectangle.width / 3} ${rectangle.y + 16}\n            V${rectangle.y}\n            `,\n\n            { ...options, fillStyle: 'solid' }\n        );\n        setStrokeLinecap(shape, 'round');\n\n        return shape;\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        const rangeRectangle = RectangleClient.getRectangleByPoints([point, point]);\n        return RectangleClient.isHit(rectangle, rangeRectangle);\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        return getNearestPointBetweenPointAndSegments(point, RectangleEngine.getCornerPoints(rectangle));\n    },\n    getEdgeByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle): [Point, Point] | null {\n        const corners = RectangleEngine.getCornerPoints(rectangle);\n        const point = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        return getPolygonEdgeByConnectionPoint(corners, point);\n    },\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    },\n    getTextRectangle(element: PlaitMultipleTextGeometry, options?: DrawTextInfo) {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const textHeight = element.texts?.find(item => item.id === options?.id)?.textHeight!;\n        if (options?.id === GeometryCommonTextKeys.name) {\n            const width = elementRectangle.width / 3 - 8 - ShapeDefaultSpace.rectangleAndText - strokeWidth;\n            return {\n                height: textHeight,\n                width: width > 0 ? width : 0,\n                x: elementRectangle.x + ShapeDefaultSpace.rectangleAndText + strokeWidth,\n                y: elementRectangle.y + (25 - textHeight) / 2\n            };\n        }\n        if (options?.id === GeometryCommonTextKeys.content) {\n            const width = elementRectangle.width - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth * 2;\n            return {\n                height: textHeight,\n                width: width > 0 ? width : 0,\n                x: elementRectangle.x + ShapeDefaultSpace.rectangleAndText + strokeWidth,\n                y: elementRectangle.y + 25 + ShapeDefaultSpace.rectangleAndText + strokeWidth\n            };\n        }\n        return elementRectangle;\n    }\n};\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    distanceBetweenPointAndPoint,\n    getNearestPointBetweenPointAndSegment,\n    getNearestPointBetweenPointAndSegments,\n    setStrokeLinecap\n} from '@plait/core';\nimport { ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { getPolygonEdgeByConnectionPoint } from '../../utils/polygon';\nimport { RectangleEngine } from '../basic-shapes/rectangle';\n\nfunction getDeletionLines(rectangle: RectangleClient): Array<[Point, Point]> {\n    return [\n        [\n            [rectangle.x, rectangle.y],\n            [rectangle.x + rectangle.width, rectangle.y + rectangle.height]\n        ],\n        [\n            [rectangle.x + rectangle.width, rectangle.y],\n            [rectangle.x, rectangle.y + rectangle.height]\n        ]\n    ];\n}\n\nexport const DeletionEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n        const lines = getDeletionLines(rectangle);\n        const shape = rs.path(\n            lines.map(([from, to]) => `M${from[0]} ${from[1]} L${to[0]} ${to[1]}`).join(' '),\n            { ...options, fillStyle: 'solid', strokeWidth: 4 }\n        );\n        setStrokeLinecap(shape, 'round');\n        return shape;\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        const rangeRectangle = RectangleClient.getRectangleByPoints([point, point]);\n        return RectangleClient.isHit(rectangle, rangeRectangle);\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        const lines = getDeletionLines(rectangle);\n        let minDistance = Infinity;\n        let nearestPoint = point;\n        lines.forEach(line => {\n            const currentPoint = getNearestPointBetweenPointAndSegment(point, line);\n            const distance = distanceBetweenPointAndPoint(point[0], point[1], currentPoint[0], currentPoint[1]);\n            if (distance < minDistance) {\n                minDistance = distance;\n                nearestPoint = currentPoint;\n            }\n        });\n        return nearestPoint;\n    },\n    getEdgeByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle): [Point, Point] | null {\n        const corners = RectangleEngine.getCornerPoints(rectangle);\n        const point = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        return getPolygonEdgeByConnectionPoint(corners, point);\n    },\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    }\n};\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    getNearestPointBetweenPointAndSegments,\n    setStrokeLinecap\n} from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { RectangleEngine } from '../basic-shapes/rectangle';\nimport { getPolygonEdgeByConnectionPoint } from '../../utils/polygon';\nimport { getStrokeWidthByElement } from '../../utils';\nimport { ShapeDefaultSpace } from '../../constants';\n\nexport const ActiveClassEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n        const shape = rs.path(\n            `M${rectangle.x} ${rectangle.y} H${rectangle.x + rectangle.width} V${rectangle.y + rectangle.height} H${\n                rectangle.x\n            } Z M${rectangle.x + rectangle.width * 0.125} ${rectangle.y} L${rectangle.x + rectangle.width * 0.125} ${rectangle.y +\n                rectangle.height} M${rectangle.x + rectangle.width - rectangle.width * 0.125} ${rectangle.y} L${rectangle.x +\n                rectangle.width -\n                rectangle.width * 0.125} ${rectangle.y + rectangle.height}`,\n            { ...options, fillStyle: 'solid' }\n        );\n        setStrokeLinecap(shape, 'round');\n\n        return shape;\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        const rangeRectangle = RectangleClient.getRectangleByPoints([point, point]);\n        return RectangleClient.isHit(rectangle, rangeRectangle);\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        return getNearestPointBetweenPointAndSegments(point, RectangleEngine.getCornerPoints(rectangle));\n    },\n    getEdgeByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle): [Point, Point] | null {\n        const corners = RectangleEngine.getCornerPoints(rectangle);\n        const point = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        return getPolygonEdgeByConnectionPoint(corners, point);\n    },\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    },\n\n    getTextRectangle: (element: PlaitGeometry) => {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const height = element.textHeight!;\n        const width =\n            elementRectangle.width - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth * 2 - elementRectangle.width * 0.125 * 2;\n        return {\n            height,\n            width: width > 0 ? width : 0,\n            x: elementRectangle.x + ShapeDefaultSpace.rectangleAndText + strokeWidth + elementRectangle.width * 0.125,\n            y: elementRectangle.y + (elementRectangle.height - height) / 2\n        };\n    }\n};\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    getEllipseTangentSlope,\n    getNearestPointBetweenPointAndSegments,\n    getVectorFromPointAndSlope,\n    setStrokeLinecap,\n    getNearestPointBetweenPointAndEllipse\n} from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { RectangleEngine } from '../basic-shapes/rectangle';\nimport { getStrokeWidthByElement } from '../../utils';\nimport { ShapeDefaultSpace } from '../../constants';\n\nexport const NoteEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n        const shape = rs.path(\n            `M${rectangle.x} ${rectangle.y} \n            h${rectangle.width - 16}\n            v16\n            h16\n            v${rectangle.height - 16}\n            h${-rectangle.width}\n            Z\n            M${rectangle.x + rectangle.width - 16} ${rectangle.y} \n            A16 16, 0,0,1, ${rectangle.x + rectangle.width} ${rectangle.y + 16}\n            `,\n            { ...options, fillStyle: 'solid' }\n        );\n        setStrokeLinecap(shape, 'round');\n\n        return shape;\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        const rangeRectangle = RectangleClient.getRectangleByPoints([point, point]);\n        return RectangleClient.isHit(rectangle, rangeRectangle);\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        const nearestPoint = getNearestPointBetweenPointAndSegments(point, RectangleEngine.getCornerPoints(rectangle));\n        if (nearestPoint[0] > rectangle.x + rectangle.width - 16 && nearestPoint[1] < rectangle.y + 16) {\n            return getNearestPointBetweenPointAndEllipse(point, [rectangle.x + rectangle.width - 16, rectangle.y + 16], 16, 16);\n        }\n        return nearestPoint;\n    },\n    getTangentVectorByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle) {\n        const connectionPoint = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        const centerPoint: Point = [rectangle.x + (rectangle.width * 3) / 4, rectangle.y + rectangle.height / 2];\n        const point = [connectionPoint[0] - centerPoint[0], -(connectionPoint[1] - centerPoint[1])];\n        const slope = getEllipseTangentSlope(point[0], point[1], 16, 16) as any;\n        return getVectorFromPointAndSlope(point[0], point[1], slope);\n    },\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    },\n    getTextRectangle: (element: PlaitGeometry) => {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const height = element.textHeight!;\n        const width = elementRectangle.width - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth - 15;\n        return {\n            height,\n            width: width > 0 ? width : 0,\n            x: elementRectangle.x + ShapeDefaultSpace.rectangleAndText + strokeWidth,\n            y: elementRectangle.y + (elementRectangle.height - height) / 2\n        };\n    }\n};\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    SVGArcCommand,\n    distanceBetweenPointAndPoint,\n    getNearestPointBetweenPointAndArc,\n    getNearestPointBetweenPointAndEllipse,\n    getNearestPointBetweenPointAndSegments,\n    setStrokeLinecap\n} from '@plait/core';\nimport { ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { RectangleEngine } from '../basic-shapes/rectangle';\nimport { getUnitVectorByPointAndPoint, rotateVector } from '@plait/common';\n\ninterface AssemblyPathData {\n    startPoint: Point;\n    line1: [Point, Point];\n    circleArcCommand: SVGArcCommand;\n    verticalArcCommand: SVGArcCommand;\n    line2: [Point, Point];\n}\n\nfunction generateAssemblyPath(rectangle: RectangleClient): AssemblyPathData {\n    const centerY = rectangle.y + rectangle.height / 2;\n    const firstLineEndX = rectangle.x + rectangle.width * 0.3;\n    const circleWidth = rectangle.width * 0.13;\n    const circleHeight = rectangle.height * 0.285;\n    const verticalX = firstLineEndX + circleWidth;\n    const verticalRadius = rectangle.width * 0.233;\n\n    return {\n        startPoint: [rectangle.x, centerY],\n        line1: [\n            [rectangle.x, centerY],\n            [firstLineEndX, centerY]\n        ],\n        circleArcCommand: {\n            rx: circleWidth,\n            ry: circleHeight,\n            xAxisRotation: 0,\n            largeArcFlag: 1,\n            sweepFlag: 1,\n            endX: firstLineEndX,\n            endY: centerY\n        },\n        verticalArcCommand: {\n            rx: verticalRadius,\n            ry: rectangle.height / 2,\n            xAxisRotation: 0,\n            largeArcFlag: 0,\n            sweepFlag: 1,\n            endX: verticalX,\n            endY: rectangle.y + rectangle.height\n        },\n        line2: [\n            [verticalX + verticalRadius, centerY],\n            [rectangle.x + rectangle.width, centerY]\n        ]\n    };\n}\n\nexport const AssemblyEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n        const { startPoint, line1, circleArcCommand, verticalArcCommand, line2 } = generateAssemblyPath(rectangle);\n\n        const pathData = [\n            `M${startPoint[0]} ${startPoint[1]}`,\n            `H${line1[1][0]}`,\n            // 画完整的圆形：先画一个半圆，再画另一个半圆\n            `A${circleArcCommand.rx} ${circleArcCommand.ry} ${circleArcCommand.xAxisRotation} ${circleArcCommand.largeArcFlag} ${circleArcCommand.sweepFlag} ${line1[1][0] + circleArcCommand.rx * 2} ${circleArcCommand.endY}`,\n            `A${circleArcCommand.rx} ${circleArcCommand.ry} ${circleArcCommand.xAxisRotation} ${circleArcCommand.largeArcFlag} ${circleArcCommand.sweepFlag} ${circleArcCommand.endX} ${circleArcCommand.endY}`,\n            // 垂直椭圆\n            `M${verticalArcCommand.endX} ${rectangle.y}`,\n            `A${verticalArcCommand.rx} ${verticalArcCommand.ry} ${verticalArcCommand.xAxisRotation} ${verticalArcCommand.largeArcFlag} ${verticalArcCommand.sweepFlag} ${verticalArcCommand.endX} ${verticalArcCommand.endY}`,\n            // 最后一条线\n            `M${line2[0][0]} ${line2[0][1]} H${line2[1][0]}`\n        ].join(' ');\n\n        const shape = rs.path(pathData, {\n            ...options,\n            fillStyle: 'solid'\n        });\n        setStrokeLinecap(shape, 'round');\n        return shape;\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        const rangeRectangle = RectangleClient.getRectangleByPoints([point, point]);\n        return RectangleClient.isHit(rectangle, rangeRectangle);\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    },\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        const { line1, line2, circleArcCommand, verticalArcCommand } = generateAssemblyPath(rectangle);\n\n        // 检查直线段\n        const nearestPointForLines = getNearestPointBetweenPointAndSegments(point, [...line1, ...line2]);\n        const distanceForLines = distanceBetweenPointAndPoint(...point, ...nearestPointForLines);\n\n        // 检查中间圆形\n        const circleCenter = [line1[1][0] + circleArcCommand.rx, line1[1][1]] as Point;\n        const nearestPointForCircle = getNearestPointBetweenPointAndEllipse(\n            point,\n            circleCenter,\n            circleArcCommand.rx,\n            circleArcCommand.ry\n        );\n        const distanceForCircle = distanceBetweenPointAndPoint(...point, ...nearestPointForCircle);\n\n        // 检查垂直椭圆（使用 getNearestPointBetweenPointAndArc 处理半圆弧）\n        const arcStartPoint: Point = [verticalArcCommand.endX, rectangle.y];\n        const nearestPointForEllipse = getNearestPointBetweenPointAndArc(\n            point,\n            arcStartPoint,\n            verticalArcCommand\n        );\n        const distanceForEllipse = distanceBetweenPointAndPoint(...point, ...nearestPointForEllipse);\n\n        // 返回最近的点\n        const minDistance = Math.min(distanceForLines, distanceForCircle, distanceForEllipse);\n        if (minDistance === distanceForLines) return nearestPointForLines;\n        if (minDistance === distanceForCircle) return nearestPointForCircle;\n        return nearestPointForEllipse;\n    },\n    getTangentVectorByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle) {\n        const connectionPoint = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        if (connectionPoint[0] > rectangle.x + rectangle.width * 0.43 && connectionPoint[1] < rectangle.y + rectangle.height / 2) {\n            return rotateVector(getUnitVectorByPointAndPoint(connectionPoint, [rectangle.x, rectangle.y + rectangle.height / 2]), -Math.PI);\n        }\n        if (connectionPoint[0] > rectangle.x + rectangle.width * 0.43 && connectionPoint[1] > rectangle.y + rectangle.height / 2) {\n            return getUnitVectorByPointAndPoint(connectionPoint, [rectangle.x, rectangle.y + rectangle.height / 2]);\n        }\n        return getUnitVectorByPointAndPoint(connectionPoint, [rectangle.x, rectangle.y + rectangle.height / 2]);\n    }\n};\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    getNearestPointBetweenPointAndSegments,\n    getNearestPointBetweenPointAndArc,\n    distanceBetweenPointAndPoint,\n    setStrokeLinecap,\n    getNearestPointBetweenPointAndSegment,\n    SVGArcCommand\n} from '@plait/core';\nimport { ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { RectangleEngine } from '../basic-shapes/rectangle';\nimport { getPolygonEdgeByConnectionPoint } from '../../utils/polygon';\n\ninterface RequiredInterfacePathData {\n    startPoint: Point;\n    leftArcCommand: SVGArcCommand;\n    line: {\n        startX: number;\n        startY: number;\n        endX: number;\n        endY: number;\n    };\n}\n\nfunction generateRequiredInterfacePath(rectangle: RectangleClient): RequiredInterfacePathData {\n    const arcWidth = rectangle.width * 0.39;\n    const arcHeight = rectangle.height / 2;\n\n    return {\n        startPoint: [rectangle.x, rectangle.y],\n        leftArcCommand: {\n            rx: arcWidth,\n            ry: arcHeight,\n            xAxisRotation: 0,\n            largeArcFlag: 0,\n            sweepFlag: 1,\n            endX: rectangle.x,\n            endY: rectangle.y + rectangle.height\n        },\n        line: {\n            startX: rectangle.x + rectangle.width * 0.41,\n            startY: rectangle.y + rectangle.height / 2,\n            endX: rectangle.x + rectangle.width,\n            endY: rectangle.y + rectangle.height / 2\n        }\n    };\n}\n\nexport const RequiredInterfaceEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n        const { startPoint, leftArcCommand, line } = generateRequiredInterfacePath(rectangle);\n\n        const pathData = [\n            `M${startPoint[0]} ${startPoint[1]}`,\n            `A${leftArcCommand.rx} ${leftArcCommand.ry} ${leftArcCommand.xAxisRotation} ${leftArcCommand.largeArcFlag} ${leftArcCommand.sweepFlag} ${leftArcCommand.endX} ${leftArcCommand.endY}`,\n            `M${line.startX} ${line.startY} H${line.endX}`\n        ].join(' ');\n\n        const shape = rs.path(pathData, {\n            ...options,\n            fillStyle: 'solid',\n            fill: 'transparent'\n        });\n        setStrokeLinecap(shape, 'round');\n        return shape;\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        const rangeRectangle = RectangleClient.getRectangleByPoints([point, point]);\n        return RectangleClient.isHit(rectangle, rangeRectangle);\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        const { startPoint, leftArcCommand, line } = generateRequiredInterfacePath(rectangle);\n        let minDistance = Infinity;\n        let nearestPoint = point;\n\n        // 检查圆弧段\n        const arcNearestPoint = getNearestPointBetweenPointAndArc(point, startPoint, leftArcCommand);\n        const arcDistance = distanceBetweenPointAndPoint(point[0], point[1], arcNearestPoint[0], arcNearestPoint[1]);\n        if (arcDistance < minDistance) {\n            minDistance = arcDistance;\n            nearestPoint = arcNearestPoint;\n        }\n\n        // 检查直线段\n        const lineStart: Point = [line.startX, line.startY];\n        const lineEnd: Point = [line.endX, line.endY];\n        const lineNearestPoint = getNearestPointBetweenPointAndSegment(point, [lineStart, lineEnd]);\n        const lineDistance = distanceBetweenPointAndPoint(point[0], point[1], lineNearestPoint[0], lineNearestPoint[1]);\n        if (lineDistance < minDistance) {\n            minDistance = lineDistance;\n            nearestPoint = lineNearestPoint;\n        }\n\n        return nearestPoint;\n    },\n    getEdgeByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle): [Point, Point] | null {\n        const corners = RectangleEngine.getCornerPoints(rectangle);\n        const point = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        return getPolygonEdgeByConnectionPoint(corners, point);\n    },\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    }\n};\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    SVGArcCommand,\n    distanceBetweenPointAndPoint,\n    getEllipseTangentSlope,\n    getNearestPointBetweenPointAndEllipse,\n    getNearestPointBetweenPointAndSegments,\n    getVectorFromPointAndSlope,\n    setStrokeLinecap\n} from '@plait/core';\nimport { ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { getUnitVectorByPointAndPoint } from '@plait/common';\n\nconst percentage = 0.54;\n\ninterface ProvidedInterfacePathData {\n    startPoint: Point;\n    line: {\n        startX: number;\n        startY: number;\n        endX: number;\n        endY: number;\n    };\n    arcCommands: SVGArcCommand[];\n}\n\nfunction generateProvidedInterfacePath(rectangle: RectangleClient): ProvidedInterfacePathData {\n    const centerY = rectangle.y + rectangle.height / 2;\n    const rx = (rectangle.width * (1 - percentage)) / 2;\n    const ry = rectangle.height / 2;\n\n    const startPoint: Point = [rectangle.x, centerY];\n    const lineEndX = rectangle.x + rectangle.width * percentage;\n\n    return {\n        startPoint,\n        line: {\n            startX: startPoint[0],\n            startY: centerY,\n            endX: lineEndX,\n            endY: centerY\n        },\n        arcCommands: [\n            {\n                rx,\n                ry,\n                xAxisRotation: 0,\n                largeArcFlag: 1,\n                sweepFlag: 1,\n                endX: rectangle.x + rectangle.width,\n                endY: centerY\n            },\n            {\n                rx,\n                ry,\n                xAxisRotation: 0,\n                largeArcFlag: 1,\n                sweepFlag: 1,\n                endX: lineEndX,\n                endY: centerY\n            }\n        ]\n    };\n}\n\nexport const ProvidedInterfaceEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n        const { startPoint, line, arcCommands } = generateProvidedInterfacePath(rectangle);\n\n        const pathData = [\n            `M${startPoint[0]} ${startPoint[1]}`,\n            `H${line.endX}`,\n            ...arcCommands.map(\n                (command) =>\n                    `A${command.rx} ${command.ry} ${command.xAxisRotation} ${command.largeArcFlag} ${command.sweepFlag} ${command.endX} ${command.endY}`\n            )\n        ].join(' ');\n\n        const shape = rs.path(pathData, {\n            ...options,\n            fillStyle: 'solid'\n        });\n        setStrokeLinecap(shape, 'round');\n        return shape;\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        const rangeRectangle = RectangleClient.getRectangleByPoints([point, point]);\n        return RectangleClient.isHit(rectangle, rangeRectangle);\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    },\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        const { startPoint, line, arcCommands } = generateProvidedInterfacePath(rectangle);\n\n        // 检查直线段\n        const lineStart: Point = [line.startX, line.startY];\n        const lineEnd: Point = [line.endX, line.endY];\n        const nearestPointForLine = getNearestPointBetweenPointAndSegments(point, [lineStart, lineEnd]);\n        const distanceForLine = distanceBetweenPointAndPoint(...point, ...nearestPointForLine);\n\n        // 检查圆弧段\n        const arcCenter = [rectangle.x + (3 * rectangle.width) / 4, line.startY] as Point;\n        const nearestPointForEllipse = getNearestPointBetweenPointAndEllipse(point, arcCenter, arcCommands[0].rx, arcCommands[0].ry);\n        const distanceForEllipse = distanceBetweenPointAndPoint(...point, ...nearestPointForEllipse);\n\n        return distanceForLine < distanceForEllipse ? nearestPointForLine : nearestPointForEllipse;\n    },\n    getTangentVectorByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle) {\n        const connectionPoint = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        const centerPoint: Point = [rectangle.x + (rectangle.width * 3) / 4, rectangle.y + rectangle.height / 2];\n        if (connectionPoint[0] > rectangle.x + rectangle.width * 0.54) {\n            const point = [connectionPoint[0] - centerPoint[0], -(connectionPoint[1] - centerPoint[1])];\n            const rx = (rectangle.width * 0.46) / 2;\n            const ry = rectangle.height / 2;\n            const slope = getEllipseTangentSlope(point[0], point[1], rx, ry) as any;\n            return getVectorFromPointAndSlope(point[0], point[1], slope);\n        }\n        return getUnitVectorByPointAndPoint(connectionPoint, [rectangle.x, rectangle.y + rectangle.height / 2]);\n    }\n};\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    getNearestPointBetweenPointAndDiscreteSegments,\n    setStrokeLinecap\n} from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { RectangleEngine } from '../basic-shapes/rectangle';\nimport { getStrokeWidthByElement } from '../../utils';\nimport { ShapeDefaultSpace } from '../../constants';\nimport { getUnitVectorByPointAndPoint } from '@plait/common';\n\ninterface ComponentPathData {\n    boxSize: {\n        width: number;\n        height: number;\n    };\n    points: {\n        mainStart: Point;\n        topBoxStart: Point;\n        topBoxEnd: Point;\n        bottomBoxStart: Point;\n        bottomBoxEnd: Point;\n        mainEnd: Point;\n        rightTop: Point;\n        rightBottom: Point;\n    };\n}\n\nfunction generateComponentPath(rectangle: RectangleClient): ComponentPathData {\n    const mainLineX = rectangle.x + 12;\n    const boxWidth = rectangle.width > 70 ? 24 : rectangle.width * 0.2;\n    const boxHeight = rectangle.height - 28 - rectangle.height * 0.35 > 1 ? 14 : rectangle.height * 0.175;\n    const topBoxY = rectangle.y + rectangle.height * 0.175;\n    const bottomBoxY = rectangle.y + rectangle.height - rectangle.height * 0.175 - boxHeight;\n    \n    return {\n        boxSize: {\n            width: boxWidth,\n            height: boxHeight\n        },\n        points: {\n            mainStart: [mainLineX, rectangle.y],\n            topBoxStart: [mainLineX, topBoxY],\n            topBoxEnd: [mainLineX, topBoxY + boxHeight],\n            bottomBoxStart: [mainLineX, bottomBoxY],\n            bottomBoxEnd: [mainLineX, bottomBoxY + boxHeight],\n            mainEnd: [mainLineX, rectangle.y + rectangle.height],\n            rightTop: [rectangle.x + rectangle.width, rectangle.y],\n            rightBottom: [rectangle.x + rectangle.width, rectangle.y + rectangle.height]\n        }\n    };\n}\n\nexport const ComponentEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n        const { boxSize, points } = generateComponentPath(rectangle);\n        \n        const pathData = [\n            // 主矩形轮廓\n            `M${points.mainStart[0]} ${points.mainStart[1]}`,\n            `H${points.rightTop[0]}`,\n            `V${points.rightBottom[1]}`,\n            `H${points.mainEnd[0]}`,\n\n            // 上方小矩形\n            `M${points.topBoxStart[0]} ${points.topBoxStart[1]}`,\n            `h${boxSize.width / 2} v${boxSize.height} h${-boxSize.width} v${-boxSize.height} h${boxSize.width / 2}`,\n\n            // 下方小矩形\n            `M${points.bottomBoxStart[0]} ${points.bottomBoxStart[1]}`,\n            `h${boxSize.width / 2} v${boxSize.height} h${-boxSize.width} v${-boxSize.height} h${boxSize.width / 2}`,\n\n            // 连接线\n            `M${points.mainStart[0]} ${points.mainStart[1]}`,\n            `V${points.topBoxStart[1]}`,\n            `M${points.topBoxEnd[0]} ${points.topBoxEnd[1]}`,\n            `V${points.bottomBoxStart[1]}`,\n            `M${points.bottomBoxEnd[0]} ${points.bottomBoxEnd[1]}`,\n            `V${points.mainEnd[1]}`\n        ].join(' ');\n\n        const shape = rs.path(pathData, { ...options, fillStyle: 'solid' });\n        setStrokeLinecap(shape, 'round');\n        return shape;\n    },\n\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        const { boxSize, points } = generateComponentPath(rectangle);\n        \n        const segments: [Point, Point][] = [\n            // 主矩形轮廓\n            [points.mainStart, [points.rightTop[0], points.mainStart[1]]],\n            [[points.rightTop[0], points.mainStart[1]], points.rightBottom],\n            [points.rightBottom, [points.mainEnd[0], points.rightBottom[1]]],\n            [[points.mainEnd[0], points.rightBottom[1]], points.mainStart],\n\n            // 上方小矩形\n            [points.topBoxStart, [points.topBoxStart[0] + boxSize.width/2, points.topBoxStart[1]]],\n            [[points.topBoxStart[0] + boxSize.width/2, points.topBoxStart[1]], [points.topBoxStart[0] + boxSize.width/2, points.topBoxEnd[1]]],\n            [[points.topBoxStart[0] + boxSize.width/2, points.topBoxEnd[1]], [points.topBoxStart[0] - boxSize.width/2, points.topBoxEnd[1]]],\n            [[points.topBoxStart[0] - boxSize.width/2, points.topBoxEnd[1]], [points.topBoxStart[0] - boxSize.width/2, points.topBoxStart[1]]],\n            [[points.topBoxStart[0] - boxSize.width/2, points.topBoxStart[1]], points.topBoxStart],\n\n            // 下方小矩形\n            [points.bottomBoxStart, [points.bottomBoxStart[0] + boxSize.width/2, points.bottomBoxStart[1]]],\n            [[points.bottomBoxStart[0] + boxSize.width/2, points.bottomBoxStart[1]], [points.bottomBoxStart[0] + boxSize.width/2, points.bottomBoxEnd[1]]],\n            [[points.bottomBoxStart[0] + boxSize.width/2, points.bottomBoxEnd[1]], [points.bottomBoxStart[0] - boxSize.width/2, points.bottomBoxEnd[1]]],\n            [[points.bottomBoxStart[0] - boxSize.width/2, points.bottomBoxEnd[1]], [points.bottomBoxStart[0] - boxSize.width/2, points.bottomBoxStart[1]]],\n            [[points.bottomBoxStart[0] - boxSize.width/2, points.bottomBoxStart[1]], points.bottomBoxStart],\n\n            // 连接线\n            [points.mainStart, points.topBoxStart],\n            [points.topBoxEnd, points.bottomBoxStart],\n            [points.bottomBoxEnd, points.mainEnd]\n        ];\n\n        return getNearestPointBetweenPointAndDiscreteSegments(point, segments);\n    },\n\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        const rangeRectangle = RectangleClient.getRectangleByPoints([point, point]);\n        return RectangleClient.isHit(rectangle, rangeRectangle);\n    },\n\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n\n    getTangentVectorByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle) {\n        const { points } = generateComponentPath(rectangle);\n        const connectionPoint = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        return getUnitVectorByPointAndPoint(points.mainStart, connectionPoint);\n    },\n\n    getConnectorPoints(rectangle: RectangleClient) {\n        const { points } = generateComponentPath(rectangle);\n        return [\n            [rectangle.x + rectangle.width / 2, rectangle.y],\n            [rectangle.x + rectangle.width, rectangle.y + rectangle.height / 2],\n            [rectangle.x + rectangle.width / 2, rectangle.y + rectangle.height],\n            [points.mainStart[0], rectangle.y + rectangle.height / 2]\n        ] as [Point, Point, Point, Point];\n    },\n\n    getTextRectangle(element: PlaitGeometry) {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const height = element.textHeight!;\n        const width = elementRectangle.width - 24 - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth * 2;\n        return {\n            height,\n            width: width > 0 ? width : 0,\n            x: elementRectangle.x + 24 + ShapeDefaultSpace.rectangleAndText + strokeWidth,\n            y: elementRectangle.y + (elementRectangle.height - height) / 2\n        };\n    }\n};\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    getNearestPointBetweenPointAndSegments,\n    setStrokeLinecap\n} from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { getPolygonEdgeByConnectionPoint } from '../../utils/polygon';\nimport { RectangleEngine } from '../basic-shapes/rectangle';\nimport { getStrokeWidthByElement } from '../../utils';\nimport { ShapeDefaultSpace } from '../../constants';\nimport { ComponentEngine } from './component';\n\nexport const ComponentBoxEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n        const componentWidth = rectangle.width - 45 * 2 - 18 > 1 ? 45 : rectangle.width * 0.25;\n        const componentHeight = rectangle.height - 30 - 8 * 2 > 1 ? 30 : rectangle.height * 0.2;\n\n        const componentRectangle = {\n            x: rectangle.x + rectangle.width - 18 - componentWidth,\n            y: rectangle.y + 8,\n            width: componentWidth,\n            height: componentHeight\n        };\n        const shape = rs.path(\n            `M${rectangle.x} ${rectangle.y} \n            H${rectangle.x + rectangle.width} \n            V${rectangle.y + rectangle.height} \n            H${rectangle.x} Z\n\n            `,\n            { ...options, fillStyle: 'solid' }\n        );\n\n        const componentShape = ComponentEngine.draw(board, componentRectangle, options);\n        shape.append(componentShape);\n        setStrokeLinecap(shape, 'round');\n\n        return shape;\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        const rangeRectangle = RectangleClient.getRectangleByPoints([point, point]);\n        return RectangleClient.isHit(rectangle, rangeRectangle);\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        return getNearestPointBetweenPointAndSegments(point, RectangleEngine.getCornerPoints(rectangle));\n    },\n    getEdgeByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle): [Point, Point] | null {\n        const corners = RectangleEngine.getCornerPoints(rectangle);\n        const point = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        return getPolygonEdgeByConnectionPoint(corners, point);\n    },\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    },\n    getTextRectangle(element: PlaitGeometry) {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const height = element.textHeight!;\n        const componentWidth = elementRectangle.width - 45 * 2 - 18 > 1 ? 45 : elementRectangle.width * 0.25;\n        const width = elementRectangle.width - 18 - componentWidth - ShapeDefaultSpace.rectangleAndText - strokeWidth * 2;\n        return {\n            height,\n            width: width > 0 ? width : 0,\n            x: elementRectangle.x + ShapeDefaultSpace.rectangleAndText + strokeWidth,\n            y: elementRectangle.y + (elementRectangle.height - height) / 2\n        };\n    }\n};\n", "import {\n    PlaitBoard,\n    Point,\n    PointOfRectangle,\n    RectangleClient,\n    drawRoundRectangle,\n    getNearestPointBetweenPointAndSegments\n} from '@plait/core';\nimport { PlaitGeometry, ShapeEngine } from '../../interfaces';\nimport { Options } from 'roughjs/bin/core';\nimport { getPolygonEdgeByConnectionPoint } from '../../utils/polygon';\nimport { RectangleEngine } from '../basic-shapes/rectangle';\nimport { getStrokeWidthByElement } from '../../utils';\nimport { ShapeDefaultSpace } from '../../constants';\n\nexport const TemplateEngine: ShapeEngine = {\n    draw(board: PlaitBoard, rectangle: RectangleClient, options: Options) {\n        const rs = PlaitBoard.getRoughSVG(board);\n\n        return drawRoundRectangle(\n            rs,\n            rectangle.x,\n            rectangle.y,\n            rectangle.x + rectangle.width,\n            rectangle.y + rectangle.height,\n            {\n                ...options,\n                fillStyle: 'solid',\n                dashGap: 10,\n                strokeLineDash: [10, 10]\n            },\n            false,\n            4\n        );\n    },\n    isInsidePoint(rectangle: RectangleClient, point: Point) {\n        const rangeRectangle = RectangleClient.getRectangleByPoints([point, point]);\n        return RectangleClient.isHit(rectangle, rangeRectangle);\n    },\n    getCornerPoints(rectangle: RectangleClient) {\n        return RectangleClient.getCornerPoints(rectangle);\n    },\n    getNearestPoint(rectangle: RectangleClient, point: Point) {\n        return getNearestPointBetweenPointAndSegments(point, RectangleEngine.getCornerPoints(rectangle));\n    },\n    getEdgeByConnectionPoint(rectangle: RectangleClient, pointOfRectangle: PointOfRectangle): [Point, Point] | null {\n        const corners = RectangleEngine.getCornerPoints(rectangle);\n        const point = RectangleClient.getConnectionPoint(rectangle, pointOfRectangle);\n        return getPolygonEdgeByConnectionPoint(corners, point);\n    },\n    getConnectorPoints(rectangle: RectangleClient) {\n        return RectangleClient.getEdgeCenterPoints(rectangle);\n    },\n    getTextRectangle(element: PlaitGeometry) {\n        const elementRectangle = RectangleClient.getRectangleByPoints(element.points!);\n        const strokeWidth = getStrokeWidthByElement(element);\n        const height = element.textHeight!;\n        const width = elementRectangle.width - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth * 2;\n        return {\n            height,\n            width: width > 0 ? width : 0,\n            x: elementRectangle.x + ShapeDefaultSpace.rectangleAndText + strokeWidth,\n            y: elementRectangle.y + (elementRectangle.height - height) / 2\n        };\n    }\n};\n", "import {\n    BasicShapes,\n    DrawOptions,\n    DrawShapes,\n    FlowchartSymbols,\n    PlaitGeometry,\n    ShapeEngine,\n    SwimlaneSymbols,\n    TableSymbols,\n    TextRectangleOptions,\n    UMLSymbols\n} from '../interfaces';\nimport { CommentEngine } from './basic-shapes/comment';\nimport { CrossEngine } from './basic-shapes/cross';\nimport { DiamondEngine } from './basic-shapes/diamond';\nimport { EllipseEngine } from './basic-shapes/ellipse';\nimport { HexagonEngine } from './basic-shapes/hexagon';\nimport { LeftArrowEngine } from './basic-shapes/left-arrow';\nimport { OctagonEngine } from './basic-shapes/octagon';\nimport { ParallelogramEngine } from './basic-shapes/parallelogram';\nimport { PentagonEngine } from './basic-shapes/pentagon';\nimport { PentagonArrowEngine } from './basic-shapes/pentagon-arrow';\nimport { ProcessArrowEngine } from './basic-shapes/process-arrow';\nimport { RightArrowEngine } from './basic-shapes/right-arrow';\nimport { RoundCommentEngine } from './basic-shapes/round-comment';\nimport { RoundRectangleEngine } from './basic-shapes/round-rectangle';\nimport { TrapezoidEngine } from './basic-shapes/trapezoid';\nimport { TriangleEngine } from './basic-shapes/triangle';\nimport { TwoWayArrowEngine } from './basic-shapes/two-way-arrow';\nimport { StarEngine } from './basic-shapes/star';\nimport { TerminalEngine } from './flowchart/terminal';\nimport { ManualInputEngine } from './flowchart/manual-input';\nimport { PreparationEngine } from './flowchart/preparation';\nimport { ManualLoopEngine } from './flowchart/manual-loop';\nimport { MergeEngine } from './flowchart/merge';\nimport { DelayEngine } from './flowchart/delay';\nimport { StoredDataEngine } from './flowchart/stored-data';\nimport { PredefinedProcessEngine } from './flowchart/predefined-process';\nimport { OffPageEngine } from './flowchart/off-page';\nimport { CloudEngine } from './basic-shapes/cloud';\nimport { OrEngine } from './flowchart/or';\nimport { SummingJunctionEngine } from './flowchart/summing-junction';\nimport { DocumentEngine } from './flowchart/document';\nimport { MultiDocumentEngine } from './flowchart/multi-document';\nimport { DatabaseEngine } from './flowchart/database';\nimport { HardDiskEngine } from './flowchart/hard-disk';\nimport { InternalStorageEngine } from './flowchart/internal-storage';\nimport { NoteCurlyLeftEngine } from './flowchart/note-curly-left';\nimport { NoteCurlyRightEngine } from './flowchart/note-curly-right';\nimport { NoteSquareEngine } from './flowchart/note-square';\nimport { DisplayEngine } from './flowchart/display';\nimport { TableEngine } from './table/table';\nimport { RectangleEngine } from './basic-shapes/rectangle';\nimport { PlaitElement } from '@plait/core';\nimport { ActorEngine } from './uml/actor';\nimport { ContainerEngine } from './uml/container';\nimport { PackageEngine } from './uml/package';\nimport { CombinedFragmentEngine } from './uml/combined-fragment';\nimport { DeletionEngine } from './uml/deletion';\nimport { ActiveClassEngine } from './uml/activity-class';\nimport { NoteEngine } from './uml/note';\nimport { AssemblyEngine } from './uml/assembly';\nimport { RequiredInterfaceEngine } from './uml/required-interface';\nimport { ProvidedInterfaceEngine } from './uml/provided-interface';\nimport { ComponentEngine } from './uml/component';\nimport { ComponentBoxEngine } from './uml/component-box';\nimport { TemplateEngine } from './uml/template';\n\nconst ShapeEngineMap: Record<DrawShapes, ShapeEngine<any, any, any>> = {\n    [BasicShapes.rectangle]: RectangleEngine,\n    [BasicShapes.diamond]: DiamondEngine,\n    [BasicShapes.ellipse]: EllipseEngine,\n    [BasicShapes.parallelogram]: ParallelogramEngine,\n    [BasicShapes.roundRectangle]: RoundRectangleEngine,\n    [BasicShapes.text]: RectangleEngine,\n    [BasicShapes.triangle]: TriangleEngine,\n    [BasicShapes.leftArrow]: LeftArrowEngine,\n    [BasicShapes.trapezoid]: TrapezoidEngine,\n    [BasicShapes.rightArrow]: RightArrowEngine,\n    [BasicShapes.cross]: CrossEngine,\n    [BasicShapes.star]: StarEngine,\n    [BasicShapes.pentagon]: PentagonEngine,\n    [BasicShapes.hexagon]: HexagonEngine,\n    [BasicShapes.octagon]: OctagonEngine,\n    [BasicShapes.pentagonArrow]: PentagonArrowEngine,\n    [BasicShapes.processArrow]: ProcessArrowEngine,\n    [BasicShapes.twoWayArrow]: TwoWayArrowEngine,\n    [BasicShapes.comment]: CommentEngine,\n    [BasicShapes.roundComment]: RoundCommentEngine,\n    [BasicShapes.cloud]: CloudEngine,\n    [FlowchartSymbols.process]: RectangleEngine,\n    [FlowchartSymbols.decision]: DiamondEngine,\n    [FlowchartSymbols.connector]: EllipseEngine,\n    [FlowchartSymbols.data]: ParallelogramEngine,\n    [FlowchartSymbols.terminal]: TerminalEngine,\n    [FlowchartSymbols.database]: DatabaseEngine,\n    [FlowchartSymbols.hardDisk]: HardDiskEngine,\n    [FlowchartSymbols.internalStorage]: InternalStorageEngine,\n    [FlowchartSymbols.manualInput]: ManualInputEngine,\n    [FlowchartSymbols.preparation]: PreparationEngine,\n    [FlowchartSymbols.manualLoop]: ManualLoopEngine,\n    [FlowchartSymbols.merge]: MergeEngine,\n    [FlowchartSymbols.delay]: DelayEngine,\n    [FlowchartSymbols.storedData]: StoredDataEngine,\n    [FlowchartSymbols.or]: OrEngine,\n    [FlowchartSymbols.summingJunction]: SummingJunctionEngine,\n    [FlowchartSymbols.predefinedProcess]: PredefinedProcessEngine,\n    [FlowchartSymbols.offPage]: OffPageEngine,\n    [FlowchartSymbols.document]: DocumentEngine,\n    [FlowchartSymbols.multiDocument]: MultiDocumentEngine,\n    [FlowchartSymbols.noteCurlyLeft]: NoteCurlyLeftEngine,\n    [FlowchartSymbols.noteCurlyRight]: NoteCurlyRightEngine,\n    [FlowchartSymbols.noteSquare]: NoteSquareEngine,\n    [FlowchartSymbols.display]: DisplayEngine,\n    [SwimlaneSymbols.swimlaneHorizontal]: TableEngine,\n    [SwimlaneSymbols.swimlaneVertical]: TableEngine,\n    [TableSymbols.table]: TableEngine,\n    [UMLSymbols.actor]: ActorEngine,\n    [UMLSymbols.useCase]: EllipseEngine,\n    [UMLSymbols.container]: ContainerEngine,\n    [UMLSymbols.note]: NoteEngine,\n    [UMLSymbols.package]: PackageEngine,\n    [UMLSymbols.combinedFragment]: CombinedFragmentEngine,\n    [UMLSymbols.class]: TableEngine,\n    [UMLSymbols.interface]: TableEngine,\n    [UMLSymbols.activation]: RectangleEngine,\n    [UMLSymbols.object]: RectangleEngine,\n    [UMLSymbols.deletion]: DeletionEngine,\n    [UMLSymbols.activityClass]: ActiveClassEngine,\n    [UMLSymbols.simpleClass]: RectangleEngine,\n    [UMLSymbols.component]: ComponentEngine,\n    [UMLSymbols.componentBox]: ComponentBoxEngine,\n    [UMLSymbols.template]: TemplateEngine,\n    [UMLSymbols.port]: RectangleEngine,\n    [UMLSymbols.branchMerge]: DiamondEngine,\n    [UMLSymbols.assembly]: AssemblyEngine,\n    [UMLSymbols.requiredInterface]: RequiredInterfaceEngine,\n    [UMLSymbols.providedInterface]: ProvidedInterfaceEngine\n};\n\nexport const getEngine = <\n    T extends PlaitElement = PlaitGeometry,\n    P extends DrawOptions = DrawOptions,\n    K extends TextRectangleOptions = TextRectangleOptions\n>(\n    shape: DrawShapes\n): ShapeEngine<T, P, K> => {\n    return ShapeEngineMap[shape];\n};\n", "import {\n    Point,\n    PlaitBoard,\n    getElementById,\n    RectangleClient,\n    PointOfRectangle,\n    Direction,\n    Vector,\n    hasValidAngle,\n    rotatePointsByElement,\n    findElements,\n    PlaitElement,\n    Path\n} from '@plait/core';\nimport {\n    getDirectionFactor,\n    rotateVectorAnti90,\n    getDirectionByVector,\n    getOppositeDirection,\n    getDirectionByPointOfRectangle,\n    getSourceAndTargetOuterRectangle,\n    getNextPoint,\n    rotateVector\n} from '@plait/common';\nimport {\n    BasicShapes,\n    ArrowLineHandleKey,\n    ArrowLineHandleRef,\n    ArrowLineHandleRefPair,\n    ArrowLineMarkerType,\n    PlaitArrowLine,\n    PlaitGeometry,\n    PlaitShapeElement,\n    PlaitDrawElement\n} from '../../interfaces';\nimport { getEngine } from '../../engines';\nimport { getElementShape } from '../shape';\nimport { getSourceAndTargetRectangle } from './elbow';\nimport { getStrokeWidthByElement } from '../common';\nimport { getArrowLinePoints, getHitConnection } from './arrow-line-basic';\n\nexport const getArrowLineHandleRefPair = (board: PlaitBoard, element: PlaitArrowLine): ArrowLineHandleRefPair => {\n    const strokeWidth = getStrokeWidthByElement(element);\n    const sourceBoundElement = element.source.boundId ? getElementById<PlaitShapeElement>(board, element.source.boundId) : undefined;\n    const targetBoundElement = element.target.boundId ? getElementById<PlaitShapeElement>(board, element.target.boundId) : undefined;\n    let sourcePoint = sourceBoundElement ? getConnectionPoint(sourceBoundElement, element.source.connection!) : element.points[0];\n    let targetPoint = targetBoundElement\n        ? getConnectionPoint(targetBoundElement, element.target.connection!)\n        : element.points[element.points.length - 1];\n    let sourceDirection = getDirectionByVector([targetPoint[0] - sourcePoint[0], targetPoint[1] - sourcePoint[1]]) || Direction.right;\n    let targetDirection = getOppositeDirection(sourceDirection);\n    const sourceFactor = getDirectionFactor(sourceDirection);\n    const targetFactor = getDirectionFactor(targetDirection);\n    const sourceHandleRef: ArrowLineHandleRef = {\n        key: ArrowLineHandleKey.source,\n        point: sourcePoint,\n        direction: sourceDirection,\n        vector: [sourceFactor.x, sourceFactor.y]\n    };\n    const targetHandleRef: ArrowLineHandleRef = {\n        key: ArrowLineHandleKey.target,\n        point: targetPoint,\n        direction: targetDirection,\n        vector: [targetFactor.x, targetFactor.y]\n    };\n    if (sourceBoundElement) {\n        const connectionOffset = PlaitArrowLine.isSourceMarkOrTargetMark(\n            element as PlaitArrowLine,\n            ArrowLineMarkerType.none,\n            ArrowLineHandleKey.source\n        )\n            ? 0\n            : strokeWidth;\n        const sourceVector = getVectorByConnection(sourceBoundElement, element.source.connection!);\n        sourceHandleRef.vector = sourceVector;\n        sourceHandleRef.boundElement = sourceBoundElement;\n        if (hasValidAngle(sourceBoundElement)) {\n            const direction = getDirectionByVector(rotateVector(sourceVector, sourceBoundElement.angle!));\n            sourceDirection = direction ? direction : sourceDirection;\n        } else {\n            const direction = getDirectionByVector(sourceVector);\n            sourceDirection = direction ? direction : sourceDirection;\n        }\n        sourceHandleRef.direction = sourceDirection;\n        sourcePoint = getConnectionPoint(sourceBoundElement, element.source.connection!, sourceDirection, connectionOffset);\n        sourceHandleRef.point = rotatePointsByElement(sourcePoint, sourceBoundElement) || sourcePoint;\n    }\n    if (targetBoundElement) {\n        const connectionOffset = PlaitArrowLine.isSourceMarkOrTargetMark(\n            element as PlaitArrowLine,\n            ArrowLineMarkerType.none,\n            ArrowLineHandleKey.target\n        )\n            ? 0\n            : strokeWidth;\n        const targetVector = getVectorByConnection(targetBoundElement, element.target.connection!);\n        targetHandleRef.vector = targetVector;\n        targetHandleRef.boundElement = targetBoundElement;\n        if (hasValidAngle(targetBoundElement)) {\n            const direction = getDirectionByVector(rotateVector(targetVector, targetBoundElement.angle!));\n            targetDirection = direction ? direction : targetDirection;\n        } else {\n            const direction = getDirectionByVector(targetVector);\n            targetDirection = direction ? direction : targetDirection;\n        }\n        targetHandleRef.direction = targetDirection;\n        targetPoint = getConnectionPoint(targetBoundElement, element.target.connection!, targetDirection, connectionOffset);\n        targetHandleRef.point = rotatePointsByElement(targetPoint, targetBoundElement) || targetPoint;\n    }\n    return { source: sourceHandleRef, target: targetHandleRef };\n};\n\nexport const getConnectionPoint = (geometry: PlaitShapeElement, connection: Point, direction?: Direction, delta?: number): Point => {\n    const rectangle = RectangleClient.getRectangleByPoints(geometry.points);\n    if (direction && delta) {\n        const directionFactor = getDirectionFactor(direction);\n        const point = RectangleClient.getConnectionPoint(rectangle, connection);\n        return [point[0] + directionFactor.x * delta, point[1] + directionFactor.y * delta];\n    } else {\n        return RectangleClient.getConnectionPoint(rectangle, connection);\n    }\n};\n\nexport const getVectorByConnection = (boundElement: PlaitShapeElement, connection: PointOfRectangle): Vector => {\n    const rectangle = RectangleClient.getRectangleByPoints(boundElement.points);\n    const shape = getElementShape(boundElement);\n    const engine = getEngine(shape);\n    let vector: Vector = [0, 0];\n    const direction = getDirectionByPointOfRectangle(connection);\n    if (direction && boundElement.shape !== BasicShapes.ellipse) {\n        const factor = getDirectionFactor(direction);\n        return [factor.x, factor.y];\n    }\n    if (engine.getEdgeByConnectionPoint) {\n        const edge = engine.getEdgeByConnectionPoint(rectangle, connection);\n        if (edge) {\n            const lineVector = [edge[1][0] - edge[0][0], edge[1][1] - edge[0][1]] as Vector;\n            return rotateVectorAnti90(lineVector);\n        }\n    }\n    if (engine.getTangentVectorByConnectionPoint) {\n        const lineVector = engine.getTangentVectorByConnectionPoint(rectangle, connection);\n        if (lineVector) {\n            return rotateVectorAnti90(lineVector);\n        }\n    }\n    return vector;\n};\n\nexport const getElbowLineRouteOptions = (board: PlaitBoard, element: PlaitArrowLine, handleRefPair?: ArrowLineHandleRefPair) => {\n    handleRefPair = handleRefPair ?? getArrowLineHandleRefPair(board, element);\n    const { sourceRectangle, targetRectangle } = getSourceAndTargetRectangle(board, element, handleRefPair);\n    const { sourceOuterRectangle, targetOuterRectangle } = getSourceAndTargetOuterRectangle(sourceRectangle, targetRectangle);\n    const sourcePoint = handleRefPair.source.point;\n    const targetPoint = handleRefPair.target.point;\n    const nextSourcePoint = getNextPoint(sourcePoint, sourceOuterRectangle, handleRefPair.source.direction);\n    const nextTargetPoint = getNextPoint(targetPoint, targetOuterRectangle, handleRefPair.target.direction);\n    return {\n        sourcePoint,\n        nextSourcePoint,\n        sourceRectangle,\n        sourceOuterRectangle,\n        targetPoint,\n        nextTargetPoint,\n        targetRectangle,\n        targetOuterRectangle\n    };\n};\n\nexport const collectArrowLineUpdatedRefsByGeometry = (\n    board: PlaitBoard,\n    element: PlaitShapeElement,\n    refs: { property: Partial<PlaitArrowLine>; path: Path }[]\n) => {\n    const lines = findElements(board, {\n        match: (element: PlaitElement) => {\n            if (PlaitDrawElement.isArrowLine(element)) {\n                return element.source.boundId === element.id || element.target.boundId === element.id;\n            }\n            return false;\n        },\n        recursion: element => true\n    }) as PlaitArrowLine[];\n    if (lines.length) {\n        lines.forEach(line => {\n            const isSourceBound = line.source.boundId === element.id;\n            const handle = isSourceBound ? 'source' : 'target';\n            const object = { ...line[handle] };\n            const linePoints = getArrowLinePoints(board, line);\n            const point = isSourceBound ? linePoints[0] : linePoints[linePoints.length - 1];\n            object.connection = getHitConnection(board, point, element);\n            const path = PlaitBoard.findPath(board, line);\n            const index = refs.findIndex(obj => Path.equals(obj.path, path));\n            if (index === -1) {\n                refs.push({\n                    property: {\n                        [handle]: object\n                    },\n                    path\n                });\n            } else {\n                refs[index].property = { ...refs[index].property, [handle]: object };\n            }\n        });\n    }\n};\n", "import { Direction, PlaitBoard, PlaitElement, Point, PointOfRectangle, Vector, getElementById, rotatePointsByElement } from '@plait/core';\nimport { Element } from 'slate';\nimport { getConnectionPoint } from '../utils/arrow-line/arrow-line-common';\nimport { PlaitShapeElement } from '.';\nimport { StrokeStyle } from '@plait/common';\n\nexport enum ArrowLineMarkerType {\n    arrow = 'arrow',\n    none = 'none',\n    openTriangle = 'open-triangle',\n    solidTriangle = 'solid-triangle',\n    sharpArrow = 'sharp-arrow',\n    oneSideUp = 'one-side-up',\n    oneSideDown = 'one-side-down',\n    hollowTriangle = 'hollow-triangle',\n    singleSlash = 'single-slash'\n}\n\nexport enum ArrowLineShape {\n    straight = 'straight',\n    curve = 'curve',\n    elbow = 'elbow'\n}\n\nexport enum ArrowLineHandleKey {\n    source = 'source',\n    target = 'target'\n}\n\nexport interface ArrowLineText {\n    text: Element;\n    // Percentage of positioning based on line length\n    position: number;\n    width: number;\n    height: number;\n}\n\nexport interface ArrowLineHandle {\n    // The id of the bounded element\n    boundId?: string;\n    connection?: PointOfRectangle;\n    marker: ArrowLineMarkerType;\n}\n\nexport interface ArrowLineHandleRef {\n    key: ArrowLineHandleKey;\n    direction: Direction;\n    point: PointOfRectangle;\n    vector: Vector;\n    boundElement?: PlaitShapeElement;\n}\n\nexport interface ArrowLineHandleRefPair {\n    source: ArrowLineHandleRef;\n    target: ArrowLineHandleRef;\n}\n\nexport interface PlaitArrowLine extends PlaitElement {\n    type: 'arrow-line';\n    shape: ArrowLineShape;\n    points: Point[];\n\n    source: ArrowLineHandle;\n    target: ArrowLineHandle;\n\n    texts: ArrowLineText[];\n\n    // node style attributes\n    strokeColor?: string;\n    strokeWidth?: number;\n    strokeStyle?: StrokeStyle;\n\n    opacity: number;\n}\n\nexport interface PlaitStraightArrowLine extends PlaitArrowLine {\n    shape: ArrowLineShape.straight;\n}\n\nexport interface PlaitCurveArrowLine extends PlaitArrowLine {\n    shape: ArrowLineShape.curve;\n}\n\nexport interface PlaitElbowArrowLine extends PlaitArrowLine {\n    shape: ArrowLineShape.elbow;\n}\n\nexport const PlaitArrowLine = {\n    isSourceMarkOrTargetMark(line: PlaitArrowLine, markType: ArrowLineMarkerType, handleKey: ArrowLineHandleKey) {\n        if (handleKey === ArrowLineHandleKey.source) {\n            return line.source.marker === markType;\n        } else {\n            return line.target.marker === markType;\n        }\n    },\n    isSourceMark(line: PlaitArrowLine, markType: ArrowLineMarkerType) {\n        return PlaitArrowLine.isSourceMarkOrTargetMark(line, markType, ArrowLineHandleKey.source);\n    },\n    isTargetMark(line: PlaitArrowLine, markType: ArrowLineMarkerType) {\n        return PlaitArrowLine.isSourceMarkOrTargetMark(line, markType, ArrowLineHandleKey.target);\n    },\n    isBoundElementOfSource(line: PlaitArrowLine, element: PlaitShapeElement) {\n        return line.source.boundId === element.id;\n    },\n    isBoundElementOfTarget(line: PlaitArrowLine, element: PlaitShapeElement) {\n        return line.target.boundId === element.id;\n    },\n    getPoints(board: PlaitBoard, line: PlaitArrowLine) {\n        let sourcePoint;\n        if (line.source.boundId) {\n            const sourceElement = getElementById<PlaitShapeElement>(board, line.source.boundId)!;\n            const sourceConnectionPoint = getConnectionPoint(sourceElement, line.source.connection!);\n            sourcePoint = rotatePointsByElement(sourceConnectionPoint, sourceElement) || sourceConnectionPoint;\n        } else {\n            sourcePoint = line.points[0];\n        }\n\n        let targetPoint;\n        if (line.target.boundId) {\n            const targetElement = getElementById<PlaitShapeElement>(board, line.target.boundId)!;\n            const targetConnectionPoint = getConnectionPoint(targetElement, line.target.connection!);\n            targetPoint = rotatePointsByElement(targetConnectionPoint, targetElement) || targetConnectionPoint;\n        } else {\n            targetPoint = line.points[line.points.length - 1];\n        }\n        const restPoints = line.points.length > 2 ? line.points.slice(1, line.points.length - 1) : [];\n        return [sourcePoint, ...restPoints, targetPoint];\n    }\n};\n", "export enum MemorizeKey {\n    basicShape = 'basicShape',\n    flowchart = 'flowchart',\n    text = 'text',\n    arrowLine = 'arrow-line',\n    UML = 'UML'\n}\n", "import { Path, PlaitElement, Point } from '@plait/core';\nimport { ArrowLineShape } from './arrow-line';\nimport { StrokeStyle } from '@plait/common';\n\nexport enum VectorLinePointerType {\n    vectorLine = 'vectorLine'\n}\n\nexport enum VectorLineShape {\n    straight = ArrowLineShape.straight,\n    curve = ArrowLineShape.curve\n}\n\nexport interface PlaitVectorLine extends PlaitElement {\n    type: 'vector-line';\n    shape: VectorLineShape;\n    points: Point[];\n    strokeColor?: string;\n    strokeWidth?: number;\n    strokeStyle?: StrokeStyle;\n    fill?: string;\n    opacity: number;\n}\n", "import { BasicShapes, FlowchartSymbols, GeometryShapes, PlaitCustomGeometry, PlaitGeometry, UMLSymbols } from './geometry';\nimport { PlaitImage } from './image';\nimport { PlaitArrowLine } from './arrow-line';\nimport { PlaitSwimlane, SwimlaneSymbols } from './swimlane';\nimport { PlaitBaseTable, PlaitTable, PlaitTableElement, TableSymbols } from './table';\nimport { PlaitText } from './text';\nimport { PlaitVectorLine } from './vector-line';\nimport { PlaitLine } from './line';\nimport { PlaitBoard, PlaitOptionsBoard } from '@plait/core';\nimport { WithDrawOptions } from './options';\nimport { WithDrawPluginKey } from '../constants/default';\n\nexport * from './arrow-line';\nexport * from './geometry';\nexport * from './text';\nexport * from './element';\nexport * from './engine';\nexport * from './swimlane';\nexport * from './table';\nexport * from './vector-line';\nexport * from './options';\n\nexport type PlaitDrawElement = PlaitGeometry | PlaitArrowLine | PlaitVectorLine | PlaitImage | PlaitBaseTable | PlaitSwimlane;\n\nexport type PlaitShapeElement = PlaitGeometry | PlaitImage | PlaitTable | PlaitSwimlane;\n\nexport type DrawShapes = GeometryShapes | TableSymbols | SwimlaneSymbols;\n\nexport const PlaitDrawElement = {\n    isGeometry: (value: any): value is PlaitGeometry => {\n        return value.type === 'geometry';\n    },\n    isArrowLine: (value: any): value is PlaitArrowLine => {\n        return value.type === 'arrow-line' || value.type === 'line';\n    },\n    isVectorLine: (value: any): value is PlaitVectorLine => {\n        return value.type === 'vector-line';\n    },\n    isLine: (value: any): value is PlaitLine => {\n        return PlaitDrawElement.isArrowLine(value) || PlaitDrawElement.isVectorLine(value);\n    },\n    isText: (value: any): value is PlaitText => {\n        return value.type === 'geometry' && value.shape === BasicShapes.text;\n    },\n    isImage: (value: any): value is PlaitImage => {\n        return value.type === 'image';\n    },\n    isTable: (value: any): value is PlaitTable => {\n        return PlaitTableElement.isTable(value);\n    },\n    isDrawElement: (value: any): value is PlaitDrawElement => {\n        if (\n            PlaitDrawElement.isGeometry(value) ||\n            PlaitDrawElement.isLine(value) ||\n            PlaitDrawElement.isImage(value) ||\n            PlaitDrawElement.isTable(value) ||\n            PlaitDrawElement.isSwimlane(value)\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    },\n    isCustomGeometryElement: (board: PlaitBoard, value: any): value is PlaitCustomGeometry => {\n        const options = (board as PlaitOptionsBoard).getPluginOptions<WithDrawOptions | undefined>(WithDrawPluginKey);\n        const customGeometryTypes = options?.customGeometryTypes || [];\n        if (customGeometryTypes.includes(value.type)) {\n            return true;\n        } else {\n            return false;\n        }\n    },\n    isShapeElement: (value: any): value is PlaitShapeElement => {\n        return (\n            PlaitDrawElement.isImage(value) ||\n            PlaitDrawElement.isGeometry(value) ||\n            PlaitDrawElement.isTable(value) ||\n            PlaitDrawElement.isSwimlane(value)\n        );\n    },\n    isBasicShape: (value: any) => {\n        return Object.keys(BasicShapes).includes(value.shape);\n    },\n    isFlowchart: (value: any) => {\n        return Object.keys(FlowchartSymbols).includes(value.shape);\n    },\n    isUML: (value: any) => {\n        return Object.keys(UMLSymbols).includes(value.shape);\n    },\n    isSwimlane: (value: any): value is PlaitSwimlane => {\n        return value.type === 'swimlane';\n    },\n    isVerticalSwimlane: (value: any) => {\n        return PlaitDrawElement.isSwimlane(value) && value.shape === SwimlaneSymbols.swimlaneVertical;\n    },\n    isHorizontalSwimlane: (value: any) => {\n        return PlaitDrawElement.isSwimlane(value) && value.shape === SwimlaneSymbols.swimlaneHorizontal;\n    },\n    isUMLClassOrInterface: (value: any) => {\n        return Object.keys(UMLSymbols).includes(value.shape) && [UMLSymbols.class, UMLSymbols.interface].includes(value.shape);\n    },\n    isGeometryByTable: (value: any): value is PlaitBaseTable => {\n        return PlaitDrawElement.isUMLClassOrInterface(value);\n    },\n    isElementByTable: (value: any): value is PlaitBaseTable => {\n        return PlaitDrawElement.isTable(value) || PlaitDrawElement.isSwimlane(value) || PlaitDrawElement.isGeometryByTable(value);\n    }\n};\n", "import {\n    PlaitBoard,\n    PlaitPluginElementContext,\n    OnContextChanged,\n    isSelectionMoving,\n    getSelectedElements,\n    ACTIVE_STROKE_WIDTH,\n    RectangleClient\n} from '@plait/core';\nimport { PlaitCommonGeometry, PlaitGeometry, PlaitMultipleTextGeometry } from './interfaces/geometry';\nimport { GeometryShapeGenerator } from './generators/geometry-shape.generator';\nimport { DrawTransforms } from './transforms';\nimport { ActiveGenerator, CommonElementFlavour, TextManageChangeData, createActiveGenerator, hasResizeHandle } from '@plait/common';\nimport { ArrowLineAutoCompleteGenerator } from './generators/arrow-line-auto-complete.generator';\nimport { getTextRectangle, isGeometryIncludeText, isMultipleTextGeometry, memorizeLatestText } from './utils';\nimport { DrawTextInfo, TextGenerator } from './generators/text.generator';\nimport { SingleTextGenerator } from './generators/single-text.generator';\nimport { PlaitText } from './interfaces';\nimport { GeometryThreshold } from './constants';\nimport { getEngine } from './engines';\n\nexport class GeometryComponent\n    extends CommonElementFlavour<PlaitCommonGeometry, PlaitBoard>\n    implements OnContextChanged<PlaitCommonGeometry, PlaitBoard>\n{\n    activeGenerator!: ActiveGenerator<PlaitCommonGeometry>;\n\n    lineAutoCompleteGenerator!: ArrowLineAutoCompleteGenerator;\n\n    shapeGenerator!: GeometryShapeGenerator;\n\n    textGenerator!: TextGenerator<PlaitMultipleTextGeometry> | SingleTextGenerator;\n\n    constructor() {\n        super();\n    }\n\n    initializeGenerator() {\n        this.activeGenerator = createActiveGenerator(this.board, {\n            getStrokeWidth: () => {\n                const selectedElements = getSelectedElements(this.board);\n                if (selectedElements.length === 1 && !isSelectionMoving(this.board)) {\n                    return ACTIVE_STROKE_WIDTH;\n                } else {\n                    return ACTIVE_STROKE_WIDTH;\n                }\n            },\n            getStrokeOpacity: () => {\n                const selectedElements = getSelectedElements(this.board);\n                if (selectedElements.length === 1 && !isSelectionMoving(this.board)) {\n                    return 1;\n                } else {\n                    return 0.5;\n                }\n            },\n            getRectangle: (element: PlaitCommonGeometry) => {\n                return RectangleClient.getRectangleByPoints(element.points);\n            },\n            hasResizeHandle: () => {\n                return hasResizeHandle(this.board, this.element);\n            }\n        });\n        this.lineAutoCompleteGenerator = new ArrowLineAutoCompleteGenerator(this.board);\n        this.shapeGenerator = new GeometryShapeGenerator(this.board);\n        if (isGeometryIncludeText(this.element)) {\n            this.initializeTextManage();\n        }\n        this.getRef().addGenerator(ArrowLineAutoCompleteGenerator.key, this.lineAutoCompleteGenerator);\n        this.getRef().addGenerator(ActiveGenerator.key, this.activeGenerator);\n        this.getRef().updateActiveSection = () => {\n            this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {\n                selected: this.selected\n            });\n            this.lineAutoCompleteGenerator.processDrawing(this.element as PlaitGeometry, PlaitBoard.getActiveHost(this.board), {\n                selected: this.selected\n            });\n        };\n    }\n\n    initialize(): void {\n        super.initialize();\n        this.initializeGenerator();\n        this.shapeGenerator.processDrawing(this.element as PlaitGeometry, this.getElementG());\n        this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {\n            selected: this.selected\n        });\n        this.lineAutoCompleteGenerator.processDrawing(this.element as PlaitGeometry, PlaitBoard.getElementTopHost(this.board), {\n            selected: this.selected\n        });\n        this.textGenerator && this.textGenerator.draw(this.getElementG());\n    }\n\n    onContextChanged(\n        value: PlaitPluginElementContext<PlaitCommonGeometry, PlaitBoard>,\n        previous: PlaitPluginElementContext<PlaitCommonGeometry, PlaitBoard>\n    ) {\n        if (value.element !== previous.element || value.hasThemeChanged) {\n            this.shapeGenerator.processDrawing(this.element as PlaitGeometry, this.getElementG());\n            this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), { selected: this.selected });\n            this.lineAutoCompleteGenerator.processDrawing(this.element as PlaitGeometry, PlaitBoard.getActiveHost(this.board), {\n                selected: this.selected\n            });\n            this.textGenerator && this.updateText(previous.element, value.element);\n        } else {\n            const hasSameSelected = value.selected === previous.selected;\n            if (!hasSameSelected || value.selected) {\n                this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {\n                    selected: this.selected\n                });\n                this.lineAutoCompleteGenerator.processDrawing(this.element as PlaitGeometry, PlaitBoard.getActiveHost(this.board), {\n                    selected: this.selected\n                });\n            }\n        }\n    }\n\n    updateText(previousElement: PlaitCommonGeometry, currentElement: PlaitCommonGeometry) {\n        if (isMultipleTextGeometry(this.element)) {\n            (this.textGenerator as TextGenerator<PlaitMultipleTextGeometry>).update(\n                this.element,\n                previousElement.texts,\n                currentElement.texts,\n                this.getElementG()\n            );\n        } else {\n            (this.textGenerator as SingleTextGenerator).update(\n                this.element as PlaitGeometry,\n                previousElement.text,\n                currentElement.text,\n                this.getElementG()\n            );\n        }\n    }\n\n    initializeTextManage() {\n        const onTextChange = (element: PlaitCommonGeometry, textManageChangeData: TextManageChangeData, text: DrawTextInfo) => {\n            if (textManageChangeData.newText) {\n                if (isMultipleTextGeometry(element)) {\n                    DrawTransforms.setDrawTexts(this.board, element, {\n                        id: text.id,\n                        text: textManageChangeData.newText,\n                        textHeight: textManageChangeData.height\n                    });\n                } else {\n                    DrawTransforms.setText(\n                        this.board,\n                        element as PlaitGeometry,\n                        textManageChangeData.newText,\n                        textManageChangeData.width,\n                        textManageChangeData.height\n                    );\n                }\n            } else {\n                DrawTransforms.setTextSize(this.board, element as PlaitGeometry, textManageChangeData.width, textManageChangeData.height);\n            }\n            textManageChangeData.operations && memorizeLatestText(element, textManageChangeData.operations);\n        };\n\n        if (isMultipleTextGeometry(this.element)) {\n            this.textGenerator = new TextGenerator<PlaitMultipleTextGeometry>(\n                this.board,\n                this.element as PlaitMultipleTextGeometry,\n                this.element.texts!,\n                {\n                    onChange: onTextChange\n                }\n            );\n        } else {\n            this.textGenerator = new SingleTextGenerator(this.board, this.element as PlaitGeometry, this.element.text, {\n                onChange: onTextChange,\n                getMaxWidth: () => {\n                    let width = getTextRectangle(this.element).width;\n                    const getRectangle = getEngine(this.element.shape).getTextRectangle;\n                    if (getRectangle) {\n                        width = getRectangle(this.element as PlaitGeometry).width;\n                    }\n                    return (this.element as PlaitText)?.autoSize ? GeometryThreshold.defaultTextMaxWidth : width;\n                }\n            });\n        }\n        this.textGenerator.initialize();\n    }\n\n    destroy(): void {\n        super.destroy();\n        this.activeGenerator.destroy();\n        this.lineAutoCompleteGenerator.destroy();\n        this.textGenerator?.destroy();\n    }\n}\n", "import { PlaitBoard, PlaitPluginElementContext, OnContextChanged, getElementById, createDebugGenerator, PlaitNode } from '@plait/core';\nimport { ArrowLineText, PlaitArrowLine, PlaitGeometry } from './interfaces';\nimport { LineActiveGenerator } from './generators/line-active.generator';\nimport { DrawTransforms } from './transforms';\nimport { GeometryThreshold, MIN_TEXT_WIDTH } from './constants';\nimport { CommonElementFlavour, TextManage, TextManageChangeData } from '@plait/common';\nimport { getArrowLineTextRectangle } from './utils/arrow-line/arrow-line-basic';\nimport { memorizeLatestText } from './utils/memorize';\nimport { ArrowLineShapeGenerator } from './generators/arrow-line.generator';\nimport { getArrowLinePoints } from './utils';\n\ninterface BoundedElements {\n    source?: PlaitGeometry;\n    target?: PlaitGeometry;\n}\n\nconst debugKey = 'debug:plait:line-turning';\nconst debugGenerator = createDebugGenerator(debugKey);\n\nexport class ArrowLineComponent\n    extends CommonElementFlavour<PlaitArrowLine, PlaitBoard>\n    implements OnContextChanged<PlaitArrowLine, PlaitBoard>\n{\n    shapeGenerator!: ArrowLineShapeGenerator;\n\n    activeGenerator!: LineActiveGenerator;\n\n    boundedElements: BoundedElements = {};\n\n    constructor() {\n        super();\n    }\n\n    initializeGenerator() {\n        this.shapeGenerator = new ArrowLineShapeGenerator(this.board);\n        this.activeGenerator = new LineActiveGenerator(this.board);\n        this.initializeTextManages();\n    }\n\n    initialize(): void {\n        this.initializeGenerator();\n        this.shapeGenerator.processDrawing(this.element, this.getElementG());\n        const linePoints = getArrowLinePoints(this.board, this.element);\n        this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {\n            selected: this.selected,\n            linePoints\n        });\n        super.initialize();\n        this.boundedElements = this.getBoundedElements();\n        this.drawText();\n        this.getRef().updateActiveSection = () => {\n            const linePoints = getArrowLinePoints(this.board, this.element);\n            this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {\n                selected: this.selected,\n                linePoints\n            });\n        };\n        debugGenerator.isDebug() && debugGenerator.drawCircles(this.board, this.element.points.slice(1, -1), 4, true);\n    }\n\n    getBoundedElements() {\n        const boundedElements: BoundedElements = {};\n        if (this.element.source.boundId) {\n            const boundElement = getElementById<PlaitGeometry>(this.board, this.element.source.boundId);\n            if (boundElement) {\n                boundedElements.source = boundElement;\n            }\n        }\n        if (this.element.target.boundId) {\n            const boundElement = getElementById<PlaitGeometry>(this.board, this.element.target.boundId);\n            if (boundElement) {\n                boundedElements.target = boundElement;\n            }\n        }\n        return boundedElements;\n    }\n\n    onContextChanged(\n        value: PlaitPluginElementContext<PlaitArrowLine, PlaitBoard>,\n        previous: PlaitPluginElementContext<PlaitArrowLine, PlaitBoard>\n    ) {\n        const boundedElements = this.getBoundedElements();\n        const isBoundedElementsChanged =\n            boundedElements.source !== this.boundedElements.source || boundedElements.target !== this.boundedElements.target;\n        this.boundedElements = boundedElements;\n        const linePoints = getArrowLinePoints(this.board, this.element);\n        if (value.element !== previous.element || value.hasThemeChanged) {\n            this.shapeGenerator.processDrawing(this.element, this.getElementG());\n            this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {\n                selected: this.selected,\n                linePoints\n            });\n            this.updateText(previous.element.texts, value.element.texts);\n            this.updateTextRectangle();\n        } else {\n            const needUpdate = value.selected !== previous.selected || this.activeGenerator.needUpdate();\n            if (needUpdate || value.selected) {\n                this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {\n                    selected: this.selected,\n                    linePoints\n                });\n            }\n        }\n        if (isBoundedElementsChanged) {\n            this.shapeGenerator.processDrawing(this.element, this.getElementG());\n            this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {\n                selected: this.selected,\n                linePoints\n            });\n            this.updateTextRectangle();\n            return;\n        }\n    }\n\n    initializeTextManages() {\n        if (this.element.texts?.length) {\n            const textManages: TextManage[] = [];\n            this.element.texts.forEach((text: ArrowLineText, index: number) => {\n                const manage = this.createTextManage(text, index);\n                textManages.push(manage);\n            });\n            this.getRef().initializeTextManage(textManages);\n        }\n    }\n\n    drawText() {\n        if (this.element.texts?.length) {\n            this.getRef()\n                .getTextManages()\n                .forEach((manage, index) => {\n                    manage.draw(this.element.texts![index].text);\n                    this.getElementG().append(manage.g);\n                });\n        }\n    }\n\n    createTextManage(text: ArrowLineText, index: number) {\n        return new TextManage(this.board, {\n            getRectangle: () => {\n                return getArrowLineTextRectangle(this.board, this.element as PlaitArrowLine, index);\n            },\n            onChange: (textManageChangeData: TextManageChangeData) => {\n                const path = PlaitBoard.findPath(this.board, this.element);\n                const node = PlaitNode.get(this.board, path) as PlaitArrowLine;\n                const texts = [...node.texts];\n                const newWidth = textManageChangeData.width < MIN_TEXT_WIDTH ? MIN_TEXT_WIDTH : textManageChangeData.width;\n                texts.splice(index, 1, {\n                    text: textManageChangeData.newText ? textManageChangeData.newText : this.element.texts[index].text,\n                    position: this.element.texts[index].position,\n                    width: newWidth,\n                    height: textManageChangeData.height\n                });\n                DrawTransforms.setArrowLineTexts(this.board, this.element as PlaitArrowLine, texts);\n                textManageChangeData.operations && memorizeLatestText(this.element, textManageChangeData.operations);\n            },\n            getMaxWidth: () => GeometryThreshold.defaultTextMaxWidth,\n            textPlugins: []\n        });\n    }\n\n    updateText(previousTexts: ArrowLineText[], currentTexts: ArrowLineText[]) {\n        if (previousTexts === currentTexts) return;\n        const previousTextsLength = previousTexts.length;\n        const currentTextsLength = currentTexts.length;\n        const textManages = this.getRef().getTextManages();\n        if (currentTextsLength === previousTextsLength) {\n            for (let i = 0; i < previousTextsLength; i++) {\n                if (previousTexts[i].text !== currentTexts[i].text) {\n                    textManages[i].updateText(currentTexts[i].text);\n                }\n            }\n        } else {\n            this.getRef().destroyTextManage();\n            this.initializeTextManages();\n            this.drawText();\n        }\n    }\n\n    updateTextRectangle() {\n        const textManages = this.getRef().getTextManages();\n        textManages.forEach((manage) => {\n            manage.updateRectangle();\n        });\n    }\n\n    destroy(): void {\n        super.destroy();\n        this.activeGenerator.destroy();\n        this.getRef().destroyTextManage();\n    }\n}\n", "import { PlaitBoard, PlaitPluginElementContext, OnContextChanged } from '@plait/core';\nimport { PlaitVectorLine } from './interfaces';\nimport { LineActiveGenerator } from './generators/line-active.generator';\nimport { CommonElementFlavour } from '@plait/common';\nimport { getVectorLinePoints } from './utils';\nimport { VectorLineShapeGenerator } from './generators/vector-line-generator';\n\nexport class VectorLineComponent\n    extends CommonElementFlavour<PlaitVectorLine, PlaitBoard>\n    implements OnContextChanged<PlaitVectorLine, PlaitBoard>\n{\n    shapeGenerator!: VectorLineShapeGenerator;\n\n    activeGenerator!: LineActiveGenerator;\n\n    constructor() {\n        super();\n    }\n\n    initializeGenerator() {\n        this.shapeGenerator = new VectorLineShapeGenerator(this.board);\n        this.activeGenerator = new LineActiveGenerator(this.board);\n        this.getRef().updateActiveSection = () => {\n            const linePoints = getVectorLinePoints(this.board, this.element)!;\n            this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {\n                selected: this.selected,\n                linePoints\n            });\n        };\n    }\n\n    initialize(): void {\n        this.initializeGenerator();\n        this.shapeGenerator.processDrawing(this.element, this.getElementG());\n        const linePoints = getVectorLinePoints(this.board, this.element)!;\n        this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {\n            selected: this.selected,\n            linePoints\n        });\n        super.initialize();\n    }\n\n    onContextChanged(\n        value: PlaitPluginElementContext<PlaitVectorLine, PlaitBoard>,\n        previous: PlaitPluginElementContext<PlaitVectorLine, PlaitBoard>\n    ) {\n        const linePoints = getVectorLinePoints(this.board, this.element)!;\n        if (value.element !== previous.element || value.hasThemeChanged) {\n            this.shapeGenerator.processDrawing(this.element, this.getElementG());\n            this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {\n                selected: this.selected,\n                linePoints\n            });\n        } else {\n            const needUpdate = value.selected !== previous.selected || this.activeGenerator.needUpdate() || value.selected;\n            if (needUpdate) {\n                this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {\n                    selected: this.selected,\n                    linePoints\n                });\n            }\n        }\n    }\n\n    destroy(): void {\n        super.destroy();\n        this.activeGenerator.destroy();\n    }\n}\n", "import { PlaitBoard, getHitElementByPoint, getSelectedElements, toHostPoint, toViewBoxPoint } from '@plait/core';\nimport { isVirtualKey, isSpaceHotkey, isDelete } from '@plait/common';\nimport { GeometryCommonTextKeys, PlaitDrawElement } from '../interfaces';\nimport { editText } from '../utils/geometry';\nimport { getHitMultipleGeometryText, isDrawElementIncludeText, isMultipleTextGeometry } from '../utils';\n\nexport const withDrawHotkey = (board: PlaitBoard) => {\n    const { keyDown, dblClick } = board;\n\n    board.keyDown = (event: KeyboardEvent) => {\n        const selectedElements = getSelectedElements(board);\n        const isSingleSelection = selectedElements.length === 1;\n        const targetElement = selectedElements[0];\n        if (\n            !PlaitBoard.isReadonly(board) &&\n            !isVirtualKey(event) &&\n            !isDelete(event) &&\n            !isSpaceHotkey(event) &&\n            isSingleSelection &&\n            PlaitDrawElement.isGeometry(targetElement)\n        ) {\n            event.preventDefault();\n            editText(board, targetElement);\n            return;\n        }\n\n        keyDown(event);\n    };\n\n    board.dblClick = (event: MouseEvent) => {\n        event.preventDefault();\n        if (!PlaitBoard.isReadonly(board)) {\n            const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n            const hitElement = getHitElementByPoint(board, point, undefined, false);\n            if (hitElement && PlaitDrawElement.isGeometry(hitElement) && isDrawElementIncludeText(hitElement)) {\n                if (isMultipleTextGeometry(hitElement)) {\n                    const hitText =\n                        getHitMultipleGeometryText(hitElement, point) ||\n                        hitElement.texts.find((item) => item.id.includes(GeometryCommonTextKeys.content)) ||\n                        hitElement.texts[0];\n                    editText(board, hitElement, hitText);\n                } else {\n                    editText(board, hitElement);\n                }\n            }\n        }\n        dblClick(event);\n    };\n    return board;\n};\n", "import { PlaitBoard, Point, RectangleClient, createG, getI18nValue, toHostPoint, toViewBoxPoint } from '@plait/core';\nimport { BasicShapes, GeometryShapes, PlaitCommonGeometry, PlaitDrawElement, PlaitGeometry } from '../interfaces';\nimport { GeometryShapeGenerator } from '../generators/geometry-shape.generator';\nimport {\n    createDefaultGeometry,\n    createTextElement,\n    getDefaultGeometryPoints,\n    getTextShapeProperty,\n    getMemorizedLatestByPointer,\n    getTextRectangle,\n    insertElement,\n    getDefaultGeometryText\n} from '../utils';\nimport { DrawPointerType, getGeometryPointers } from '../constants';\nimport {\n    normalizeShapePoints,\n    isDndMode,\n    isDrawingMode,\n    getDirectionFactorByDirectionComponent,\n    getUnitVectorByPointAndPoint,\n    TextManage\n} from '@plait/common';\nimport { isKeyHotkey } from 'is-hotkey';\nimport { getSnapResizingRef } from '../utils/snap-resizing';\nimport { getGeometryGeneratorByShape } from '../utils/shape';\n\nexport interface FakeCreateTextRef {\n    g: SVGGElement;\n    textManage: TextManage;\n}\n\nconst isGeometryDndMode = (board: PlaitBoard) => {\n    const geometryPointers = getGeometryPointers();\n    const isGeometryPointer = PlaitBoard.isInPointer(board, geometryPointers);\n    const dndMode = isGeometryPointer && isDndMode(board);\n    return dndMode;\n};\n\nconst isGeometryDrawingMode = (board: PlaitBoard) => {\n    const geometryPointers = getGeometryPointers();\n    const isGeometryPointer = PlaitBoard.isInPointer(board, geometryPointers);\n    const drawingMode = isGeometryPointer && isDrawingMode(board);\n    return drawingMode;\n};\n\nexport const withGeometryCreateByDrag = (board: PlaitBoard) => {\n    const { pointerMove, globalPointerUp, pointerUp } = board;\n\n    let geometryShapeG: SVGGElement | null = null;\n\n    let temporaryElement: PlaitCommonGeometry | null = null;\n\n    let fakeCreateTextRef: FakeCreateTextRef | null = null;\n\n    board.pointerMove = (event: PointerEvent) => {\n        geometryShapeG?.remove();\n        geometryShapeG = createG();\n\n        const geometryPointers = getGeometryPointers();\n        const isGeometryPointer = PlaitBoard.isInPointer(board, geometryPointers);\n        const dragMode = isGeometryPointer && isDndMode(board);\n        const movingPoint = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n        const pointer = PlaitBoard.getPointer(board) as DrawPointerType;\n        const geometryGenerator = getGeometryGeneratorByShape(board, pointer);\n        if (dragMode) {\n            const memorizedLatest = getMemorizedLatestByPointer(pointer);\n            if (pointer === BasicShapes.text) {\n                const property = getTextShapeProperty(board, getDefaultGeometryText(board), memorizedLatest.textProperties['font-size']);\n                const points = RectangleClient.getPoints(\n                    RectangleClient.getRectangleByCenterPoint(movingPoint, property.width, property.height)\n                );\n                temporaryElement = createTextElement(board, points, getDefaultGeometryText(board));\n                if (!fakeCreateTextRef) {\n                    const textManage = new TextManage(board, {\n                        getRectangle: () => {\n                            return getTextRectangle(temporaryElement!);\n                        }\n                    });\n                    textManage.draw(temporaryElement!.text);\n                    fakeCreateTextRef = {\n                        g: createG(),\n                        textManage\n                    };\n\n                    PlaitBoard.getHost(board).append(fakeCreateTextRef.g);\n                    fakeCreateTextRef.g.append(textManage.g);\n                } else {\n                    fakeCreateTextRef.textManage.updateRectangle();\n                    fakeCreateTextRef.g.append(fakeCreateTextRef.textManage.g);\n                }\n            } else {\n                const points = getDefaultGeometryPoints(pointer, movingPoint);\n                temporaryElement = createDefaultGeometry(board, points, pointer as GeometryShapes);\n                geometryGenerator.processDrawing(temporaryElement as PlaitGeometry, geometryShapeG);\n                PlaitBoard.getElementTopHost(board).append(geometryShapeG);\n            }\n        }\n\n        pointerMove(event);\n    };\n\n    board.pointerUp = (event: PointerEvent) => {\n        if (isGeometryDndMode(board) && temporaryElement) {\n            return;\n        }\n        pointerUp(event);\n    };\n\n    board.globalPointerUp = (event: PointerEvent) => {\n        if (isGeometryDndMode(board) && temporaryElement) {\n            insertElement(board, temporaryElement);\n            fakeCreateTextRef?.textManage.destroy();\n            fakeCreateTextRef?.g.remove();\n            fakeCreateTextRef = null;\n        }\n        temporaryElement = null;\n        geometryShapeG?.remove();\n        geometryShapeG = null;\n        globalPointerUp(event);\n    };\n\n    return board;\n};\n\nexport const withGeometryCreateByDrawing = (board: PlaitBoard) => {\n    const { pointerDown, pointerMove, pointerUp, keyDown, keyUp } = board;\n    let start: Point | null = null;\n\n    let geometryShapeG: SVGGElement | null = null;\n\n    let temporaryElement: PlaitCommonGeometry | null = null;\n\n    let isShift = false;\n\n    let snapG: SVGGElement | null;\n\n    board.keyDown = (event: KeyboardEvent) => {\n        isShift = isKeyHotkey('shift', event);\n        keyDown(event);\n    };\n\n    board.keyUp = (event: KeyboardEvent) => {\n        isShift = false;\n        keyUp(event);\n    };\n\n    board.pointerDown = (event: PointerEvent) => {\n        if (!PlaitBoard.isReadonly(board) && isGeometryDrawingMode(board)) {\n            const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n            start = point;\n            const pointer = PlaitBoard.getPointer(board) as DrawPointerType;\n            if (pointer === BasicShapes.text) {\n                const memorizedLatest = getMemorizedLatestByPointer(pointer);\n                const property = getTextShapeProperty(board, getDefaultGeometryText(board), memorizedLatest.textProperties['font-size']);\n                const points = RectangleClient.getPoints(RectangleClient.getRectangleByCenterPoint(point, property.width, property.height));\n                const textElement = createTextElement(board, points, getDefaultGeometryText(board));\n                insertElement(board, textElement);\n                start = null;\n            }\n        }\n        pointerDown(event);\n    };\n\n    board.pointerMove = (event: PointerEvent) => {\n        geometryShapeG?.remove();\n        geometryShapeG = createG();\n        const movingPoint = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n        const pointer = PlaitBoard.getPointer(board) as DrawPointerType;\n        const geometryGenerator = getGeometryGeneratorByShape(board, pointer);\n\n        snapG?.remove();\n        if (start && isGeometryDrawingMode(board)) {\n            let points: [Point, Point] = normalizeShapePoints([start, movingPoint], isShift);\n            const activeRectangle = RectangleClient.getRectangleByPoints(points);\n            const [x, y] = getUnitVectorByPointAndPoint(start, movingPoint);\n            const resizeSnapRef = getSnapResizingRef(board, [], {\n                resizePoints: points,\n                activeRectangle,\n                directionFactors: [getDirectionFactorByDirectionComponent(x), getDirectionFactorByDirectionComponent(y)],\n                isAspectRatio: isShift,\n                isFromCorner: true,\n                isCreate: true\n            });\n            snapG = resizeSnapRef.snapG;\n            PlaitBoard.getElementTopHost(board).append(snapG);\n            points = normalizeShapePoints(resizeSnapRef.activePoints as [Point, Point], isShift);\n            temporaryElement = createDefaultGeometry(board, points, pointer as GeometryShapes);\n            geometryGenerator.processDrawing(temporaryElement as PlaitGeometry, geometryShapeG);\n            PlaitBoard.getElementTopHost(board).append(geometryShapeG);\n        }\n        pointerMove(event);\n    };\n\n    board.pointerUp = (event: PointerEvent) => {\n        if (isGeometryDrawingMode(board) && start) {\n            const targetPoint = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n            const { width, height } = RectangleClient.getRectangleByPoints([start!, targetPoint]);\n            if (Math.hypot(width, height) < 8) {\n                const pointer = PlaitBoard.getPointer(board) as DrawPointerType;\n                if (pointer !== BasicShapes.text) {\n                    const points = getDefaultGeometryPoints(pointer, targetPoint);\n                    temporaryElement = createDefaultGeometry(board, points, pointer as GeometryShapes);\n                }\n            }\n            if (temporaryElement) {\n                insertElement(board, temporaryElement);\n            }\n            snapG?.remove();\n            geometryShapeG?.remove();\n            geometryShapeG = null;\n            start = null;\n            temporaryElement = null;\n            return;\n        }\n        pointerUp(event);\n    };\n    return board;\n};\n", "import {\n    ClipboardData,\n    PlaitBoard,\n    PlaitElement,\n    Point,\n    RectangleClient,\n    WritableClipboardContext,\n    WritableClipboardOperationType,\n    WritableClipboardType,\n    addOrCreateClipboardContext,\n    getSelectedElements\n} from '@plait/core';\nimport { getSelectedDrawElements } from '../utils/selected';\nimport { PlaitDrawElement, PlaitGeometry, PlaitArrowLine, PlaitShapeElement, PlaitSwimlane, PlaitVectorLine } from '../interfaces';\nimport { buildClipboardData, insertClipboardData } from '../utils/clipboard';\nimport { DrawTransforms } from '../transforms';\nimport { getArrowLines } from '../utils/arrow-line/arrow-line-basic';\nimport { PlaitImage } from '../interfaces/image';\nimport { acceptImageTypes, buildImage, getElementOfFocusedImage, getElementsText } from '@plait/common';\nimport { DEFAULT_IMAGE_WIDTH } from '../constants';\nimport { PlaitTable } from '../interfaces/table';\n\nexport const withDrawFragment = (baseBoard: PlaitBoard) => {\n    const board = baseBoard as PlaitBoard;\n    const { getDeletedFragment, buildFragment, insertFragment } = board;\n\n    board.getDeletedFragment = (data: PlaitElement[]) => {\n        const drawElements = getSelectedDrawElements(board);\n        if (drawElements.length) {\n            const geometryElements = drawElements.filter(value => PlaitDrawElement.isGeometry(value)) as PlaitGeometry[];\n            const arrowLineElements = drawElements.filter(value => PlaitDrawElement.isArrowLine(value)) as PlaitArrowLine[];\n            const vectorLineElements = drawElements.filter(value => PlaitDrawElement.isVectorLine(value)) as PlaitVectorLine[];\n            const imageElements = drawElements.filter(value => PlaitDrawElement.isImage(value)) as PlaitImage[];\n            const tableElements = drawElements.filter(value => PlaitDrawElement.isTable(value)) as PlaitTable[];\n            const swimlaneElements = drawElements.filter(value => PlaitDrawElement.isSwimlane(value)) as PlaitSwimlane[];\n\n            const boundLineElements = [\n                ...getBoundedArrowLineElements(board, geometryElements),\n                ...getBoundedArrowLineElements(board, imageElements),\n                ...getBoundedArrowLineElements(board, tableElements),\n                ...getBoundedArrowLineElements(board, swimlaneElements)\n            ].filter(line => !arrowLineElements.includes(line));\n            data.push(\n                ...[\n                    ...geometryElements,\n                    ...arrowLineElements,\n                    ...vectorLineElements,\n                    ...imageElements,\n                    ...tableElements,\n                    ...swimlaneElements,\n                    ...boundLineElements.filter(line => !arrowLineElements.includes(line))\n                ]\n            );\n        }\n        return getDeletedFragment(data);\n    };\n\n    board.buildFragment = (\n        clipboardContext: WritableClipboardContext | null,\n        rectangle: RectangleClient | null,\n        operationType: WritableClipboardOperationType,\n        originData?: PlaitElement[]\n    ) => {\n        const targetDrawElements = getSelectedDrawElements(board, originData);\n        let boundLineElements: PlaitArrowLine[] = [];\n        if (targetDrawElements.length) {\n            if (operationType === WritableClipboardOperationType.cut) {\n                const geometryElements = targetDrawElements.filter(value => PlaitDrawElement.isGeometry(value)) as PlaitGeometry[];\n                const lineElements = targetDrawElements.filter(value => PlaitDrawElement.isArrowLine(value)) as PlaitArrowLine[];\n                boundLineElements = getBoundedArrowLineElements(board, geometryElements).filter(line => !lineElements.includes(line));\n            }\n            const selectedElements = [...targetDrawElements, ...boundLineElements];\n            const elements = buildClipboardData(board, selectedElements, rectangle ? [rectangle.x, rectangle.y] : [0, 0]);\n            const text = getElementsText(selectedElements);\n            const addition: WritableClipboardContext = {\n                text,\n                type: WritableClipboardType.elements,\n                elements: elements\n            };\n            clipboardContext = addOrCreateClipboardContext(clipboardContext, addition);\n        }\n        return buildFragment(clipboardContext, rectangle, operationType, originData);\n    };\n\n    board.insertFragment = (clipboardData: ClipboardData | null, targetPoint: Point, operationType?: WritableClipboardOperationType) => {\n        const selectedElements = getSelectedElements(board);\n        if (clipboardData?.files?.length) {\n            const acceptImageArray = acceptImageTypes.map(type => 'image/' + type);\n            const canInsertionImage =\n                !getElementOfFocusedImage(board) && !(selectedElements.length === 1 && board.isImageBindingAllowed(selectedElements[0]));\n            if (acceptImageArray.includes(clipboardData.files[0].type) && canInsertionImage) {\n                const imageFile = clipboardData.files[0];\n                buildImage(board, imageFile, DEFAULT_IMAGE_WIDTH, imageItem => {\n                    DrawTransforms.insertImage(board, imageItem, targetPoint);\n                });\n                return;\n            }\n        }\n\n        if (clipboardData?.elements?.length) {\n            const drawElements = clipboardData.elements?.filter(value => PlaitDrawElement.isDrawElement(value)) as PlaitDrawElement[];\n            if (clipboardData.elements && clipboardData.elements.length > 0 && drawElements.length > 0) {\n                insertClipboardData(board, drawElements, targetPoint);\n            }\n        }\n\n        if (clipboardData?.text) {\n            if (!clipboardData.elements || clipboardData.elements.length === 0) {\n                // (*￣︶￣)\n                const insertAsChildren = selectedElements.length === 1 && selectedElements[0].children;\n                const insertAsFreeText = !insertAsChildren;\n                if (insertAsFreeText) {\n                    DrawTransforms.insertText(board, targetPoint, clipboardData.text);\n                    return;\n                }\n            }\n        }\n\n        insertFragment(clipboardData, targetPoint, operationType);\n    };\n\n    return board;\n};\n\nexport const getBoundedArrowLineElements = (board: PlaitBoard, plaitShapes: PlaitShapeElement[]) => {\n    const lines = getArrowLines(board);\n    return lines.filter(line =>\n        plaitShapes.find(shape => PlaitArrowLine.isBoundElementOfSource(line, shape) || PlaitArrowLine.isBoundElementOfTarget(line, shape))\n    );\n};\n", "import {\n    BoardTransforms,\n    PlaitBoard,\n    PlaitPointerType,\n    Point,\n    Transforms,\n    addSelectedElement,\n    clearSelectedElement,\n    createG,\n    toHostPoint,\n    toViewBoxPoint\n} from '@plait/core';\nimport { ArrowLineShape, PlaitArrowLine, PlaitShapeElement } from '../../interfaces';\nimport { getArrowLinePointers } from '../../constants';\nimport { isDrawingMode } from '@plait/common';\nimport { handleArrowLineCreating } from '../../utils/arrow-line/arrow-line-basic';\nimport { getSnappingShape } from '../../utils';\n\nexport const withArrowLineCreateByDraw = (board: PlaitBoard) => {\n    const { pointerDown, pointerMove, globalPointerUp } = board;\n\n    let start: Point | null = null;\n\n    let sourceElement: PlaitShapeElement | null;\n\n    let lineShapeG: SVGGElement | null = null;\n\n    let temporaryElement: PlaitArrowLine | null = null;\n\n    board.pointerDown = (event: PointerEvent) => {\n        const linePointers = getArrowLinePointers();\n        const isLinePointer = PlaitBoard.isInPointer(board, linePointers);\n        if (!PlaitBoard.isReadonly(board) && isLinePointer && isDrawingMode(board)) {\n            const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n            start = point;\n            const hitElement = getSnappingShape(board, point);\n            if (hitElement) {\n                sourceElement = hitElement;\n            }\n        }\n        pointerDown(event);\n    };\n\n    board.pointerMove = (event: PointerEvent) => {\n        lineShapeG?.remove();\n        lineShapeG = createG();\n        let movingPoint = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n        if (start) {\n            const lineShape = PlaitBoard.getPointer(board) as ArrowLineShape;\n            temporaryElement = handleArrowLineCreating(board, lineShape, start, movingPoint, sourceElement, lineShapeG);\n        }\n\n        pointerMove(event);\n    };\n\n    board.globalPointerUp = (event: PointerEvent) => {\n        if (temporaryElement) {\n            Transforms.insertNode(board, temporaryElement, [board.children.length]);\n            clearSelectedElement(board);\n            addSelectedElement(board, temporaryElement);\n            BoardTransforms.updatePointerType(board, PlaitPointerType.selection);\n        }\n        lineShapeG?.remove();\n        lineShapeG = null;\n        sourceElement = null;\n        start = null;\n        temporaryElement = null;\n        globalPointerUp(event);\n    };\n\n    return board;\n};\n", "import { Path, PlaitBoard, PlaitNode, Point } from '@plait/core';\nimport { ResizeRef, ResizeState, WithResizeOptions, simplifyOrthogonalPoints, withResize } from '@plait/common';\nimport { getSelectedArrowLineElements } from '../../utils/selected';\nimport { getHitLineResizeHandleRef, LineResizeHandle } from '../../utils/position/line';\nimport { ArrowLineHandle, ArrowLineShape, PlaitArrowLine } from '../../interfaces';\nimport { DrawTransforms } from '../../transforms';\nimport { getElbowPoints, getNextRenderPoints, isUseDefaultOrthogonalRoute } from '../../utils/arrow-line/elbow';\nimport {\n    alignElbowSegment,\n    alignPoints,\n    getIndexAndDeleteCountByKeyPoint,\n    getResizedPreviousAndNextPoint,\n    hasIllegalElbowPoint\n} from '../../utils/arrow-line/arrow-line-resize';\nimport { getHitConnection, getArrowLinePoints } from '../../utils/arrow-line/arrow-line-basic';\nimport { getElbowLineRouteOptions } from '../../utils/arrow-line';\nimport { getSnappingShape } from '../../utils';\n\nexport const withArrowLineResize = (board: PlaitBoard) => {\n    let elbowLineIndex: number | null;\n    let elbowLineDeleteCount: number | null;\n    let elbowSourcePoint: Point | null;\n    let elbowTargetPoint: Point | null;\n    let elbowNextRenderPoints: Point[] | null;\n\n    const options: WithResizeOptions<PlaitArrowLine, LineResizeHandle> = {\n        key: 'draw-line',\n        canResize: () => {\n            return true;\n        },\n        hitTest: (point: Point) => {\n            const selectedLineElements = getSelectedArrowLineElements(board);\n            if (selectedLineElements.length > 0) {\n                let result = null;\n                selectedLineElements.forEach((value) => {\n                    const handleRef = getHitLineResizeHandleRef(board, value, point);\n                    if (handleRef) {\n                        result = {\n                            element: value,\n                            handle: handleRef.handle,\n                            handleIndex: handleRef.handleIndex\n                        };\n                    }\n                });\n                return result;\n            }\n            return null;\n        },\n        beforeResize: (resizeRef: ResizeRef<PlaitArrowLine, LineResizeHandle>) => {\n            if (\n                resizeRef.element.shape === ArrowLineShape.elbow &&\n                resizeRef.handle !== LineResizeHandle.source &&\n                resizeRef.handle !== LineResizeHandle.target\n            ) {\n                const params = getElbowLineRouteOptions(board, resizeRef.element);\n                if (isUseDefaultOrthogonalRoute(resizeRef.element, params)) {\n                    return;\n                }\n                const points: Point[] = [...resizeRef.element.points];\n                const handleIndex = resizeRef.handleIndex!;\n                const pointsOnElbow = getElbowPoints(board, resizeRef.element);\n                elbowSourcePoint = pointsOnElbow[0];\n                elbowTargetPoint = pointsOnElbow[pointsOnElbow.length - 1];\n                elbowNextRenderPoints = getNextRenderPoints(board, resizeRef.element, pointsOnElbow);\n\n                const value = getIndexAndDeleteCountByKeyPoint(board, resizeRef.element, [...points], elbowNextRenderPoints, handleIndex);\n                elbowLineIndex = value.index;\n                elbowLineDeleteCount = value.deleteCount;\n            }\n        },\n        onResize: (resizeRef: ResizeRef<PlaitArrowLine, LineResizeHandle>, resizeState: ResizeState) => {\n            let points: Point[] = [...resizeRef.element.points];\n            let source: ArrowLineHandle = { ...resizeRef.element.source };\n            let target: ArrowLineHandle = { ...resizeRef.element.target };\n            let handleIndex = resizeRef.handleIndex!;\n            const hitElement = getSnappingShape(board, resizeState.endPoint);\n            if (resizeRef.handle === LineResizeHandle.source || resizeRef.handle === LineResizeHandle.target) {\n                const object = resizeRef.handle === LineResizeHandle.source ? source : target;\n                points[handleIndex] = resizeState.endPoint;\n                if (hitElement) {\n                    object.connection = getHitConnection(board, resizeState.endPoint, hitElement);\n                    object.boundId = hitElement.id;\n                } else {\n                    object.connection = undefined;\n                    object.boundId = undefined;\n                }\n            } else {\n                if (resizeRef.element.shape === ArrowLineShape.elbow) {\n                    if (elbowNextRenderPoints && elbowSourcePoint && elbowTargetPoint) {\n                        const resizedPreviousAndNextPoint = getResizedPreviousAndNextPoint(\n                            elbowNextRenderPoints,\n                            elbowSourcePoint,\n                            elbowTargetPoint,\n                            handleIndex\n                        );\n                        const startKeyPoint = elbowNextRenderPoints[handleIndex];\n                        const endKeyPoint = elbowNextRenderPoints[handleIndex + 1];\n                        const [newStartPoint, newEndPoint] = alignElbowSegment(\n                            startKeyPoint,\n                            endKeyPoint,\n                            resizeState,\n                            resizedPreviousAndNextPoint\n                        );\n                        let midDataPoints: Point[] = [...points].slice(1, points.length - 1);\n                        if (elbowLineIndex !== null && elbowLineDeleteCount !== null) {\n                            if (hasIllegalElbowPoint(midDataPoints)) {\n                                midDataPoints = [newStartPoint, newEndPoint];\n                            } else {\n                                midDataPoints.splice(elbowLineIndex, elbowLineDeleteCount, newStartPoint, newEndPoint);\n                            }\n                            points = [elbowSourcePoint, ...midDataPoints, elbowTargetPoint];\n                        }\n                    }\n                } else {\n                    if (resizeRef.handle === LineResizeHandle.addHandle) {\n                        points.splice(handleIndex + 1, 0, resizeState.endPoint);\n                    } else {\n                        points[handleIndex] = resizeState.endPoint;\n                    }\n                }\n            }\n\n            if (!hitElement) {\n                handleIndex = resizeRef.handle === LineResizeHandle.addHandle ? handleIndex + 1 : handleIndex;\n                const drawPoints = getArrowLinePoints(board, resizeRef.element);\n                const newPoints = [...points];\n                newPoints[0] = drawPoints[0];\n                newPoints[newPoints.length - 1] = drawPoints[drawPoints.length - 1];\n                if (\n                    resizeRef.element.shape !== ArrowLineShape.elbow ||\n                    (resizeRef.element.shape === ArrowLineShape.elbow && newPoints.length === 2)\n                ) {\n                    newPoints.forEach((point, index) => {\n                        if (index === handleIndex) return;\n                        if (points[handleIndex]) {\n                            points[handleIndex] = alignPoints(point, points[handleIndex]);\n                        }\n                    });\n                }\n            }\n            DrawTransforms.resizeArrowLine(board, { points, source, target }, resizeRef.path as Path);\n        },\n        afterResize: (resizeRef: ResizeRef<PlaitArrowLine, LineResizeHandle>) => {\n            if (resizeRef.element.shape === ArrowLineShape.elbow) {\n                const element = PlaitNode.get(board, resizeRef.path as Path);\n                let points = element && [...element.points!];\n                if (points.length > 2 && elbowNextRenderPoints && elbowSourcePoint && elbowTargetPoint) {\n                    const nextSourcePoint = elbowNextRenderPoints[0];\n                    const nextTargetPoint = elbowNextRenderPoints[elbowNextRenderPoints.length - 1];\n                    points.splice(0, 1, nextSourcePoint);\n                    points.splice(-1, 1, nextTargetPoint);\n                    points = simplifyOrthogonalPoints(points!);\n                    if (Point.isEquals(points[0], nextSourcePoint)) {\n                        points.splice(0, 1);\n                    }\n                    if (Point.isEquals(points[points.length - 1], nextTargetPoint)) {\n                        points.pop();\n                    }\n                    if (points.length === 1) {\n                        points = [];\n                    }\n                    points = [elbowSourcePoint, ...points, elbowTargetPoint];\n                    DrawTransforms.resizeArrowLine(board, { points }, resizeRef.path as Path);\n                }\n            }\n            elbowLineIndex = null;\n            elbowLineDeleteCount = null;\n            elbowSourcePoint = null;\n            elbowTargetPoint = null;\n            elbowNextRenderPoints = null;\n        }\n    };\n\n    withResize<PlaitArrowLine, LineResizeHandle>(board, options);\n\n    return board;\n};\n", "import {\n    SNAPPING_STROKE_WIDTH,\n    PlaitBoard,\n    PlaitElement,\n    RectangleClient,\n    SELECTION_BORDER_COLOR,\n    drawCircle,\n    hasValidAngle,\n    setAngleForG,\n    toHostPoint,\n    toViewBoxPoint\n} from '@plait/core';\nimport { ArrowLineShape, PlaitDrawElement } from '../../interfaces';\nimport { isResizingByCondition } from '@plait/common';\nimport { LineResizeHandle } from '../../utils/position/line';\nimport { drawBoundReaction, getHitShape, getSnappingRef } from '../../utils';\n\nexport const withArrowLineBoundReaction = (board: PlaitBoard) => {\n    const { pointerMove, pointerUp } = board;\n\n    let boundShapeG: SVGGElement | null = null;\n\n    board.pointerMove = (event: PointerEvent) => {\n        boundShapeG?.remove();\n        if (PlaitBoard.isReadonly(board)) {\n            pointerMove(event);\n            return;\n        }\n        const linePointers = Object.keys(ArrowLineShape);\n        const isLinePointer = PlaitBoard.isInPointer(board, linePointers);\n        const movingPoint = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n        const isLineResizing = isResizingByCondition<PlaitElement, LineResizeHandle>(board, (resizeRef) => {\n            const { element, handle } = resizeRef;\n            const isSourceOrTarget = handle === LineResizeHandle.target || handle === LineResizeHandle.source;\n            return PlaitDrawElement.isArrowLine(element) && isSourceOrTarget;\n        });\n        if (isLinePointer || isLineResizing) {\n            const hitElement = getHitShape(board, movingPoint);\n            if (hitElement) {\n                const ref = getSnappingRef(board, hitElement, movingPoint);\n                const isSnapping = ref.isHitEdge || ref.isHitConnector;\n                boundShapeG = drawBoundReaction(board, hitElement, { hasMask: isSnapping, hasConnector: true });\n                if (isSnapping) {\n                    const circleG = drawCircle(PlaitBoard.getRoughSVG(board), ref.connectorPoint || ref.edgePoint, 6, {\n                        stroke: SELECTION_BORDER_COLOR,\n                        strokeWidth: SNAPPING_STROKE_WIDTH,\n                        fill: SELECTION_BORDER_COLOR,\n                        fillStyle: 'solid'\n                    });\n                    boundShapeG.appendChild(circleG);\n                }\n                if (hasValidAngle(hitElement)) {\n                    setAngleForG(boundShapeG, RectangleClient.getCenterPointByPoints(hitElement.points), hitElement.angle!);\n                }\n                PlaitBoard.getElementTopHost(board).append(boundShapeG);\n            }\n        }\n        pointerMove(event);\n    };\n\n    board.pointerUp = (event) => {\n        boundShapeG?.remove();\n        boundShapeG = null;\n        pointerUp(event);\n    };\n\n    return board;\n};\n", "import {\n    PlaitBoard,\n    PlaitNode,\n    getHitElementByPoint,\n    getI18nValue,\n    getNearestPointBetweenPointAndSegments,\n    toHostPoint,\n    toViewBoxPoint\n} from '@plait/core';\nimport { PlaitArrowLine, PlaitDrawElement } from '../../interfaces';\nimport { Node } from 'slate';\nimport { buildText, DEFAULT_FONT_FAMILY, getMemorizedLatest, getRatioByPoint, getTextManages, measureElement } from '@plait/common';\nimport { DrawTransforms } from '../../transforms';\nimport { getArrowLinePoints } from '../../utils/arrow-line/arrow-line-basic';\nimport { getHitArrowLineTextIndex } from '../../utils/position/arrow-line';\nimport { isHitArrowLineText } from '../../utils/hit';\nimport { LINE_TEXT } from '../../constants/line';\nimport { DEFAULT_FONT_SIZE } from '@plait/text-plugins';\nimport { DrawI18nKey } from '../../constants/default';\n\nexport const getDefaultLineText = (board: PlaitBoard) => {\n    return getI18nValue(board, DrawI18nKey.lineText, LINE_TEXT);\n};\n\nexport const withArrowLineText = (board: PlaitBoard) => {\n    const { dblClick } = board;\n\n    board.dblClick = (event: MouseEvent) => {\n        if (!PlaitBoard.isReadonly(board)) {\n            const clickPoint = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n            const hitTarget = getHitElementByPoint(board, clickPoint) as undefined | PlaitArrowLine;\n            if (hitTarget && PlaitDrawElement.isArrowLine(hitTarget)) {\n                const hitTargetPath = hitTarget && PlaitBoard.findPath(board, hitTarget);\n                const points = getArrowLinePoints(board, hitTarget);\n                const point = getNearestPointBetweenPointAndSegments(clickPoint, points);\n                const texts = hitTarget.texts?.length ? [...hitTarget.texts] : [];\n                const textIndex = getHitArrowLineTextIndex(board, hitTarget, clickPoint);\n                const isHitText = isHitArrowLineText(board, hitTarget, clickPoint);\n                if (isHitText) {\n                    editHandle(board, hitTarget, textIndex);\n                } else {\n                    const defaultLineText = getDefaultLineText(board);\n                    const textMemory = getMemorizedLatest('arrow-line')?.text || {};\n                    const textElement = buildText(defaultLineText, undefined, textMemory);\n                    const { width, height } = measureElement(board, textElement, {\n                        fontSize: DEFAULT_FONT_SIZE,\n                        fontFamily: DEFAULT_FONT_FAMILY\n                    });\n                    const ratio = getRatioByPoint(points, point);\n                    texts.push({\n                        text: textElement,\n                        position: ratio,\n                        width,\n                        height\n                    });\n                    DrawTransforms.setArrowLineTexts(board, hitTarget, texts);\n                    setTimeout(() => {\n                        if (hitTargetPath) {\n                            const newHitTarget = PlaitNode.get(board, hitTargetPath) as PlaitArrowLine;\n                            const textManages = getTextManages(newHitTarget);\n                            editHandle(board, newHitTarget, textManages.length - 1, true);\n                        }\n                    });\n                }\n            }\n        }\n        dblClick(event);\n    };\n\n    return board;\n};\n\nfunction editHandle(board: PlaitBoard, element: PlaitArrowLine, manageIndex: number, isFirstEdit: boolean = false) {\n    const textManages = getTextManages(element);\n    const textManage = textManages[manageIndex];\n    textManage.edit(() => {\n        const text = Node.string(textManage.getText());\n        const defaultLineText = getDefaultLineText(board);\n        const shouldRemove = !text || (isFirstEdit && text === defaultLineText);\n        if (shouldRemove) {\n            DrawTransforms.removeArrowLineText(board, element, manageIndex);\n        }\n    });\n}\n", "import { PlaitBoard, PlaitPluginElementContext, OnContextChanged } from '@plait/core';\nimport { CommonElementFlavour, ImageGenerator } from '@plait/common';\nimport { PlaitImage } from './interfaces/image';\nimport { ArrowLineAutoCompleteGenerator } from './generators/arrow-line-auto-complete.generator';\n\nexport class ImageComponent extends CommonElementFlavour<PlaitImage, PlaitBoard> implements OnContextChanged<PlaitImage, PlaitBoard> {\n    imageGenerator!: ImageGenerator<PlaitImage>;\n\n    lineAutoCompleteGenerator!: ArrowLineAutoCompleteGenerator<PlaitImage>;\n\n    constructor() {\n        super();\n    }\n\n    initializeGenerator() {\n        this.imageGenerator = new ImageGenerator<PlaitImage>(this.board, {\n            getRectangle: (element: PlaitImage) => {\n                return {\n                    x: element.points[0][0],\n                    y: element.points[0][1],\n                    width: element.points[1][0] - element.points[0][0],\n                    height: element.points[1][1] - element.points[0][1]\n                };\n            },\n            getImageItem: (element) => {\n                return {\n                    url: element.url,\n                    width: element.points[1][0] - element.points[0][0],\n                    height: element.points[1][1] - element.points[0][1]\n                };\n            }\n        });\n        this.lineAutoCompleteGenerator = new ArrowLineAutoCompleteGenerator(this.board);\n        this.getRef().addGenerator(ArrowLineAutoCompleteGenerator.key, this.lineAutoCompleteGenerator);\n        this.getRef().updateActiveSection = () => {\n            this.imageGenerator.setFocus(this.element, this.selected);\n            this.lineAutoCompleteGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {\n                selected: this.selected\n            });\n        };\n    }\n\n    initialize(): void {\n        super.initialize();\n        this.initializeGenerator();\n        this.imageGenerator.processDrawing(this.element, this.getElementG());\n        this.lineAutoCompleteGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {\n            selected: this.selected\n        });\n    }\n\n    onContextChanged(\n        value: PlaitPluginElementContext<PlaitImage, PlaitBoard>,\n        previous: PlaitPluginElementContext<PlaitImage, PlaitBoard>\n    ) {\n        if (value.element !== previous.element) {\n            this.imageGenerator.updateImage(this.getElementG(), previous.element, value.element);\n            this.imageGenerator.setFocus(this.element, this.selected);\n            this.lineAutoCompleteGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {\n                selected: this.selected\n            });\n        } else {\n            const hasSameSelected = value.selected === previous.selected;\n            if (!hasSameSelected || value.selected) {\n                this.imageGenerator.setFocus(this.element, this.selected);\n                this.lineAutoCompleteGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {\n                    selected: this.selected\n                });\n            }\n        }\n    }\n\n    destroy(): void {\n        super.destroy();\n        this.imageGenerator.destroy();\n        this.lineAutoCompleteGenerator.destroy();\n    }\n}\n", "import {\n    BoardTransforms,\n    PRESS_AND_MOVE_BUFFER,\n    PlaitBoard,\n    PlaitOptionsBoard,\n    PlaitPointerType,\n    Point,\n    RectangleClient,\n    Transforms,\n    addSelectedElement,\n    clearSelectedElement,\n    createG,\n    distanceBetweenPointAndPoint,\n    rotateAntiPointsByElement,\n    rotatePointsByElement,\n    temporaryDisableSelection,\n    toActivePoint,\n    toHostPoint,\n    toScreenPointFromActivePoint,\n    toViewBoxPoint\n} from '@plait/core';\nimport { ArrowLineShape, PlaitArrowLine, PlaitDrawElement, PlaitGeometry, PlaitShapeElement, PlaitSwimlane } from '../../interfaces';\nimport { getElementShape } from '../../utils/shape';\nimport { getEngine } from '../../engines';\nimport { handleArrowLineCreating } from '../../utils/arrow-line/arrow-line-basic';\nimport { getSelectedDrawElements } from '../../utils/selected';\nimport { getAutoCompletePoints, getHitIndexOfAutoCompletePoint } from '../../utils/geometry';\nimport { insertElement } from '../../utils';\n\nexport const WithArrowLineAutoCompletePluginKey = 'plait-arrow-line-auto-complete-plugin-key';\n\nexport interface ArrowLineAutoCompleteOptions {\n    afterComplete: (element: PlaitArrowLine) => {};\n}\n\nexport type PreCommitRef = { temporaryArrowLineElement: PlaitArrowLine; temporaryShapeElement: PlaitGeometry };\n\nexport const BOARD_TO_PRE_COMMIT = new WeakMap<PlaitBoard, PreCommitRef>();\n\nexport const withArrowLineAutoComplete = (board: PlaitBoard) => {\n    const { pointerDown, pointerMove, globalPointerUp } = board;\n\n    let autoCompletePoint: Point | null = null;\n    let lineShapeG: SVGGElement | null = null;\n    let sourceElement: PlaitShapeElement | null;\n    let temporaryElement: PlaitArrowLine | null;\n\n    board.pointerDown = (event: PointerEvent) => {\n        const selectedElements = getSelectedDrawElements(board);\n        const targetElement = selectedElements.length === 1 && selectedElements[0];\n        const activePoint = toActivePoint(board, event.x, event.y);\n        if (!PlaitBoard.isReadonly(board) && targetElement && PlaitDrawElement.isShapeElement(targetElement)) {\n            const points = getAutoCompletePoints(board, targetElement, true);\n            const index = getHitIndexOfAutoCompletePoint(\n                rotateAntiPointsByElement(board, activePoint, targetElement, true) || activePoint,\n                points\n            );\n            const hitPoint = points[index];\n            if (hitPoint) {\n                temporaryDisableSelection(board as PlaitOptionsBoard);\n                const screenPoint = toScreenPointFromActivePoint(board, hitPoint);\n                autoCompletePoint = toViewBoxPoint(board, toHostPoint(board, screenPoint[0], screenPoint[1]));\n                sourceElement = targetElement;\n                BoardTransforms.updatePointerType(board, ArrowLineShape.elbow);\n            }\n        }\n        pointerDown(event);\n    };\n\n    board.pointerMove = (event: PointerEvent) => {\n        lineShapeG?.remove();\n        lineShapeG = createG();\n        let movingPoint = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n        if (autoCompletePoint && sourceElement) {\n            const distance = distanceBetweenPointAndPoint(\n                ...(rotateAntiPointsByElement(board, movingPoint, sourceElement) || movingPoint),\n                ...autoCompletePoint\n            );\n            if (distance > PRESS_AND_MOVE_BUFFER * 2) {\n                const rectangle = RectangleClient.getRectangleByPoints(sourceElement.points);\n                const shape = getElementShape(sourceElement);\n                const engine = getEngine(shape);\n                let sourcePoint = autoCompletePoint;\n                if (engine.getNearestCrossingPoint) {\n                    const crossingPoint = engine.getNearestCrossingPoint(rectangle, autoCompletePoint);\n                    sourcePoint = crossingPoint;\n                }\n                // source point must be click point\n                const rotatedSourcePoint = rotatePointsByElement(sourcePoint, sourceElement) || sourcePoint;\n                temporaryElement = handleArrowLineCreating(\n                    board,\n                    ArrowLineShape.elbow,\n                    rotatedSourcePoint,\n                    movingPoint,\n                    sourceElement,\n                    lineShapeG\n                );\n                Transforms.addSelectionWithTemporaryElements(board, []);\n            }\n        }\n        pointerMove(event);\n    };\n\n    board.globalPointerUp = (event) => {\n        if (temporaryElement) {\n            Transforms.insertNode(board, temporaryElement, [board.children.length]);\n            clearSelectedElement(board);\n            addSelectedElement(board, temporaryElement);\n            const afterComplete = (board as PlaitOptionsBoard).getPluginOptions<ArrowLineAutoCompleteOptions>(\n                WithArrowLineAutoCompletePluginKey\n            )?.afterComplete;\n            afterComplete && afterComplete(temporaryElement);\n        } else {\n            const preCommitRef = BOARD_TO_PRE_COMMIT.get(board);\n            if (preCommitRef) {\n                Transforms.insertNode(board, preCommitRef.temporaryArrowLineElement, [board.children.length]);\n                insertElement(board, preCommitRef.temporaryShapeElement);\n                BOARD_TO_PRE_COMMIT.delete(board);\n            }\n        }\n        if (autoCompletePoint) {\n            BoardTransforms.updatePointerType(board, PlaitPointerType.selection);\n            autoCompletePoint = null;\n        }\n        lineShapeG?.remove();\n        lineShapeG = null;\n        sourceElement = null;\n        temporaryElement = null;\n        globalPointerUp(event);\n    };\n\n    return board;\n};\n", "import {\n    CursorClass,\n    PlaitBoard,\n    PlaitElement,\n    RectangleClient,\n    rgbaToHEX,\n    drawCircle,\n    hasValidAngle,\n    isSelectionMoving,\n    rotateAntiPointsByElement,\n    setAngleForG,\n    toActivePoint,\n    toActiveRectangleFromViewBoxRectangle,\n    createG,\n    rotatePointsByElement,\n    isHorizontalDirection,\n    Point\n} from '@plait/core';\nimport {\n    createDefaultGeometry,\n    createDefaultSwimlane,\n    getAutoCompletePoints,\n    getHitConnection,\n    getHitIndexOfAutoCompletePoint,\n    getSelectedDrawElements,\n    handleArrowLineCreating\n} from '../../utils';\nimport { PRIMARY_COLOR, PlaitCommonElementRef, getDirectionByIndex, getXDistanceBetweenPoint, moveXOfPoint } from '@plait/common';\nimport { BOARD_TO_PRE_COMMIT } from './with-arrow-line-auto-complete';\nimport { DrawPointerType, LINE_AUTO_COMPLETE_HOVERED_DIAMETER, LINE_AUTO_COMPLETE_HOVERED_OPACITY } from '../../constants';\nimport { ArrowLineAutoCompleteGenerator } from '../../generators';\nimport { ArrowLineShape, PlaitArrowLine, PlaitDrawElement, PlaitGeometry, PlaitSwimlane, SwimlaneDrawSymbols } from '../../interfaces';\nimport { getGeometryGeneratorByShape } from '../../utils/shape';\n\nconst PREVIEW_ARROW_LINE_DISTANCE = 100;\n\nexport const withArrowLineAutoCompleteReaction = (board: PlaitBoard) => {\n    const { pointerMove, pointerLeave, globalPointerUp } = board;\n    let reactionG: SVGGElement | null = null;\n    let temporaryArrowLineElement: PlaitArrowLine | null = null;\n    let temporaryShapeElement: PlaitGeometry | PlaitSwimlane | null = null;\n    let temporaryArrowLineG: SVGGElement | null = null;\n    let temporaryShapeG: SVGGElement | null = null;\n\n    board.pointerMove = (event: PointerEvent) => {\n        reactionG?.remove();\n        PlaitBoard.getBoardContainer(board).classList.remove(CursorClass.crosshair);\n        const selectedElements = getSelectedDrawElements(board);\n        temporaryArrowLineG?.remove();\n        temporaryShapeG?.remove();\n        const originElement = selectedElements.length === 1 && selectedElements[0];\n        const activePoint = toActivePoint(board, event.x, event.y);\n        if (!PlaitBoard.isReadonly(board) && !isSelectionMoving(board) && originElement && PlaitDrawElement.isShapeElement(originElement)) {\n            const points = getAutoCompletePoints(board, originElement, true);\n            const hitIndex = getHitIndexOfAutoCompletePoint(\n                rotateAntiPointsByElement(board, activePoint, originElement, true) || activePoint,\n                points\n            );\n            const hitPoint = points[hitIndex];\n            const ref = PlaitElement.getElementRef<PlaitCommonElementRef>(originElement);\n            const lineAutoCompleteGenerator = ref.getGenerator<ArrowLineAutoCompleteGenerator>(ArrowLineAutoCompleteGenerator.key);\n            lineAutoCompleteGenerator.recoverAutoCompleteG();\n            if (hitPoint) {\n                // function 1: dnd\n                reactionG = drawCircle(PlaitBoard.getRoughSVG(board), hitPoint, LINE_AUTO_COMPLETE_HOVERED_DIAMETER, {\n                    stroke: 'none',\n                    fill: rgbaToHEX(PRIMARY_COLOR, LINE_AUTO_COMPLETE_HOVERED_OPACITY),\n                    fillStyle: 'solid'\n                });\n                PlaitBoard.getActiveHost(board).append(reactionG);\n                PlaitBoard.getBoardContainer(board).classList.add(CursorClass.crosshair);\n                if (hasValidAngle(originElement)) {\n                    const rectangle = board.getRectangle(originElement)!;\n                    const activeRectangle = toActiveRectangleFromViewBoxRectangle(board, rectangle);\n                    setAngleForG(reactionG, RectangleClient.getCenterPoint(activeRectangle), originElement.angle!);\n                }\n                // function 2: hover to preview and click to commit\n                if (PlaitDrawElement.isGeometry(originElement) && !PlaitDrawElement.isText(originElement)) {\n                    const originRect = RectangleClient.getRectangleByPoints(originElement.points);\n                    let arrowLineStartPoint = RectangleClient.getEdgeCenterPoints(originRect)[hitIndex];\n                    const arrowLineDirection = getDirectionByIndex(hitIndex);\n                    let arrowLineEndPoint = moveXOfPoint(arrowLineStartPoint, PREVIEW_ARROW_LINE_DISTANCE, arrowLineDirection);\n                    const geometryGenerator = getGeometryGeneratorByShape(board, originElement.shape);\n                    const temporaryShapePoints = originElement.points.map((point) =>\n                        moveXOfPoint(\n                            point,\n                            PREVIEW_ARROW_LINE_DISTANCE +\n                                getXDistanceBetweenPoint(\n                                    originElement.points[0],\n                                    originElement.points[1],\n                                    isHorizontalDirection(arrowLineDirection)\n                                ),\n                            arrowLineDirection\n                        )\n                    );\n                    temporaryArrowLineG = createG();\n                    temporaryShapeG = createG();\n                    temporaryArrowLineG.style.opacity = '0.6';\n                    temporaryShapeG.style.opacity = '0.6';\n\n                    temporaryShapeElement = createDefaultGeometry(board, temporaryShapePoints as [Point, Point], originElement.shape);\n                    temporaryShapeElement.angle = originElement.angle;\n                    temporaryShapeElement.fill = originElement.fill;\n                    temporaryShapeElement.strokeColor = originElement.strokeColor;\n                    temporaryShapeElement.strokeStyle = originElement.strokeStyle;\n                    temporaryShapeElement.strokeWidth = originElement.strokeWidth;\n                    temporaryShapeElement.groupId = originElement.groupId;\n\n                    const rotatedArrowLineStartPoint = rotatePointsByElement(arrowLineStartPoint, originElement) || arrowLineStartPoint;\n                    const rotatedArrowLineEndPoint = rotatePointsByElement(arrowLineEndPoint, temporaryShapeElement) || arrowLineEndPoint;\n                    temporaryArrowLineElement = handleArrowLineCreating(\n                        board,\n                        ArrowLineShape.elbow,\n                        rotatedArrowLineStartPoint,\n                        rotatedArrowLineEndPoint,\n                        originElement,\n                        temporaryArrowLineG\n                    );\n                    BOARD_TO_PRE_COMMIT.set(board, { temporaryArrowLineElement, temporaryShapeElement });\n                    const connectionInfo = getHitConnection(board, rotatedArrowLineEndPoint, temporaryShapeElement);\n                    temporaryArrowLineElement.target.boundId = temporaryShapeElement.id;\n                    temporaryArrowLineElement.target.connection = connectionInfo;\n                    geometryGenerator.processDrawing(temporaryShapeElement as PlaitGeometry, temporaryShapeG);\n                    PlaitBoard.getElementTopHost(board).append(temporaryShapeG);\n                }\n                return;\n            }\n        }\n        BOARD_TO_PRE_COMMIT.delete(board);\n        pointerMove(event);\n    };\n\n    board.pointerLeave = (pointer: PointerEvent) => {\n        clearRef();\n        pointerLeave(pointer);\n    };\n\n    const clearRef = () => {\n        if (reactionG) {\n            reactionG?.remove();\n            PlaitBoard.getBoardContainer(board).classList.remove(CursorClass.crosshair);\n            temporaryArrowLineG?.remove();\n            temporaryShapeG?.remove();\n        }\n        if (BOARD_TO_PRE_COMMIT.get(board)) {\n            BOARD_TO_PRE_COMMIT.delete(board);\n        }\n    };\n\n    board.globalPointerUp = (event: PointerEvent) => {\n        globalPointerUp(event);\n        clearRef();\n    };\n\n    return board;\n};\n", "import {\n    PlaitBoard,\n    PlaitElement,\n    Point,\n    distanceBetweenPointAndSegments,\n    getHitElementByPoint,\n    getNearestPointBetweenPointAndSegments\n} from '@plait/core';\nimport { PlaitArrowLine, PlaitDrawElement } from '../../interfaces';\nimport { ResizeHandle, ResizeRef, ResizeState, WithResizeOptions, getRatioByPoint, getTextManages, withResize } from '@plait/common';\nimport { DrawTransforms } from '../../transforms';\nimport { getArrowLinePoints } from '../../utils/arrow-line/arrow-line-basic';\nimport { getHitArrowLineTextIndex } from '../../utils/position/arrow-line';\n\nexport const withArrowLineTextMove = (board: PlaitBoard) => {\n    let textIndex = 0;\n    const movableBuffer = 100;\n    const options: WithResizeOptions<PlaitArrowLine> = {\n        key: 'line-text',\n        canResize: () => {\n            return true;\n        },\n        hitTest: (point: Point) => {\n            let result = null;\n            const line = getHitElementByPoint(board, point, (element: PlaitElement) => {\n                return PlaitDrawElement.isArrowLine(element);\n            }) as undefined | PlaitArrowLine;\n            if (line) {\n                const index = getHitArrowLineTextIndex(board, line, point);\n                const textManages = getTextManages(line);\n                const textManage = textManages[index];\n                if (index !== -1 && !textManage.isEditing) {\n                    textIndex = index;\n                    return { element: line, handle: ResizeHandle.e };\n                }\n            }\n            return result;\n        },\n        onResize: (resizeRef: ResizeRef<PlaitArrowLine>, resizeState: ResizeState) => {\n            const element = resizeRef.element;\n            if (element) {\n                const movingPoint = resizeState.endPoint;\n                const points = getArrowLinePoints(board, element);\n                const distance = distanceBetweenPointAndSegments(movingPoint, points);\n                if (distance <= movableBuffer) {\n                    const point = getNearestPointBetweenPointAndSegments(movingPoint, points, false);\n                    const position = getRatioByPoint(points, point);\n                    const texts = [...element.texts];\n                    texts[textIndex] = {\n                        ...texts[textIndex],\n                        position\n                    };\n                    DrawTransforms.setArrowLineTexts(board, element, texts);\n                }\n            }\n        }\n    };\n\n    withResize<PlaitArrowLine>(board, options);\n\n    return board;\n};\n", "import {\n    MERGING,\n    PlaitBoard,\n    RectangleClient,\n    Transforms,\n    getRectangleByElements,\n    getSelectedElements,\n    getSelectionAngle,\n    isMainPointer,\n    isSelectionMoving,\n    rotatePoints,\n    throttleRAF,\n    drawRectangle,\n    ACTIVE_STROKE_WIDTH,\n    SELECTION_BORDER_COLOR,\n    setAngleForG,\n    rotateElements,\n    getAngleBetweenPoints,\n    ROTATE_HANDLE_CLASS_NAME,\n    SELECTION_RECTANGLE_CLASS_NAME,\n    normalizeAngle,\n    degreesToRadians,\n    toActiveRectangleFromViewBoxRectangle,\n    toActivePoint\n} from '@plait/core';\nimport { addRotating, removeRotating, drawRotateHandle, RotateRef } from '@plait/common';\nimport { PlaitDrawElement } from '../interfaces';\nimport { getRotateHandleRectangle } from '../utils/position/geometry';\n\nexport const withDrawRotate = (board: PlaitBoard) => {\n    const { pointerDown, pointerMove, globalPointerUp, afterChange, drawSelectionRectangle } = board;\n    let rotateRef: RotateRef | null = null;\n    let rotateHandleG: SVGGElement | null;\n    let needCustomActiveRectangle = false;\n\n    const canRotate = () => {\n        const elements = getSelectedElements(board);\n        return (\n            elements.length > 0 &&\n            elements.every(\n                (el) =>\n                    (PlaitDrawElement.isDrawElement(el) && !PlaitDrawElement.isArrowLine(el)) ||\n                    PlaitDrawElement.isCustomGeometryElement(board, el)\n            )\n        );\n    };\n\n    board.pointerDown = (event: PointerEvent) => {\n        if (!canRotate() || PlaitBoard.isReadonly(board) || PlaitBoard.hasBeenTextEditing(board) || !isMainPointer(event)) {\n            pointerDown(event);\n            return;\n        }\n        const activePoint = toActivePoint(board, event.x, event.y);\n        const elements = getSelectedElements(board) as PlaitDrawElement[];\n        const rectangle = getRectangleByElements(board, elements, false);\n        const activeRectangle = toActiveRectangleFromViewBoxRectangle(board, rectangle);\n        const handleRectangle = getRotateHandleRectangle(activeRectangle);\n        const angle = getSelectionAngle(elements);\n        const rotatedPoint = angle ? rotatePoints(activePoint, RectangleClient.getCenterPoint(activeRectangle), -angle) : activePoint;\n        if (handleRectangle && RectangleClient.isHit(RectangleClient.getRectangleByPoints([rotatedPoint, rotatedPoint]), handleRectangle)) {\n            rotateRef = {\n                elements: [...elements],\n                startPoint: activePoint\n            };\n        }\n        pointerDown(event);\n    };\n\n    board.pointerMove = (event: PointerEvent) => {\n        if (rotateRef) {\n            event.preventDefault();\n            const isShift = !!event.shiftKey;\n            addRotating(board, rotateRef);\n            const endPoint = toActivePoint(board, event.x, event.y);\n            const rectangle = getRectangleByElements(board, rotateRef.elements, false);\n            const activeRectangle = toActiveRectangleFromViewBoxRectangle(board, rectangle);\n            const selectionCenterPoint = RectangleClient.getCenterPoint(activeRectangle);\n            if (!getSelectionAngle(rotateRef.elements) && rotateRef.elements.length > 1) {\n                needCustomActiveRectangle = true;\n            }\n\n            throttleRAF(board, 'with-common-rotate', () => {\n                if (rotateRef && rotateRef.startPoint) {\n                    let angle = getAngleBetweenPoints(rotateRef.startPoint, endPoint, selectionCenterPoint);\n                    const selectionAngle = getSelectionAngle(rotateRef.elements);\n                    angle = normalizeAngle(selectionAngle + angle);\n                    if (isShift) {\n                        angle += Math.PI / 12 / 2;\n                        angle -= angle % (Math.PI / 12);\n                    }\n\n                    let remainder = angle % (Math.PI / 2);\n                    if (Math.PI / 2 - remainder <= degreesToRadians(5)) {\n                        const snapAngle = Math.PI / 2 - remainder;\n                        angle += snapAngle;\n                    }\n\n                    if (remainder <= degreesToRadians(5)) {\n                        const snapAngle = -remainder;\n                        angle += snapAngle;\n                    }\n\n                    rotateRef.angle = normalizeAngle(angle - selectionAngle) || 0;\n                    rotateElements(board, rotateRef.elements, rotateRef.angle);\n                    MERGING.set(board, true);\n                    PlaitBoard.getBoardContainer(board).classList.add('element-rotating');\n                }\n            });\n            return;\n        }\n\n        pointerMove(event);\n    };\n\n    board.globalPointerUp = (event: PointerEvent) => {\n        globalPointerUp(event);\n        if (needCustomActiveRectangle) {\n            needCustomActiveRectangle = false;\n            const selectedElements = getSelectedElements(board);\n            Transforms.addSelectionWithTemporaryElements(board, selectedElements);\n        }\n        PlaitBoard.getBoardContainer(board).classList.remove('element-rotating');\n        removeRotating(board);\n        rotateRef = null;\n        MERGING.set(board, false);\n    };\n\n    board.afterChange = () => {\n        afterChange();\n        if (rotateHandleG) {\n            rotateHandleG.remove();\n            rotateHandleG = null;\n        }\n\n        if (canRotate() && !isSelectionMoving(board)) {\n            if (needCustomActiveRectangle && rotateRef) {\n                const boundingRectangle = getRectangleByElements(board, rotateRef.elements, false);\n                const boundingActiveRectangle = toActiveRectangleFromViewBoxRectangle(board, boundingRectangle);\n                rotateHandleG = drawRotateHandle(board, boundingActiveRectangle);\n                rotateHandleG.classList.add(ROTATE_HANDLE_CLASS_NAME);\n                if (rotateRef.angle) {\n                    setAngleForG(rotateHandleG, RectangleClient.getCenterPoint(boundingActiveRectangle), rotateRef.angle);\n                }\n            } else {\n                const elements = getSelectedElements(board) as PlaitDrawElement[];\n                const boundingRectangle = getRectangleByElements(board, elements, false);\n                const boundingActiveRectangle = toActiveRectangleFromViewBoxRectangle(board, boundingRectangle);\n                rotateHandleG = drawRotateHandle(board, boundingActiveRectangle);\n                rotateHandleG.classList.add(ROTATE_HANDLE_CLASS_NAME);\n                setAngleForG(rotateHandleG, RectangleClient.getCenterPoint(boundingActiveRectangle), getSelectionAngle(elements));\n            }\n            PlaitBoard.getActiveHost(board).append(rotateHandleG);\n        }\n    };\n\n    board.drawSelectionRectangle = () => {\n        if (needCustomActiveRectangle && rotateRef) {\n            const rectangle = getRectangleByElements(board, rotateRef.elements, false);\n            const activeRectangle = toActiveRectangleFromViewBoxRectangle(board, rectangle);\n            const rectangleG = drawRectangle(board, RectangleClient.inflate(activeRectangle, ACTIVE_STROKE_WIDTH), {\n                stroke: SELECTION_BORDER_COLOR,\n                strokeWidth: ACTIVE_STROKE_WIDTH\n            });\n            rectangleG.classList.add(SELECTION_RECTANGLE_CLASS_NAME);\n            if (rotateRef.angle) {\n                setAngleForG(rectangleG, RectangleClient.getCenterPoint(activeRectangle), rotateRef.angle);\n            }\n            return rectangleG;\n        }\n        return drawSelectionRectangle();\n    };\n\n    return board;\n};\n", "import {\n    PlaitBoard,\n    PlaitPluginElementContext,\n    OnContextChanged,\n    ACTIVE_STROKE_WIDTH,\n    RectangleClient,\n    setAngleForG,\n    degreesToRadians\n} from '@plait/core';\nimport { ActiveGenerator, CommonElementFlavour, TextManageChangeData, createActiveGenerator, hasResizeHandle } from '@plait/common';\nimport { PlaitTable, PlaitTableBoard, PlaitTableCell, PlaitTableElement } from './interfaces/table';\nimport { DrawTextInfo, TextGenerator } from './generators/text.generator';\nimport { TableGenerator } from './generators/table.generator';\nimport { DrawTransforms } from './transforms';\nimport { getCellWithPoints, getTextManageByCell, isCellIncludeText } from './utils/table';\nimport {\n    clearSelectedCells,\n    getCellsRectangle,\n    getSelectedCells,\n    getStrokeWidthByElement,\n    memorizeLatestText,\n    setSelectedCells\n} from './utils';\nimport { getEngine } from './engines';\nimport { TableSymbols } from './interfaces';\nimport { getHorizontalTextRectangle } from './engines/table/table';\nimport { ShapeDefaultSpace } from './constants';\nimport { ArrowLineAutoCompleteGenerator } from './generators/arrow-line-auto-complete.generator';\n\nexport class TableComponent<T extends PlaitTable> extends CommonElementFlavour<T, PlaitBoard> implements OnContextChanged<T, PlaitBoard> {\n    activeGenerator!: ActiveGenerator<T>;\n\n    tableGenerator!: TableGenerator<T>;\n\n    textGenerator!: TextGenerator<T>;\n\n    lineAutoCompleteGenerator!: ArrowLineAutoCompleteGenerator<PlaitTable>;\n\n    constructor() {\n        super();\n    }\n\n    initializeGenerator() {\n        this.activeGenerator = createActiveGenerator<T>(this.board, {\n            getStrokeWidth: () => {\n                return ACTIVE_STROKE_WIDTH;\n            },\n            getStrokeOpacity: () => {\n                return 1;\n            },\n            getRectangle: (value: T) => {\n                const cells = getSelectedCells(value);\n                if (cells?.length) {\n                    return getCellsRectangle(this.board as PlaitTableBoard, this.element, cells);\n                }\n                return RectangleClient.getRectangleByPoints(value.points!);\n            },\n            hasResizeHandle: () => {\n                const cells = getSelectedCells(this.element);\n                if (cells?.length) {\n                    return false;\n                }\n                return hasResizeHandle(this.board, this.element);\n            }\n        });\n        this.tableGenerator = new TableGenerator<T>(this.board);\n        this.initializeTextManage();\n        this.lineAutoCompleteGenerator = new ArrowLineAutoCompleteGenerator(this.board);\n        this.getRef().addGenerator(ArrowLineAutoCompleteGenerator.key, this.lineAutoCompleteGenerator);\n        this.getRef().updateActiveSection = () => {\n            this.activeGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {\n                selected: this.selected\n            });\n            this.lineAutoCompleteGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {\n                selected: this.selected\n            });\n        };\n    }\n\n    initialize(): void {\n        super.initialize();\n        this.initializeGenerator();\n        this.draw();\n    }\n\n    draw() {\n        this.tableGenerator.processDrawing(this.element, this.getElementG());\n        this.textGenerator.draw(this.getElementG());\n        this.rotateVerticalText();\n        this.lineAutoCompleteGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {\n            selected: this.selected\n        });\n    }\n\n    rotateVerticalText() {\n        const table = (this.board as PlaitTableBoard).buildTable(this.element);\n        table.cells.forEach((item) => {\n            if (PlaitTableElement.isVerticalText(item)) {\n                const textManage = getTextManageByCell(this.board, item);\n                if (textManage) {\n                    const engine = getEngine<PlaitTable>(TableSymbols.table);\n                    const rectangle = engine.getTextRectangle!(this.element, { id: item.id, board: this.board });\n                    textManage.g.classList.add('vertical-cell-text');\n                    setAngleForG(textManage.g, RectangleClient.getCenterPoint(rectangle), degreesToRadians(-90));\n                }\n            }\n        });\n    }\n\n    getDrawShapeTexts(cells: PlaitTableCell[]): DrawTextInfo[] {\n        return cells\n            .filter((item) => isCellIncludeText(item))\n            .map((item) => {\n                return {\n                    id: item.id,\n                    text: item.text!,\n                    textHeight: item.textHeight!,\n                    board: this.board\n                };\n            });\n    }\n\n    initializeTextManage() {\n        const texts = this.getDrawShapeTexts(this.element.cells);\n        this.textGenerator = new TextGenerator(this.board, this.element, texts, {\n            onChange: (value: PlaitTable, data: TextManageChangeData, text: DrawTextInfo) => {\n                const path = PlaitBoard.findPath(this.board, value);\n                if (data.newText) {\n                    DrawTransforms.setTableText(this.board, path, text.id, data.newText, data.height);\n                }\n                data.operations && memorizeLatestText(value, data.operations);\n            },\n            getRenderRectangle: (value: PlaitTable, text: DrawTextInfo) => {\n                const cell = getCellWithPoints(this.board, value, text.id);\n                if (PlaitTableElement.isVerticalText(cell)) {\n                    const cellRectangle = RectangleClient.getRectangleByPoints(cell.points);\n                    const strokeWidth = getStrokeWidthByElement(cell);\n                    const width = cell.textHeight || 0;\n                    const height = cellRectangle.height - ShapeDefaultSpace.rectangleAndText * 2 - strokeWidth * 2;\n                    return {\n                        width,\n                        height: height > 0 ? height : 0,\n                        x: cellRectangle.x + ShapeDefaultSpace.rectangleAndText + strokeWidth,\n                        y: cellRectangle.y + (cellRectangle.height - height) / 2\n                    };\n                } else {\n                    return getHorizontalTextRectangle(cell);\n                }\n            }\n        });\n        this.textGenerator.initialize();\n    }\n\n    onContextChanged(value: PlaitPluginElementContext<T, PlaitBoard>, previous: PlaitPluginElementContext<T, PlaitBoard>) {\n        if (value.element !== previous.element || value.hasThemeChanged) {\n            const previousSelectedCells = getSelectedCells(previous.element);\n            if (previousSelectedCells?.length) {\n                clearSelectedCells(previous.element);\n                setSelectedCells(value.element, previousSelectedCells);\n            }\n            this.tableGenerator.processDrawing(value.element, this.getElementG());\n            this.activeGenerator.processDrawing(value.element, PlaitBoard.getActiveHost(this.board), { selected: this.selected });\n            const previousTexts = this.getDrawShapeTexts(previous.element.cells);\n            const currentTexts = this.getDrawShapeTexts(value.element.cells);\n            this.textGenerator.update(value.element, previousTexts, currentTexts, this.getElementG());\n            this.rotateVerticalText();\n        } else {\n            const hasSameSelected = value.selected === previous.selected;\n            const currentSelectedCells = getSelectedCells(value.element);\n            if (!hasSameSelected || currentSelectedCells?.length || value.selected) {\n                this.activeGenerator.processDrawing(value.element, PlaitBoard.getActiveHost(this.board), {\n                    selected: this.selected\n                });\n            }\n            if (!this.selected) {\n                clearSelectedCells(value.element);\n            }\n        }\n        this.lineAutoCompleteGenerator.processDrawing(this.element, PlaitBoard.getActiveHost(this.board), {\n            selected: this.selected\n        });\n    }\n\n    destroy(): void {\n        super.destroy();\n        this.activeGenerator.destroy();\n        this.tableGenerator.destroy();\n        this.textGenerator.destroy();\n        this.lineAutoCompleteGenerator.destroy();\n    }\n}\n", "import {\n    PlaitBoard,\n    Point,\n    RectangleClient,\n    Transforms,\n    isSelectedElement,\n    getSelectedElements,\n    hasValidAngle,\n} from '@plait/core';\nimport { PlaitBaseTable, PlaitTableBoard, PlaitTableCellWithPoints } from '../interfaces/table';\nimport {\n    getIndexByResizeHandle,\n    isCornerHandle,\n    ResizeOptions,\n    ResizeHandle,\n    ResizeRef,\n    ResizeState,\n    withResize,\n    WithResizeOptions,\n    normalizeShapePoints\n} from '@plait/common';\nimport { getCellsWithPoints, updateColumns, updateRows } from '../utils/table';\nimport { getHitRectangleResizeHandleRef } from '../utils/position/geometry';\nimport {\n    getResizeOriginPointAndHandlePoint,\n    getResizeZoom,\n    movePointByZoomAndOriginPoint\n} from './with-draw-resize';\nimport { getSnapResizingRef, getSnapResizingRefOptions } from '../utils/snap-resizing';\nimport { PlaitDrawElement } from '../interfaces';\nimport { isSingleSelectTable } from '../utils';\n\n// const debugKey = 'debug:plait:table:resize';\n// const debugGenerator = createDebugGenerator(debugKey);\n\ninterface TableResizeOptions extends ResizeOptions {\n    cell: PlaitTableCellWithPoints;\n}\n\nconst MIN_CELL_SIZE = 20;\n\nexport function withTableResize(board: PlaitTableBoard) {\n    let snapG: SVGGElement | null;\n\n    const options: WithResizeOptions<PlaitBaseTable, ResizeHandle, TableResizeOptions> = {\n        key: 'draw-table',\n        canResize: () => {\n            const selectedElements = getSelectedElements(board);\n            return isSingleSelectTable(board) && !hasValidAngle(selectedElements[0]);\n        },\n        hitTest: (point: Point) => {\n            const selectedElements = getSelectedElements(board);\n            const hitElement = selectedElements[0];\n            // debugGenerator.clear();\n            if (hitElement && PlaitDrawElement.isElementByTable(hitElement)) {\n                let rectangle = board.getRectangle(hitElement) as RectangleClient;\n                // debugGenerator.drawRectangle(board, rectangle);\n                // debugGenerator.drawCircles(board, [point], 5);\n                let handleRef = getHitRectangleResizeHandleRef(board, rectangle, point, hitElement.angle);\n                if (handleRef) {\n                    const selectElement = isSelectedElement(board, hitElement);\n                    if ((selectElement && isSingleSelectTable(board)) || (!selectElement && !isCornerHandle(board, handleRef.handle))) {\n                        return {\n                            element: hitElement,\n                            handle: handleRef.handle,\n                            cursorClass: handleRef.cursorClass,\n                            rectangle\n                        };\n                    }\n                }\n                const cells = getCellsWithPoints(board, hitElement);\n                for (let i = 0; i < cells.length; i++) {\n                    rectangle = RectangleClient.getRectangleByPoints(cells[i].points);\n                    handleRef = getHitRectangleResizeHandleRef(board, rectangle, point, 0);\n                    if (handleRef && !isCornerHandle(board, handleRef.handle)) {\n                        return {\n                            element: hitElement,\n                            handle: handleRef.handle,\n                            cursorClass: handleRef.cursorClass,\n                            rectangle,\n                            options: {\n                                cell: cells[i]\n                            }\n                        };\n                    }\n                }\n            }\n            return null;\n        },\n        onResize: (resizeRef: ResizeRef<PlaitBaseTable, ResizeHandle, TableResizeOptions>, resizeState: ResizeState) => {\n            snapG?.remove();\n            const path = PlaitBoard.findPath(board, resizeRef.element);\n            if (resizeRef.options?.cell && resizeRef.rectangle) {\n                const handleIndex = getIndexByResizeHandle(resizeRef.handle);\n                const { originPoint, handlePoint } = getResizeOriginPointAndHandlePoint(board, handleIndex, resizeRef.rectangle!);\n                const resizePoints: [Point, Point] = [resizeState.startPoint, resizeState.endPoint];\n                const { xZoom, yZoom } = getResizeZoom(resizePoints, originPoint, handlePoint, false, false);\n                const originPoints = resizeRef.options?.cell.points;\n                const targetPoints = originPoints.map((p) => {\n                    return movePointByZoomAndOriginPoint(p, originPoint, xZoom, yZoom);\n                }) as [Point, Point];\n                const offsetX = targetPoints[1][0] - originPoints[1][0];\n                const offsetY = targetPoints[1][1] - originPoints[1][1];\n                const width = targetPoints[1][0] - targetPoints[0][0];\n                const height = targetPoints[1][1] - targetPoints[0][1];\n                if (offsetX !== 0 && width >= MIN_CELL_SIZE) {\n                    const { columns, points } = updateColumns(resizeRef.element, resizeRef.options?.cell.columnId, width, offsetX);\n                    Transforms.setNode(board, { columns, points }, path);\n                } else if (offsetY !== 0 && height >= MIN_CELL_SIZE) {\n                    const { rows, points } = updateRows(resizeRef.element, resizeRef.options?.cell.rowId, height, offsetY);\n                    Transforms.setNode(board, { rows, points }, path);\n                }\n            } else {\n                const isFromCorner = isCornerHandle(board, resizeRef.handle);\n                const isAspectRatio = resizeState.isShift;\n                const handleIndex = getIndexByResizeHandle(resizeRef.handle);\n                const { originPoint, handlePoint } = getResizeOriginPointAndHandlePoint(board, handleIndex, resizeRef.rectangle!);\n                const resizeSnapRefOptions = getSnapResizingRefOptions(\n                    board,\n                    resizeRef,\n                    resizeState,\n                    {\n                        originPoint,\n                        handlePoint\n                    },\n                    isAspectRatio,\n                    isFromCorner\n                );\n                const resizeSnapRef = getSnapResizingRef(board, [resizeRef.element], resizeSnapRefOptions);\n                snapG = resizeSnapRef.snapG;\n                PlaitBoard.getElementTopHost(board).append(snapG);\n                const points = resizeSnapRef.activePoints as [Point, Point];\n                const originPoints = resizeRef.element.points;\n                const originRect = RectangleClient.getRectangleByPoints(originPoints);\n                const targetRect = RectangleClient.getRectangleByPoints(points);\n                const offsetWidth = targetRect.width - originRect.width;\n                const offsetHeight = targetRect.height - originRect.height;\n                let columns = [...resizeRef.element.columns];\n                let rows = [...resizeRef.element.rows];\n                if (offsetWidth !== 0) {\n                    columns = columns.map((item) => {\n                        if (item.width) {\n                            return {\n                                ...item,\n                                width: item.width + offsetWidth * (item.width / originRect.width)\n                            };\n                        }\n                        return item;\n                    });\n                }\n                if (offsetHeight !== 0) {\n                    rows = rows.map((item) => {\n                        if (item.height) {\n                            return {\n                                ...item,\n                                height: item.height + offsetHeight * (item.height / originRect.height)\n                            };\n                        }\n                        return item;\n                    });\n                }\n                Transforms.setNode(board, { points: normalizeShapePoints(points), columns, rows }, path);\n            }\n        },\n        afterResize: (resizeRef: ResizeRef<PlaitBaseTable, ResizeHandle, TableResizeOptions>) => {\n            snapG?.remove();\n            snapG = null;\n        }\n    };\n\n    withResize<PlaitBaseTable, ResizeHandle, TableResizeOptions>(board, options);\n\n    return board;\n}\n", "import { TableComponent } from '../table.component';\nimport { PlaitBaseTable, PlaitTableBoard } from '../interfaces/table';\nimport {\n    PlaitBoard,\n    PlaitPluginElementContext,\n    PlaitElement,\n    RectangleClient,\n    Selection,\n    isLineHitRectangle,\n    toViewBoxPoint,\n    toHostPoint,\n    getHitElementByPoint,\n    getSelectedElements,\n    PlaitPointerType,\n    isDragging,\n    isMainPointer,\n    distanceBetweenPointAndPoint,\n    HIT_DISTANCE_BUFFER\n} from '@plait/core';\nimport { editCell, getHitCell } from '../utils/table';\nimport { withTableResize } from './with-table-resize';\nimport { isVirtualKey, isDelete, isSpaceHotkey } from '@plait/common';\nimport { PlaitDrawElement } from '../interfaces';\nimport { getSelectedCells, getSelectedTableElements, isHitEdgeOfShape, isSingleSelectTable, setSelectedCells } from '../utils';\nimport { TableEngine } from '../engines/table/table';\n\nexport const withTable = (board: PlaitBoard) => {\n    const tableBoard = board as PlaitTableBoard;\n\n    const { drawElement, getRectangle, isRectangleHit, isHit, isMovable, dblClick, keyDown, pointerUp } = tableBoard;\n\n    tableBoard.drawElement = (context: PlaitPluginElementContext) => {\n        if (PlaitDrawElement.isElementByTable(context.element)) {\n            return TableComponent;\n        }\n        return drawElement(context);\n    };\n\n    tableBoard.isHit = (element, point, isStrict?: boolean) => {\n        if (PlaitDrawElement.isElementByTable(element)) {\n            const client = RectangleClient.getRectangleByPoints(element.points);\n            const nearestPoint = TableEngine.getNearestPoint(client, point);\n            const distance = distanceBetweenPointAndPoint(nearestPoint[0], nearestPoint[1], point[0], point[1]);\n            return distance <= HIT_DISTANCE_BUFFER || RectangleClient.isPointInRectangle(client, point);\n        }\n        return isHit(element, point, isStrict);\n    };\n\n    tableBoard.getRectangle = (element: PlaitElement) => {\n        if (PlaitDrawElement.isElementByTable(element)) {\n            return RectangleClient.getRectangleByPoints(element.points);\n        }\n        return getRectangle(element);\n    };\n\n    tableBoard.isMovable = (element: PlaitElement) => {\n        if (PlaitDrawElement.isElementByTable(element)) {\n            return true;\n        }\n\n        return isMovable(element);\n    };\n\n    tableBoard.isRectangleHit = (element: PlaitElement, selection: Selection) => {\n        if (PlaitDrawElement.isElementByTable(element)) {\n            const rangeRectangle = RectangleClient.getRectangleByPoints([selection.anchor, selection.focus]);\n            const client = RectangleClient.getRectangleByPoints(element.points);\n            return isLineHitRectangle(RectangleClient.getCornerPoints(client), rangeRectangle);\n        }\n        return isRectangleHit(element, selection);\n    };\n\n    tableBoard.keyDown = (event: KeyboardEvent) => {\n        const selectedElements = getSelectedElements(board);\n        const isSingleSelection = selectedElements.length === 1;\n        const targetElement = selectedElements[0];\n        if (\n            !PlaitBoard.isReadonly(board) &&\n            !PlaitBoard.hasBeenTextEditing(tableBoard) &&\n            !isVirtualKey(event) &&\n            !isDelete(event) &&\n            !isSpaceHotkey(event) &&\n            isSingleSelection\n        ) {\n            event.preventDefault();\n            if (PlaitDrawElement.isElementByTable(targetElement)) {\n                const cells = getSelectedCells(targetElement);\n                let cell = targetElement.cells.find((item) => item.text && item.textHeight);\n                if (cells?.length) {\n                    cell = cells.find((item) => item.text && item.textHeight);\n                }\n                if (cell) {\n                    editCell(board, cell);\n                    return;\n                }\n            }\n        }\n        keyDown(event);\n    };\n\n    tableBoard.dblClick = (event: MouseEvent) => {\n        event.preventDefault();\n        if (!PlaitBoard.isReadonly(board)) {\n            const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n            const hitElement = getHitElementByPoint(board, point);\n            if (hitElement && PlaitDrawElement.isElementByTable(hitElement)) {\n                const hitCell = getHitCell(tableBoard, hitElement, point);\n                if (hitCell && hitCell.text && hitCell.textHeight) {\n                    editCell(board, hitCell);\n                    return;\n                }\n            }\n        }\n        dblClick(event);\n    };\n\n    tableBoard.pointerUp = (event: PointerEvent) => {\n        const isSetSelectionPointer =\n            PlaitBoard.isPointer(tableBoard, PlaitPointerType.selection) || PlaitBoard.isPointer(tableBoard, PlaitPointerType.hand);\n        const isSkip = !isMainPointer(event) || isDragging(tableBoard) || !isSetSelectionPointer;\n        if (isSkip) {\n            pointerUp(event);\n            return;\n        }\n        if (isSingleSelectTable(tableBoard)) {\n            const point = toViewBoxPoint(tableBoard, toHostPoint(tableBoard, event.x, event.y));\n            const element = getSelectedTableElements(tableBoard)[0];\n            const hitCell = getHitCell(tableBoard, element, point);\n            if (hitCell && hitCell.text && hitCell.textHeight) {\n                setSelectedCells(element, [hitCell]);\n            }\n        }\n        pointerUp(event);\n    };\n\n    tableBoard.buildTable = (element: PlaitBaseTable) => {\n        return element;\n    };\n\n    return withTableResize(tableBoard);\n};\n", "import { PlaitBoard, Point, RectangleClient, createG, toHostPoint, toViewBoxPoint } from '@plait/core';\nimport { PlaitSwimlane, SwimlaneDrawSymbols } from '../interfaces';\nimport { insertElement } from '../utils';\nimport {\n    normalizeShapePoints,\n    isDndMode,\n    isDrawingMode,\n    getDirectionFactorByDirectionComponent,\n    getUnitVectorByPointAndPoint,\n    TextManage\n} from '@plait/common';\nimport { isKeyHotkey } from 'is-hotkey';\nimport { getSnapResizingRef } from '../utils/snap-resizing';\nimport { TableGenerator } from '../generators/table.generator';\nimport { createDefaultSwimlane, getDefaultSwimlanePoints, isSwimlanePointers } from '../utils/swimlane';\nimport { getGeometryGeneratorByShape } from '../utils/shape';\nimport { DrawPointerType } from '../constants/pointer';\n\nexport interface FakeCreateTextRef {\n    g: SVGGElement;\n    textManage: TextManage;\n}\n\nconst isSwimlaneDndMode = (board: PlaitBoard) => {\n    const isSwimlanePointer = isSwimlanePointers(board);\n    const dndMode = isSwimlanePointer && isDndMode(board);\n    return dndMode;\n};\n\nconst isSwimlaneDrawingMode = (board: PlaitBoard) => {\n    const isSwimlanePointer = isSwimlanePointers(board);\n    const drawingMode = isSwimlanePointer && isDrawingMode(board);\n    return drawingMode;\n};\n\nexport const withSwimlaneCreateByDrag = (board: PlaitBoard) => {\n    const { pointerMove, globalPointerUp, pointerUp } = board;\n\n    let swimlaneG: SVGGElement | null = null;\n\n    let temporaryElement: PlaitSwimlane | null = null;\n\n    board.pointerMove = (event: PointerEvent) => {\n        swimlaneG?.remove();\n        swimlaneG = createG();\n        const tableGenerator = new TableGenerator(board);\n        const pointer = PlaitBoard.getPointer(board) as SwimlaneDrawSymbols;\n        const dragMode = isSwimlaneDndMode(board);\n        const movingPoint = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n\n        if (dragMode) {\n            const points = getDefaultSwimlanePoints(pointer, movingPoint);\n            temporaryElement = createDefaultSwimlane(pointer, points);\n            tableGenerator.processDrawing(temporaryElement, swimlaneG);\n            PlaitBoard.getElementTopHost(board).append(swimlaneG);\n        }\n\n        pointerMove(event);\n    };\n\n    board.pointerUp = (event: PointerEvent) => {\n        if (isSwimlaneDndMode(board) && temporaryElement) {\n            return;\n        }\n        pointerUp(event);\n    };\n\n    board.globalPointerUp = (event: PointerEvent) => {\n        if (isSwimlaneDndMode(board) && temporaryElement) {\n            insertElement(board, temporaryElement);\n        }\n        temporaryElement = null;\n        swimlaneG?.remove();\n        swimlaneG = null;\n        globalPointerUp(event);\n    };\n\n    return board;\n};\n\nexport const withSwimlaneCreateByDrawing = (board: PlaitBoard) => {\n    const { pointerDown, pointerMove, pointerUp, keyDown, keyUp } = board;\n    let start: Point | null = null;\n\n    let swimlaneG: SVGGElement | null = null;\n\n    let temporaryElement: PlaitSwimlane | null = null;\n\n    let isShift = false;\n\n    let snapG: SVGGElement | null;\n\n    board.keyDown = (event: KeyboardEvent) => {\n        isShift = isKeyHotkey('shift', event);\n        keyDown(event);\n    };\n\n    board.keyUp = (event: KeyboardEvent) => {\n        isShift = false;\n        keyUp(event);\n    };\n\n    board.pointerDown = (event: PointerEvent) => {\n        if (!PlaitBoard.isReadonly(board) && isSwimlaneDrawingMode(board)) {\n            const point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n            start = point;\n        }\n        pointerDown(event);\n    };\n\n    board.pointerMove = (event: PointerEvent) => {\n        swimlaneG?.remove();\n        swimlaneG = createG();\n        const tableGenerator = new TableGenerator(board);\n        const movingPoint = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n        const pointer = PlaitBoard.getPointer(board) as SwimlaneDrawSymbols;\n        snapG?.remove();\n        if (start && isSwimlaneDrawingMode(board)) {\n            let points: [Point, Point] = normalizeShapePoints([start, movingPoint], isShift);\n            const activeRectangle = RectangleClient.getRectangleByPoints(points);\n            const [x, y] = getUnitVectorByPointAndPoint(start, movingPoint);\n            const resizeSnapRef = getSnapResizingRef(board, [], {\n                resizePoints: points,\n                activeRectangle,\n                directionFactors: [getDirectionFactorByDirectionComponent(x), getDirectionFactorByDirectionComponent(y)],\n                isAspectRatio: isShift,\n                isFromCorner: true,\n                isCreate: true\n            });\n            snapG = resizeSnapRef.snapG;\n            PlaitBoard.getElementTopHost(board).append(snapG);\n            points = normalizeShapePoints(resizeSnapRef.activePoints as [Point, Point], isShift);\n            temporaryElement = createDefaultSwimlane(pointer, points);\n            tableGenerator.processDrawing(temporaryElement, swimlaneG);\n            PlaitBoard.getElementTopHost(board).append(swimlaneG);\n        }\n        pointerMove(event);\n    };\n\n    board.pointerUp = (event: PointerEvent) => {\n        if (isSwimlaneDrawingMode(board) && start) {\n            const targetPoint = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n            const { width, height } = RectangleClient.getRectangleByPoints([start!, targetPoint]);\n            if (Math.hypot(width, height) < 8) {\n                const pointer = PlaitBoard.getPointer(board) as SwimlaneDrawSymbols;\n                const points = getDefaultSwimlanePoints(pointer, targetPoint);\n                temporaryElement = createDefaultSwimlane(pointer, points);\n            }\n            if (temporaryElement) {\n                insertElement(board, temporaryElement);\n            }\n            snapG?.remove();\n            swimlaneG?.remove();\n            swimlaneG = null;\n            start = null;\n            temporaryElement = null;\n            return;\n        }\n        pointerUp(event);\n    };\n    return board;\n};\n", "import { PlaitPluginElementContext } from '@plait/core';\nimport { PlaitDrawElement, PlaitSwimlane } from '../interfaces';\nimport { buildSwimlaneTable } from '../utils/swimlane';\nimport { TableComponent } from '../table.component';\nimport { withSwimlaneCreateByDrag, withSwimlaneCreateByDrawing } from './with-swimlane-create';\nimport { PlaitBaseTable, PlaitTableBoard } from '../interfaces/table';\n\nexport const withSwimlane = (board: PlaitTableBoard) => {\n    const { drawElement, buildTable, pointerUp } = board;\n\n    board.drawElement = (context: PlaitPluginElementContext) => {\n        if (PlaitDrawElement.isSwimlane(context.element)) {\n            return TableComponent;\n        }\n        return drawElement(context);\n    };\n\n    board.buildTable = (element: PlaitBaseTable) => {\n        if (PlaitDrawElement.isSwimlane(element)) {\n            return buildSwimlaneTable(element as PlaitSwimlane);\n        }\n        return buildTable(element);\n    };\n\n    return withSwimlaneCreateByDrawing(withSwimlaneCreateByDrag(board));\n};\n", "import {\n    BoardTransforms,\n    PlaitBoard,\n    PlaitPointerType,\n    Point,\n    Transforms,\n    addSelectedElement,\n    createG,\n    distanceBetweenPointAndPoint,\n    toHostPoint,\n    toViewBoxPoint\n} from '@plait/core';\nimport { PlaitVectorLine, VectorLineShape, VectorLinePointerType } from '../interfaces';\nimport { DrawPointerType, LINE_HIT_GEOMETRY_BUFFER, getVectorLinePointers } from '../constants';\nimport { isDrawingMode } from '@plait/common';\nimport { vectorLineCreating } from '../utils';\nimport { isKeyHotkey } from 'is-hotkey';\n\nexport const withVectorLineCreateByDraw = (board: PlaitBoard) => {\n    const { pointerDown, pointerMove, dblClick, globalKeyDown } = board;\n\n    let lineShapeG: SVGGElement | null = null;\n\n    let temporaryElement: PlaitVectorLine | null = null;\n\n    let drawPoints: Point[] = [];\n\n    const vectorLineComplete = () => {\n        if (temporaryElement) {\n            Transforms.insertNode(board, temporaryElement, [board.children.length]);\n        }\n        PlaitBoard.getBoardContainer(board).classList.remove(`vector-line-closed`);\n        lineShapeG?.remove();\n        lineShapeG = null;\n        temporaryElement = null;\n        drawPoints = [];\n    };\n\n    board.pointerDown = (event: PointerEvent) => {\n        const penPointers = getVectorLinePointers();\n        const isVectorLinePointer = PlaitBoard.isInPointer(board, penPointers);\n        if (!PlaitBoard.isReadonly(board) && isVectorLinePointer && isDrawingMode(board)) {\n            let point = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n            if (drawPoints.length > 1) {\n                const isClosed = distanceBetweenPointAndPoint(...point, ...drawPoints[0]) <= LINE_HIT_GEOMETRY_BUFFER;\n                if (isClosed) {\n                    drawPoints.push(drawPoints[0]);\n                    vectorLineComplete();\n                    return;\n                }\n            }\n            drawPoints.push(point);\n            return;\n        }\n        pointerDown(event);\n    };\n\n    board.pointerMove = (event: PointerEvent) => {\n        lineShapeG?.remove();\n        lineShapeG = createG();\n        let movingPoint = toViewBoxPoint(board, toHostPoint(board, event.x, event.y));\n        const pointer = PlaitBoard.getPointer(board) as DrawPointerType;\n        if (pointer === VectorLinePointerType.vectorLine) {\n            if (drawPoints.length > 0) {\n                const distance = distanceBetweenPointAndPoint(...movingPoint, ...drawPoints[0]);\n                if (distance <= LINE_HIT_GEOMETRY_BUFFER) {\n                    movingPoint = drawPoints[0];\n                    PlaitBoard.getBoardContainer(board).classList.add(`vector-line-closed`);\n                } else {\n                    PlaitBoard.getBoardContainer(board).classList.remove(`vector-line-closed`);\n                }\n                temporaryElement = vectorLineCreating(board, VectorLineShape.straight, drawPoints, movingPoint, lineShapeG);\n            }\n        }\n        pointerMove(event);\n    };\n\n    board.dblClick = (event: MouseEvent) => {\n        if (!PlaitBoard.isReadonly(board)) {\n            if (temporaryElement) {\n                vectorLineComplete();\n                BoardTransforms.updatePointerType(board, PlaitPointerType.selection);\n                return;\n            }\n        }\n        dblClick(event);\n    };\n\n    board.globalKeyDown = (event: KeyboardEvent) => {\n        if (!PlaitBoard.isReadonly(board)) {\n            const isEsc = isKeyHotkey('esc', event);\n            const isV = isKeyHotkey('v', event);\n            if ((isEsc || isV) && temporaryElement) {\n                vectorLineComplete();\n                if (isV) {\n                    BoardTransforms.updatePointerType(board, PlaitPointerType.selection);\n                }\n            }\n        }\n        globalKeyDown(event);\n    };\n\n    return board;\n};\n", "import { Path, PlaitBoard, Point, Transforms, distanceBetweenPointAndPoint } from '@plait/core';\nimport { ResizeRef, ResizeState, WithResizeOptions, withResize } from '@plait/common';\nimport { getSelectedVectorLineElements } from '../utils/selected';\nimport { getHitLineResizeHandleRef, LineResizeHandle } from '../utils/position/line';\nimport { PlaitVectorLine } from '../interfaces';\nimport { LINE_HIT_GEOMETRY_BUFFER } from '../constants';\nimport { isClosedPoints } from '../utils';\n\nexport const withVectorLineResize = (board: PlaitBoard) => {\n    const options: WithResizeOptions<PlaitVectorLine, LineResizeHandle> = {\n        key: 'draw-vector-line',\n        canResize: () => {\n            return true;\n        },\n        hitTest: (point: Point) => {\n            const selectedVectorLineElements = getSelectedVectorLineElements(board);\n            if (selectedVectorLineElements.length > 0) {\n                let result = null;\n                selectedVectorLineElements.forEach(value => {\n                    const handleRef = getHitLineResizeHandleRef(board, value, point);\n                    if (handleRef) {\n                        result = {\n                            element: value,\n                            handle: handleRef.handle,\n                            handleIndex: handleRef.handleIndex\n                        };\n                    }\n                });\n                return result;\n            }\n            return null;\n        },\n\n        onResize: (resizeRef: ResizeRef<PlaitVectorLine, LineResizeHandle>, resizeState: ResizeState) => {\n            let points: Point[] = [...resizeRef.element.points];\n            let handleIndex = resizeRef.handleIndex!;\n            if (resizeRef.handle === LineResizeHandle.source || resizeRef.handle === LineResizeHandle.target) {\n                points[handleIndex] = resizeState.endPoint;\n                if (isClosedPoints(resizeRef.element.points)) {\n                    points[points.length - 1] = resizeState.endPoint;\n                } else {\n                    const targetPoint = resizeRef.handle === LineResizeHandle.source ? points[points.length - 1] : points[0];\n                    const distance = distanceBetweenPointAndPoint(...resizeState.endPoint, ...targetPoint);\n                    if (distance <= LINE_HIT_GEOMETRY_BUFFER) {\n                        points[handleIndex] = targetPoint;\n                    }\n                }\n            } else {\n                if (resizeRef.handle === LineResizeHandle.addHandle) {\n                    points.splice(handleIndex + 1, 0, resizeState.endPoint);\n                } else {\n                    points[handleIndex] = resizeState.endPoint;\n                }\n            }\n\n            Transforms.setNode(board, { points }, resizeRef.path as Path);\n        }\n    };\n\n    withResize<PlaitVectorLine, LineResizeHandle>(board, options);\n\n    return board;\n};\n", "import { PlaitBoard, PlaitElement, PlaitPluginElementContext, Point, RectangleClient, Selection, getSelectedElements } from '@plait/core';\nimport { GeometryComponent } from '../geometry.component';\nimport { ArrowLineComponent } from '../arrow-line.component';\nimport { VectorLineComponent } from '../vector-line.component';\nimport { PlaitDrawElement } from '../interfaces';\nimport { withDrawHotkey } from './with-draw-hotkey';\nimport { withGeometryCreateByDrawing, withGeometryCreateByDrag } from './with-geometry-create';\nimport { withDrawFragment } from './with-draw-fragment';\nimport { withArrowLineCreateByDraw } from './arrow-line/with-arrow-line-create';\nimport { withArrowLineResize } from './arrow-line/with-arrow-line-resize';\nimport { withArrowLineBoundReaction } from './arrow-line/with-arrow-line-bound-reaction';\nimport { withArrowLineText } from './arrow-line/with-arrow-line-text';\nimport { ImageComponent } from '../image.component';\nimport { withArrowLineAutoCompleteReaction } from './arrow-line/with-arrow-line-auto-complete-reaction';\nimport { withArrowLineAutoComplete } from './arrow-line/with-arrow-line-auto-complete';\nimport { withArrowLineTextMove } from './arrow-line/with-arrow-line-text-move';\nimport { withDrawResize } from './with-draw-resize';\nimport { getHitDrawElement, isHitDrawElement, isHitElementInside, isRectangleHitDrawElement } from '../utils/hit';\nimport { getArrowLinePoints, getArrowLineTextRectangle } from '../utils/arrow-line/arrow-line-basic';\nimport { withDrawRotate } from './with-draw-rotate';\nimport { withTable } from './with-table';\nimport { withSwimlane } from './with-swimlane';\nimport { withVectorLineCreateByDraw } from './with-vector-line-create';\nimport { getVectorLinePoints } from '../utils/vector-line';\nimport { withVectorLineResize } from './with-vector-line-resize';\n\nexport const withDraw = (board: PlaitBoard) => {\n    const { drawElement, getRectangle, isRectangleHit, isHit, isInsidePoint, isMovable, isAlign, getRelatedFragment, getOneHitElement } =\n        board;\n\n    board.drawElement = (context: PlaitPluginElementContext) => {\n        if (PlaitDrawElement.isGeometry(context.element)) {\n            if (PlaitDrawElement.isUML(context.element)) {\n                return GeometryComponent;\n            }\n            return GeometryComponent;\n        } else if (PlaitDrawElement.isArrowLine(context.element)) {\n            return ArrowLineComponent;\n        } else if (PlaitDrawElement.isVectorLine(context.element)) {\n            return VectorLineComponent;\n        } else if (PlaitDrawElement.isImage(context.element)) {\n            return ImageComponent;\n        }\n        return drawElement(context);\n    };\n\n    board.getRectangle = (element: PlaitElement) => {\n        if (PlaitDrawElement.isGeometry(element)) {\n            return RectangleClient.getRectangleByPoints(element.points);\n        }\n        if (PlaitDrawElement.isArrowLine(element)) {\n            const points = getArrowLinePoints(board, element);\n            const lineTextRectangles = element.texts.map((text, index) => {\n                const rectangle = getArrowLineTextRectangle(board, element, index);\n                return rectangle;\n            });\n            const linePointsRectangle = RectangleClient.getRectangleByPoints(points);\n            return RectangleClient.getBoundingRectangle([linePointsRectangle, ...lineTextRectangles]);\n        }\n        if (PlaitDrawElement.isVectorLine(element)) {\n            const points = getVectorLinePoints(board, element);\n            const linePointsRectangle = RectangleClient.getRectangleByPoints(points!);\n            return RectangleClient.getBoundingRectangle([linePointsRectangle]);\n        }\n        if (PlaitDrawElement.isImage(element)) {\n            return RectangleClient.getRectangleByPoints(element.points);\n        }\n        return getRectangle(element);\n    };\n\n    board.isRectangleHit = (element: PlaitElement, selection: Selection) => {\n        const result = isRectangleHitDrawElement(board, element, selection);\n        if (result !== null) {\n            return result;\n        }\n        return isRectangleHit(element, selection);\n    };\n\n    board.isHit = (element, point, isStrict?: boolean) => {\n        const result = isHitDrawElement(board, element, point, isStrict);\n        if (result !== null) {\n            return result;\n        }\n        return isHit(element, point, isStrict);\n    };\n\n    board.getOneHitElement = (elements) => {\n        const isAllDrawElements = elements.every((item) => PlaitDrawElement.isDrawElement(item));\n        if (isAllDrawElements) {\n            return getHitDrawElement(board, elements as PlaitDrawElement[]);\n        }\n        return getOneHitElement(elements);\n    };\n\n    board.isInsidePoint = (element: PlaitElement, point: Point) => {\n        const result = isHitElementInside(board, element, point);\n        if (result !== null) {\n            return result;\n        }\n        return isInsidePoint(element, point);\n    };\n\n    board.isMovable = (element: PlaitElement) => {\n        if (PlaitDrawElement.isGeometry(element)) {\n            return true;\n        }\n        if (PlaitDrawElement.isImage(element)) {\n            return true;\n        }\n        if (PlaitDrawElement.isVectorLine(element)) {\n            return true;\n        }\n        if (PlaitDrawElement.isArrowLine(element)) {\n            const selectedElements = getSelectedElements(board);\n            const isSelected = (boundId: string) => {\n                return !!selectedElements.find((value) => value.id === boundId);\n            };\n            if (!element.source.boundId && !element.target.boundId) {\n                return true;\n            }\n            if (element.source.boundId && isSelected(element.source.boundId) && selectedElements.includes(element)) {\n                return true;\n            }\n            if (element.target.boundId && isSelected(element.target.boundId) && selectedElements.includes(element)) {\n                return true;\n            }\n            return false;\n        }\n        return isMovable(element);\n    };\n\n    board.isAlign = (element: PlaitElement) => {\n        if (PlaitDrawElement.isGeometry(element) || PlaitDrawElement.isImage(element)) {\n            return true;\n        }\n        return isAlign(element);\n    };\n\n    board.getRelatedFragment = (elements: PlaitElement[], originData?: PlaitElement[]) => {\n        const selectedElements = originData?.length ? originData : getSelectedElements(board);\n        const lineElements = board.children.filter((element) => PlaitDrawElement.isArrowLine(element));\n        const activeLines = lineElements.filter((line) => {\n            const source = selectedElements.find((element) => element.id === line.source.boundId);\n            const target = selectedElements.find((element) => element.id === line.target.boundId);\n            const isSelected = selectedElements.includes(line);\n            return source && target && !isSelected;\n        });\n        return getRelatedFragment([...elements, ...activeLines], originData);\n    };\n\n    return withSwimlane(\n        withTable(\n            withDrawResize(\n                withVectorLineCreateByDraw(\n                    withArrowLineAutoCompleteReaction(\n                        withArrowLineBoundReaction(\n                            withVectorLineResize(\n                                withArrowLineResize(\n                                    withArrowLineTextMove(\n                                        withArrowLineText(\n                                            withDrawRotate(\n                                                withArrowLineCreateByDraw(\n                                                    withArrowLineAutoComplete(\n                                                        withGeometryCreateByDrag(\n                                                            withGeometryCreateByDrawing(withDrawFragment(withDrawHotkey(board)))\n                                                        )\n                                                    )\n                                                )\n                                            )\n                                        )\n                                    )\n                                )\n                            )\n                        )\n                    )\n                )\n            )\n        )\n    );\n};\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],
  "mappings": "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",
  "names": ["BasicShapes", "FlowchartSymbols", "UMLSymbols", "GeometryCommonTextKeys", "SwimlaneSymbols", "SwimlaneDrawSymbols", "TableSymbols", "DrawI18nKey", "shapes", "debugKey", "debugGenerator", "getCenterPointsOnPolygon", "LineResizeHandle", "rectangle", "normalizePoints", "rowId", "columnId", "debugKey", "debugGenerator", "centerPoint", "rectangle", "buildClipboardData", "basicBuildClipboard", "insertClipboardData", "basicInsertClipboard", "heightRatio", "getPoints", "options", "getCenterPointsOnPolygon", "getNearestPointBetweenPointAndRoundRectangle", "nearestPoint", "x", "y", "width", "height", "element", "ArrowLineMarkerType", "ArrowLineShape", "ArrowLineHandleKey", "MemorizeKey", "VectorLinePointerType", "VectorLineShape", "linePoints"]
}
