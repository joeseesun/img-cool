import { transformToDrawnixArrowElement, transformToDrawnixRectangleElement, transformToDrawnixLineElement, transformToDrawnixTextElement, transformToDrawnixGroupElement, } from "../transformToDrawnixElement.js";
import { GraphConverter } from "../GraphConverter.js";
import { ArrowLineShape, } from "@plait/draw";
import { getHitConnectionFromConnectionPoint } from "../helpers.js";
export const classToDrawnixConvertor = new GraphConverter({
    converter: (chart, config) => {
        const elements = [];
        const mermaidIdToElementMap = {};
        const mermaidGroupIdToElementMap = {};
        Object.values(chart.nodes).forEach((node) => {
            if (!node || !node.length) {
                return;
            }
            node.forEach((element) => {
                let drawnixElement;
                switch (element.type) {
                    case "line":
                        drawnixElement = transformToDrawnixLineElement(element, mermaidGroupIdToElementMap, config);
                        break;
                    case "rectangle":
                    case "ellipse":
                        drawnixElement = transformToDrawnixRectangleElement(element, mermaidGroupIdToElementMap, config);
                        break;
                    case "text":
                        drawnixElement = transformToDrawnixTextElement(element, mermaidGroupIdToElementMap, config);
                        break;
                    default:
                        throw `unknown type ${element.type}`;
                        break;
                }
                drawnixElement.origin = element;
                if (element.id) {
                    mermaidIdToElementMap[element.id] = drawnixElement;
                }
                elements.push(drawnixElement);
            });
        });
        Object.values(chart.lines).forEach((line) => {
            if (!line) {
                return;
            }
            let drawnixElement = transformToDrawnixLineElement(line, mermaidGroupIdToElementMap, config);
            drawnixElement.origin = line;
            elements.push(drawnixElement);
        });
        Object.values(chart.arrows).forEach((arrow) => {
            if (!arrow) {
                return;
            }
            const drawnixElement = transformToDrawnixArrowElement(arrow, mermaidGroupIdToElementMap, {
                ...config,
                arrowLineShape: ArrowLineShape.straight,
            });
            if (arrow.start &&
                arrow.start.id &&
                mermaidIdToElementMap[arrow.start.id]) {
                drawnixElement.source.boundId =
                    mermaidIdToElementMap[arrow.start.id].id;
                drawnixElement.source.connection = getHitConnectionFromConnectionPoint(drawnixElement.points[0], mermaidIdToElementMap[arrow.start.id]);
            }
            if (arrow.end && arrow.end.id && mermaidIdToElementMap[arrow.end.id]) {
                drawnixElement.target.boundId = mermaidIdToElementMap[arrow.end.id].id;
                drawnixElement.target.connection = getHitConnectionFromConnectionPoint(drawnixElement.points[drawnixElement.points.length - 1], mermaidIdToElementMap[arrow.end.id]);
            }
            drawnixElement.origin = arrow;
            elements.push(drawnixElement);
        });
        Object.values(chart.text).forEach((ele) => {
            const drawnixElement = transformToDrawnixTextElement(ele, mermaidGroupIdToElementMap, config);
            drawnixElement.origin = ele;
            elements.push(drawnixElement);
        });
        Object.values(chart.namespaces).forEach((namespace) => {
            const classIds = Object.keys(namespace.classes);
            const children = [...classIds];
            const chartElements = [...chart.lines, ...chart.arrows, ...chart.text];
            classIds.forEach((classId) => {
                const childIds = chartElements
                    .filter((ele) => ele.metadata && ele.metadata.classId === classId)
                    .map((ele) => ele.id);
                if (childIds.length) {
                    children.push(...childIds);
                }
            });
            const childrenElements = elements.filter((ele) => ele.origin && ele.origin.id && children.includes(ele.origin.id));
            const { textElement, containerElement } = transformToDrawnixGroupElement(childrenElements, namespace.id);
            elements.unshift(textElement);
            elements.unshift(containerElement);
        });
        elements.forEach((ele) => {
            if (ele.origin) {
                delete ele.origin;
            }
        });
        Object.values(mermaidGroupIdToElementMap).forEach((groupElement) => {
            elements.push(groupElement);
        });
        return { elements };
    },
});
