import { CONTAINER_STYLE_PROPERTY, LABEL_STYLE_PROPERTY, } from "../interfaces.js";
import { RectangleClient } from "@plait/core";
import { ArrowLineMarkerType, } from "@plait/draw";
import { StrokeStyle } from "@plait/common";
import { removeMarkdown } from "../markdown-to-text.js";
/**
 * Convert mermaid edge type to Drawnix arrow type
 */
const MERMAID_EDGE_TYPE_MAPPER = {
    arrow_point: {
        source: { marker: ArrowLineMarkerType.none },
        target: { marker: ArrowLineMarkerType.arrow },
    },
    arrow_circle: {
        source: { marker: ArrowLineMarkerType.none },
        target: { marker: ArrowLineMarkerType.arrow },
    },
    arrow_cross: {
        source: { marker: ArrowLineMarkerType.none },
        target: { marker: ArrowLineMarkerType.arrow },
    },
    arrow_open: {
        source: { marker: ArrowLineMarkerType.none },
        target: { marker: ArrowLineMarkerType.none },
    },
    double_arrow_circle: {
        source: { marker: ArrowLineMarkerType.arrow },
        target: { marker: ArrowLineMarkerType.arrow },
    },
    double_arrow_cross: {
        source: { marker: ArrowLineMarkerType.arrow },
        target: { marker: ArrowLineMarkerType.arrow },
    },
    double_arrow_point: {
        source: { marker: ArrowLineMarkerType.arrow },
        target: { marker: ArrowLineMarkerType.arrow },
    },
};
export const computeDrawnixArrowType = (mermaidArrowType) => {
    return MERMAID_EDGE_TYPE_MAPPER[mermaidArrowType];
};
export const computeDrawnixArrowStyle = (edge) => {
    const arrowStyle = {};
    if (edge.stroke === "dotted") {
        arrowStyle.strokeStyle = StrokeStyle.dotted;
    }
    return arrowStyle;
};
// Get text from graph elements, fallback markdown to text
export const getText = (element) => {
    let text = element.text;
    if (element.labelType === "markdown") {
        text = removeMarkdown(element.text);
    }
    // 处理换行符
    text = text.replace(/<br\/?>/g, '\n');
    text = text.replace(/\\n/g, '\n');
    // 移除 Mermaid 支持的格式标签
    const tagsToRemove = ['sub', 'small', 'i'];
    tagsToRemove.forEach(tag => {
        text = text.replace(new RegExp(`<${tag}>|</${tag}>`, 'g'), '');
    });
    return removeFontAwesomeIcons(text);
};
/**
 * Remove font awesome icons support from text
 */
const removeFontAwesomeIcons = (input) => {
    const fontAwesomeRegex = /\s?(fa|fab):[a-zA-Z0-9-]+/g;
    return input.replace(fontAwesomeRegex, "");
};
/**
 * Compute style for vertex
 */
export const computeDrawnixVertexStyle = (style) => {
    const plaitElementProperty = {};
    Object.keys(style).forEach((property) => {
        switch (property) {
            case CONTAINER_STYLE_PROPERTY.FILL: {
                plaitElementProperty.fill = style[property];
                break;
            }
            case CONTAINER_STYLE_PROPERTY.STROKE: {
                plaitElementProperty.strokeColor = style[property];
                break;
            }
            case CONTAINER_STYLE_PROPERTY.STROKE_WIDTH: {
                plaitElementProperty.strokeWidth = Number(style[property]?.split("px")[0]);
                break;
            }
            case CONTAINER_STYLE_PROPERTY.STROKE_DASHARRAY: {
                plaitElementProperty.strokeStyle = StrokeStyle.dashed;
                break;
            }
        }
    });
    return plaitElementProperty;
};
/**
 * Compute style for label
 */
export const computeDrawnixTextStyle = (style) => {
    const textProperty = {};
    Object.keys(style).forEach((property) => {
        switch (property) {
            case LABEL_STYLE_PROPERTY.COLOR: {
                textProperty.color = style[property];
                break;
            }
        }
    });
    return textProperty;
};
export const getRectangleByMermaidElement = (vertex) => {
    return vertex;
};
export const normalizeText = (text) => {
    return text.replace(/\\n/g, "\n");
};
export const getHitConnectionFromConnectionPoint = (connectionPoint, hitElement) => {
    let rectangle = RectangleClient.getRectangleByPoints(hitElement.points);
    return [(connectionPoint[0] - rectangle.x) / rectangle.width, (connectionPoint[1] - rectangle.y) / rectangle.height];
};
