import { buildText, DEFAULT_FONT_FAMILY, measureElement, StrokeStyle, } from "@plait/common";
import { getRectangleByMermaidElement, normalizeText } from "./helpers.js";
import { ArrowLineMarkerType, ArrowLineShape, BasicShapes, createArrowLineElement, createGeometryElement, getTextShapeProperty, ShapeDefaultSpace, } from "@plait/draw";
import { createGroup, RectangleClient } from "@plait/core";
import { Node as SlateNode } from "slate";
import { DEFAULT_FONT_SIZE as PLAIT_DEFAULT_FONT_SIZE } from "@plait/text-plugins";
export const transformToDrawnixLineElement = (element, mermaidGroupIdToElementMap, config) => {
    const points = [
        [element.startX, element.startY],
        [element.endX, element.endY],
    ];
    const arrowOptions = {
        strokeColor: element.strokeColor ||
            "hsl(259.6261682243, 59.7765363128%, 87.9019607843%)",
        strokeWidth: element.strokeWidth || 2,
        strokeStyle: (element.strokeStyle || StrokeStyle.solid),
    };
    const line = createArrowLineElement(ArrowLineShape.straight, [...points], {
        marker: ArrowLineMarkerType.none,
    }, {
        marker: ArrowLineMarkerType.none,
    }, [], { ...arrowOptions });
    if (element.groupId) {
        let groupElement = mermaidGroupIdToElementMap[element.groupId];
        if (!groupElement) {
            groupElement = createGroup();
            mermaidGroupIdToElementMap[element.groupId] = groupElement;
        }
        line.groupId = groupElement.id;
    }
    return line;
};
export const transformToDrawnixArrowElement = (element, mermaidGroupIdToElementMap, config) => {
    let points = [
        [element.startX, element.startY],
        [element.endX, element.endY],
    ];
    if (element.points) {
        points = element.points.map((point) => [
            element.startX + point[0],
            element.startY + point[1],
        ]);
    }
    const arrowOptions = {
        strokeColor: (element.strokeColor &&
            element.strokeColor !== "none" &&
            element.strokeColor) ||
            "#000",
        strokeWidth: element.strokeWidth || 1,
        strokeStyle: (element.strokeStyle || StrokeStyle.solid),
    };
    const arrowText = buildText(normalizeText(element?.label?.text || ""), undefined);
    const texts = [];
    if (SlateNode.string(arrowText).trim().length > 0) {
        const textSize = measureElement(null, arrowText, {
            fontFamily: DEFAULT_FONT_FAMILY,
            fontSize: PLAIT_DEFAULT_FONT_SIZE,
        });
        texts.push({
            position: 0.5,
            text: arrowText,
            width: textSize.width,
            height: textSize.height,
        });
    }
    const arrow = createArrowLineElement(config.arrowLineShape || ArrowLineShape.curve, [...points], {
        marker: element.startArrowhead
            ? ArrowLineMarkerType.arrow
            : ArrowLineMarkerType.none,
    }, {
        marker: element.endArrowhead
            ? ArrowLineMarkerType.arrow
            : ArrowLineMarkerType.none,
    }, texts, { ...arrowOptions });
    if (element.groupId) {
        let groupElement = mermaidGroupIdToElementMap[element.groupId];
        if (!groupElement) {
            groupElement = createGroup();
            mermaidGroupIdToElementMap[element.groupId] = groupElement;
        }
        arrow.groupId = groupElement.id;
    }
    return arrow;
};
export const transformToDrawnixRectangleElement = (element, mermaidGroupIdToElementMap, config) => {
    let extraProps = {};
    if (element.type === "rectangle" && element.subtype === "activation") {
        extraProps = {
            fill: "#e9ecef",
            strokeStyle: StrokeStyle.solid,
        };
    }
    const styleOptions = {
        strokeStyle: (element?.strokeStyle || StrokeStyle.solid),
        strokeWidth: element?.strokeWidth || 1,
        strokeColor: element?.strokeColor ||
            "hsl(259.6261682243, 59.7765363128%, 87.9019607843%)",
        fill: element?.bgColor || "#ECECFF",
        ...extraProps,
    };
    const textStyle = {
        color: element.label?.color || "#000",
    };
    const verticesText = buildText(normalizeText(element?.label?.text || ""), undefined, textStyle);
    const textSize = measureElement(null, verticesText, {
        fontFamily: DEFAULT_FONT_FAMILY,
        fontSize: PLAIT_DEFAULT_FONT_SIZE,
    });
    const rectangle = getRectangleByMermaidElement({
        ...element,
        width: element.width ||
            textSize.width +
                ShapeDefaultSpace.rectangleAndText * 2 +
                styleOptions.strokeWidth * 2,
    });
    const container = createGeometryElement(element.type, RectangleClient.getPoints(rectangle), verticesText, {
        ...styleOptions,
    }, {
        textHeight: textSize.height,
    });
    if (element.groupId) {
        let groupElement = mermaidGroupIdToElementMap[element.groupId];
        if (!groupElement) {
            groupElement = createGroup();
            mermaidGroupIdToElementMap[element.groupId] = groupElement;
        }
        container.groupId = groupElement.id;
    }
    return container;
};
export const transformToDrawnixTextElement = (element, mermaidGroupIdToElementMap, config) => {
    const text = buildText(normalizeText(element.text || ""), undefined);
    const textSize = getTextShapeProperty({}, text);
    const textRectangle = RectangleClient.getRectangleByCenterPoint([element.x + textSize.width / 2, element.y], textSize.width, textSize.height);
    const textElement = createGeometryElement(BasicShapes.text, RectangleClient.getPoints(textRectangle), text, {}, {
        textHeight: textSize.height,
    });
    if (element.groupId) {
        let groupElement = mermaidGroupIdToElementMap[element.groupId];
        if (!groupElement) {
            groupElement = createGroup();
            mermaidGroupIdToElementMap[element.groupId] = groupElement;
        }
        textElement.groupId = groupElement.id;
    }
    return textElement;
};
export const transformToDrawnixGroupElement = (childrenElements, text, options = {}) => {
    const childrenRectangle = RectangleClient.getBoundingRectangle(childrenElements.map((ele) => RectangleClient.getRectangleByPoints(ele.points)));
    const PADDING = 60;
    const groupRectangle = RectangleClient.inflate(childrenRectangle, PADDING);
    const containerElement = createGeometryElement(BasicShapes.rectangle, [...RectangleClient.getPoints(groupRectangle)], "", { strokeWidth: 1, ...options });
    const slateTextElement = buildText(text, undefined);
    const textSize = getTextShapeProperty({}, text);
    const points = RectangleClient.getPoints(RectangleClient.getRectangleByCenterPoint([
        groupRectangle.x + groupRectangle.width / 2,
        groupRectangle.y + 4 + textSize.height / 2,
    ], textSize.width, textSize.height));
    const textElement = createGeometryElement(BasicShapes.text, points, slateTextElement);
    return { textElement, containerElement };
};
