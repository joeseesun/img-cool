import { createMindElement, getTopicSize, } from "@plait/mind";
import { buildText } from "@plait/common";
import { MindLayoutType } from "@plait/layouts";
import { unified } from "unified";
import remarkParse from "remark-parse";
export const getTextFromNode = (node) => {
    let text = "";
    const transform = (node) => {
        if (node.type === "text" ||
            node.type === "inlineCode" ||
            node.type === "code") {
            text += node.value;
            return;
        }
        if (node.type === "link") {
            text += `${node.url}`;
            return;
        }
        if (node.children && node.children.length > 0) {
            node.children.forEach((node) => {
                transform(node);
            });
        }
    };
    transform(node);
    return text;
};
export const getParentMindNode = (node, parentNodeMap) => {
    if (node.type === "heading") {
        const depth = node.depth;
        for (let i = depth - 1; i >= 0; i--) {
            if (parentNodeMap[`${i}`]) {
                return parentNodeMap[`${i}`];
            }
        }
    }
    return parentNodeMap["0"];
};
const parseMarkdownToDrawnix = (definition, mainTopic) => {
    // 解析 markdown
    const processor = unified().use(remarkParse);
    const root = processor.parse(definition);
    let hasTopTopic = false;
    const firstHeading = root.children?.find((node) => {
        if (node.type === "heading") {
            return node;
        }
    });
    if (firstHeading &&
        root.children?.filter((node) => node.type === "heading" &&
            firstHeading &&
            node.depth === firstHeading.depth).length === 1) {
        hasTopTopic = true;
    }
    // 转化为 drawnix 思维导图
    const firstHeadingText = getTextFromNode(firstHeading);
    const centerTopic = mainTopic || (hasTopTopic && firstHeadingText) || "中心主题";
    const topicSize = getTopicSize(null, true, false, buildText(centerTopic));
    const mind = createMindElement(centerTopic, topicSize.width, topicSize.height, {
        layout: MindLayoutType.right,
    });
    mind.isRoot = true;
    mind.type = "mindmap";
    const parentNodeMap = { "0": mind };
    let currentParent = mind;
    const transform = (node, isNext = false) => {
        if (hasTopTopic && !mainTopic && node === firstHeading) {
            return;
        }
        if (node.type === "heading") {
            const parentMindNode = getParentMindNode(node, parentNodeMap);
            const text = getTextFromNode(node);
            if (!text) {
                return;
            }
            const { width, height } = getTopicSize(null, false, false, buildText(text));
            const element = createMindElement(text, width, height, {});
            parentMindNode.children.push(element);
            parentNodeMap[`${node.depth}`] = element;
            currentParent = element;
        }
        else if (node.type === "list") {
            node.children?.forEach((node) => {
                transform(node);
            });
        }
        else if (node.type === "listItem") {
            if (node.children && node.children.length > 1) {
                const _currentParent = currentParent;
                node.children.forEach((node, index) => {
                    transform(node, index === 0);
                });
                currentParent = _currentParent;
                return;
            }
            const text = getTextFromNode(node);
            if (!text) {
                return;
            }
            const { width, height } = getTopicSize(null, false, false, buildText(text));
            const element = createMindElement(text, width, height, {});
            currentParent.children.push(element);
        }
        else {
            const text = getTextFromNode(node);
            if (!text) {
                return;
            }
            const { width, height } = getTopicSize(null, false, false, buildText(text));
            const element = createMindElement(text, width, height, {});
            currentParent.children.push(element);
            if (isNext) {
                currentParent = element;
            }
        }
    };
    root.children?.forEach((node) => {
        transform(node);
    });
    return mind;
};
export { parseMarkdownToDrawnix };
